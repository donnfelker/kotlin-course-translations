1
00:00:00,490 --> 00:00:01,323
- Всем привет.

2
00:00:01,323 --> 00:00:03,380
Меня зовут Дон Фэлкер.
Добро пожаловать на курс

3
00:00:03,380 --> 00:00:04,990
по изучению языка Котлин.

4
00:00:04,990 --> 00:00:06,900
Я буду вашим проводником
и инструктором в этом путешествии.

5
00:00:06,900 --> 00:00:10,040
Вы смотрите видео длиной
более 9-ти часов

6
00:00:10,040 --> 00:00:12,500
о языке программирования Котлин

7
00:00:12,500 --> 00:00:14,410
Это видео можно смотреть двумя способами:

8
00:00:14,410 --> 00:00:16,770
Если хотите, вы можете посмотреть
все видео целиком,

9
00:00:16,770 --> 00:00:19,410
или, если вы хотите смотреть
курс частями на манер плэйлиста

10
00:00:19,410 --> 00:00:21,900
в виде небольших видео уроков,

11
00:00:21,900 --> 00:00:23,760
вы можете найти ссылку
на плэйлист ниже

12
00:00:23,760 --> 00:00:24,820
в описании видео.

13
00:00:24,820 --> 00:00:27,370
Заходите на него и смотрите
весь материал

14
00:00:27,370 --> 00:00:30,980
разбитый на
130 раздельных урока.

15
00:00:30,980 --> 00:00:33,790
Главная цель данного курса
дать вам возможность

16
00:00:33,790 --> 00:00:36,520
приносить ценность и пользу
в любой котлин проект

17
00:00:36,520 --> 00:00:37,450
который есть в открытом доступе.

18
00:00:37,450 --> 00:00:40,370
Мы рассмотрим теорию и изучим
переменные, функции

19
00:00:40,370 --> 00:00:43,740
классы, узнаем как работать с дженериками

20
00:00:43,740 --> 00:00:45,420
как работать со списками, изменять списки,

21
00:00:45,420 --> 00:00:48,360
рассмотрим различные структуры
данных, словари и массивы

22
00:00:48,360 --> 00:00:50,910
и даже немного поговорим
про лямда выражения.

23
00:00:50,910 --> 00:00:52,720
Курс мы закончим написанием вашего

24
00:00:52,720 --> 00:00:55,720
первого Котлин проекта,
который вы сможете запустить

25
00:00:55,720 --> 00:00:57,240
локально на вашем компьюетере.

26
00:00:57,240 --> 00:00:58,590
Когда вы закончите этот курс,

27
00:00:58,590 --> 00:01:01,060
вы сможете уверенно читать
код проекта написанного на Kotlin

28
00:01:01,060 --> 00:01:03,660
и чувствоать себя достаточно уверенно

29
00:01:03,660 --> 00:01:05,450
для внесения изменений в код.

30
00:01:05,450 --> 00:01:07,340
Уточню, что в этом курсе
будут вещи, которые мы не затронем

31
00:01:07,340 --> 00:01:10,830
в основном это будут сложные темы,
такие как корутины, флоу

32
00:01:10,830 --> 00:01:12,040
и подобные им вещи.

33
00:01:12,040 --> 00:01:15,360
Однако, как только вы поймете
и изучите основы

34
00:01:15,360 --> 00:01:16,650
представленные в этом курсе,

35
00:01:16,650 --> 00:01:19,560
вы сможете самостоятельно начать
изучение более сложных вещей.

36
00:01:19,560 --> 00:01:21,430
Осталась одна единственная
вещь, которую я хотел сказать

37
00:01:21,430 --> 00:01:22,580
вам перед тем как мы начнем.

38
00:01:22,580 --> 00:01:26,680
Со временем шаги по установке
могут сильно измениться,

39
00:01:26,680 --> 00:01:28,880
все зависит от того "когда"
вы смотрите это видео,

40
00:01:28,880 --> 00:01:32,270
это значит что шаги по установки
окружения IntelliJ community edition

41
00:01:32,270 --> 00:01:34,650
для Котлин, которые будут
в первых нескольких минутах

42
00:01:34,650 --> 00:01:37,140
этого видео,

43
00:01:37,140 --> 00:01:38,570
со временем могут измениться.

44
00:01:38,570 --> 00:01:40,330
Веб страница скорее всего будет
выглядеть по другому,

45
00:01:40,330 --> 00:01:42,250
процесс установки будет
выглядеть немного иначе.

46
00:01:42,250 --> 00:01:45,040
И первая страница, где вы будете
создавать новый проект

47
00:01:45,040 --> 00:01:46,560
будет немного отличаться.

48
00:01:46,560 --> 00:01:49,190
Моя совет вам, когда вы
установите IntelliJ

49
00:01:49,190 --> 00:01:51,330
просто следуйте инструкциям
на сайте

50
00:01:51,330 --> 00:01:53,810
создайте новый проект, убедитесь
что в качестве языка у вас выбран Kotlin.

51
00:01:53,810 --> 00:01:55,240
После этого проблем,

52
00:01:55,240 --> 00:01:57,280
у вас быть не должно.

53
00:01:57,280 --> 00:01:58,870
Надеюсь, что скоро смогу поздравить

54
00:01:58,870 --> 00:02:01,330
вас в конце видео, в связи с его окончанием.

55
00:02:01,330 --> 00:02:03,080
А пока этого не произошло,
если у вас есть вопросы

56
00:02:03,080 --> 00:02:06,130
задавайте их в комментариях,
увидимся в конце видео.

57
00:02:06,130 --> 00:02:06,963
Удачи.

58
00:02:06,963 --> 00:02:08,800
Чтобы начать писать на Котлин,

59
00:02:08,800 --> 00:02:11,370
вам нужно установить специальную
среду для разработки,

60
00:02:11,370 --> 00:02:12,530
сокращенно - IDE (integrated
development environment)

61
00:02:13,911 --> 00:02:15,800
Вы можете скачать ее
на сайте free@jetbrains.com

62
00:02:15,800 --> 00:02:17,650
зайдите в "Tools" (Инструменты)
и выберете IntelliJ IDEA.

63
00:02:18,970 --> 00:02:21,260
Далее найдите и нажмите
на ссылку для скачивания.

64
00:02:22,120 --> 00:02:24,590
Здесь вы можете скачать
бесплатную версию IDEA

65
00:02:24,590 --> 00:02:27,640
для нужной вам
операционной системы

66
00:02:27,640 --> 00:02:30,670
Windows, MacOS, Linux.

67
00:02:31,620 --> 00:02:33,490
Для этого курса я буду использовать
версию для MacOS

68
00:02:33,490 --> 00:02:35,440
я загружаю бесплатную версию.

69
00:02:36,440 --> 00:02:37,860
Как только файл скачается,

70
00:02:37,860 --> 00:02:39,900
вы можете вернуться на сайт

71
00:02:39,900 --> 00:02:43,322
и следовать инструкции по установке
для операционной системы

72
00:02:43,322 --> 00:02:44,155
которую вы используете.

73
00:02:44,155 --> 00:02:45,900
Я не буду показывать все

74
00:02:45,900 --> 00:02:49,310
инструкции по установке
потому что они отличаются

75
00:02:49,310 --> 00:02:52,320
и зависят от операционной системы.

76
00:02:52,320 --> 00:02:54,930
Время от времени и сами инструкции

77
00:02:54,930 --> 00:02:56,630
по установке могут меняться,

78
00:02:56,630 --> 00:02:59,390
поэтому не удивляйтесь, если
то что вы видите на сайте

79
00:02:59,390 --> 00:03:01,590
и то что вы видете сейча,
в этом курсе
может немного отличаться

80
00:03:01,590 --> 00:03:03,470
может немного отличаться.

81
00:03:03,470 --> 00:03:06,220
Если вы с этим столкнулись
просто убедитесь, что вы

82
00:03:08,144 --> 00:03:08,977
скачиваете бесплатную версию

83
00:03:08,977 --> 00:03:11,200
и найдите инструкции по установке.

84
00:03:11,200 --> 00:03:13,980
Как только приложение установится
и вы будете котовы

85
00:03:13,980 --> 00:03:17,260
работать в IntelliJ,
вы можете начинать писать код

86
00:03:17,260 --> 00:03:19,820
на языке Котлин.

87
00:03:19,820 --> 00:03:21,680
Как только IntelliJ установилась,

88
00:03:21,680 --> 00:03:23,720
вы можете запустить приложение
и увидите окно, которое

89
00:03:23,720 --> 00:03:25,700
похоже на это.

90
00:03:25,700 --> 00:03:28,640
Нажмите "Создать новый проект"
и появится список с

91
00:03:28,640 --> 00:03:31,518
различными настройками
слева экрана

92
00:03:31,518 --> 00:03:34,800
Выберите вкладку Котлин,
и пункт Котлин JVM

93
00:03:36,220 --> 00:03:39,590
нажмите "далее", теперь
назовите ваш проект

94
00:03:39,590 --> 00:03:41,820
Я назову его Caster Kotlin

95
00:03:42,800 --> 00:03:44,950
Вы можете назвать его как
только захотите

96
00:03:44,950 --> 00:03:46,920
Вы можете не менять SDK
для проекта

97
00:03:46,920 --> 00:03:50,040
и все оставить как оно есть
дальше нажмите "Закончить"

98
00:03:54,205 --> 00:03:55,160
Вы можете закрыть "Подсказку дня"

99
00:03:55,160 --> 00:03:57,990
и закрыть все

100
00:03:57,990 --> 00:03:59,960
всплывающие окна.

101
00:03:59,960 --> 00:04:01,600
Слева вы видите окно

102
00:04:01,600 --> 00:04:04,400
оно содержит файловую структуру
вашего проекта.

103
00:04:04,400 --> 00:04:06,930
Внутри этого окна
мы видим пакеты, файлы

104
00:04:06,930 --> 00:04:09,420
и другие вещи связанные
с проектом.

105
00:04:10,540 --> 00:04:13,970
Первым делом
откройте это папку.

106
00:04:13,970 --> 00:04:15,370
Вы увидите папку "src".

107
00:04:15,370 --> 00:04:17,390
В этой папке будет хранится код.

108
00:04:18,860 --> 00:04:21,440
Для начала давайте создадим наш
первый файл.

109
00:04:21,440 --> 00:04:25,660
Нажмите правой кнопкой мышки на
папке и выберете New -> Kotlin file class

110
00:04:26,832 --> 00:04:27,910
давайте назовем его main.kt

111
00:04:29,521 --> 00:04:32,410
"kt" - это расширение для
Котлин файлов. Нажмите "ok"

112
00:04:34,550 --> 00:04:37,082
Теперь вы готовы написать

113
00:04:37,082 --> 00:04:37,915
свою первую строчку
кода на Котлин.

114
00:04:39,095 --> 00:04:40,000
Если у вас появится такое уведомление,

115
00:04:40,000 --> 00:04:42,180
вы можете выбрать "Install"
чтобы установить плагины для Котлин,

116
00:04:42,180 --> 00:04:43,013
если захотите.

117
00:04:43,013 --> 00:04:45,280
Если у вас не было такого
уведомления

118
00:04:45,280 --> 00:04:47,600
вы можете пропустить эту часть
видео

119
00:04:47,600 --> 00:04:49,410
Вы будете получать подобные
уведомления

120
00:04:49,410 --> 00:04:51,970
когда будут выходить новые
версии Котлин или

121
00:04:51,970 --> 00:04:53,820
Котлин плагинов

122
00:04:53,820 --> 00:04:56,190
Теперь нажмите кнопку "Install"

123
00:04:56,190 --> 00:04:58,380
Идея загрузит новый плагин

124
00:04:58,380 --> 00:05:00,180
и покажет прогресс загрузки тут.

125
00:05:00,180 --> 00:05:02,380
Это плагин для нашей среды разработки

126
00:05:03,297 --> 00:05:05,790
Вы можете посмотреть эти плагины
здесь зайдя в настройки

127
00:05:05,790 --> 00:05:07,610
И здесь нажмите "Plugins".

128
00:05:07,610 --> 00:05:11,540
Заходим в настройки, пишем "plugins".

129
00:05:13,580 --> 00:05:15,700
Тут можно увидеть все установленные
плагины, которые

130
00:05:15,700 --> 00:05:17,520
установлены в вашей InltelliJ Idea.

131
00:05:17,520 --> 00:05:22,120
Наберите в поиске Kotlin
и вы увидите,

132
00:05:22,120 --> 00:05:24,530
что мы только что установили его,

133
00:05:24,530 --> 00:05:26,167
поэтому нам нужно перезапустить IDE,

134
00:05:26,167 --> 00:05:28,320
это дополнительно написано
в этом окне.

135
00:05:28,320 --> 00:05:30,179
После того как вы нажмете "restart",

136
00:05:30,179 --> 00:05:33,280
IntelliJ перезапустится
и загрузится с новой

137
00:05:33,280 --> 00:05:34,113
версие плагина.

138
00:05:35,840 --> 00:05:37,878
Мы можем закрыть это окно
и вернуться

139
00:05:37,878 --> 00:05:38,900
к нашему main.kt файлу.

140
00:05:38,900 --> 00:05:41,270
Котлин плагин должен был
обновиться внутри

141
00:05:41,270 --> 00:05:43,470
IntelliJ и мы готовы начинать.

142
00:05:43,470 --> 00:05:46,660
Для того чтобы создать свой
первое "Hello World" приложение,

143
00:05:46,660 --> 00:05:50,380
вам нужно создать "main" функцию
в вашем файле.

144
00:05:50,380 --> 00:05:52,310
И это выглядит как fun main.

145
00:05:52,310 --> 00:05:54,390
Тут будут открытая и закрытая скобки

146
00:05:54,390 --> 00:05:56,610
и открытая и закрытая фигурные скобки.

147
00:05:56,610 --> 00:06:00,100
Каждый раз, когда вы пишите
подобную конструкцию в IntelliJ

148
00:06:00,100 --> 00:06:02,854
в любом Котлин файле,
слева будет появляться зеленая стрелочка.

149
00:06:02,854 --> 00:06:04,440
По клику на эту стрелку вы можете
запустить или проебажить

150
00:06:04,440 --> 00:06:05,800
вашу программу.

151
00:06:07,154 --> 00:06:07,990
Мы поговорим об этом
через секунду.

152
00:06:07,990 --> 00:06:09,170
Если мы запустим программу прямо сейчас

153
00:06:09,170 --> 00:06:10,630
ничего не произойдет.

154
00:06:10,630 --> 00:06:13,392
Поэтому, для начала
мы попробуем вывести что-нибудь

155
00:06:13,392 --> 00:06:14,225
на экран.

156
00:06:14,225 --> 00:06:16,990
Мы хотим написать "Hello, World" ("Привет, Мир").

157
00:06:16,990 --> 00:06:20,820
Функция println это стандартная
функция в Котлин,

158
00:06:20,820 --> 00:06:24,120
Которая позволяет выводить
заданный ей текст

159
00:06:24,120 --> 00:06:27,520
и переводить каретку на новую
строку в "стандартный способ вывода"

160
00:06:27,520 --> 00:06:28,860
В нашем случае стандартный способ вывода

161
00:06:28,860 --> 00:06:31,430
Это просто окно снизу экрана.

162
00:06:31,430 --> 00:06:33,690
Если мы вернумся назад к нашей стрелке,

163
00:06:33,690 --> 00:06:36,393
и нажмем "Run main.kt",
hit play and hit run main.kt,

164
00:06:36,393 --> 00:06:39,180
мы увидим что код компилируется
и выполняется.

165
00:06:39,180 --> 00:06:41,704
Это может занимать немного больше
времени у вас,

166
00:06:41,704 --> 00:06:43,870
все зависит от характеристик вашего
ПК или ноутбука.

167
00:06:43,870 --> 00:06:46,500
И теперь тут, в окне вы
можете увидеть ваше сообщение hello world.

168
00:06:46,500 --> 00:06:48,620
Таким образом вы смогли написать
свою первую программу

169
00:06:48,620 --> 00:06:49,590
на языке Kotlin.

170
00:06:49,590 --> 00:06:52,690
Переменные - основной винтик
в вашей программе.

171
00:06:52,690 --> 00:06:55,970
Чтобы создать переменную в Котлине
используется ключевое слово var,

172
00:06:55,970 --> 00:06:57,740
после него вы пишите название
вашей переменной.

173
00:06:57,740 --> 00:06:59,690
В этом случае мы назовем ее
"полное имя" (fullName)

174
00:07:00,556 --> 00:07:02,610
и напишем что оно равно значению.

175
00:07:02,610 --> 00:07:06,570
Тут я задам переменной строковое
значение "Donn Felker"

176
00:07:06,570 --> 00:07:08,890
теперь у нас есть переменная
с именем "fullName"

177
00:07:08,890 --> 00:07:11,580
и она содержит значение "Donn Felker"

178
00:07:12,743 --> 00:07:14,767
Если мы захотим вывести ее на экран,

179
00:07:14,767 --> 00:07:15,950
то мы можем использовать функцию println

180
00:07:17,065 --> 00:07:19,060
и теперь мы можем нажать стрелочку
и запустить программу

181
00:07:19,060 --> 00:07:20,060
и нажать "Run main.kt"

182
00:07:21,555 --> 00:07:23,569
Программа скомпилируется, об этом
написано снизу

183
00:07:23,569 --> 00:07:25,569
и программа выведет значение "Donn Felker".

184
00:07:44,950 --> 00:07:45,783
Запустим заново

185
00:07:49,540 --> 00:07:51,700
Вы видите "Donn Felker" и "John Felker".

186
00:07:52,600 --> 00:07:57,600
Вы таким же образом можете
присвоить пустое значение

187
00:07:57,810 --> 00:07:59,160
и вывести его на экран,

188
00:08:00,440 --> 00:08:01,944
не смотря на то что мы не видим
результата программы

189
00:08:01,944 --> 00:08:03,820
потому что переменная пустая,
мы можем запустить программу

190
00:08:03,820 --> 00:08:06,280
и увидеть, что в конце появилась
дополнительная пустая строка.

191
00:08:06,280 --> 00:08:08,430
Вместо одной, теперь тут две
пустые строки

192
00:08:08,430 --> 00:08:10,130
потому что вы вывели одну
пустую строку.

193
00:08:12,090 --> 00:08:14,700
Когда мы работаем с переменными,


194
00:08:14,700 --> 00:08:16,820
мы имеем полный доступ к их методам

195
00:08:16,820 --> 00:08:19,540
Например, мы хотим проверить
характеристику строки

196
00:08:19,540 --> 00:08:22,760
и вызвать фунцию, которая
проверит пустая она или нет.

197
00:08:22,760 --> 00:08:25,600
Я напишу isEmpty и это метод для

198
00:08:25,600 --> 00:08:26,830
строковой переменной.

199
00:08:26,830 --> 00:08:29,557
С помощью нее мы можем проверить
нашу переменную.

200
00:08:29,557 --> 00:08:32,619
Я нажму cmd+B чтобы посмотреть
код функции.

201
00:08:32,619 --> 00:08:34,440
Тут можно увидеть, что метод isEmpty,

202
00:08:34,440 --> 00:08:36,960
возвращает true, когда длина
последовательности

203
00:08:36,960 --> 00:08:39,100
символов равняется нулю.

204
00:08:39,995 --> 00:08:41,850
Последовательность символов это строка.

205
00:08:41,850 --> 00:08:44,480
Если переменная пустая, тогда функция
вернет true, иначе вернет false.

206
00:08:44,480 --> 00:08:47,530
Если запустить программу мы получим
"Donn Felker", "John Felker",

207
00:08:47,530 --> 00:08:50,600
пустую строку и затем
мы увидим слово true.

208
00:08:50,600 --> 00:08:51,750
Давайте проверим

209
00:08:53,222 --> 00:08:54,334
Теперь вы сами видите снизу
в окне вывода

210
00:08:54,334 --> 00:08:57,910
"Donn Felker", "John Felker",
пустую строку и "true"

211
00:08:57,910 --> 00:09:00,920
Ключевой момент, который нужно запомнить:

212
00:09:00,920 --> 00:09:03,710
если вы используете ключевое слово
"var" это значит, что в любой момент

213
00:09:03,710 --> 00:09:06,130
вы или другие объекты программы
могут изменить значение вашей переменной,

214
00:09:06,130 --> 00:09:08,170
если вы хотите менять значение -
миспользуйте "var".

215
00:09:08,170 --> 00:09:11,740
Например, я могу написать, что age = 32

216
00:09:11,740 --> 00:09:14,190
и в любой момент без проблем могу
изменить значение на другое

217
00:09:15,183 --> 00:09:16,356
Еще одно замечание.

218
00:09:16,356 --> 00:09:18,730
Если я снова напишу "var age"

219
00:09:18,730 --> 00:09:19,850
то мы увидим красную линию под
переменной

220
00:09:19,850 --> 00:09:22,900
В подсказке написано, что у нас
две конфликтующие переменные

221
00:09:22,900 --> 00:09:26,040
это значит что мы не можем дважды
объявить одну и ту же переменную

222
00:09:26,040 --> 00:09:28,672
в скоупе выполнения

223
00:09:28,672 --> 00:09:30,300
в данном примере - в рамках
функции main()

224
00:09:30,300 --> 00:09:32,870
Если я хочу задать переменной новое
значение, я не буду писать "var"

225
00:09:32,870 --> 00:09:35,330
я просто напишу что age равно 32

226
00:09:35,330 --> 00:09:36,840
и это изменит значение.

227
00:09:36,840 --> 00:09:40,980
Я так же могу вывести
значение age в консоль

228
00:09:40,980 --> 00:09:43,400
напишем age и увидим, что age

229
00:09:43,400 --> 00:09:47,800
выведет в консоль 32, не смотря на то
что переменная создавалась со значением 30

230
00:09:47,800 --> 00:09:50,760
В консоль выводится 32

231
00:09:51,920 --> 00:09:54,650
Последнее важное замечание,

232
00:09:54,650 --> 00:09:57,360
что переменной age при создании
неявно присвоился целочисленный тип

233
00:09:57,360 --> 00:09:59,170
При этом мы нигде явно этого не указывали

234
00:10:00,500 --> 00:10:01,880
Компилятор достатоно умный для того
чтобы присвоить тип переменной

235
00:10:01,880 --> 00:10:04,060
в зависимости от того, что вы в нее кладете

236
00:10:04,060 --> 00:10:06,080
в нашем случае - целочисленный тип.

237
00:10:07,330 --> 00:10:09,510
В котлин вы можете создавать переменные

238
00:10:09,510 --> 00:10:13,220
с помощью ключевого слова "var",
но если вы хотите создать

239
00:10:13,220 --> 00:10:14,320
неизменяемое значение,

240
00:10:14,320 --> 00:10:16,780
то нужно использовать ключевое
слово "val".

241
00:10:16,780 --> 00:10:19,591
Давайте попробуем проделать все
то же самое.

242
00:10:19,591 --> 00:10:20,940
Мы создадим новую переменную

243
00:10:20,940 --> 00:10:23,959
но на этот раз будем использовать
ключевое слово "val"

244
00:10:23,959 --> 00:10:26,809
и присвоим ей значение
"Donn Felker" как раньше

245
00:10:27,730 --> 00:10:29,800
И выведем все в консоль

246
00:10:29,800 --> 00:10:32,240
На данный момент ничего не поменялось

247
00:10:32,240 --> 00:10:34,180
Результат будет точно такой же

248
00:10:34,180 --> 00:10:37,090
Мы создали переменную "fullName"

249
00:10:37,090 --> 00:10:38,870
со значением "Donn Felker"

250
00:10:38,870 --> 00:10:41,700
И когда мы запускаем программу, мы
видим "Donn Felker"

251
00:10:41,700 --> 00:10:43,140
в выводе консоли.

252
00:10:43,140 --> 00:10:46,950
Но самое большое отличие тут то,
что мы использовали

253
00:10:46,950 --> 00:10:50,130
ключевое слово "val".
Тем самым мы создали переменную

254
00:10:50,130 --> 00:10:52,560
которую нельзя изменять

255
00:10:52,560 --> 00:10:55,140
Если я попытаюсь задать у нее
другое значение

256
00:10:55,140 --> 00:10:58,730
например, попрубую заменить
ее на "John Felker"

257
00:11:00,260 --> 00:11:02,900
я автоматически получу предупреждение -
красную полосу

258
00:11:02,900 --> 00:11:07,090
потому что Котлин понимает, что
так делать нельзя

259
00:11:07,090 --> 00:11:09,500
И в подсказке написано, что значения
"val" переменных нельзя менять

260
00:11:09,500 --> 00:11:11,650
И если я попробую проигнорировать
IDE и запущу программу

261
00:11:11,650 --> 00:11:12,990
нажму на кнопку Run

262
00:11:12,990 --> 00:11:16,370
Компилятор запустится
и напишет что произошла ошибка компиляции

263
00:11:16,370 --> 00:11:19,100
Компилятор скажет, что он
не смог скомпилировать программу

264
00:11:19,100 --> 00:11:20,160
потому что в коде ошибка

265
00:11:20,160 --> 00:11:24,450
и вы попытались поменять val переменную
в строчке 5

266
00:11:24,450 --> 00:11:26,510
Мы посмотрим на строчку 5 и вот
наша попытка поменять значение val

267
00:11:26,510 --> 00:11:29,680
переменной

268
00:11:29,680 --> 00:11:33,180
Как только мы создаем val переменную

269
00:11:33,180 --> 00:11:35,940
ее значение больше не может
меняться

270
00:11:35,940 --> 00:11:37,690
То же самое работает для всех

271
00:11:37,690 --> 00:11:41,230
других типов данных. Например
если это будет 32

272
00:11:41,230 --> 00:11:44,100
вы так же можете вывести ее в консоль

273
00:11:44,100 --> 00:11:47,670
Но если попробуете изменить ее

274
00:11:47,670 --> 00:11:49,130
например присвоить 42

275
00:11:51,114 --> 00:11:52,060
вы можете увидеть ту же самую
проблему

276
00:11:52,060 --> 00:11:54,880
Ради эксперимента запустим программу
и увидим все

277
00:11:54,880 --> 00:11:56,480
ту же ошибку компилятора,
который говорит

278
00:11:56,480 --> 00:11:57,760
что val нельзя изменять

279
00:11:57,760 --> 00:11:58,920
и покажет что ошибка в строке 8

280
00:11:58,920 --> 00:12:01,930
Номер строки это первая цифра в
этом сообщении об ошибке

281
00:12:01,930 --> 00:12:06,290
И вот тут на строке 8 пытаемся
поменять val переменную

282
00:12:06,290 --> 00:12:09,080
Поэтому мы не можем менять val
переменные

283
00:12:09,080 --> 00:12:10,470
и можем только читать их

284
00:12:10,470 --> 00:12:13,140
Поэтому это отличный вариант, когда вам
нужно создать то что нельзя менять

285
00:12:13,140 --> 00:12:16,340
в вашей программе и эту

286
00:12:16,340 --> 00:12:18,720
неизменчивость вы делигируете
и проверяете

287
00:12:18,720 --> 00:12:19,970
с помощью компилятора.

288
00:12:19,970 --> 00:12:24,300
До этого момента все переменные
неявно получали свой тип данных

289
00:12:24,300 --> 00:12:28,040
Однако, если у вас есть
переменная fullName

290
00:12:28,040 --> 00:12:31,860
и мы присваиваем ей строку
равную "Donn Felker"

291
00:12:31,860 --> 00:12:34,290
неявно она получит строковый тип

292
00:12:34,290 --> 00:12:35,690
И мы можем это проверить

293
00:12:35,690 --> 00:12:38,030
используя встроенные функции
рефлексии

294
00:12:38,030 --> 00:12:41,000
Напишем println функцию
и в скобках напишем fullName::class

295
00:12:41,000 --> 00:12:44,710
Чтобы проверить к какому классу
принадлежит эта переменная

296
00:12:44,710 --> 00:12:47,510
Если мы запустим программу, то в

297
00:12:47,510 --> 00:12:49,730
консоли мы увидим, что переменная
принадлежит к классу String

298
00:12:49,730 --> 00:12:51,530
Так мы понимаем что работаем со строкой

299
00:12:52,480 --> 00:12:54,770
Бывают случаи, когда вам нужно

300
00:12:54,770 --> 00:12:57,180
явно указать тип переменной

301
00:12:57,180 --> 00:13:00,010
и выможете это сделать, если после
названия переменной напишите

302
00:13:00,010 --> 00:13:04,150
двоеточие и тип, который вам нужен

303
00:13:04,150 --> 00:13:05,550
в нашем примере будет String

304
00:13:06,933 --> 00:13:08,120
И справа значение "Donn Felker"

305
00:13:08,120 --> 00:13:10,630
Если я тут напишу неправильный тип

306
00:13:10,630 --> 00:13:13,983
например целочисленный Integer
и значение будет равно

307
00:13:13,983 --> 00:13:14,816
"Donn Felker", то мы получим ошибку

308
00:13:14,816 --> 00:13:16,640
И в ошибке сказано, что тип переменной
и присвоенное значение не совпадают

309
00:13:17,721 --> 00:13:20,200
Значением должно быть число

310
00:13:20,200 --> 00:13:21,970
а вы пытаетесь присвоить строку

311
00:13:21,970 --> 00:13:23,050
и это просто не сработает

312
00:13:23,050 --> 00:13:25,800
если вы попробуете запустить
программу, игнорируя ошибку

313
00:13:26,671 --> 00:13:27,660
то компилятор скажет вам все тоже самое:

314
00:13:27,660 --> 00:13:30,780
Присвоенный тип строковый, а

315
00:13:30,780 --> 00:13:32,280
ожидался целочисленный

316
00:13:32,280 --> 00:13:36,490
Поэтому нужно поменять либо
ожидаемый тип

317
00:13:36,490 --> 00:13:38,670
либо заменить присваеваемое значение.

318
00:13:38,670 --> 00:13:41,540
Еще пример, если мы создадим
переменную age

319
00:13:41,540 --> 00:13:43,820
и явно захотим указать ее тип

320
00:13:44,670 --> 00:13:46,440
то мы напишем тип перед значением

321
00:13:46,440 --> 00:13:49,520
Таким образом, каждый раз когда
вы хотите явно указать тип

322
00:13:49,520 --> 00:13:54,520
для val/var переменной
вы пишите двоеточие и тип

323
00:13:54,840 --> 00:13:57,350
вы пишите двоеточие и тип

324
00:13:57,350 --> 00:13:59,100
после названия переменной

325
00:14:00,590 --> 00:14:02,660
В языке Котлин есть несколько
строенных типов

326
00:14:02,660 --> 00:14:05,620
Для начала рассмотрим
числовые типы

327
00:14:05,620 --> 00:14:08,450
Самый маленький из них - Byte (байт)

328
00:14:08,450 --> 00:14:10,536
Я создам переменную и назову
ее myByte

329
00:14:10,536 --> 00:14:12,423
и укажу ей тип Byte

330
00:14:12,423 --> 00:14:14,630
я присвою ей значение 8

331
00:14:14,630 --> 00:14:18,110
Байт - целоцисленное значение
размеровм 8 бит

332
00:14:20,750 --> 00:14:23,680
Следующее число Short
я создам переменную

333
00:14:23,680 --> 00:14:28,630
myShort и явно укажу тип Short

334
00:14:28,630 --> 00:14:31,170
Этой переменной я присвою
значение 16

335
00:14:31,170 --> 00:14:34,960
и это целочисленное значение
размером 16 бит

336
00:14:34,960 --> 00:14:38,380
Как вы уже могли заметить,
чем дальше тем

337
00:14:38,380 --> 00:14:40,170
больше становятся размеры типов

338
00:14:40,170 --> 00:14:42,070
Это значит, что максимальная величина
числа, котоаря может в них

339
00:14:42,070 --> 00:14:46,090
хранится, тоже становится больше.
Мы подходим к самомму популярному

340
00:14:46,090 --> 00:14:49,090
типу, который вы будете видеть
чаще всего,

341
00:14:49,090 --> 00:14:50,950
и это тип Integer.

342
00:14:50,950 --> 00:14:53,890
Integer может хранить

343
00:14:53,890 --> 00:14:54,960
в себе 32 бита информации.

344
00:14:57,270 --> 00:14:59,920
Дальше идет тип Long.

345
00:14:59,920 --> 00:15:01,820
этот тип может вмещать всебя очень
длинные числа

346
00:15:02,674 --> 00:15:03,712
наверное поэтому он так и называется

347
00:15:03,712 --> 00:15:05,725
Этот тип удобно использовать

348
00:15:05,725 --> 00:15:08,340
когда вы работаете с большими числами
и он вмещает в себя

349
00:15:09,300 --> 00:15:10,133
64-бита информации

350
00:15:12,600 --> 00:15:14,120
Это встроенные числовые типы языка

351
00:15:14,120 --> 00:15:17,027
вы будете работать с ними,

352
00:15:17,027 --> 00:15:17,937
если используете числа в программе.

353
00:15:17,937 --> 00:15:19,110
Скорее всего, самым частым
в использовании для вас

354
00:15:19,110 --> 00:15:23,940
станет Integer, который покрывает
90% кейсов при работе с числами

355
00:15:23,940 --> 00:15:26,910
Если числа у вас будут очень большие

356
00:15:26,910 --> 00:15:28,410
то лучше использовать Long

357
00:15:29,426 --> 00:15:30,259
И когда это действительно необходимо,

358
00:15:30,259 --> 00:15:32,820
и вы будете работать с действительно
большими числами

359
00:15:34,020 --> 00:15:36,180
используйте Long

360
00:15:36,180 --> 00:15:38,756
Однако бывают ситуации
когда вам нужно будет работать

361
00:15:38,756 --> 00:15:39,589
с десятичными числами.

362
00:15:39,589 --> 00:15:42,000
Если вам нужно хранить десятичные чиста

363
00:15:42,000 --> 00:15:44,900
Вы можете использовать тип Float

364
00:15:45,780 --> 00:15:47,750
Запишем переменную с типом Float

365
00:15:47,750 --> 00:15:52,030
и допустим ее значение равно 32.00

366
00:15:52,865 --> 00:15:54,650
Я поставлю 'F' на конце, потому что

367
00:15:54,650 --> 00:15:57,200
это значит что этот литерал имеет тип Float

368
00:15:57,200 --> 00:16:00,180
Float содержить 32 бита информации

369
00:16:01,380 --> 00:16:02,480
и так же называется числом
с плавающей точной

370
00:16:05,130 --> 00:16:07,640
Этот минимальный по размеру тип
данных для чисел с плавающей точкой

371
00:16:07,640 --> 00:16:09,420
Если вам нужны числа больше

372
00:16:09,420 --> 00:16:11,900
то вы можете использовать
тип Double

373
00:16:11,900 --> 00:16:15,140
и называется он Double потому что
хранит в два раза больше информации

374
00:16:15,140 --> 00:16:19,900
а именно число с плавоющей точкой
размером 64 байта

375
00:16:21,050 --> 00:16:22,760
Итак, это основные численные типы

376
00:16:22,760 --> 00:16:23,690
Которые вы будете использовать

377
00:16:23,690 --> 00:16:27,000
внутри вашей программы

378
00:16:27,000 --> 00:16:29,900
Есть у них всех необычная особенность

379
00:16:29,900 --> 00:16:31,770
Если мы посмотрим определение
любого из этих типов

380
00:16:31,770 --> 00:16:32,670
например Byte

381
00:16:32,670 --> 00:16:34,850
мы можем увидеть, что оно расширяет
тип Number (число)

382
00:16:36,070 --> 00:16:39,010
То же самое с типом Short

383
00:16:39,010 --> 00:16:41,220
Short тоже расширяет тип Number

384
00:16:41,220 --> 00:16:43,610
И мы можем пройти по каждому из них

385
00:16:43,610 --> 00:16:46,210
и заметим что каждый из них

386
00:16:46,210 --> 00:16:51,210
Integer, Long, Float и т.д.

387
00:16:51,980 --> 00:16:56,170
все они расширяют абстрактный класс
Number

388
00:16:56,170 --> 00:16:57,280
Давайте посмотрим на Number

389
00:16:57,280 --> 00:16:59,400
и узнаем из чего он сотоит

390
00:16:59,400 --> 00:17:01,150
Если мы зайдем в реализацию
типа Number

391
00:17:01,150 --> 00:17:03,460
мы увидим, что внутри него находится
множество разных функций

392
00:17:03,460 --> 00:17:05,530
к которым у нас есть доступ

393
00:17:05,530 --> 00:17:08,000
Здесь возникает важная для
Котлин концепция

394
00:17:08,000 --> 00:17:13,000
о том что любой тип это объект

395
00:17:13,670 --> 00:17:14,620
в языке Котлин

396
00:17:14,620 --> 00:17:18,260
Даже если вот это целое число - это объект

397
00:17:18,260 --> 00:17:21,860
Этот лонг - объект
Этот байт - объект

398
00:17:21,860 --> 00:17:24,109
А это значит, что мы можем вызывать методы

399
00:17:24,109 --> 00:17:25,660
и свойства этих объектов

400
00:17:25,660 --> 00:17:29,540
Например, если я захочу вывести myByte

401
00:17:32,980 --> 00:17:35,870
Допустим я хочу поделить его на что-нибудь

402
00:17:35,870 --> 00:17:38,530
тут можно увидеть кучу математических
функций готовых для этого класса

403
00:17:38,530 --> 00:17:42,520
И это уже готовые функции для
всех встроенных типов

404
00:17:42,520 --> 00:17:45,210
Возможно я хочу использовать toDouble
я могу написать toDouble

405
00:17:45,210 --> 00:17:47,170
и это превратит мой байт в double тип

406
00:17:47,170 --> 00:17:49,970
И эти преобразования реализованы
в классе Number

407
00:17:50,897 --> 00:17:54,310
Если мы пойдем в родительский класс

408
00:17:54,310 --> 00:17:56,630
мы увидим, что эта функция
лежит именно там

409
00:17:56,630 --> 00:17:58,940
и возвращает Double

410
00:17:59,840 --> 00:18:01,940
И если я сейчас возьму этот байт и

411
00:18:01,940 --> 00:18:03,100
преобразую его в Double

412
00:18:03,100 --> 00:18:04,860
Если мы сейчас выведем его тип

413
00:18:04,860 --> 00:18:08,510
консоль, используя ::class

414
00:18:08,510 --> 00:18:09,690
и запустим программу

415
00:18:09,690 --> 00:18:11,920
вы увидите, что тип нашего байта
стал double

416
00:18:14,750 --> 00:18:16,060
Теперь, если мы сменим

417
00:18:16,060 --> 00:18:18,550
это значение на toLong

418
00:18:20,410 --> 00:18:23,630
и запустим снова, то увидим
что тип стал Long

419
00:18:26,003 --> 00:18:28,010
Мы получаем восемь

420
00:18:28,010 --> 00:18:31,270
просто мы забыли добавить ::class

421
00:18:32,340 --> 00:18:36,340
Вот теперь вывод показывает
тип Kotlin.Long

422
00:18:36,340 --> 00:18:39,200
Когда мы работаем с такими специфичными
типами, как Long

423
00:18:39,200 --> 00:18:41,340
мы можем использовать литералы

424
00:18:43,380 --> 00:18:46,390
Назовем переменную bigLong
и укажем тип Long

425
00:18:46,390 --> 00:18:48,640
И теперь мы можем использовать интересный
синтаксис языка

426
00:18:49,500 --> 00:18:53,440
Такой способ записи встроен
в синтаксис языка Котлим

427
00:18:53,440 --> 00:18:54,830
и читать большие числа в такой записи
гораздо легче

428
00:18:54,830 --> 00:18:56,520
Это значение равно одному миллиону

429
00:18:56,520 --> 00:19:00,590
И теперь, если мы захотим

430
00:19:00,590 --> 00:19:03,760
напечатать это число в консоль

431
00:19:03,760 --> 00:19:06,300
мы увидим что в выводе
будет просто один миллион,

432
00:19:06,300 --> 00:19:08,550
но читать такую запись
гораздо проще

433
00:19:08,550 --> 00:19:11,270
просто из-за визуального
разделения

434
00:19:11,270 --> 00:19:14,080
...

435
00:19:14,080 --> 00:19:16,950
Такой вид записи полезен,
когда у вас в программе

436
00:19:16,950 --> 00:19:19,530
есть, например, переменная в 1 миллион

437
00:19:19,530 --> 00:19:20,370
или в тысячу, неважно

438
00:19:20,370 --> 00:19:22,590
Вы можете упростить чтение

439
00:19:22,590 --> 00:19:26,120
потому что, допустим
если у вас будет миллиард

440
00:19:26,120 --> 00:19:29,920
такая запись гораздо легче,
чем без подчеркиваний

441
00:19:29,920 --> 00:19:31,680
потому что вы просто не понимаете
сразу с первого взгляда

442
00:19:31,680 --> 00:19:34,960
что это 1 миллион или
10 миллионов

443
00:19:34,960 --> 00:19:36,680
Это очень трудно определить

444
00:19:36,680 --> 00:19:39,310
но если добавить подчеркивания

445
00:19:39,310 --> 00:19:41,410
то разница становится очевидна

446
00:19:41,410 --> 00:19:43,110
что это 1 миллиард

447
00:19:43,110 --> 00:19:46,450
Еще одна вещь, которую
можно делать с числами -

448
00:19:46,450 --> 00:19:48,310
конечно мы можем их складывать

449
00:19:48,310 --> 00:19:50,250
Заведем переменную myInt

450
00:19:51,470 --> 00:19:55,000
а точнее newInt и напишем
что она равна myInt+12

451
00:19:55,000 --> 00:19:57,080
и это будет равно 44

452
00:19:57,080 --> 00:20:01,110
Выведем это число через println

453
00:20:01,110 --> 00:20:03,900
и когда мы запусти программу
внизу экрана

454
00:20:03,900 --> 00:20:08,030
мы увидим что newInt равен 44

455
00:20:08,030 --> 00:20:09,980
Еще мы можем использовать

456
00:20:09,980 --> 00:20:11,530
встроенные в Котлин методы

457
00:20:13,330 --> 00:20:15,360
напишем plus и число 12

458
00:20:17,240 --> 00:20:18,170
Теперь мы можем запустить

459
00:20:18,170 --> 00:20:20,640
Так вот, это очень удобный синтаксический
сахар для сложения

460
00:20:20,640 --> 00:20:22,070
мы так же получим 44

461
00:20:22,070 --> 00:20:25,570
Мы так же можем сделать minus и

462
00:20:25,570 --> 00:20:27,640
если запустим то увидим 20 (не 44)

463
00:20:28,681 --> 00:20:30,720
И таких математических функций
очень много

464
00:20:30,720 --> 00:20:32,600
мы можем посмотреть их все разом

465
00:20:32,600 --> 00:20:35,560
если просто введем точку,
чтобы среда подсказала

466
00:20:35,560 --> 00:20:36,860
нам эти методы.

467
00:20:36,860 --> 00:20:39,090
И если вы не знаете
какие-то из них

468
00:20:39,090 --> 00:20:40,020
вы можете посмореть их

469
00:20:40,020 --> 00:20:41,980
Например, вы не знаете

470
00:20:41,980 --> 00:20:45,200
метод "and" вы можете нажать
cmd+B

471
00:20:45,200 --> 00:20:47,210
и посмотреть определения функции
что and проводит

472
00:20:47,210 --> 00:20:49,250
побитовое "И" на двух числах

473
00:20:49,250 --> 00:20:52,980
Если вам нужны побитовые операции
вы ожете использовать для этого "and"

474
00:20:52,980 --> 00:20:57,520
вы можете вызвать функции "plus"
"multiply" или "times"

475
00:20:57,520 --> 00:20:58,580
и вы можете запустить
программу и посмотреть результат

476
00:20:58,580 --> 00:21:03,580
Умножая 32 на 12 мы получим 384

477
00:21:04,260 --> 00:21:06,910
Итак, все это базовые типы от
маленьких к большим

478
00:21:06,910 --> 00:21:09,230
Мы начинаем в byte, short,
int, long

479
00:21:10,094 --> 00:21:10,927
а потом переходим на десятичные

480
00:21:10,927 --> 00:21:11,890
типы float и double

481
00:21:11,890 --> 00:21:14,190
Это встроенные бызовые числовые
типы языка Котлин

482
00:21:15,380 --> 00:21:18,410
В языке котлин строки
тоже являются объектами

483
00:21:18,410 --> 00:21:21,460
Если мы вернемся к нашему
первому примеру с полным именем

484
00:21:21,460 --> 00:21:25,210
и явно укажем у fullName
строковый тип String

485
00:21:25,210 --> 00:21:28,320
и запишем значение "Donn Felker"
мы получим строковый объект

486
00:21:28,320 --> 00:21:32,280
с названием fullName
и значением "Donn Felker"

487
00:21:33,140 --> 00:21:36,180
У него мы можем вызывать

488
00:21:36,180 --> 00:21:38,950
методы, напечатав точку

489
00:21:38,950 --> 00:21:40,310
например, чтобы узнать длину строки

490
00:21:41,768 --> 00:21:43,792
Так мы получим длину строки

491
00:21:43,792 --> 00:21:46,130
Я скопирую эту строку с помощью
хоткея cmd+D

492
00:21:46,130 --> 00:21:50,630
Можно получить все символы строки

493
00:21:50,630 --> 00:21:53,690
которые мы получим в виде
набора символов

494
00:21:53,690 --> 00:21:55,730
Можно использовать очень много

495
00:21:55,730 --> 00:21:57,300
готовых функций

496
00:21:57,300 --> 00:22:00,060
например, я могу привести к
строчному виду первый символ строки

497
00:22:00,060 --> 00:22:01,880
Давайте приведем к строчному виду

498
00:22:01,880 --> 00:22:06,250
и запустим программу,
снизу мы увидим

499
00:22:06,250 --> 00:22:11,250
"donn Felker" - наша строка
в строчном виде

500
00:22:11,350 --> 00:22:14,820
Если мы будем работать с предложением,
допустим строкой "Hello World"

501
00:22:15,860 --> 00:22:18,220
если я снова запущу
программу, мы увидим

502
00:22:18,220 --> 00:22:20,450
что первый символ новой строки

503
00:22:20,450 --> 00:22:21,740
будет строчным

504
00:22:21,740 --> 00:22:24,060
Если я захочу, чтобы вся строка
была в нижнем регистре

505
00:22:24,060 --> 00:22:27,730
анпишем toLowercase
и запустим программу

506
00:22:27,730 --> 00:22:30,280
и это позволяет сделать все символы

507
00:22:30,280 --> 00:22:31,910
строки в строчном виде

508
00:22:31,910 --> 00:22:36,910
Строки в котлине можно создавать
используя две кавычки

509
00:22:38,780 --> 00:22:41,320
Мы можем написать firastName "Donn"

510
00:22:41,320 --> 00:22:42,153
обязательно через две кавычки

511
00:22:42,153 --> 00:22:43,060
Есть еще один тип, когда

512
00:22:43,060 --> 00:22:45,480
мы хотим работать с единичными
символами

513
00:22:45,480 --> 00:22:47,900
мы можем использовать тип Char
(character - символ)

514
00:22:47,900 --> 00:22:51,000
Я напишу "val c"
с типом Char

515
00:22:51,000 --> 00:22:54,330
и присвою ему значение X

516
00:22:55,700 --> 00:22:57,850
Стоп, что-то идет не так

517
00:22:58,710 --> 00:23:01,450
Почему ругается компилятор?

518
00:23:01,450 --> 00:23:04,670
Все потому что, если в Котлине
вы хотите объявить символ

519
00:23:04,670 --> 00:23:07,880
Вам нужно использовать литерал
одинарных ковычек (апострофоф)

520
00:23:07,880 --> 00:23:11,550
Апострофы дают возможность создать

521
00:23:11,550 --> 00:23:13,810
символьные объекты

522
00:23:15,170 --> 00:23:18,940
Тут есть небольшой подвох

523
00:23:18,940 --> 00:23:22,930
Символы бывают разными, например
символ Tab отступа

524
00:23:22,930 --> 00:23:25,060
для того чтобы его создать
нужно указать символ "\" перед "t"

525
00:23:25,060 --> 00:23:27,221
есть еще перенос строки '\n'

526
00:23:27,221 --> 00:23:29,850
и, конечно, если вы хотите создать
символ "\", вам нужно написать '\\'

527
00:23:29,850 --> 00:23:31,670
в Котлине есть еще много специальных
символов, которые вы

528
00:23:31,670 --> 00:23:33,750
можете найти самостоятельно.

529
00:23:33,750 --> 00:23:38,650
В котлине тип Char это
16-ти битный юникод символ

530
00:23:39,710 --> 00:23:43,272
Поэтому каждый раз, когда
вам понадобится символ

531
00:23:43,272 --> 00:23:44,750
спокойно используйте тип Char

532
00:23:44,750 --> 00:23:46,800
Но ничего вам не межает использовать

533
00:23:46,800 --> 00:23:49,140
строковый тип с одним символом

534
00:23:52,695 --> 00:23:54,395
Можем написать переменную "foo"
с типом String и написать, что

535
00:23:55,540 --> 00:23:56,410
это равно "Y" и это
будет работать

536
00:23:56,410 --> 00:23:59,360
В этом случае вы будете работать
с типом String

537
00:23:59,360 --> 00:24:01,890
Единственная разнича, что
строка в памяти будет занимать

538
00:24:03,010 --> 00:24:04,450
больше места, чем "Char"

539
00:24:04,450 --> 00:24:06,100
Но вряд ли это на что-то сильно повлияет
и вы можете работать со строкой

540
00:24:06,100 --> 00:24:08,821
Однако, если вы точно знаете, что
у переменной будет только один

541
00:24:08,821 --> 00:24:11,150
символ, то лучше работать
с типом Char

542
00:24:13,030 --> 00:24:13,863
Иногда, при создании строки,
вам нужно написать ее в

543
00:24:13,863 --> 00:24:17,120
несколько строк

544
00:24:17,120 --> 00:24:19,180
Наприме, если у нас есть
переменная "message"

545
00:24:19,180 --> 00:24:21,700
и значение у нее будет "Hello"

546
00:24:21,700 --> 00:24:22,920
символ переноса строки

547
00:24:25,118 --> 00:24:27,550
"меня зову Донн Фэлкер"
символ новой строки

548
00:24:29,217 --> 00:24:30,360
"как ваши дела" и выведу это
на экран

549
00:24:31,660 --> 00:24:34,310
И когда я запущу,
я увижу все свое сообщение

550
00:24:34,310 --> 00:24:36,510
на нескольких строках

551
00:24:36,510 --> 00:24:39,240
Но выглядит это очень убого

552
00:24:39,240 --> 00:24:41,480
В Котлине есть способ для
таких случаев

553
00:24:41,480 --> 00:24:43,880
можно использовать три
ковычки подряд

554
00:24:45,006 --> 00:24:49,493
Перепишем наш текст и уберем
символы переносы строки

555
00:24:50,853 --> 00:24:52,260
и снова запустим программу

556
00:24:54,040 --> 00:24:55,910
Я для запуска использую шорткат

557
00:24:55,910 --> 00:24:59,520
который можно посмотреть здесь.
Это шорткат

558
00:24:59,520 --> 00:25:01,540
control+shift+R на Маке

559
00:25:03,004 --> 00:25:05,075
В окне вывода можно увидеть,
что результат тот же самый

560
00:25:05,075 --> 00:25:05,908
"Hello, my name is Donn Felker."

561
00:25:05,908 --> 00:25:06,741
Но что значит trimIndent

562
00:25:06,741 --> 00:25:07,960
Что тут происходит

563
00:25:07,960 --> 00:25:11,290
Наш текст форматируется так же как
он записывается в тройные кавычки

564
00:25:11,290 --> 00:25:14,068
функция trimIndent просто затирает
ненужные пробелы

565
00:25:14,068 --> 00:25:14,970
Мы можем посмотреть
документацию функции

566
00:25:14,970 --> 00:25:18,470
trimIndent затирает отступы
в каждой строке

567
00:25:18,470 --> 00:25:20,520
вашего предложения

568
00:25:20,520 --> 00:25:23,390
Если мы уберем этот метод
мы увидим что

569
00:25:23,390 --> 00:25:26,130
появилось много ненужных отступов

570
00:25:26,130 --> 00:25:27,280
Строка наша начнется с символа новой строки

571
00:25:27,280 --> 00:25:29,440
и каждая отдельная строка
будет иметь большой отступ

572
00:25:29,440 --> 00:25:32,118
Запустим и проверим

573
00:25:32,118 --> 00:25:32,951
Вот наш перенос строки

574
00:25:32,951 --> 00:25:34,490
и везде появились отступы

575
00:25:34,490 --> 00:25:38,240
Вернем наш метод обратно, чтобы

576
00:25:38,240 --> 00:25:42,970
убрать переносы и лишние отступы

577
00:25:42,970 --> 00:25:46,340
Я перезапушу программу, чтобы
вернуть все назад

578
00:25:46,340 --> 00:25:49,920
Теперь посмотрим на функцию
replaceIndent

579
00:25:49,920 --> 00:25:52,160
Если напрмер я хочу самомстоятельно
заменить отступы в

580
00:25:52,160 --> 00:25:55,020
строке, но не хочу их убирать,
а хочу подставить что-то другое

581
00:25:55,020 --> 00:25:57,700
а хочу подставить что-то другое

582
00:25:57,700 --> 00:26:02,700
например строку "abc" и символ
вертикальной черточки

583
00:26:03,710 --> 00:26:05,210
или что-то другое

584
00:26:05,210 --> 00:26:07,770
Если я запущу это, программа
заменит отступы

585
00:26:07,770 --> 00:26:11,160
в каждой строке на то что
я ей сказал

586
00:26:11,160 --> 00:26:15,390
выглядит очень круто

587
00:26:15,390 --> 00:26:17,890
Еще это форматирование
можно регулировать

588
00:26:17,890 --> 00:26:20,760
с помощью метода

589
00:26:20,760 --> 00:26:25,760
trimMargin. напишем наш метод
и укажем какой-нибудь префикс

590
00:26:27,310 --> 00:26:29,740
Например я хочу чтобы в тексте

591
00:26:29,740 --> 00:26:33,590
форматировались только строки у
которых в начале три стрелочки ">>>"

592
00:26:33,590 --> 00:26:37,600
Если я запущу программу со строкой
в таком виде, то мы уидим

593
00:26:37,600 --> 00:26:39,160
что программа не нашла нашего префикса

594
00:26:39,160 --> 00:26:40,540
поэтому ничего не меняла

595
00:26:40,540 --> 00:26:43,550
Это значит, что для этой функции

596
00:26:43,550 --> 00:26:44,383
в строке должны быть стрелочки

597
00:26:44,383 --> 00:26:45,216
Допустим эти стрелочки

598
00:26:45,216 --> 00:26:46,870
появились, добавим их везде

599
00:26:49,279 --> 00:26:50,540
И если теперь это запустим

600
00:26:50,540 --> 00:26:51,890
мы увидим, что все три строки
теперь без отступов

601
00:26:51,890 --> 00:26:55,670
Если мы уберем значение
префикса из функции

602
00:26:56,917 --> 00:26:59,020
то эти стрелочки появятся в
выводе вместе с отступами

603
00:26:59,020 --> 00:27:03,450
У метода trimmargin
есть значение по дефолту

604
00:27:03,450 --> 00:27:07,960
это символ вертикальной черты "|"

605
00:27:09,830 --> 00:27:13,480
Я допишу символы и запущу программу

606
00:27:13,480 --> 00:27:15,320
Функция нашла строки с вертикальной
чертой и убрала все отступы

607
00:27:15,320 --> 00:27:16,860
и саму черту

608
00:27:16,860 --> 00:27:19,470
Вот таким образом можно делать

609
00:27:19,470 --> 00:27:21,570
многострочные предложение

610
00:27:21,570 --> 00:27:24,430
Еще одна интересная штуковина:
допустим, у нас есть

611
00:27:24,430 --> 00:27:26,650
переменная "name" со значением "Donn"

612
00:27:26,650 --> 00:27:29,470
Иногда, у вас может возникнуть
необходимость вывести

613
00:27:29,470 --> 00:27:30,610
сообщение в консоль таким образом:

614
00:27:30,610 --> 00:27:32,460
представьте, что мы хотим поприветствовать
человека и написать "Hello Donn"

615
00:27:33,414 --> 00:27:35,760
Мы сделаем это с помощью
конкатенации строк

616
00:27:35,760 --> 00:27:38,980
это самый стандартный метод
для многих языков и он рабочий

617
00:27:39,920 --> 00:27:42,581
Запустим и увидим в консоли
"Hello Donn"

618
00:27:42,581 --> 00:27:43,414
Все работает как должно

619
00:27:43,414 --> 00:27:45,050
Но обратите внимание, что
копилятор подчеркнул нашу строку

620
00:27:45,050 --> 00:27:47,260
В подсказке он предлагает
перевести конкатенацию в шаблон

621
00:27:47,260 --> 00:27:49,510
В Котлине вы можете соединять
строки без конкатенации,

622
00:27:49,510 --> 00:27:50,920
а с помощью шаблонов

623
00:27:50,920 --> 00:27:54,060
На подсвеченной строке нажмем alt+enter
и возникнет подсказка

624
00:27:54,060 --> 00:27:55,970
выберем первый пункт и

625
00:27:55,970 --> 00:27:57,540
компилятор сам исправит наш код

626
00:27:57,540 --> 00:27:59,290
И новый код делает
ровно ту же вещь

627
00:28:00,596 --> 00:28:03,130
С единственным исключением
что в коде это

628
00:28:03,130 --> 00:28:04,730
выглядит как одна строка

629
00:28:05,820 --> 00:28:08,290
Добавим еще возраст

630
00:28:08,290 --> 00:28:09,460
допустим 32

631
00:28:10,957 --> 00:28:12,410
И скажем "Приввет имя, твой возраст"

632
00:28:12,410 --> 00:28:15,948
и добавим age переменную
в конце

633
00:28:15,948 --> 00:28:19,650
И теперь возраст тоже выведется
в этой строке.

634
00:28:20,780 --> 00:28:23,416
Еще одна интересная вещь,
которую мы можем

635
00:28:23,416 --> 00:28:25,030
делать через шаблоны -

636
00:28:25,030 --> 00:28:25,863
напишем в таком виде

637
00:28:25,863 --> 00:28:30,860
Привет, дальше имя, возраст
и добавим "длина твоего имени"

638
00:28:31,890 --> 00:28:33,430
поставим знак доллара

639
00:28:34,780 --> 00:28:37,100
откроем фигурные скобки и
у переменной вызовем функцию

640
00:28:37,100 --> 00:28:39,420
через точку, чтобы вывести длину
переменной

641
00:28:40,910 --> 00:28:42,240
получится ${name.length}

642
00:28:43,450 --> 00:28:44,283
И теперь в консоль выведется

643
00:28:44,283 --> 00:28:46,520
Привет Дон, тебе 32 года

644
00:28:46,520 --> 00:28:51,520
и твое имя такой-то длинны

645
00:28:52,630 --> 00:28:53,530
запустим этот код

646
00:28:55,530 --> 00:28:57,540
Привет Дон, тебе 32 года и твое имя

647
00:28:57,540 --> 00:28:58,490
длинной 4 символа

648
00:28:58,490 --> 00:29:03,330
Таким образом вместо сложной
конкатенации строк

649
00:29:03,330 --> 00:29:04,700
можно просто

650
00:29:04,700 --> 00:29:07,390
использовать интерполяцию строк

651
00:29:07,390 --> 00:29:08,870
и шаблонами передавать значения

652
00:29:08,870 --> 00:29:11,470
Если вы не вызываете методов
то можно просто писать знак доллара

653
00:29:11,470 --> 00:29:14,660
а методы нужно оборачивать в
фигурные скобки

654
00:29:14,660 --> 00:29:17,550
В любом случае компилятор

655
00:29:17,550 --> 00:29:21,120
и IDE подскажет вам, если что-то
лишнее или чего-то не хватает

656
00:29:21,120 --> 00:29:23,260
так вы можете писать код прямо в строку

657
00:29:23,260 --> 00:29:25,440
и оборачивать его в фигурные скобки

658
00:29:26,430 --> 00:29:29,890
Last, but certainly not
least is the Boolean value.

659
00:29:29,890 --> 00:29:31,720
And we could specify one like this.

660
00:29:31,720 --> 00:29:33,150
So we could say is blank.

661
00:29:34,298 --> 00:29:37,040
It would provide us a
truer val false value,

662
00:29:37,040 --> 00:29:39,960
and we'll just initialize it to false.

663
00:29:39,960 --> 00:29:42,480
And so this just basically has two options

664
00:29:42,480 --> 00:29:44,780
and that's true or false when
we go to the implementation.

665
00:29:44,780 --> 00:29:47,300
Again, everything in Kotlin is an object.

666
00:29:47,300 --> 00:29:49,280
And so there's some other
built-in operators here.

667
00:29:49,280 --> 00:29:52,020
So we can do the inverse of that.

668
00:29:52,020 --> 00:29:55,350
So if we wanted to know, for
example, let's just print this.

669
00:29:55,350 --> 00:30:00,350
Print ln is blank and then we
can just do print ln is blank,

670
00:30:03,410 --> 00:30:05,860
and then not, and this will
print the inverse of it.

671
00:30:05,860 --> 00:30:09,110
If we run it again, we see
here in our output window,

672
00:30:09,110 --> 00:30:11,120
of course we had false
and then we have true.

673
00:30:11,120 --> 00:30:13,450
So we initialize it to
false and then true.

674
00:30:13,450 --> 00:30:16,910
We can also initialize it, of
course, using other variables,

675
00:30:16,910 --> 00:30:20,430
such as a string, so it will say is blank.

676
00:30:21,800 --> 00:30:22,760
And then we can use a string.

677
00:30:22,760 --> 00:30:26,950
So we go blank, that is blank.

678
00:30:26,950 --> 00:30:29,440
So function is blank on a string.

679
00:30:29,440 --> 00:30:31,430
So this is a char sequence
function that checks

680
00:30:31,430 --> 00:30:36,110
to see if they link the zero
and return the Boolean value.

681
00:30:36,110 --> 00:30:38,320
And if it's zero, then
it's going to return true.

682
00:30:38,320 --> 00:30:40,010
So we can print this off here.

683
00:30:40,010 --> 00:30:44,440
I'm just gonna copy this and
then we could see the value

684
00:30:44,440 --> 00:30:45,380
true or false.

685
00:30:47,480 --> 00:30:50,220
So we'll run this and of
course it's blank of course.

686
00:30:50,220 --> 00:30:53,970
If we change this to two first name, Don,

687
00:30:53,970 --> 00:30:55,940
and we run it, it's gonna end up false.

688
00:30:56,807 --> 00:30:58,480
Then it will say false, of
course we did the inverse,

689
00:30:58,480 --> 00:30:59,610
which is not.

690
00:30:59,610 --> 00:31:02,500
And there's many other
functions on this Kotlin object

691
00:31:02,500 --> 00:31:05,330
that you can also inspect that you can do,

692
00:31:05,330 --> 00:31:08,150
which is gonna be or, X or et cetera

693
00:31:08,150 --> 00:31:09,510
and a bunch of other ones inside there.

694
00:31:09,510 --> 00:31:10,970
You can check them out by navigating

695
00:31:10,970 --> 00:31:13,600
to the Boolean section there.

696
00:31:13,600 --> 00:31:16,310
But if you need something that
represents a true or false

697
00:31:16,310 --> 00:31:18,340
condition, you'll want to use Boolean.

698
00:31:19,310 --> 00:31:21,630
Working with conditionals
is a very common thing

699
00:31:21,630 --> 00:31:23,224
that you'll do in the Kotlin language.

700
00:31:23,224 --> 00:31:26,040
Let's assume that you're
building an application

701
00:31:26,040 --> 00:31:28,580
which will track your calories.

702
00:31:28,580 --> 00:31:31,300
And let's assume we
start with 2,500 calories

703
00:31:31,300 --> 00:31:34,530
and these would be the calories
that we consumed already,

704
00:31:34,530 --> 00:31:37,328
or the user has consumed in their tracking

705
00:31:37,328 --> 00:31:38,330
for their diet purposes.

706
00:31:38,330 --> 00:31:40,410
Now let's assume that we
had a requirement that says,

707
00:31:40,410 --> 00:31:43,980
if the calories that have
been consumed are over 2000,

708
00:31:43,980 --> 00:31:47,300
then we have to print
a message to the viewer

709
00:31:47,300 --> 00:31:50,240
or the end user to let them
know that they've eaten enough,

710
00:31:50,240 --> 00:31:52,740
they've consumed all of
their calories for a day.

711
00:31:55,260 --> 00:31:57,370
So, here we have see that they've consumed

712
00:31:57,370 --> 00:31:58,260
all their calories for a day.

713
00:31:58,260 --> 00:32:00,330
Now, if we run this,
you're gonna see down here

714
00:32:00,330 --> 00:32:02,590
in the bottom window that we can see

715
00:32:02,590 --> 00:32:04,630
that they've consumed all
their calories for the day

716
00:32:04,630 --> 00:32:06,190
down here at the bottom.

717
00:32:06,190 --> 00:32:10,380
Now, if we were to change
this, let's say to 1900,

718
00:32:10,380 --> 00:32:13,261
we're gonna notice that
the line of code here

719
00:32:13,261 --> 00:32:15,480
on line four does not get
run because the calories

720
00:32:15,480 --> 00:32:18,160
are less than 2000.

721
00:32:18,160 --> 00:32:20,730
So that means we're not
gonna print this line.

722
00:32:20,730 --> 00:32:25,050
So let's say for some reason,
we wanted to check to see.

723
00:32:25,970 --> 00:32:28,240
Otherwise, if they haven't eaten all 2000,

724
00:32:28,240 --> 00:32:29,930
we can say something else like,

725
00:32:29,930 --> 00:32:31,930
okay, you still have some calories left.

726
00:32:31,930 --> 00:32:33,080
So I'll say print line.

727
00:32:35,700 --> 00:32:36,970
And if we were to run
this, we would see now

728
00:32:36,970 --> 00:32:39,950
that you still have some calories left.

729
00:32:39,950 --> 00:32:42,080
So we know that again,
this is a conditional,

730
00:32:42,080 --> 00:32:44,967
if conditional, and this
is the else portion.

731
00:32:44,967 --> 00:32:48,080
So if there are over
2000 calories consumed,

732
00:32:48,932 --> 00:32:50,200
this line of code is gonna be printed.

733
00:32:51,234 --> 00:32:53,445
Otherwise, else we're going to print this.

734
00:32:53,445 --> 00:32:55,100
So any other types of, if it
does not match this condition,

735
00:32:55,100 --> 00:32:58,210
so anything less than 2000
is gonna show up here.

736
00:32:58,210 --> 00:33:03,000
So we even just put this
to 2001 and rerun this.

737
00:33:03,000 --> 00:33:05,790
You're gonna see that we have consumed

738
00:33:05,790 --> 00:33:07,390
all of our calories for the day.

739
00:33:08,476 --> 00:33:09,610
Now let's assume that
you're working with someone

740
00:33:09,610 --> 00:33:11,910
and they decide, or you decide in your app

741
00:33:12,766 --> 00:33:15,110
that you would like to make
sure that if they've consumed

742
00:33:15,110 --> 00:33:18,320
over 1500, then what you would like to do

743
00:33:19,200 --> 00:33:21,080
is give them a little bit of motivation

744
00:33:21,080 --> 00:33:23,100
and to let them know they
had a little bit of room

745
00:33:23,100 --> 00:33:25,170
to have like a snack or something.

746
00:33:25,170 --> 00:33:29,020
And so you can say, if
calories is less than,

747
00:33:29,950 --> 00:33:33,800
excuse me, is greater than 1500.

748
00:33:33,800 --> 00:33:37,781
So here, perhaps it's a 2000.

749
00:33:37,781 --> 00:33:38,750
So if the calories are greater than 1500,

750
00:33:38,750 --> 00:33:42,020
we can say print ln and say,

751
00:33:42,020 --> 00:33:45,820
you have a few more calories left to eat.

752
00:33:46,860 --> 00:33:49,320
And so if we run this again,
what we're gonna see here

753
00:33:49,320 --> 00:33:50,520
is still the top line.

754
00:33:50,520 --> 00:33:53,020
You've consumed all your
calories for the day.

755
00:33:53,020 --> 00:33:54,380
Let's go ahead and make an adjustment

756
00:33:54,380 --> 00:33:58,460
saying we've eaten 1750 and
we were running our program

757
00:33:58,460 --> 00:34:00,080
and the program would now say,

758
00:34:00,080 --> 00:34:01,960
you have a few more calories to eat

759
00:34:02,808 --> 00:34:04,030
as we can see down here in the bottom.

760
00:34:04,030 --> 00:34:08,120
And then for some reason,
we even set this to 1499,

761
00:34:08,120 --> 00:34:10,520
which means this condition will be false.

762
00:34:10,520 --> 00:34:11,800
And then it checks this condition,

763
00:34:11,800 --> 00:34:13,010
this condition will be false,

764
00:34:13,010 --> 00:34:16,420
which means anything in the
else block without be printed.

765
00:34:16,420 --> 00:34:19,750
So let's run that and we
can see that you still have

766
00:34:19,750 --> 00:34:22,480
some calories left, which is pretty cool.

767
00:34:22,480 --> 00:34:26,350
So you can keep adding on these
various different else, ifs.

768
00:34:26,350 --> 00:34:27,990
So, if we wanted to add another one here,

769
00:34:27,990 --> 00:34:30,450
we can add another else, if as well.

770
00:34:30,450 --> 00:34:31,920
And we could say something else,

771
00:34:31,920 --> 00:34:36,920
like calories is greater
than 1200 and perhaps

772
00:34:39,290 --> 00:34:41,790
we just wanna give another
message here like this.

773
00:34:45,200 --> 00:34:48,070
And then if you were to run
this and you were to set this

774
00:34:48,070 --> 00:34:51,690
at, let's say 1400, and
we were to run this,

775
00:34:52,540 --> 00:34:54,140
you could see down here at the bottom,

776
00:34:54,140 --> 00:34:56,670
you have some room for snacks.

777
00:34:56,670 --> 00:34:59,400
So we can not keep adjusting
this and play with this.

778
00:34:59,400 --> 00:35:01,820
And there's no limit to
the amount of else ifs

779
00:35:01,820 --> 00:35:03,400
that you can throw in here.

780
00:35:03,400 --> 00:35:05,510
So if you have many conditions,

781
00:35:05,510 --> 00:35:09,220
so if you only have one
condition, it may just equate

782
00:35:09,220 --> 00:35:10,520
to be something like this.

783
00:35:11,909 --> 00:35:13,260
It's very simple, your if or else.

784
00:35:13,260 --> 00:35:15,300
You do not have to have an else either.

785
00:35:15,300 --> 00:35:17,890
If you don't wanna have
an else and you just need

786
00:35:19,193 --> 00:35:21,650
to perform some type of
action only if one value

787
00:35:21,650 --> 00:35:24,640
is true here, then you
go ahead and print this.

788
00:35:24,640 --> 00:35:26,540
So else is not required.

789
00:35:26,540 --> 00:35:29,190
The else ifs are not
required if you're using

790
00:35:29,190 --> 00:35:30,720
an if statement.

791
00:35:30,720 --> 00:35:33,920
So again, just an if statement
or you continually add

792
00:35:33,920 --> 00:35:37,540
else ifs and we can continue
to add these if we wanted to.

793
00:35:37,540 --> 00:35:39,890
So we could add another one here

794
00:35:39,890 --> 00:35:43,800
and we could say, calories
were greater than 1000,

795
00:35:43,800 --> 00:35:48,800
you can say, you have plenty
of calories left, et cetera.

796
00:35:50,060 --> 00:35:54,640
And as we go down, so again,
if we were to go to 1100,

797
00:35:54,640 --> 00:35:56,110
that line would now print,

798
00:35:57,397 --> 00:35:58,230
you have plenty of calories left.

799
00:35:58,230 --> 00:36:02,080
And if again, we dropped
it down to let's say 800

800
00:36:02,080 --> 00:36:04,340
and we ran it, which one
you think would run here.

801
00:36:04,340 --> 00:36:06,774
It's actually going to
be the bottom one here

802
00:36:06,774 --> 00:36:09,260
because the calories is
not greater than 2000.

803
00:36:09,260 --> 00:36:12,350
It's not greater than 1500,
it's not greater than 1200,

804
00:36:12,350 --> 00:36:13,770
it's not greater than 1000.

805
00:36:13,770 --> 00:36:16,690
So therefore the final
conditions going to run.

806
00:36:16,690 --> 00:36:20,460
And this is a very simple,
if else conditional

807
00:36:20,460 --> 00:36:21,293
that you can use.

808
00:36:21,293 --> 00:36:23,380
These are gonna be the most
traditional type of if elses

809
00:36:23,380 --> 00:36:24,920
that you see in your programs.

810
00:36:24,920 --> 00:36:28,330
In Kotlin, you can also
omit the closing parentheses

811
00:36:28,330 --> 00:36:31,660
and open parentheses of a
condition if it's a one-liner.

812
00:36:31,660 --> 00:36:34,550
So let's say if the
age is greater than 10,

813
00:36:34,550 --> 00:36:39,110
you can actually just write
ln is greater than 10.

814
00:36:40,200 --> 00:36:43,630
So let's go and change it
actually two 11 and we run it.

815
00:36:43,630 --> 00:36:45,460
We're gonna see that the
output in a window down here

816
00:36:45,460 --> 00:36:46,960
as the age is greater than 10.

817
00:36:48,376 --> 00:36:50,430
Now, if for some reason
we change this to nine,

818
00:36:50,430 --> 00:36:54,370
notice how the steel yet
we don't get an error,

819
00:36:54,370 --> 00:36:57,470
but we don't see that the
age is greater than 10

820
00:36:57,470 --> 00:37:02,470
because a single line statement
can now just be printed

821
00:37:03,410 --> 00:37:04,280
without parentheses.

822
00:37:04,280 --> 00:37:06,750
However, this should be often avoided

823
00:37:06,750 --> 00:37:09,130
as it can be confusing even if I divert

824
00:37:09,130 --> 00:37:10,430
to do something like this.

825
00:37:12,102 --> 00:37:13,140
It's hard just to type this.

826
00:37:14,415 --> 00:37:15,248
Just basically upon the indentation,

827
00:37:15,248 --> 00:37:17,300
you would think that hello
there would not be printed,

828
00:37:17,300 --> 00:37:21,340
but however, hello there is
not part of the if condition.

829
00:37:21,340 --> 00:37:23,770
The highlighted area you see here

830
00:37:23,770 --> 00:37:25,170
is part of the if condition.

831
00:37:26,717 --> 00:37:29,070
This print line, hello there is not part

832
00:37:29,070 --> 00:37:31,130
of the if condition.

833
00:37:31,130 --> 00:37:33,230
So if you know that you're
gonna have code here,

834
00:37:33,230 --> 00:37:34,300
it can be very confusing.

835
00:37:34,300 --> 00:37:36,940
So it's usually often
better to just go ahead

836
00:37:36,940 --> 00:37:40,350
and provide the braces as
it's much more readable.

837
00:37:41,408 --> 00:37:42,241
And when you're writing code,

838
00:37:42,241 --> 00:37:44,220
you should be trying to write code

839
00:37:44,220 --> 00:37:46,280
that you can understand in the future.

840
00:37:46,280 --> 00:37:49,250
Now, one thing I did
mention for a quick second

841
00:37:49,250 --> 00:37:52,820
was the word one-liner,
or words one-liner.

842
00:37:52,820 --> 00:37:54,560
What that means is you
can actually put this all

843
00:37:54,560 --> 00:37:55,540
in the same line here.

844
00:37:55,540 --> 00:37:58,880
Now, if I were to run this
it'll compile and everything,

845
00:37:58,880 --> 00:38:00,420
and we'll just see the words, hello there.

846
00:38:00,420 --> 00:38:02,290
And that's because it'd be hello there,

847
00:38:02,290 --> 00:38:05,040
that's because the age is
nine and we're looking for age

848
00:38:05,040 --> 00:38:06,090
greater than 10.

849
00:38:06,090 --> 00:38:08,180
So let's change this to 11.

850
00:38:08,180 --> 00:38:11,273
And then if we were to run
this, this single line of code

851
00:38:11,273 --> 00:38:13,922
is actually pretty easy to read.

852
00:38:13,922 --> 00:38:16,340
So now, if you're just
gonna write a single line,

853
00:38:16,340 --> 00:38:20,360
this is very readable and we
know that this line below it,

854
00:38:20,360 --> 00:38:22,880
hello there is not going to get executed.

855
00:38:22,880 --> 00:38:25,673
So if you're just running a single line,

856
00:38:25,673 --> 00:38:27,210
it's very often you'll see
this and you can remove

857
00:38:28,490 --> 00:38:30,050
the brackets as I've done here.

858
00:38:30,050 --> 00:38:31,220
And if again, we're gonna run this,

859
00:38:31,220 --> 00:38:33,365
we're gonna see the two things here,

860
00:38:33,365 --> 00:38:35,790
the age is grater than 10,
you dropped this to nine

861
00:38:35,790 --> 00:38:38,270
and we're only gonna see
the words hello there

862
00:38:38,270 --> 00:38:40,490
because if condition has not been met.

863
00:38:40,490 --> 00:38:43,448
Now, you can also take
this a step further.

864
00:38:43,448 --> 00:38:44,840
If you know that your, if else condition

865
00:38:44,840 --> 00:38:47,800
might be very short, you
can actually all do this

866
00:38:47,800 --> 00:38:48,633
on one line.

867
00:38:48,633 --> 00:38:53,360
So print line, and we could
say the age is less than 10.

868
00:38:54,280 --> 00:38:56,440
And so we can actually have
the entire if else condition

869
00:38:56,440 --> 00:38:57,880
right here on a line.

870
00:38:57,880 --> 00:39:00,270
And it's very small,
it's very easy to read.

871
00:39:00,270 --> 00:39:02,551
And so if we're to run this again,

872
00:39:02,551 --> 00:39:04,230
we're now going to see down at the bottom,

873
00:39:04,230 --> 00:39:07,410
the age is less than 10 and
then the words, hello there.

874
00:39:07,410 --> 00:39:11,560
If I change this to 17
and we run it again,

875
00:39:11,560 --> 00:39:14,962
we're not gonna see that
the age is greater than 10.

876
00:39:14,962 --> 00:39:16,730
And of course, we're still
gonna see the words hello there,

877
00:39:16,730 --> 00:39:19,170
because it's printing its own statement.

878
00:39:19,170 --> 00:39:22,670
So you can definitely
create if else statements

879
00:39:22,670 --> 00:39:24,870
on a single line and it's advice to do it

880
00:39:24,870 --> 00:39:27,170
only when there are a single line.

881
00:39:27,170 --> 00:39:29,550
It's also good to mention
if your else statement

882
00:39:29,550 --> 00:39:33,340
becomes very, very long and
you have to continually scroll,

883
00:39:33,340 --> 00:39:34,850
and there's just a lot of text over here.

884
00:39:34,850 --> 00:39:39,190
So if I were to say, my
content went way over here

885
00:39:39,190 --> 00:39:42,960
and in the editor, I had
to kind of look over,

886
00:39:42,960 --> 00:39:44,860
you'll see this little gray line here.

887
00:39:46,026 --> 00:39:48,110
This gray line is kind of
the recommended line break.

888
00:39:48,110 --> 00:39:50,370
So if you had a bunch of
texts and I'm just gonna type

889
00:39:50,370 --> 00:39:51,720
a bunch of garbage in here.

890
00:39:53,384 --> 00:39:54,560
If I had this line and went beyond here,

891
00:39:54,560 --> 00:39:58,150
this recommended line is where
your line breaks should be.

892
00:39:58,150 --> 00:40:01,200
So if it goes past that line,
you should probably consider

893
00:40:01,200 --> 00:40:05,590
breaking this into a
traditional if else statement,

894
00:40:05,590 --> 00:40:07,520
which we can just put
brackets there and the IDE

895
00:40:07,520 --> 00:40:08,930
will apply them for us.

896
00:40:08,930 --> 00:40:10,660
Now it's much easier to read.

897
00:40:10,660 --> 00:40:13,610
It doesn't require that I
do any horizontal scrolling

898
00:40:13,610 --> 00:40:15,550
and makes it easier to understand the code

899
00:40:15,550 --> 00:40:17,160
by just looking at it.

900
00:40:17,160 --> 00:40:20,280
A fundamental understanding
of truth tables will help you

901
00:40:20,280 --> 00:40:23,560
understand what's going on
inside of your if statement

902
00:40:23,560 --> 00:40:25,730
and if it will evaluate to true,

903
00:40:25,730 --> 00:40:29,850
or if it will evaluate the
false and execute this line

904
00:40:29,850 --> 00:40:30,683
down here.

905
00:40:31,671 --> 00:40:32,504
So let's hop over and take a look

906
00:40:32,504 --> 00:40:34,190
at some simple truth tables.

907
00:40:34,190 --> 00:40:36,090
Here, I have created two truth tables,

908
00:40:37,078 --> 00:40:40,093
one on the left, which is the
logic well conjunction and

909
00:40:40,093 --> 00:40:40,926
which we'll talk about first.

910
00:40:40,926 --> 00:40:43,990
And then we'll move on to
the logical conjunction or.

911
00:40:43,990 --> 00:40:47,480
A logical conjunction and state
that we have two variables,

912
00:40:47,480 --> 00:40:48,820
P and Q.

913
00:40:50,218 --> 00:40:51,800
And this is red on the
light right hand side.

914
00:40:51,800 --> 00:40:55,660
P and Q, so you'd be at P the up arrow Q

915
00:40:55,660 --> 00:40:57,310
and it's red as P Q.

916
00:40:57,310 --> 00:40:59,412
And that's what it evaluates too.

917
00:40:59,412 --> 00:41:02,490
So if P is true and Q is true,

918
00:41:02,490 --> 00:41:06,000
then if we were to combine
them, P and Q would be true.

919
00:41:07,954 --> 00:41:10,700
If we have a P that is
true, but that is false,

920
00:41:10,700 --> 00:41:14,440
well, then that would equate
to a false representation

921
00:41:14,440 --> 00:41:15,273
in this truth table.

922
00:41:15,273 --> 00:41:18,980
So if the first expression,
so if we go back to our code,

923
00:41:18,980 --> 00:41:23,400
if our first expression was
true, our second expression

924
00:41:23,400 --> 00:41:26,120
was false and we're using a logical and,

925
00:41:26,120 --> 00:41:28,770
this is an and operator
that the Emerson Emerson

926
00:41:28,770 --> 00:41:33,770
means logical and, then
the false will be executed

927
00:41:34,110 --> 00:41:36,180
because the second item here is false.

928
00:41:36,180 --> 00:41:37,480
We can move on to the third line.

929
00:41:37,480 --> 00:41:41,270
If the first item is false
and the second item is true,

930
00:41:41,270 --> 00:41:43,450
it's still gonna be false because in order

931
00:41:43,450 --> 00:41:46,720
to get a true value, we need
both of them to be true.

932
00:41:46,720 --> 00:41:50,700
So back to the code, this one
at this point would be false

933
00:41:50,700 --> 00:41:52,050
and this one would be true.

934
00:41:53,247 --> 00:41:54,080
If we were to add these together,

935
00:41:54,080 --> 00:41:56,017
that would not equate to true.

936
00:41:56,017 --> 00:41:57,670
So we will be executing the
else statement down here.

937
00:41:57,670 --> 00:42:01,830
And lastly, if both the items
are false, then of course,

938
00:42:01,830 --> 00:42:04,292
if we logically and them together,

939
00:42:04,292 --> 00:42:05,125
we're going to get a false statement.

940
00:42:05,125 --> 00:42:07,770
So back in the code, if both
of these are false up here,

941
00:42:07,770 --> 00:42:11,000
this is false and this statement is false,

942
00:42:11,000 --> 00:42:13,630
then of course, it's
gonna execute down here.

943
00:42:13,630 --> 00:42:14,720
Now on the other side of the fence,

944
00:42:14,720 --> 00:42:16,990
we have a logical conjunction or.

945
00:42:16,990 --> 00:42:19,713
Now this is operated in code,

946
00:42:19,713 --> 00:42:20,546
let's go back to the code here.

947
00:42:20,546 --> 00:42:24,820
And we change a or two B with two lines.

948
00:42:24,820 --> 00:42:26,890
And so that's gonna be a logical or.

949
00:42:27,834 --> 00:42:31,870
So what this says is here is
this statement has to be true

950
00:42:31,870 --> 00:42:34,110
or this statement has to be true.

951
00:42:34,110 --> 00:42:35,650
And if either one of these are true,

952
00:42:35,650 --> 00:42:39,260
if this one's true or this one's true,

953
00:42:39,260 --> 00:42:43,000
then it's okay to continue on
and execute this line of code.

954
00:42:43,000 --> 00:42:44,900
However, both of them are false,

955
00:42:44,900 --> 00:42:47,050
well, then it's gonna
execute this false statement

956
00:42:47,050 --> 00:42:48,040
down here in the else.

957
00:42:48,040 --> 00:42:48,910
And so let's take a look at them again.

958
00:42:48,910 --> 00:42:52,525
We're using P and Q
and it's red as P or Q.

959
00:42:52,525 --> 00:42:54,993
And that's that little V thing there

960
00:42:54,993 --> 00:42:55,826
used to be a down arrow.

961
00:42:55,826 --> 00:42:58,760
And so if P is true or Q is true,

962
00:42:58,760 --> 00:43:01,440
then of course the resulting
truth would be true.

963
00:43:02,320 --> 00:43:06,510
If P is true and Q is false,
well, we're still saying,

964
00:43:06,510 --> 00:43:07,960
"Hey, either one of these is fine,

965
00:43:07,960 --> 00:43:09,370
"so let's go ahead and move forward."

966
00:43:09,370 --> 00:43:12,670
And that would be basically
like saying if this is true,

967
00:43:12,670 --> 00:43:13,830
then okay, we can continue.

968
00:43:13,830 --> 00:43:17,020
Or if this is true, that's
okay, let's continue.

969
00:43:17,020 --> 00:43:19,690
Same thing here, if the
first item in the evaluation

970
00:43:19,690 --> 00:43:23,570
is false, so P is false and Q is true,

971
00:43:23,570 --> 00:43:26,890
then our logical or conjunction
would equate to true.

972
00:43:26,890 --> 00:43:29,739
Then our logical or conjunction
would equate to true.

973
00:43:29,739 --> 00:43:31,860
so this equates to false.

974
00:43:32,814 --> 00:43:35,330
So false, it's gonna go
to the next item over here

975
00:43:35,330 --> 00:43:36,830
and it's going to return true.

976
00:43:38,245 --> 00:43:39,078
So it says, "Oh, I found a true here,

977
00:43:39,078 --> 00:43:40,620
"which means I'm going to
execute this line here."

978
00:43:41,575 --> 00:43:44,096
And lastly, we have the false or false.

979
00:43:44,096 --> 00:43:46,683
So if both of them are
false, back in the code.

980
00:43:46,683 --> 00:43:49,720
if both of them are
false back in the code.

981
00:43:49,720 --> 00:43:52,000
which means they're both false
means neither one of them

982
00:43:53,117 --> 00:43:54,420
are true, then it's gonna
execute the else statement.

983
00:43:55,741 --> 00:43:56,574
There's one thing important to note

984
00:43:56,574 --> 00:43:57,830
is that these conditionals, when we use

985
00:43:57,830 --> 00:44:02,000
the logical operation or,
or the logical operation and

986
00:44:02,000 --> 00:44:04,250
are known as short circuiting,

987
00:44:05,833 --> 00:44:09,073
which means that if this
operation here is false,

988
00:44:10,780 --> 00:44:12,530
it's just gonna skip this together.

989
00:44:14,025 --> 00:44:14,858
It will happen is Kotlin will say,

990
00:44:14,858 --> 00:44:15,930
"Oh, you want me to add these together.

991
00:44:15,930 --> 00:44:17,630
"So I'm going to need this value."

992
00:44:20,815 --> 00:44:23,350
What it's gonna do is at
runtime, it'll check say,

993
00:44:23,350 --> 00:44:24,183
"Hey, is this false?

994
00:44:24,183 --> 00:44:26,392
"Okay, I already know this is false,

995
00:44:26,392 --> 00:44:28,390
"which means this whole statement
is gonna equate to false

996
00:44:28,390 --> 00:44:30,550
"because the first one's already false

997
00:44:30,550 --> 00:44:33,670
"and you're asking me to
have both of them be true."

998
00:44:33,670 --> 00:44:36,500
So what you would then do
is, Kotlin would then do,

999
00:44:36,500 --> 00:44:39,549
is say, "All right, well, I'm
just gonna go and skip this.

1000
00:44:39,549 --> 00:44:40,530
"I'm a short circuit this because
I know that there's no way

1001
00:44:40,530 --> 00:44:42,770
"and no reason for me to
even run this code over here,

1002
00:44:42,770 --> 00:44:46,206
"because I've already
determined that this first piece

1003
00:44:46,206 --> 00:44:49,120
"is false and we need
both of them to be true

1004
00:44:49,120 --> 00:44:50,440
"in order to continue."

1005
00:44:50,440 --> 00:44:53,170
On the opposite side of
the spectrum we have or,

1006
00:44:54,030 --> 00:44:56,662
or this could be short-circuited here.

1007
00:44:56,662 --> 00:44:59,598
So for example, let's
assume that this was true.

1008
00:44:59,598 --> 00:45:01,310
So we're basically saying if this is true,

1009
00:45:01,310 --> 00:45:04,890
or this is true, print
this statement right here.

1010
00:45:04,890 --> 00:45:08,035
So what this would mean is
Kotlin would short circuit.

1011
00:45:08,035 --> 00:45:10,280
If this was true, it
wouldn't even bother checking

1012
00:45:10,280 --> 00:45:11,370
to see if this was true at all.

1013
00:45:11,370 --> 00:45:13,760
So it would, short-circuit
this entire operation.

1014
00:45:13,760 --> 00:45:14,620
So, all right, this is true.

1015
00:45:14,620 --> 00:45:17,441
All right, cool, I'm
not even going to worry

1016
00:45:17,441 --> 00:45:18,570
about executing the statement over here.

1017
00:45:18,570 --> 00:45:21,290
However, if this was false
right here, it would say,

1018
00:45:22,316 --> 00:45:23,370
"Okay, this is false, so I
need to go check the next one,

1019
00:45:23,370 --> 00:45:24,990
"because I'm going to logically or them.

1020
00:45:24,990 --> 00:45:27,190
"And I'll check to see
if this one is true."

1021
00:45:28,387 --> 00:45:29,220
And it says, "Oh, this one's true.

1022
00:45:29,220 --> 00:45:30,610
"Okay, I'm going to use this."

1023
00:45:30,610 --> 00:45:32,930
Now, this could continue on as well

1024
00:45:32,930 --> 00:45:35,160
if you had a, for example, we could have

1025
00:45:35,160 --> 00:45:39,463
another condition here, we
might say, my age equals

1026
00:45:41,370 --> 00:45:43,470
equals my name.length.

1027
00:45:45,703 --> 00:45:46,630
And so we can actually
have three conditions here.

1028
00:45:46,630 --> 00:45:50,510
So this one right here
might equate to false.

1029
00:45:50,510 --> 00:45:52,060
This one might equate the true.

1030
00:45:52,932 --> 00:45:54,040
And if it does equate the
true it's going to skip

1031
00:45:54,040 --> 00:45:55,800
the rest of the conditional here,

1032
00:45:55,800 --> 00:45:58,400
because we've already found
a true and Kotlin knows,

1033
00:45:59,611 --> 00:46:02,071
"Hey, we're just trying to
or all of these together."

1034
00:46:02,071 --> 00:46:04,720
And so understanding basic
truth tables is a humongous help

1035
00:46:04,720 --> 00:46:06,230
in understanding of what's gonna happen

1036
00:46:06,230 --> 00:46:07,780
in your conditional statements.

1037
00:46:10,460 --> 00:46:12,590
In Kotlin, there are
two types of equality,

1038
00:46:12,590 --> 00:46:15,230
structural and referential.

1039
00:46:15,230 --> 00:46:17,810
Let's assume that we
have two string variables

1040
00:46:17,810 --> 00:46:20,970
by the name of name one and name two,

1041
00:46:20,970 --> 00:46:23,700
both containing different strings.

1042
00:46:23,700 --> 00:46:26,780
We could compare them and
see if they're the same

1043
00:46:26,780 --> 00:46:30,650
by using the structural
equivalent operator,

1044
00:46:30,650 --> 00:46:33,470
which is the equals equal sign to say,

1045
00:46:33,470 --> 00:46:36,720
"Hey, is name one equal to name two?"

1046
00:46:36,720 --> 00:46:38,930
And if we were to run
this, it would output

1047
00:46:38,930 --> 00:46:41,550
to the terminal window
saying that it's false,

1048
00:46:41,550 --> 00:46:44,000
that named one does not equal name two.

1049
00:46:44,840 --> 00:46:46,710
Now this is very similar
to other languages

1050
00:46:46,710 --> 00:46:50,490
such as Java's equals method,
which you can also use.

1051
00:46:50,490 --> 00:46:52,150
And you'll see this here.

1052
00:46:52,150 --> 00:46:56,110
And if we run this, we'll
also get false here as well.

1053
00:46:56,110 --> 00:46:57,700
Notice this squiggly line here.

1054
00:46:57,700 --> 00:47:00,850
If you put your cursor
there and you hit alt enter,

1055
00:47:00,850 --> 00:47:01,910
you'll get a pop-up.

1056
00:47:01,910 --> 00:47:04,580
Otherwise you can just click
on the little light bulb

1057
00:47:04,580 --> 00:47:07,030
and say replace with equals equals.

1058
00:47:07,030 --> 00:47:10,140
This is the more idiomatic
way to do it in Kotlin.

1059
00:47:10,140 --> 00:47:14,880
So this says, hey, is name
one equal to name two.

1060
00:47:14,880 --> 00:47:18,100
Now there's also, if
we were to change this.

1061
00:47:18,100 --> 00:47:21,840
So let's say that this was
changed name two to Don.

1062
00:47:21,840 --> 00:47:23,620
This would then evaluate the true

1063
00:47:24,694 --> 00:47:27,050
because the structure of
the contents are the same.

1064
00:47:27,050 --> 00:47:29,230
So they are the same types,

1065
00:47:29,230 --> 00:47:31,010
same types and the same contents.

1066
00:47:32,137 --> 00:47:33,770
So structural equality is true.

1067
00:47:33,770 --> 00:47:36,020
And so if we were turned this
back to char, and we say,

1068
00:47:36,020 --> 00:47:37,870
"Hey, I wanna see if these are different."

1069
00:47:37,870 --> 00:47:40,580
We can use, what's known
as structural inequality,

1070
00:47:40,580 --> 00:47:44,431
and that's going to be with
the exclamation and equal sign.

1071
00:47:44,431 --> 00:47:47,431
Now, if we run this, we're going
to see that we have a true,

1072
00:47:48,853 --> 00:47:50,100
that Donn does not equal to char.

1073
00:47:50,100 --> 00:47:53,520
Now, if I change the
second one to Donn again,

1074
00:47:54,936 --> 00:47:55,940
what do we think is gonna happen here?

1075
00:47:55,940 --> 00:47:58,486
Donn does not equal Don.

1076
00:47:58,486 --> 00:47:59,870
Well, that's gonna be
false because these two

1077
00:47:59,870 --> 00:48:01,060
are exactly the same.

1078
00:48:02,602 --> 00:48:06,940
So that is the way that you
can use structural equalities

1079
00:48:06,940 --> 00:48:08,750
inside of Kotlin.

1080
00:48:08,750 --> 00:48:12,080
You're going to get the first
one, which is equals equals

1081
00:48:12,080 --> 00:48:14,744
is the regular equal equality.

1082
00:48:14,744 --> 00:48:19,130
And exclamation equals is inequality.

1083
00:48:19,130 --> 00:48:20,890
The other type of equality checking

1084
00:48:20,890 --> 00:48:23,390
is referential equalities.

1085
00:48:23,390 --> 00:48:26,740
And we can determine those
using a different operator.

1086
00:48:26,740 --> 00:48:30,360
So let's assume that we have
one variable that's equal to 12

1087
00:48:30,360 --> 00:48:34,760
named A and another variable
that's equal to 12 is B.

1088
00:48:35,987 --> 00:48:39,610
And since every object,
everything in Kotlin is an object,

1089
00:48:39,610 --> 00:48:42,920
these, you would think
would be different objects.

1090
00:48:42,920 --> 00:48:46,840
So if we were to run this, we're gonna use

1091
00:48:46,840 --> 00:48:49,280
referential equality with
the three equal signs,

1092
00:48:49,280 --> 00:48:51,080
which is referential quality saying,

1093
00:48:52,055 --> 00:48:54,100
hey is A equal to the same object as B,

1094
00:48:55,020 --> 00:48:55,960
we were gonna get true.

1095
00:48:57,362 --> 00:48:59,870
Which if you know about
references and memory,

1096
00:48:59,870 --> 00:49:01,760
this was not making any sense,

1097
00:49:01,760 --> 00:49:04,360
except there is a caveat in Kotlin

1098
00:49:04,360 --> 00:49:07,770
and that is number,
characters and Boolean.

1099
00:49:07,770 --> 00:49:12,770
So numbers and Booleans,
all have a special

1100
00:49:12,930 --> 00:49:14,550
internal representation

1101
00:49:14,550 --> 00:49:17,330
and they're represented
as primitives at runtime.

1102
00:49:17,330 --> 00:49:19,940
But to users, they look
like ordinary classes.

1103
00:49:19,940 --> 00:49:23,680
Therefore the triples equals
is the same effective thing

1104
00:49:23,680 --> 00:49:28,590
as the double equals when
we're using primitives.

1105
00:49:28,590 --> 00:49:31,680
So let's get rid of these
primitives here and let's go ahead

1106
00:49:31,680 --> 00:49:33,110
and we're gonna jump ahead real quick,

1107
00:49:33,110 --> 00:49:34,370
and we're gonna create a class.

1108
00:49:34,370 --> 00:49:37,385
And this is a very simple class
with a user who has a name

1109
00:49:37,385 --> 00:49:40,350
that is a string.

1110
00:49:40,350 --> 00:49:43,746
And let's set person A equal two person,

1111
00:49:43,746 --> 00:49:44,630
and we'll give them the name of Don,

1112
00:49:44,630 --> 00:49:48,090
and then person B will also
have the same name, Don.

1113
00:49:48,090 --> 00:49:51,600
And then what we'll do
is we'll do referential,

1114
00:49:51,600 --> 00:49:53,470
a referral equality check here,

1115
00:49:55,266 --> 00:49:57,730
run the program to see if
object A equals object B.

1116
00:49:57,730 --> 00:50:00,510
And as it runs down here, we have false,

1117
00:50:00,510 --> 00:50:04,220
which means that object A
does not equal object B,

1118
00:50:04,220 --> 00:50:06,610
meaning that it does not
share the same object,

1119
00:50:06,610 --> 00:50:09,210
it's not the same object whatsoever.

1120
00:50:09,210 --> 00:50:11,600
We could also change these things around

1121
00:50:11,600 --> 00:50:15,596
and do referential inequality.

1122
00:50:15,596 --> 00:50:16,890
So we would do exclamation equal equals,

1123
00:50:16,890 --> 00:50:21,460
that would say object A
does not equal object B.

1124
00:50:21,460 --> 00:50:24,140
So they're not pointing at
the same place in memory.

1125
00:50:24,140 --> 00:50:26,240
So for, to run this, you would see

1126
00:50:27,531 --> 00:50:28,364
that we now get back true.

1127
00:50:28,364 --> 00:50:29,980
Then we're getting back
true because person A

1128
00:50:31,002 --> 00:50:31,890
is a completely different
object than person B,

1129
00:50:31,890 --> 00:50:34,810
they're stored in completely
different parts of memory.

1130
00:50:34,810 --> 00:50:38,100
So for referential integrity,
we have the triple equals,

1131
00:50:38,100 --> 00:50:40,730
which is equality.

1132
00:50:40,730 --> 00:50:43,880
And then we have
exclamation equals equals,

1133
00:50:43,880 --> 00:50:45,620
which is inequality.

1134
00:50:47,991 --> 00:50:48,824
One of the goals of Kotlin's type system

1135
00:50:48,824 --> 00:50:51,400
is to eliminate no reference exceptions.

1136
00:50:51,400 --> 00:50:54,090
So if you two were to take
this existing name variable

1137
00:50:54,090 --> 00:50:56,450
and set it equal to null, you would notice

1138
00:50:56,450 --> 00:50:58,440
that you would not be allowed to do that.

1139
00:50:58,440 --> 00:51:00,570
And the reason being
is this string is known

1140
00:51:00,570 --> 00:51:02,480
as a non null reference.

1141
00:51:02,480 --> 00:51:04,640
If you wanted to create
a nullable reference,

1142
00:51:04,640 --> 00:51:05,830
you would still say string,

1143
00:51:05,830 --> 00:51:08,820
but you would add the
question mark at the end.

1144
00:51:08,820 --> 00:51:13,820
This would allow the name
to be reassigned to null.

1145
00:51:14,020 --> 00:51:17,820
The same goes for other
types as well, such as age.

1146
00:51:17,820 --> 00:51:21,050
We might say, this is int, we've got 32.

1147
00:51:21,050 --> 00:51:24,410
However, if we tried
to assign age to null,

1148
00:51:25,281 --> 00:51:26,420
this would not be allowed either.

1149
00:51:26,420 --> 00:51:29,330
So anytime we would like to make maybe age

1150
00:51:29,330 --> 00:51:32,344
or any other type, we
need to remember to add

1151
00:51:32,344 --> 00:51:35,050
the question Mark at the end,
which then would allow us

1152
00:51:35,050 --> 00:51:38,120
to set the type to null.

1153
00:51:38,120 --> 00:51:42,540
Even if we had a simple
class such as a person class,

1154
00:51:44,550 --> 00:51:49,550
we could say var person equals
person, that would work fine.

1155
00:51:50,470 --> 00:51:54,130
But if we were to
reassign person to a null,

1156
00:51:54,130 --> 00:51:56,710
this would not be allowed
because we are guaranteeing

1157
00:51:56,710 --> 00:51:59,080
that this is a non-nullable reference.

1158
00:51:59,080 --> 00:52:01,500
However, if we did want a null reference,

1159
00:52:01,500 --> 00:52:04,460
we could say person two,
we would need to provide

1160
00:52:04,460 --> 00:52:06,390
the type here 'cause it's
going to be a nullable type.

1161
00:52:06,390 --> 00:52:09,300
And then we could say equals person Fu.

1162
00:52:09,300 --> 00:52:12,430
Now I could set person two equal to null

1163
00:52:12,430 --> 00:52:14,670
when working with non-nullable references

1164
00:52:14,670 --> 00:52:16,880
as the first name variable here.

1165
00:52:16,880 --> 00:52:19,790
If we wanted to see the
length of the first name,

1166
00:52:19,790 --> 00:52:21,740
we would simply say, first name.length.

1167
00:52:22,680 --> 00:52:24,330
This would give us the length.

1168
00:52:24,330 --> 00:52:26,300
There's no need to check
to see a first name is null

1169
00:52:26,300 --> 00:52:28,300
because we're using a
non-nullable reference

1170
00:52:28,300 --> 00:52:30,980
and Kotlin guarantees that
that will not be null.

1171
00:52:30,980 --> 00:52:32,700
When we were using a
non-nullable reference

1172
00:52:32,700 --> 00:52:34,080
if we attempt to do the same thing

1173
00:52:34,080 --> 00:52:37,000
and we'd get the last name.length,

1174
00:52:37,000 --> 00:52:39,080
you'll notice that we
have a red squiggly here.

1175
00:52:39,080 --> 00:52:40,420
So what we have to do is introduce

1176
00:52:40,420 --> 00:52:42,560
what's known as a safe call.

1177
00:52:42,560 --> 00:52:46,370
This basically says, if
the last name is null,

1178
00:52:46,370 --> 00:52:48,050
then go ahead and make this null.

1179
00:52:48,050 --> 00:52:49,780
Otherwise give the length.

1180
00:52:49,780 --> 00:52:53,160
So this variable could be
equivalent to one of two things,

1181
00:52:53,160 --> 00:52:55,550
either null or the number six,

1182
00:52:55,550 --> 00:52:58,510
because there's six
characters in the word Felker.

1183
00:52:59,510 --> 00:53:02,830
So if the last name is
null, it would return null.

1184
00:53:02,830 --> 00:53:05,120
Otherwise it would return length.

1185
00:53:05,120 --> 00:53:08,010
You could do the same thing
with an if statement as well

1186
00:53:08,010 --> 00:53:09,190
in one line.

1187
00:53:09,190 --> 00:53:12,000
So you can say if last
name does not equal null,

1188
00:53:12,000 --> 00:53:17,000
then you could say last
name.length else will say zero.

1189
00:53:17,550 --> 00:53:19,310
Now what this is doing
is saying last name.

1190
00:53:19,310 --> 00:53:21,320
We're checking to see if
the last name is not null.

1191
00:53:21,320 --> 00:53:22,230
They're gonna get the length.

1192
00:53:22,230 --> 00:53:26,150
Now notice how I did not use
the safe call operator here.

1193
00:53:26,150 --> 00:53:29,070
The reason is, is Kotlin
recognizes in this if statement,

1194
00:53:29,070 --> 00:53:31,330
we are checking to see
if last name is null,

1195
00:53:31,330 --> 00:53:34,180
therefore I don't have
to check for null here

1196
00:53:34,180 --> 00:53:37,120
because it was already
taken care of in this step.

1197
00:53:37,120 --> 00:53:39,190
However, if for some reason
the last name is null,

1198
00:53:39,190 --> 00:53:41,080
then we'll just go ahead
and return a value of zero.

1199
00:53:41,080 --> 00:53:44,050
So either way, the answer here
would be we're either going

1200
00:53:44,050 --> 00:53:46,220
to get six or we're going to get zero.

1201
00:53:46,220 --> 00:53:49,110
Now of course you could
change this to null

1202
00:53:49,110 --> 00:53:51,530
if you would like, though to
essentially do the same thing

1203
00:53:51,530 --> 00:53:54,250
as the above, but most
likely you probably want

1204
00:53:54,250 --> 00:53:56,320
some type of value in your code

1205
00:53:56,320 --> 00:53:58,630
so you can do this with a single line if.

1206
00:53:58,630 --> 00:54:00,600
And you can also chain
these safe calls together.

1207
00:54:00,600 --> 00:54:04,230
So let's say that we wanted
the first two letters

1208
00:54:04,230 --> 00:54:08,790
of the last name, and
then we wanted the length

1209
00:54:08,790 --> 00:54:10,840
of the last name.

1210
00:54:10,840 --> 00:54:12,090
Notice how we would need.

1211
00:54:13,200 --> 00:54:16,360
So we'll say link four, so last name says

1212
00:54:16,360 --> 00:54:20,470
it needs a safe call and
notice now the next one

1213
00:54:20,470 --> 00:54:21,303
needs the safe call.

1214
00:54:21,303 --> 00:54:22,760
So what this one will do is says,

1215
00:54:22,760 --> 00:54:26,330
hey, if last name is
null, then just go ahead

1216
00:54:26,330 --> 00:54:27,970
and return null, if last name's not null,

1217
00:54:27,970 --> 00:54:29,950
go ahead and pull the
sub string off of that.

1218
00:54:29,950 --> 00:54:32,210
So grab the first two characters.

1219
00:54:32,210 --> 00:54:34,240
And if for some reason that's null,

1220
00:54:34,240 --> 00:54:35,910
go ahead and return null.

1221
00:54:35,910 --> 00:54:37,610
Otherwise go ahead and return length.

1222
00:54:37,610 --> 00:54:39,370
Now you may have another
language has seen something

1223
00:54:39,370 --> 00:54:40,410
very similar to this.

1224
00:54:40,410 --> 00:54:45,350
If last name does not equal
null and last name.length

1225
00:54:47,440 --> 00:54:52,440
is greater than one, then you
might wanna continue off there

1226
00:54:53,037 --> 00:54:57,690
then you could have your
statement to say that your length

1227
00:54:57,690 --> 00:55:01,750
or whatever is, to check
to make sure it's not null.

1228
00:55:01,750 --> 00:55:05,180
So this would be very common
in our languages such as Java,

1229
00:55:05,180 --> 00:55:08,660
but here you can start
chaining these calls together.

1230
00:55:08,660 --> 00:55:10,900
You could even take this
even further by saying

1231
00:55:10,900 --> 00:55:13,520
last name.sub string would say 05.

1232
00:55:13,520 --> 00:55:15,840
So we get the first five characters,

1233
00:55:15,840 --> 00:55:17,230
then we could say something different,

1234
00:55:17,230 --> 00:55:20,740
like drop the last two characters.

1235
00:55:20,740 --> 00:55:22,869
Then we could get another
sub string of those

1236
00:55:22,869 --> 00:55:26,480
and then we would say, let's
say we want the second one

1237
00:55:26,480 --> 00:55:29,760
to the third one and
then we would say length.

1238
00:55:29,760 --> 00:55:33,330
And so we could say
length five equals this.

1239
00:55:33,330 --> 00:55:36,170
Now, because this could be
null all the way across,

1240
00:55:36,170 --> 00:55:38,200
we would need to use safe calls.

1241
00:55:38,200 --> 00:55:40,510
So every time all the
way across we need to use

1242
00:55:40,510 --> 00:55:42,930
these safe calls, meaning
that if any of these

1243
00:55:42,930 --> 00:55:46,180
were to return null
length five will be null.

1244
00:55:46,180 --> 00:55:48,190
Otherwise it will be
the length when working

1245
00:55:48,190 --> 00:55:52,010
with nullable types, it's often
to wanna retrieve a value.

1246
00:55:52,010 --> 00:55:54,510
So let's say the length
again of a certain,

1247
00:55:54,510 --> 00:55:55,860
maybe the last name string,

1248
00:55:55,860 --> 00:55:57,330
you wanna get the length of that.

1249
00:55:57,330 --> 00:56:00,090
And so the need to perform
some type of safe operation

1250
00:56:00,090 --> 00:56:01,600
to get that value.

1251
00:56:01,600 --> 00:56:04,310
However, this is going to
leave us in a certain situation

1252
00:56:04,310 --> 00:56:06,070
where we could either have null

1253
00:56:06,070 --> 00:56:09,110
or the length of the string,
last name which is six,

1254
00:56:09,110 --> 00:56:10,630
so we could get either one.

1255
00:56:10,630 --> 00:56:13,660
Let's say for whatever reason,
we determined that we know

1256
00:56:13,660 --> 00:56:16,197
we wanted a non-null reference.

1257
00:56:16,197 --> 00:56:17,980
So in that case, we're
going to get an error

1258
00:56:17,980 --> 00:56:21,500
because last name dot length
is going to return us a null.

1259
00:56:21,500 --> 00:56:23,370
So how would we fix that?

1260
00:56:23,370 --> 00:56:25,150
You could fix that with
a simple if statement.

1261
00:56:25,150 --> 00:56:28,050
So what we could do is we
could just check to see

1262
00:56:28,050 --> 00:56:31,360
if the last name does not equal null,

1263
00:56:31,360 --> 00:56:34,000
then give us a length,
otherwise give us zero.

1264
00:56:34,839 --> 00:56:36,090
And we can get rid of the safe call here

1265
00:56:36,090 --> 00:56:39,770
because again, this null
has already been checked.

1266
00:56:40,670 --> 00:56:44,790
So what this will return is a
non-null reference of length,

1267
00:56:44,790 --> 00:56:47,330
either the length of the
actual string variable,

1268
00:56:47,330 --> 00:56:48,163
otherwise zero.

1269
00:56:49,599 --> 00:56:52,150
Now this can also be
short-circuited as well.

1270
00:56:52,150 --> 00:56:56,516
So we'll say linked to int,
and this can be short circuit,

1271
00:56:56,516 --> 00:56:59,240
so we're gonna use in what's
known as the Elvis operator.

1272
00:56:59,240 --> 00:57:02,120
And Elvis operator looks like
this, is a question mark,

1273
00:57:02,120 --> 00:57:03,850
colon and then a value.

1274
00:57:03,850 --> 00:57:07,317
And what this means is the
Elvis operator means is,

1275
00:57:07,317 --> 00:57:10,400
if anything on the left-hand
side of this Elvis operator

1276
00:57:10,400 --> 00:57:12,530
is null, then return this value.

1277
00:57:12,530 --> 00:57:15,480
So if last name is null, then return it.

1278
00:57:15,480 --> 00:57:16,840
We could even go a step further

1279
00:57:16,840 --> 00:57:19,050
and change some things together.

1280
00:57:19,050 --> 00:57:24,050
So we could actually say
0,2 and we could do multiple

1281
00:57:24,390 --> 00:57:26,698
safe calls in order.

1282
00:57:26,698 --> 00:57:29,540
So if last name is no, or
this sub string is null,

1283
00:57:29,540 --> 00:57:32,920
then return zero, otherwise
return us the length here.

1284
00:57:32,920 --> 00:57:35,770
And this will give us
a non-Konoll reference.

1285
00:57:35,770 --> 00:57:37,600
Now you may be wondering
why is this called

1286
00:57:37,600 --> 00:57:38,670
the Elvis operator?

1287
00:57:40,000 --> 00:57:41,810
Well, if we turn it sideways and zoom in

1288
00:57:41,810 --> 00:57:44,390
and have this image here, you can see

1289
00:57:44,390 --> 00:57:46,520
that it looks like Elvis Presley's hair,

1290
00:57:46,520 --> 00:57:48,920
and that's why it's
called the Elvis operator.

1291
00:57:48,920 --> 00:57:51,620
To create a function in
Kotlin, what you'll need to do

1292
00:57:52,888 --> 00:57:55,080
is use the keyword fun and
then the name of your function.

1293
00:57:55,080 --> 00:57:57,760
So we can create one called hello world,

1294
00:57:57,760 --> 00:57:59,980
and you'll have open
and closed parentheses

1295
00:57:59,980 --> 00:58:01,470
and then open and close brackets here

1296
00:58:01,470 --> 00:58:04,440
will give you a function
that you can call.

1297
00:58:04,440 --> 00:58:07,420
Now, if we were to call
hello world from somewhere,

1298
00:58:07,420 --> 00:58:10,450
to call that, again, our main
function is going to be called

1299
00:58:10,450 --> 00:58:12,987
because we have a little run button here.

1300
00:58:12,987 --> 00:58:16,800
If we want to execute
what's whatever is inside

1301
00:58:16,800 --> 00:58:18,630
of the hello world function,

1302
00:58:18,630 --> 00:58:21,200
we would need to call
the hello world function.

1303
00:58:21,200 --> 00:58:24,700
And we do that by just
typing the word, hello world,

1304
00:58:24,700 --> 00:58:26,170
the name of the function
here with the open

1305
00:58:26,170 --> 00:58:27,850
and closed parentheses.

1306
00:58:27,850 --> 00:58:29,570
Now, if I were to run this,

1307
00:58:29,570 --> 00:58:31,250
you would see that
nothing is going to happen

1308
00:58:31,250 --> 00:58:33,713
because inside of this function,

1309
00:58:33,713 --> 00:58:35,800
we're not really telling
Kotlin to do anything at all.

1310
00:58:35,800 --> 00:58:38,510
You can see it the program exited.

1311
00:58:38,510 --> 00:58:39,780
If we want to do something in here,

1312
00:58:39,780 --> 00:58:42,430
what we can say is we say print line.

1313
00:58:42,430 --> 00:58:46,580
And what we could say is,
hello world inside of here

1314
00:58:46,580 --> 00:58:51,580
with double quotes and then
ups here when we've now run it,

1315
00:58:51,630 --> 00:58:54,520
we'll see Kotlin will
compile it and we will print

1316
00:58:54,520 --> 00:58:57,330
hello world right here to the screen.

1317
00:58:57,330 --> 00:59:00,070
Now we could change his
function name to something else.

1318
00:59:00,070 --> 00:59:05,070
So let's call it something
fancy like purple cow.

1319
00:59:05,190 --> 00:59:08,050
So we have purple cow here
and I'm gonna go ahead

1320
00:59:08,050 --> 00:59:10,480
and copy and paste that
name there, purple cow.

1321
00:59:10,480 --> 00:59:13,400
Anytime I call purple cow, it's
going to print hello world.

1322
00:59:13,400 --> 00:59:15,660
Again, we'll just double
check that here to make sure.

1323
00:59:15,660 --> 00:59:17,940
And there we go, we see hello world here.

1324
00:59:17,940 --> 00:59:20,080
Now the cool thing about
functions is you can call them

1325
00:59:20,080 --> 00:59:21,380
over and over.

1326
00:59:21,380 --> 00:59:22,213
So I'm gonna copy this
and go to a new line,

1327
00:59:22,213 --> 00:59:25,400
I'm gonna paste it again
and again and again.

1328
00:59:25,400 --> 00:59:26,830
So if you're wondering,
what's gonna happen

1329
00:59:26,830 --> 00:59:29,860
is due to the procedural nature of Kotlin,

1330
00:59:29,860 --> 00:59:32,000
it's going to execute this code,

1331
00:59:32,000 --> 00:59:35,070
which means it's going to
walk into this function

1332
00:59:35,070 --> 00:59:37,300
and it's going to run
whatever inside of here.

1333
00:59:37,300 --> 00:59:39,568
Now it's going to, and then after that,

1334
00:59:39,568 --> 00:59:41,360
it's gonna come into
this function and call

1335
00:59:41,360 --> 00:59:42,193
into whatever is inside of here.

1336
00:59:42,193 --> 00:59:44,130
So basically it's gonna call
this purple cow function

1337
00:59:44,130 --> 00:59:46,150
one, two, three, four times.

1338
00:59:46,150 --> 00:59:49,810
So we should see print line
of hello world four times

1339
00:59:49,810 --> 00:59:53,100
down in here in our run
window, which we do.

1340
00:59:53,100 --> 00:59:54,290
We see hello world.

1341
00:59:54,290 --> 00:59:56,560
Now the cool thing about
functions is that we can actually

1342
00:59:56,560 --> 00:59:59,007
change what's inside of
them and it will change

1343
00:59:59,007 --> 01:00:00,870
anytime you call it.

1344
01:00:00,870 --> 01:00:03,440
So if I realize I have in
my application purple cow

1345
01:00:03,440 --> 01:00:05,910
called four times, and I
wanna change this to say,

1346
01:00:05,910 --> 01:00:08,040
"Oops, you know what,
this should actually say,

1347
01:00:08,040 --> 01:00:09,730
"hello purple cow."

1348
01:00:09,730 --> 01:00:10,900
I can just change here.

1349
01:00:10,900 --> 01:00:13,400
Now when I run it, we
should see down here,

1350
01:00:13,400 --> 01:00:15,960
hello purple cow four times.

1351
01:00:15,960 --> 01:00:17,860
So we'll see hello world purple cow.

1352
01:00:17,860 --> 01:00:20,120
There we go, it shows up four times.

1353
01:00:20,120 --> 01:00:22,460
Now I can also do other things
inside of this function.

1354
01:00:22,460 --> 01:00:25,170
So a function is just a place
where we can put other code

1355
01:00:25,170 --> 01:00:27,680
that we would like to call
it over and over and over.

1356
01:00:27,680 --> 01:00:30,920
So it's kind of like a reusable
piece of application code

1357
01:00:30,920 --> 01:00:31,753
that you can use over.

1358
01:00:31,753 --> 01:00:33,250
So if I were to do something else,

1359
01:00:33,250 --> 01:00:36,450
I could say per line, hello there.

1360
01:00:36,450 --> 01:00:38,480
And now what we're going
to see is hello purple cow.

1361
01:00:38,480 --> 01:00:41,065
And then it's going to print hello there,

1362
01:00:41,065 --> 01:00:41,898
but it's gonna print that four times.

1363
01:00:41,898 --> 01:00:44,040
So if we run this here,
you're going to see

1364
01:00:44,040 --> 01:00:47,500
that it's going to call hello purple cow,

1365
01:00:47,500 --> 01:00:49,010
hello there, hello purple cow.

1366
01:00:49,010 --> 01:00:51,670
Hello there because what's
happening is each time

1367
01:00:51,670 --> 01:00:54,790
this line of purple cow is called,

1368
01:00:54,790 --> 01:00:57,730
two things are being
executed inside of here.

1369
01:00:57,730 --> 01:00:59,930
Now functions can also
call other functions.

1370
01:00:59,930 --> 01:01:02,554
So it was just kind of makes sense

1371
01:01:02,554 --> 01:01:04,740
because inside of the main function here,

1372
01:01:04,740 --> 01:01:07,010
we're calling another
function called purple cow,

1373
01:01:07,010 --> 01:01:10,760
but also inside a purple
cow, we could also call

1374
01:01:10,760 --> 01:01:12,540
another functional call moo.

1375
01:01:12,540 --> 01:01:14,630
And maybe this function might just say moo

1376
01:01:14,630 --> 01:01:16,800
and we'll call function called moo.

1377
01:01:16,800 --> 01:01:20,140
And inside of here, we'll do print ln moo.

1378
01:01:21,260 --> 01:01:24,160
Now what will happen is
when purple cow is called,

1379
01:01:24,160 --> 01:01:27,450
we'll see, hello purple cow
and then we're gonna see

1380
01:01:27,450 --> 01:01:29,520
print line is gonna be called hello there

1381
01:01:29,520 --> 01:01:31,079
it's gonna be called.

1382
01:01:31,079 --> 01:01:32,350
So hello purple cow, hello there.

1383
01:01:32,350 --> 01:01:35,140
And then the purple cow function
is going to call the moo

1384
01:01:35,140 --> 01:01:37,783
function and the moo
function is going to say moo.

1385
01:01:37,783 --> 01:01:40,270
And so if we were to run this year,

1386
01:01:42,630 --> 01:01:44,200
you would see that's going to call.

1387
01:01:44,200 --> 01:01:45,660
Here we go, hello purple cow,

1388
01:01:45,660 --> 01:01:46,600
hello there moo.

1389
01:01:46,600 --> 01:01:48,630
Hello, purple cow, hello there moo.

1390
01:01:48,630 --> 01:01:51,540
So now I can actually change
this around if I decided,

1391
01:01:51,540 --> 01:01:55,830
"Hey, you know what, I
wanna move this up here

1392
01:01:55,830 --> 01:02:00,330
"and I wanted to change this
to say, hello pink cow."

1393
01:02:01,860 --> 01:02:02,900
Or let's do blue.

1394
01:02:02,900 --> 01:02:06,230
Let's do hello blue cow and we'll do moo.

1395
01:02:06,230 --> 01:02:08,793
Now, if I hit run again, we're gonna see

1396
01:02:08,793 --> 01:02:09,626
what do you think was gonna happen?

1397
01:02:09,626 --> 01:02:12,480
We're gonna see hello purple
cow, moo, hello blue cow, moo.

1398
01:02:12,480 --> 01:02:14,500
And so we just see move
between each one of these

1399
01:02:14,500 --> 01:02:16,570
because that's all that moo is doing.

1400
01:02:16,570 --> 01:02:18,150
And then we could add
something to this if we want.

1401
01:02:18,150 --> 01:02:21,000
Of course, to say moomoo Buckaroo.

1402
01:02:22,480 --> 01:02:24,350
And if I were to run this again,

1403
01:02:24,350 --> 01:02:26,700
we would see all different
types of stuff here.

1404
01:02:26,700 --> 01:02:27,910
So it kinda makes sense.

1405
01:02:27,910 --> 01:02:30,260
Hello purple cow, moo, moo moo Buckaroo.

1406
01:02:30,260 --> 01:02:32,946
Hello, blue cow, moo, moo moo Buckaroo.

1407
01:02:32,946 --> 01:02:35,090
Say that 10 times fast.

1408
01:02:35,090 --> 01:02:37,580
So as you can see, these are
just very simple functions,

1409
01:02:37,580 --> 01:02:39,480
but the functions allow you to reuse code.

1410
01:02:39,480 --> 01:02:41,504
Now I can also come up here and say,

1411
01:02:41,504 --> 01:02:43,870
I can say I wanna do moo right here,

1412
01:02:43,870 --> 01:02:45,820
and I don't really wanna have it here.

1413
01:02:45,820 --> 01:02:48,900
So I can kind of use these
reusable chunks here.

1414
01:02:48,900 --> 01:02:51,140
And this case, we're
gonna say purple cow once,

1415
01:02:51,140 --> 01:02:53,150
we'll do the moo routine
and then will just print

1416
01:02:53,150 --> 01:02:54,350
purple cow.

1417
01:02:54,350 --> 01:02:56,790
And so, like I said, each
one of these functions

1418
01:02:56,790 --> 01:02:58,730
allows us to have reusable chunks of code.

1419
01:02:58,730 --> 01:03:01,260
So we started off with hello,
purple cow, hello, blue cow.

1420
01:03:01,260 --> 01:03:02,950
And then we did the moo, moo Buckaroo,

1421
01:03:02,950 --> 01:03:06,080
and then it went back and
executed the purple cow function

1422
01:03:06,080 --> 01:03:07,380
three or four times.

1423
01:03:07,380 --> 01:03:09,760
So this is how you create
a very simple function.

1424
01:03:09,760 --> 01:03:12,670
This function has, as you currently see,

1425
01:03:12,670 --> 01:03:14,810
no return type specified.

1426
01:03:14,810 --> 01:03:17,290
And because we don't have
any returns type specified,

1427
01:03:17,290 --> 01:03:19,570
what is actually returned is a unit type.

1428
01:03:19,570 --> 01:03:20,810
And we'll talk about the hair in a second,

1429
01:03:20,810 --> 01:03:23,480
but if we leave it off there by default,

1430
01:03:23,480 --> 01:03:27,140
any function that does not
specify a particular return type

1431
01:03:27,140 --> 01:03:28,000
will return a unit.

1432
01:03:28,000 --> 01:03:30,100
So we'll get to that in a second.

1433
01:03:30,100 --> 01:03:32,360
By default, all functions in Kotlin

1434
01:03:32,360 --> 01:03:33,840
have a returned type of units.

1435
01:03:33,840 --> 01:03:36,410
So if we create a function called say hi,

1436
01:03:36,410 --> 01:03:40,390
that's just going to print
out some text to the screen,

1437
01:03:40,390 --> 01:03:44,640
such as hello world and we call it here,

1438
01:03:47,030 --> 01:03:49,030
it's actually, it doesn't
have a return type.

1439
01:03:49,030 --> 01:03:52,370
And then to specify a return
type in Kotlin's functions,

1440
01:03:52,370 --> 01:03:55,280
you're just going to,
after the parentheses here,

1441
01:03:55,280 --> 01:03:58,690
you'll put a colon and then
the type that this function

1442
01:03:58,690 --> 01:03:59,523
is going to return.

1443
01:03:59,523 --> 01:04:00,830
So if it returns something
back, you could say

1444
01:04:00,830 --> 01:04:02,260
it's gonna return back a unit.

1445
01:04:02,260 --> 01:04:03,660
So you'll notice at this point in time,

1446
01:04:03,660 --> 01:04:06,060
I don't have any type of
statement to tell it to return

1447
01:04:06,060 --> 01:04:07,650
a unit or anything like that.

1448
01:04:08,540 --> 01:04:11,050
I could do this, and it
would work just fine.

1449
01:04:11,050 --> 01:04:13,680
But by default all
functions that don't have

1450
01:04:13,680 --> 01:04:15,120
a return type return unit,

1451
01:04:15,120 --> 01:04:17,810
which if you see the
IDE IntelliJ is saying

1452
01:04:17,810 --> 01:04:21,120
that the unit is it
redundant so I can alt enter,

1453
01:04:21,120 --> 01:04:23,790
or I can click on this
little light bulb and say,

1454
01:04:23,790 --> 01:04:26,260
remove the explicit type declaration.

1455
01:04:26,260 --> 01:04:30,700
So I've done that now to prove
that this does return a unit,

1456
01:04:30,700 --> 01:04:32,800
I can actually just create a variable

1457
01:04:32,800 --> 01:04:36,210
and I'm gonna print this
variable to the screen.

1458
01:04:36,210 --> 01:04:39,780
So whatever X is here,
because again, say hi

1459
01:04:39,780 --> 01:04:41,030
is going to return something.

1460
01:04:41,030 --> 01:04:44,600
And because this function
does not have a return type

1461
01:04:44,600 --> 01:04:48,400
specified by default, it's
actually just going to be a unit.

1462
01:04:48,400 --> 01:04:51,210
We'll just leave that
off to show you that.

1463
01:04:51,210 --> 01:04:52,670
And since it's returning something,

1464
01:04:52,670 --> 01:04:53,980
I can set it equal to a value.

1465
01:04:53,980 --> 01:04:57,580
So this is also valid to
call this just like this

1466
01:04:57,580 --> 01:04:58,810
and have it execute the function.

1467
01:04:58,810 --> 01:05:00,570
I don't have to do
anything with return type,

1468
01:05:00,570 --> 01:05:03,680
but if I would like to, I
could actually take that stuff

1469
01:05:03,680 --> 01:05:05,930
into a variable as I'm
doing here into the say

1470
01:05:05,930 --> 01:05:08,940
at two variable X and I'm
a print to the screen.

1471
01:05:08,940 --> 01:05:11,910
Now, once we run this here,
say high is gonna execute

1472
01:05:11,910 --> 01:05:13,870
and return a unit and
you can see it printed

1473
01:05:13,870 --> 01:05:17,090
the hello world text and
then it printed the type

1474
01:05:17,090 --> 01:05:21,048
which is Kotlin.unit,
so that is a unit type.

1475
01:05:21,048 --> 01:05:23,280
And so again, if I just
specify it here, units.

1476
01:05:23,280 --> 01:05:26,110
Again, I'm not having to
specify a return statement

1477
01:05:26,110 --> 01:05:29,650
because just by default, if
it's a function like this,

1478
01:05:29,650 --> 01:05:30,640
it will return a unit.

1479
01:05:30,640 --> 01:05:34,440
And there we go, as you can
see it returns a unit here.

1480
01:05:34,440 --> 01:05:36,220
Now let's say for whatever reason,

1481
01:05:36,220 --> 01:05:38,390
we want it to return a string though.

1482
01:05:38,390 --> 01:05:39,840
And so you'll see here,
as soon as I did that,

1483
01:05:39,840 --> 01:05:41,010
got a squiggly line here.

1484
01:05:41,010 --> 01:05:42,620
Now what that's saying
is we haven't returned

1485
01:05:42,620 --> 01:05:43,453
any string here.

1486
01:05:43,453 --> 01:05:45,550
So let's say, I wanna return something.

1487
01:05:45,550 --> 01:05:49,410
So let's say, hello, is this
return the word hello world.

1488
01:05:49,410 --> 01:05:51,830
So instead of printing it,
let's just return it here.

1489
01:05:53,465 --> 01:05:55,726
And it's going to return
the value hello world.

1490
01:05:55,726 --> 01:05:57,150
And then when we print it to the screen,

1491
01:05:58,830 --> 01:06:00,200
we can say hello world.

1492
01:06:00,200 --> 01:06:02,790
And did go ahead and print to the screen

1493
01:06:02,790 --> 01:06:05,770
because what happened here
is these say hi function

1494
01:06:05,770 --> 01:06:08,120
is now returning hello world.

1495
01:06:08,120 --> 01:06:11,230
We're gonna stuff that
value into this variable X

1496
01:06:11,230 --> 01:06:13,620
and then we're gonna print
the variable X to the screen

1497
01:06:13,620 --> 01:06:15,360
with the print ln statement.

1498
01:06:15,360 --> 01:06:17,170
So now something interesting happens.

1499
01:06:17,170 --> 01:06:18,800
You may be thinking, well,
let's just call say hi

1500
01:06:18,800 --> 01:06:22,050
a few times here and
let's see what happens.

1501
01:06:22,050 --> 01:06:24,510
And if I run this, you'll
notice that we're just going

1502
01:06:24,510 --> 01:06:28,040
to get on the screen hello world one time.

1503
01:06:28,040 --> 01:06:30,775
And the reason why we're
only getting hello world

1504
01:06:30,775 --> 01:06:32,660
to the screen one time
is because remember,

1505
01:06:32,660 --> 01:06:36,820
say hi is returning something,
it's returning a string.

1506
01:06:36,820 --> 01:06:38,260
So it's not doing anything in here,

1507
01:06:38,260 --> 01:06:40,080
but saying, hey, I'm gonna have this value

1508
01:06:40,080 --> 01:06:42,400
and I'm going to return hello world.

1509
01:06:42,400 --> 01:06:44,500
And at that point you can do
whatever you want with it.

1510
01:06:44,500 --> 01:06:47,184
And in that case, we are just
assigning it to a variable X

1511
01:06:47,184 --> 01:06:48,700
and printing it to the screen.

1512
01:06:48,700 --> 01:06:51,190
Now, these last three,
aren't doing anything.

1513
01:06:51,190 --> 01:06:53,580
It's calling this and it's
returning hello world,

1514
01:06:53,580 --> 01:06:55,200
but we're not doing
anything with the results.

1515
01:06:55,200 --> 01:07:00,200
So if I did val Y equals
this, I did val X,

1516
01:07:01,418 --> 01:07:03,060
(indistinct) would have X, Z equals this.

1517
01:07:03,060 --> 01:07:08,060
I'm val A equals this, those
variables would then be set

1518
01:07:09,180 --> 01:07:12,650
and I could actually print
them to the screen as well.

1519
01:07:12,650 --> 01:07:17,620
So I'll change these from Y to Z to A.

1520
01:07:21,300 --> 01:07:23,320
And if we'd run this
again, you're gonna see

1521
01:07:23,320 --> 01:07:28,320
that all the values are running
and printed to the screen.

1522
01:07:28,580 --> 01:07:30,910
So hello world, hello world, hello world,

1523
01:07:30,910 --> 01:07:32,340
because we had to actually do something

1524
01:07:32,340 --> 01:07:33,300
with those return values.

1525
01:07:33,300 --> 01:07:34,630
And if I get rid of this right here,

1526
01:07:34,630 --> 01:07:37,530
we're gonna see that we
have an error on the screen,

1527
01:07:37,530 --> 01:07:40,220
simply because those variables
have not been declared.

1528
01:07:40,220 --> 01:07:42,580
So that's just not gonna
work, it won't even compile.

1529
01:07:42,580 --> 01:07:44,180
So this is a return type.

1530
01:07:44,180 --> 01:07:46,040
If we wanna change the return
type to something else,

1531
01:07:46,040 --> 01:07:48,280
we can say int, so it's gonna return int.

1532
01:07:48,280 --> 01:07:50,030
And by default, this will not work.

1533
01:07:51,095 --> 01:07:51,928
You'll say, hey, there's a problem here.

1534
01:07:51,928 --> 01:07:54,650
And so I can return the value
of 32 or something like that.

1535
01:07:54,650 --> 01:07:58,120
And if we run this again,
we can then execute it.

1536
01:07:58,120 --> 01:07:59,550
Now, of course, because
this is a function,

1537
01:07:59,550 --> 01:08:01,880
We can say something, we
could put some if statements

1538
01:08:01,880 --> 01:08:04,570
inside of here or whatever we wanted to,

1539
01:08:04,570 --> 01:08:06,750
even if we wanted to
return it to the string,

1540
01:08:06,750 --> 01:08:08,340
but we only had a integer in here.

1541
01:08:08,340 --> 01:08:12,540
I could say dot two string
and that would then print 32

1542
01:08:12,540 --> 01:08:14,630
as a string to the screen.

1543
01:08:14,630 --> 01:08:16,797
So now whatever return types are,

1544
01:08:16,797 --> 01:08:18,020
which could be any of the built-in types

1545
01:08:18,020 --> 01:08:20,160
that you've already learned could be here.

1546
01:08:20,160 --> 01:08:23,340
So it could be a Boolean
value, it could be a long,

1547
01:08:23,340 --> 01:08:26,138
it could be a double,
if it can be any float,

1548
01:08:26,138 --> 01:08:27,753
whatever you're working
with at that point in time,

1549
01:08:27,753 --> 01:08:29,340
you'll need to return that.

1550
01:08:30,181 --> 01:08:31,820
So in this case, I'd say return true,

1551
01:08:31,820 --> 01:08:33,190
and it would return that value.

1552
01:08:33,190 --> 01:08:35,050
So you need to return
whatever the value is.

1553
01:08:35,050 --> 01:08:39,060
And of course, as we know,
if we don't return anything

1554
01:08:39,060 --> 01:08:41,410
at all, it's going to return a unit,

1555
01:08:41,410 --> 01:08:44,350
which even if the function
does nothing whatsoever,

1556
01:08:44,350 --> 01:08:46,830
it's still going to return a unit,

1557
01:08:46,830 --> 01:08:48,780
which then we print to the screen here.

1558
01:08:50,360 --> 01:08:52,450
Functions instead of
Kotlin are first class.

1559
01:08:52,450 --> 01:08:56,480
So if we have a function, say hi,

1560
01:08:56,480 --> 01:08:59,230
we might have something
that look like this.

1561
01:08:59,230 --> 01:09:01,080
And inside of here, when I say hello.

1562
01:09:02,171 --> 01:09:03,004
And if we were to call this function,

1563
01:09:03,004 --> 01:09:04,740
of course, we just call
it in the main function

1564
01:09:04,740 --> 01:09:08,030
and it's just going to
print hello to the screen.

1565
01:09:08,030 --> 01:09:10,320
However, one a bit are cool
things that you can also do

1566
01:09:10,320 --> 01:09:12,667
inside of Kotlin with functions

1567
01:09:12,667 --> 01:09:14,410
since they are first-class
citizens and technically objects,

1568
01:09:14,410 --> 01:09:16,930
which we will get to is
you create another function

1569
01:09:16,930 --> 01:09:18,300
inside of another function.

1570
01:09:18,300 --> 01:09:23,030
So we can say bye and that
would look something like this.

1571
01:09:23,030 --> 01:09:26,630
So now I'm creating a function
inside of another function.

1572
01:09:26,630 --> 01:09:29,280
And this one just gonna be bye.

1573
01:09:29,280 --> 01:09:31,220
Now, if I wanna call this function,

1574
01:09:32,816 --> 01:09:35,001
if I go up here and I try to say, say bye,

1575
01:09:35,001 --> 01:09:36,234
you'll notice I can't call this up here

1576
01:09:36,234 --> 01:09:37,780
because this function is not found.

1577
01:09:37,780 --> 01:09:41,510
It's because the scope of this
function is within say hi.

1578
01:09:41,510 --> 01:09:44,480
So the only place I can call say bye,

1579
01:09:44,480 --> 01:09:47,420
is it within the say hi
function, so this won't work.

1580
01:09:47,420 --> 01:09:50,940
So if I wanna call it, I can
come in here and call it.

1581
01:09:50,940 --> 01:09:52,970
But if I try it right
here, you'll notice again,

1582
01:09:52,970 --> 01:09:54,920
it's red, which means it can't be found

1583
01:09:55,818 --> 01:09:58,040
and the reason why Kotlin can't find it

1584
01:09:58,040 --> 01:09:59,060
is because it has not been declared yet.

1585
01:09:59,060 --> 01:10:01,410
So by the time the code gets here,

1586
01:10:01,410 --> 01:10:03,420
you have no idea what say bye means

1587
01:10:03,420 --> 01:10:05,380
because it's been declared below.

1588
01:10:05,380 --> 01:10:08,190
So we can go underneath
the function and call it.

1589
01:10:08,190 --> 01:10:11,320
And so say bye, and if
we were to run this now,

1590
01:10:11,320 --> 01:10:13,990
what we see to say hi and then bye.

1591
01:10:15,472 --> 01:10:17,690
And if we run it, we
would see hello and bye.

1592
01:10:17,690 --> 01:10:20,080
Now, of course, we should
probably rename this

1593
01:10:20,080 --> 01:10:23,030
to something else to say hi and bye.

1594
01:10:23,030 --> 01:10:25,781
And that was a simple rename,

1595
01:10:25,781 --> 01:10:27,300
which is done with a short cut key

1596
01:10:27,300 --> 01:10:30,090
or you could just do refactor rename.

1597
01:10:30,090 --> 01:10:32,280
So I used the shift F six here on a Mac.

1598
01:10:32,280 --> 01:10:34,870
So shifted F six giving
the highlight to change it.

1599
01:10:34,870 --> 01:10:36,980
So say, hi and bye and it will say hello.

1600
01:10:36,980 --> 01:10:39,290
And then it will say goodbye or just bye.

1601
01:10:41,490 --> 01:10:43,850
And then that function inside
of their head of function.

1602
01:10:43,850 --> 01:10:45,220
You can also put another function

1603
01:10:45,220 --> 01:10:46,900
inside of something in here.

1604
01:10:47,752 --> 01:10:50,520
So you could say move like a
cow, it would say print ln.

1605
01:10:50,520 --> 01:10:52,250
And this could say moo.

1606
01:10:53,330 --> 01:10:56,450
Now of course, I need a call
moon after I've declared it.

1607
01:10:56,450 --> 01:10:59,280
So at this point, I'm
gonna call say, hi and bye

1608
01:10:59,280 --> 01:11:02,260
and then print hello, this
function will be declared

1609
01:11:02,260 --> 01:11:04,650
and then we'll call say bye
which then we'll hop into here.

1610
01:11:04,650 --> 01:11:07,220
It'll say bye, we'll declare moo.

1611
01:11:07,220 --> 01:11:09,260
Then moo will be called, which
will print inside of here.

1612
01:11:09,260 --> 01:11:11,100
So all different kinds of stuff happening.

1613
01:11:11,100 --> 01:11:12,430
We're going here to here to here

1614
01:11:12,430 --> 01:11:14,600
kind of jumping around all over.

1615
01:11:14,600 --> 01:11:16,450
And if we were to run this again,

1616
01:11:16,450 --> 01:11:20,070
we're going to see hello, bye, moo

1617
01:11:20,070 --> 01:11:21,560
as we see on the helmet here.

1618
01:11:21,560 --> 01:11:24,530
Now there are again,
functions inside of functions.

1619
01:11:24,530 --> 01:11:28,090
This can get really squarely
looking and look real nasty

1620
01:11:28,090 --> 01:11:29,390
after a period of time.

1621
01:11:29,390 --> 01:11:32,540
So I advise that you be
very careful with declaring

1622
01:11:32,540 --> 01:11:34,730
functions inside of
functions and make sure

1623
01:11:34,730 --> 01:11:36,570
that's the proper right thing to do,

1624
01:11:36,570 --> 01:11:38,840
because it can make the
code very hard to read.

1625
01:11:38,840 --> 01:11:41,290
So unless you have a really
good idea for making a function

1626
01:11:41,290 --> 01:11:43,460
inside of a function, then you
might wanna steer clear of it

1627
01:11:43,460 --> 01:11:46,170
until you have a good grasp on
when you might want to do it,

1628
01:11:46,170 --> 01:11:48,220
which there are various
different implementations

1629
01:11:48,220 --> 01:11:50,220
that are beyond the scope of this video.

1630
01:11:51,890 --> 01:11:56,090
Functions in Kotlin typically
look something like this

1631
01:11:56,090 --> 01:11:59,570
and this function called say
hi, what we'll actually have

1632
01:11:59,570 --> 01:12:04,360
is a print line statement that says hi.

1633
01:12:04,360 --> 01:12:07,230
And so if I were to call
this from the main function,

1634
01:12:07,230 --> 01:12:09,580
we're gonna go ahead and
see high printed down here

1635
01:12:09,580 --> 01:12:11,800
to the output screen says hi.

1636
01:12:13,499 --> 01:12:15,650
Now, unfortunately,
with a lot of languages,

1637
01:12:15,650 --> 01:12:17,910
this bracket and this
bracket is kind of verbose

1638
01:12:17,910 --> 01:12:19,310
for just a simple statement.

1639
01:12:20,503 --> 01:12:21,790
Now, of course, this
function could have multiple

1640
01:12:21,790 --> 01:12:23,860
different things in here,
but let's just assume

1641
01:12:23,860 --> 01:12:25,490
it did one thing for now.

1642
01:12:25,490 --> 01:12:27,190
So Kotlin actually has a concept

1643
01:12:27,190 --> 01:12:29,640
known as a single expression function.

1644
01:12:29,640 --> 01:12:32,610
So we could do this here,
say hi is equivalent

1645
01:12:32,610 --> 01:12:34,280
to what we had before.

1646
01:12:34,280 --> 01:12:37,820
What this means is I have a
function, it's name is say hi,

1647
01:12:37,820 --> 01:12:39,580
it doesn't have any parameters.

1648
01:12:39,580 --> 01:12:42,070
And it's body of the
function is the equivalent

1649
01:12:42,997 --> 01:12:45,455
to this stuff over here, which
is on the right hand side

1650
01:12:45,455 --> 01:12:46,530
of the equals sign.

1651
01:12:46,530 --> 01:12:47,790
So inside the body of the function

1652
01:12:47,790 --> 01:12:49,140
is just gonna be print line.

1653
01:12:49,140 --> 01:12:52,130
So if I run this, we'll see
the same exact thing here.

1654
01:12:52,130 --> 01:12:53,870
So we can actually see hi.

1655
01:12:53,870 --> 01:12:57,020
Since Kotlin supports
functions inside of functions

1656
01:12:57,020 --> 01:12:59,756
because functions are actually objects,

1657
01:12:59,756 --> 01:13:01,980
we can actually declare a function

1658
01:13:01,980 --> 01:13:04,310
inside of another function,
which you could decide

1659
01:13:04,310 --> 01:13:07,120
to do or not and we'd say do work.

1660
01:13:07,120 --> 01:13:10,780
Let's say we had a variable
peer called age equals 32.

1661
01:13:10,780 --> 01:13:13,680
And then it said, if age is less than 32,

1662
01:13:13,680 --> 01:13:17,230
excuse me, less than 21, we
would go ahead and print out

1663
01:13:17,230 --> 01:13:22,230
that the whatever person or
whoever is less than at 21,

1664
01:13:24,770 --> 01:13:29,770
and otherwise they are say
eligible for whatever reason,

1665
01:13:31,580 --> 01:13:34,030
maybe have some reason
someone has to be over 21.

1666
01:13:35,600 --> 01:13:38,470
So now if we were to call do
work out or try to of course,

1667
01:13:38,470 --> 01:13:40,830
type a here do work has
not been declared yet

1668
01:13:40,830 --> 01:13:44,800
so I can't call it, so I'm
going to call it from down here.

1669
01:13:44,800 --> 01:13:47,270
And if I run this, we're
going to see say hi

1670
01:13:47,270 --> 01:13:51,070
and then we'll see eligible
because the person is eligible.

1671
01:13:51,070 --> 01:13:53,880
Let's set this to 12 and run it.

1672
01:13:53,880 --> 01:13:58,130
And you're going to see
that it says less than 21.

1673
01:13:58,130 --> 01:14:00,760
Now we can also perform, this is kind of

1674
01:14:00,760 --> 01:14:01,950
as we know multi-line statement.

1675
01:14:01,950 --> 01:14:05,530
But since we can use
single line if statements,

1676
01:14:05,530 --> 01:14:08,010
we can also turn this into
a single line expression.

1677
01:14:08,010 --> 01:14:10,080
So what I'm gonna do is I'm gonna get rid

1678
01:14:10,080 --> 01:14:13,380
of these brackets, basically all of them.

1679
01:14:14,990 --> 01:14:18,190
And we'll do is kind of
line this stuff up here

1680
01:14:19,080 --> 01:14:22,580
and turn this into a
single line expression.

1681
01:14:22,580 --> 01:14:25,850
And so again, the age is
12 if it's less than 21,

1682
01:14:25,850 --> 01:14:29,160
it'll print line here, else
that'll print this other thing.

1683
01:14:29,160 --> 01:14:32,430
If we run it, we can
actually, we see less than 21.

1684
01:14:32,430 --> 01:14:36,580
And of course, if I changed
it to 32, run it again,

1685
01:14:36,580 --> 01:14:39,470
you'll see that the output is eligible,

1686
01:14:39,470 --> 01:14:41,950
which is the other part
of the statement here.

1687
01:14:41,950 --> 01:14:43,900
So you can clean up a lot of your code

1688
01:14:43,900 --> 01:14:45,510
by using single line expressions.

1689
01:14:45,510 --> 01:14:48,710
There is a heuristic that
you should follow though.

1690
01:14:48,710 --> 01:14:52,380
Let's close this window
over here and you'll notice

1691
01:14:52,380 --> 01:14:55,220
the right-hand margin with
this little gray line here.

1692
01:14:55,220 --> 01:14:58,380
If you find your code
approaching this over here.

1693
01:14:58,380 --> 01:15:01,980
So let's just go ahead and type
eligible a couple of times,

1694
01:15:01,980 --> 01:15:04,180
if for whatever reason eligible,

1695
01:15:04,180 --> 01:15:06,208
you've typed a bunch of stuff here,

1696
01:15:06,208 --> 01:15:07,650
it goes beyond the right margin,

1697
01:15:07,650 --> 01:15:11,180
it's usually advisable that
you'd turn this instead of this

1698
01:15:11,180 --> 01:15:15,180
into an old fashioned multiline function

1699
01:15:15,180 --> 01:15:16,830
just so that it's more readable.

1700
01:15:16,830 --> 01:15:19,070
So here you'd wanna go
ahead and of course,

1701
01:15:19,070 --> 01:15:20,410
add your brackets.

1702
01:15:20,410 --> 01:15:22,810
And you'd kind of do
this thing right here.

1703
01:15:24,080 --> 01:15:28,560
And as we've kind of seen
before, we'll put this down here.

1704
01:15:29,420 --> 01:15:32,800
Oops, we'll clean this up a
little bit, so there we go.

1705
01:15:32,800 --> 01:15:37,800
So now if the age is less than
21, we're gonna print line.

1706
01:15:37,979 --> 01:15:39,960
Otherwise we're gonna
print eligible, eligible,

1707
01:15:39,960 --> 01:15:41,290
eligible, eligible.

1708
01:15:41,290 --> 01:15:43,840
Again, now the reason is
because the right-hand margin,

1709
01:15:43,840 --> 01:15:46,020
it's just a common coding practice.

1710
01:15:46,020 --> 01:15:48,770
If your code goes beyond
that right-hand margin,

1711
01:15:48,770 --> 01:15:51,410
you should figure out a way
to break into a new line.

1712
01:15:51,410 --> 01:15:53,610
And usually if you're using
a single line expression,

1713
01:15:53,610 --> 01:15:55,850
you'll wanna go ahead and
that's usually an indicator

1714
01:15:55,850 --> 01:15:57,500
that you should probably
use a regular function body

1715
01:15:57,500 --> 01:15:59,300
instead of a single line expression.

1716
01:16:00,370 --> 01:16:03,130
Functions in Kotlin without any parameters

1717
01:16:03,130 --> 01:16:04,710
are going to look just like this

1718
01:16:04,710 --> 01:16:06,240
with an open and close parentheses.

1719
01:16:06,240 --> 01:16:07,850
So the parameters are gonna be

1720
01:16:07,850 --> 01:16:09,760
in between the parentheses here

1721
01:16:09,760 --> 01:16:11,050
and there are no parameters here.

1722
01:16:11,050 --> 01:16:13,270
So if we were to call do work,

1723
01:16:13,270 --> 01:16:14,930
of course, nothing would happen.

1724
01:16:14,930 --> 01:16:18,690
We could say print the
line work is happening.

1725
01:16:19,670 --> 01:16:23,040
And then if we were to run
it, of course we'll do that.

1726
01:16:23,040 --> 01:16:24,121
Now, parameter is something

1727
01:16:24,121 --> 01:16:26,220
that we can parse into a function

1728
01:16:26,220 --> 01:16:27,730
to do work with it.

1729
01:16:27,730 --> 01:16:29,500
We can perform some type of value.

1730
01:16:29,500 --> 01:16:31,290
So what I would like to
do maybe is I would like

1731
01:16:31,290 --> 01:16:34,166
to provide some type of value here,

1732
01:16:34,166 --> 01:16:36,360
I wanna type in the value
of 32 into this function.

1733
01:16:36,360 --> 01:16:38,230
So what I'll do is take
the value 32 and say,

1734
01:16:38,230 --> 01:16:42,170
"Hey, do work, you need to do
something with this 32 value."

1735
01:16:42,170 --> 01:16:44,700
But in order to do that, I
need to provide a parameter

1736
01:16:44,700 --> 01:16:46,450
inside of the function declaration.

1737
01:16:47,497 --> 01:16:49,340
And so to do that, what I'm
going to do is type the word age

1738
01:16:49,340 --> 01:16:50,420
and its type.

1739
01:16:50,420 --> 01:16:55,320
So here age is gonna be an
integer and its value up here

1740
01:16:55,320 --> 01:16:56,750
is gonna be 32.

1741
01:16:56,750 --> 01:17:01,060
So now what I can do is I can say age is,

1742
01:17:01,060 --> 01:17:03,170
and of course, when you
string interpolation here

1743
01:17:03,170 --> 01:17:06,440
and say age is age and whatever.

1744
01:17:08,053 --> 01:17:08,970
Let's just do the reads a little better.

1745
01:17:08,970 --> 01:17:11,510
You are blank.

1746
01:17:11,510 --> 01:17:13,840
And so let's say you are
32 in this case so far.

1747
01:17:13,840 --> 01:17:18,430
To run this, we would see
that do work functions

1748
01:17:18,430 --> 01:17:20,790
says you are 32, which is great.

1749
01:17:20,790 --> 01:17:23,720
Now if I call this function
with another value,

1750
01:17:23,720 --> 01:17:26,400
let's say 12, we're gonna
see two different values

1751
01:17:26,400 --> 01:17:28,770
returned here, you are 32 and you are 12.

1752
01:17:28,770 --> 01:17:31,660
So what the parameter allows you to do

1753
01:17:31,660 --> 01:17:34,630
is allows you to parse in
values to your function.

1754
01:17:34,630 --> 01:17:38,420
So you say you are 32.

1755
01:17:38,420 --> 01:17:41,370
Now I could also provide
other additional values here

1756
01:17:41,370 --> 01:17:43,740
so I can put name and
access can be a string.

1757
01:17:43,740 --> 01:17:47,350
So I need to provide the
variable argument name

1758
01:17:47,350 --> 01:17:49,980
and the argument type, which
is string for both of them.

1759
01:17:49,980 --> 01:17:53,900
So again, this is the argument
name, argument type comma.

1760
01:17:53,900 --> 01:17:55,870
So I need another one in there.

1761
01:17:55,870 --> 01:17:57,080
Argument name, argument type.

1762
01:17:57,080 --> 01:17:58,980
Now you'll see that we have
a red squiggly up here,

1763
01:17:58,980 --> 01:18:00,770
that is because IntelliJ says,

1764
01:18:00,770 --> 01:18:03,650
"Hey, you're missing a additional value."

1765
01:18:03,650 --> 01:18:06,960
So I'm gonna type in Donn
and instead of saying,

1766
01:18:08,478 --> 01:18:11,750
I can say, string interpolation
again, name, comma,

1767
01:18:14,247 --> 01:18:16,697
and we'll have proper
punctuation here, period.

1768
01:18:17,900 --> 01:18:20,560
And if we hit run here,
what we'll see is 32

1769
01:18:20,560 --> 01:18:23,850
and Donn says, Don, you are 32 now.

1770
01:18:23,850 --> 01:18:27,950
If I to change their own,
I could say something else

1771
01:18:27,950 --> 01:18:32,710
like 12 and I could put Jonas,

1772
01:18:32,710 --> 01:18:35,660
and Jonas might be 12 for whatever reason.

1773
01:18:36,818 --> 01:18:39,820
And if we print that out here,
well, I'd have you're 12.

1774
01:18:39,820 --> 01:18:42,230
Now the cool thing you
can do with this thing

1775
01:18:42,230 --> 01:18:44,570
inside of the do work
function is now you can start

1776
01:18:44,570 --> 01:18:46,720
working with these values inside of here.

1777
01:18:46,720 --> 01:18:48,870
So maybe you might have an if statement.

1778
01:18:48,870 --> 01:18:51,780
If the age is less than 21,

1779
01:18:51,780 --> 01:18:54,060
you might wanna say something different,

1780
01:18:54,060 --> 01:18:58,500
like I wanna cut this out
here and we'll say the name,

1781
01:18:58,500 --> 01:19:03,220
you are not old enough.

1782
01:19:03,220 --> 01:19:05,410
Now, for whatever reason,
perhaps you have some logic

1783
01:19:05,410 --> 01:19:08,150
that states that for someone
to use this application,

1784
01:19:08,150 --> 01:19:11,180
they have to be over the age
of 21 for whatever reason.

1785
01:19:11,180 --> 01:19:14,336
And we wanna put it you're not enough.

1786
01:19:14,336 --> 01:19:17,094
You are blank, let's say age.

1787
01:19:17,094 --> 01:19:22,094
As I say, Don, you are say far
too old at the ripe age of,

1788
01:19:28,080 --> 01:19:30,310
and then we'll put the age of 32.

1789
01:19:30,310 --> 01:19:32,860
And so now as I run this,
we'll get two different values

1790
01:19:32,860 --> 01:19:34,120
that we're we're working with here.

1791
01:19:34,120 --> 01:19:36,190
So we'll see the first one is Donn

1792
01:19:36,190 --> 01:19:37,040
and the next one is Jonah.

1793
01:19:37,040 --> 01:19:40,270
So Donn far too old at the ripe age of 32,

1794
01:19:40,270 --> 01:19:43,100
Jonas, you are not old enough, you are 12.

1795
01:19:43,100 --> 01:19:44,980
And so I can continue down this road here.

1796
01:19:44,980 --> 01:19:47,910
Now, if I wanted to start
having, if I call this function

1797
01:19:47,910 --> 01:19:51,370
all over the place, let's
say I have a 71 year old

1798
01:19:51,370 --> 01:19:55,100
and her name is Evelyn and
Evelyn's using the app too

1799
01:19:55,100 --> 01:19:57,520
and she types in her age and we run it.

1800
01:19:57,520 --> 01:19:59,700
We'll see now that
Evelyn also has an entry,

1801
01:19:59,700 --> 01:20:02,820
Evelyn far too old at the ripe age of 71.

1802
01:20:02,820 --> 01:20:04,910
Sorry, Evelyn, if you're really not 71.

1803
01:20:05,800 --> 01:20:08,610
So we can actually start
various different values in here

1804
01:20:08,610 --> 01:20:10,730
that can be any different types here.

1805
01:20:10,730 --> 01:20:13,050
You can provide one
that's a Boolean value.

1806
01:20:13,050 --> 01:20:16,850
So you could say, yeah is
happy and you could tap in

1807
01:20:16,850 --> 01:20:17,890
a Boolean value.

1808
01:20:19,583 --> 01:20:21,703
And of course, because everybody's happy,

1809
01:20:21,703 --> 01:20:22,800
we'll just put true here.

1810
01:20:23,680 --> 01:20:25,900
And we'll say true and you
see IntelliJ is giving us

1811
01:20:25,900 --> 01:20:29,880
some nice little hints here of
what the actual (indistinct)

1812
01:20:29,880 --> 01:20:31,900
this is not something I typed
here is happy or age or name.

1813
01:20:31,900 --> 01:20:33,670
That's IntelliJ saying, "Hey, by the way,

1814
01:20:33,670 --> 01:20:36,400
"the name of this parameter is happy."

1815
01:20:36,400 --> 01:20:38,500
And then we've put true here because,

1816
01:20:38,500 --> 01:20:40,450
Evelyn, everybody's happy.

1817
01:20:40,450 --> 01:20:42,210
Then we can hit run.

1818
01:20:42,210 --> 01:20:43,810
And of course, we're gonna run it again.

1819
01:20:43,810 --> 01:20:45,970
Donn you're far too old age, ripe 32.

1820
01:20:45,970 --> 01:20:49,190
You notice, hey, we didn't
do anything with that value.

1821
01:20:49,190 --> 01:20:51,920
So we, of course, we might
need to do something with it,

1822
01:20:51,920 --> 01:20:55,110
which has says you are happy.

1823
01:20:56,890 --> 01:20:58,630
And then we could put something like this.

1824
01:20:58,630 --> 01:21:01,300
We could actually put some
other type of code in here.

1825
01:21:02,240 --> 01:21:06,910
We'll say, boom is happy
and then we'll run it again.

1826
01:21:08,053 --> 01:21:10,170
And again, of course, now we're
gonna see each one of them's

1827
01:21:10,170 --> 01:21:12,050
for Don, Jonas and Evelyn,
you are happy, true,

1828
01:21:12,050 --> 01:21:13,500
you are happy, true, you're happy, true.

1829
01:21:13,500 --> 01:21:16,420
For some reason today I was not happy,

1830
01:21:16,420 --> 01:21:19,700
maybe I stubbed my toe or to run it again.

1831
01:21:19,700 --> 01:21:22,780
We would see that Donn is not happy

1832
01:21:22,780 --> 01:21:24,310
because he stubbed his toe.

1833
01:21:24,310 --> 01:21:27,200
Jonas and Evelyn though are
still happy and so forth.

1834
01:21:27,200 --> 01:21:28,790
So this is how we can start adding in

1835
01:21:28,790 --> 01:21:30,650
various different parameters.

1836
01:21:30,650 --> 01:21:33,320
Again, if you need another
one, you're gonna put a comma

1837
01:21:33,320 --> 01:21:35,260
in here and you're going
to add another one.

1838
01:21:35,260 --> 01:21:38,520
So we could say foo is
going to be of type long,

1839
01:21:38,520 --> 01:21:40,630
for whatever reason, you may
need some different types here.

1840
01:21:40,630 --> 01:21:41,920
And of course, IntelliJ is gonna say,

1841
01:21:41,920 --> 01:21:43,890
hey, that's not gonna work 'cause you need

1842
01:21:43,890 --> 01:21:45,710
to provide that value up top.

1843
01:21:45,710 --> 01:21:48,800
So this how you provide
arguments to a function.

1844
01:21:48,800 --> 01:21:51,900
Let's assume we have a function
called print and user info.

1845
01:21:51,900 --> 01:21:55,053
It takes a bunch of arguments
such as the first name,

1846
01:21:55,053 --> 01:21:57,580
last name, age, if the user sunburned,

1847
01:21:57,580 --> 01:22:00,120
if they like movies and
if they love popcorn.

1848
01:22:00,120 --> 01:22:02,590
And if you would like to
do something with this,

1849
01:22:02,590 --> 01:22:04,780
and perhaps we just want
to print it to the screen,

1850
01:22:04,780 --> 01:22:07,850
we could provide some
implementation that looks like this,

1851
01:22:07,850 --> 01:22:09,950
that uses string literals
and prints it to the screen.

1852
01:22:09,950 --> 01:22:11,000
Fair enough.

1853
01:22:11,000 --> 01:22:13,970
Now, if we wanna call it, we're
going to call it like this.

1854
01:22:13,970 --> 01:22:15,150
We'll say print user info.

1855
01:22:15,150 --> 01:22:18,190
And then we have to start
providing all of the information

1856
01:22:18,190 --> 01:22:22,580
such as Donn Felker and then
we have to provide the age.

1857
01:22:22,580 --> 01:22:25,270
And then we say, is he sunburned?

1858
01:22:25,270 --> 01:22:26,430
No, he's not sunburned.

1859
01:22:26,430 --> 01:22:28,880
He loves movies or likes movies, true

1860
01:22:28,880 --> 01:22:31,300
and he loves popcorn, of course, why not?

1861
01:22:32,190 --> 01:22:34,920
So this now very simple,
we've covered this before,

1862
01:22:34,920 --> 01:22:37,690
but now we have these nice
little IDE hints in here

1863
01:22:37,690 --> 01:22:41,880
that say, Hey, this is
what this argument is.

1864
01:22:41,880 --> 01:22:42,720
It's his sunburn.

1865
01:22:42,720 --> 01:22:45,300
And this has works great
except until it goes

1866
01:22:45,300 --> 01:22:48,730
outside of the IDE because
IntelliJ and other IDEs

1867
01:22:48,730 --> 01:22:51,940
that are from IntelliJ
brains do this for us.

1868
01:22:51,940 --> 01:22:53,470
But once we get online
or into another IDE,

1869
01:22:53,470 --> 01:22:54,710
we don't get the same feature.

1870
01:22:54,710 --> 01:22:56,640
So let's hop over into another IDE.

1871
01:22:56,640 --> 01:22:58,710
Okay, we're inside of visual studio code.

1872
01:22:58,710 --> 01:23:00,290
I'm gonna paste the code
in here and you'll notice

1873
01:23:00,290 --> 01:23:02,330
that we don't get those
nice little previews

1874
01:23:02,330 --> 01:23:03,430
like we see over here.

1875
01:23:05,152 --> 01:23:07,657
So we have first name, last
name, age, sunburned, et cetera.

1876
01:23:07,657 --> 01:23:09,038
If we go back to visual studio code,

1877
01:23:09,038 --> 01:23:11,480
we don't have those values over here.

1878
01:23:11,480 --> 01:23:13,610
That's a feature of the IntelliJ IDE.

1879
01:23:13,610 --> 01:23:15,930
So at this point when
we're reading this code,

1880
01:23:15,930 --> 01:23:18,980
and this will be the case, if
you're doing a poll request

1881
01:23:18,980 --> 01:23:22,250
or viewing the source code
online through a web browser,

1882
01:23:22,250 --> 01:23:24,470
you're not gonna understand
what this false even means,

1883
01:23:24,470 --> 01:23:26,599
especially a couple of
months down the road.

1884
01:23:26,599 --> 01:23:27,910
You're not gonna
understand what true means.

1885
01:23:27,910 --> 01:23:30,880
True here, we have no idea
what print user info is.

1886
01:23:30,880 --> 01:23:33,840
And most likely this
method is somewhere perhaps

1887
01:23:33,840 --> 01:23:36,470
in another file, perhaps further
down where I can't see it

1888
01:23:36,470 --> 01:23:38,620
unless I have to scroll
for it and find it.

1889
01:23:39,719 --> 01:23:40,552
And it just makes it more difficult

1890
01:23:40,552 --> 01:23:42,810
and I have to do a lot of
context switching to find it.

1891
01:23:45,805 --> 01:23:47,680
Now, the interesting thing
here is that we can fix this

1892
01:23:47,680 --> 01:23:48,530
inside of Kotlin.

1893
01:23:49,457 --> 01:23:50,750
Let me go back to IntelliJ
and what we can do

1894
01:23:50,750 --> 01:23:52,810
is actually provide the
name parameters here.

1895
01:23:52,810 --> 01:23:55,270
So I'm gonna type first name.

1896
01:23:55,270 --> 01:23:57,340
So this is what is known
as a named parameter.

1897
01:23:57,340 --> 01:24:01,450
I'm using the name of the
parameter and at the call site,

1898
01:24:01,450 --> 01:24:03,270
I'm actually providing the name here.

1899
01:24:03,270 --> 01:24:06,980
So is sunburned, that's false.

1900
01:24:06,980 --> 01:24:09,640
And then we could say
it likes movies, true

1901
01:24:09,640 --> 01:24:12,720
and loves popcorn is true.

1902
01:24:12,720 --> 01:24:14,660
Now, if I actually, I'm
gonna copy and paste

1903
01:24:14,660 --> 01:24:17,040
this code again, go back
to visual studio code,

1904
01:24:17,040 --> 01:24:18,880
delete this code here and paste it.

1905
01:24:18,880 --> 01:24:22,590
You'll see we actually get
those name parameters over,

1906
01:24:22,590 --> 01:24:25,080
By default, Kotilin will
still compile those code.

1907
01:24:25,080 --> 01:24:27,800
So back inside of IntelliJ,
it will still compile

1908
01:24:27,800 --> 01:24:28,850
this code right here.

1909
01:24:29,824 --> 01:24:34,470
And if we were to run it, we
would see this as Donn Felker

1910
01:24:34,470 --> 01:24:36,650
is of age 32 sunburned,
false, likes movies, true,

1911
01:24:36,650 --> 01:24:38,080
loves popcorn, true.

1912
01:24:38,080 --> 01:24:40,450
So the things all run
in, which is really nice.

1913
01:24:40,450 --> 01:24:42,910
Now the other great thing
about named parameters

1914
01:24:42,910 --> 01:24:44,690
is they're also positional based.

1915
01:24:44,690 --> 01:24:46,600
So let's get rid of this one down here

1916
01:24:46,600 --> 01:24:48,595
so you can see what I'm talking about.

1917
01:24:48,595 --> 01:24:49,640
We get a little squiggly here.

1918
01:24:49,640 --> 01:24:52,470
It says mixing named
and positioned arguments

1919
01:24:52,470 --> 01:24:53,960
is not allowed, meaning that we can't...

1920
01:24:53,960 --> 01:24:56,220
We're using a positional
based argument right now.

1921
01:24:56,220 --> 01:24:57,670
This is a positional based argument,

1922
01:24:57,670 --> 01:25:01,740
it's the last one here
in the list of arguments.

1923
01:25:01,740 --> 01:25:02,990
I could also undo this and say,

1924
01:25:02,990 --> 01:25:05,380
hey, let's get rid of the age one here.

1925
01:25:05,380 --> 01:25:06,870
and I'd get the same thing here and say,

1926
01:25:06,870 --> 01:25:11,520
hey, this is basically the
third item in the argument list.

1927
01:25:11,520 --> 01:25:13,180
Kotlin says, "I don't know
what you're trying to do.

1928
01:25:13,180 --> 01:25:15,280
"You wanna use name parameters,
but now you're using one

1929
01:25:15,280 --> 01:25:17,800
"that's a positional based,
decide what you wanna do."

1930
01:25:17,800 --> 01:25:19,070
But it won't compile.

1931
01:25:19,070 --> 01:25:20,620
So if you're gonna use one name,

1932
01:25:20,620 --> 01:25:22,470
you need to provide the
name for all of them,

1933
01:25:22,470 --> 01:25:24,170
which is much more readable.

1934
01:25:24,170 --> 01:25:26,300
Now because we're using name parameters,

1935
01:25:26,300 --> 01:25:29,360
I can actually move these
around, which is very cool.

1936
01:25:29,360 --> 01:25:33,010
So the print user info
method takes a first name,

1937
01:25:33,010 --> 01:25:35,520
last name, age, those
are the parameter order.

1938
01:25:35,520 --> 01:25:38,050
So in traditional languages
that you're used to working

1939
01:25:38,050 --> 01:25:41,970
with otherwise, you always
have to provide the values

1940
01:25:41,970 --> 01:25:43,340
in that order.

1941
01:25:43,340 --> 01:25:45,320
However, with Kotlin you can
provide a named argument.

1942
01:25:45,320 --> 01:25:48,150
So it says, hey, age is
32, Kotlin will know to map

1943
01:25:48,150 --> 01:25:52,840
this value here over
into this age parameter.

1944
01:25:52,840 --> 01:25:54,480
Now, if I wanna move his sunburned

1945
01:25:54,480 --> 01:25:56,540
maybe a little bit closer,
'cause for whatever reason

1946
01:25:56,540 --> 01:25:59,020
in my program, it makes more sense,

1947
01:25:59,020 --> 01:26:01,150
I can do that here in
Cottonwood note to map

1948
01:26:01,150 --> 01:26:03,460
this parameter value,
which is second the list

1949
01:26:04,344 --> 01:26:06,050
in the positional sense, map it over here

1950
01:26:06,050 --> 01:26:08,560
because we're using the
actual named parameter.

1951
01:26:08,560 --> 01:26:11,190
So we're using the name
parameter to map it over.

1952
01:26:11,190 --> 01:26:14,560
And that's how you can use
name parameters in Kotlin.

1953
01:26:14,560 --> 01:26:17,940
In Kotlin, there's a concept
known as a default argument.

1954
01:26:17,940 --> 01:26:20,390
Now, every time I call
this print user function.

1955
01:26:20,390 --> 01:26:22,910
So let's say I had to call it a few times,

1956
01:26:22,910 --> 01:26:26,310
I have to change this
from every time of course,

1957
01:26:26,310 --> 01:26:28,850
these values are gonna
change to some other types

1958
01:26:28,850 --> 01:26:32,970
of thing and it's gonna
say 31 to 37 and 12

1959
01:26:32,970 --> 01:26:34,110
and all these different types of things.

1960
01:26:34,110 --> 01:26:37,100
And this person is sunburned, et cetera.

1961
01:26:37,100 --> 01:26:39,030
But perhaps the majority of the time,

1962
01:26:39,030 --> 01:26:40,880
I always know that these
people are not sunburned

1963
01:26:40,880 --> 01:26:43,130
and maybe because these
people are my family,

1964
01:26:43,130 --> 01:26:45,720
they like movies and I know
that they love popcorn,

1965
01:26:45,720 --> 01:26:48,310
but having to repeat these
things many times as troublesome.

1966
01:26:48,310 --> 01:26:52,040
So we can actually use the
power of default arguments.

1967
01:26:52,040 --> 01:26:55,070
And to do so we can specify a
default value for an argument.

1968
01:26:55,070 --> 01:26:57,870
So it will say the user loves popcorn.

1969
01:26:57,870 --> 01:26:59,300
So we're gonna set it to true here.

1970
01:26:59,300 --> 01:27:01,570
Now, if Love's popcorn is not provided,

1971
01:27:02,468 --> 01:27:03,990
we can actually remove
it from this call site,

1972
01:27:03,990 --> 01:27:05,640
it will just default to true.

1973
01:27:06,813 --> 01:27:08,450
So I can actually remove it
from these other ones as well.

1974
01:27:08,450 --> 01:27:13,450
And I can provide a default
argument for likes movies.

1975
01:27:13,760 --> 01:27:14,790
And we're gonna default that the true,

1976
01:27:14,790 --> 01:27:17,240
because everybody should
like movies, I think.

1977
01:27:17,240 --> 01:27:19,790
And then again, I can remove
this from the call site.

1978
01:27:19,790 --> 01:27:22,710
And because I'm removing
it, the default value

1979
01:27:22,710 --> 01:27:25,470
of likes movies is going to be true.

1980
01:27:25,470 --> 01:27:29,513
And of course, it's not often
that everyone is sunburned.

1981
01:27:29,513 --> 01:27:32,010
So let's go ahead and set this to false.

1982
01:27:32,010 --> 01:27:34,610
And it's pretty easy to
do, so I'll say false.

1983
01:27:34,610 --> 01:27:37,248
Now we can go ahead and
remove this from here.

1984
01:27:37,248 --> 01:27:38,081
And now this cleans up the call side

1985
01:27:38,081 --> 01:27:39,880
of these three functions quite a bit.

1986
01:27:39,880 --> 01:27:42,860
We can actually see the
only relevant information

1987
01:27:42,860 --> 01:27:46,180
that is changed in each
print user info function.

1988
01:27:46,180 --> 01:27:48,130
And if we were to run
these here, let's run it.

1989
01:27:48,130 --> 01:27:50,081
You're gonna see it's printed three times

1990
01:27:50,081 --> 01:27:51,310
and we see sunburned,
false, likes movies, true,

1991
01:27:51,310 --> 01:27:52,620
loves popcorn, true.

1992
01:27:52,620 --> 01:27:56,032
Now, if for some reason
that I know that this time,

1993
01:27:56,032 --> 01:27:58,420
perhaps I've just eaten a lot popcorn

1994
01:27:58,420 --> 01:27:59,980
and I'm just not really fond of it lately,

1995
01:27:59,980 --> 01:28:01,590
I'm just gonna say it
loves popcorn, false.

1996
01:28:01,590 --> 01:28:05,320
And maybe I know that Bob
this week is sunburned

1997
01:28:05,320 --> 01:28:07,981
'cause he just got back
from the beach here over

1998
01:28:07,981 --> 01:28:09,090
in New Jersey and the Jersey shore.

1999
01:28:10,165 --> 01:28:12,309
And perhaps Sarah, for whatever reason

2000
01:28:12,309 --> 01:28:15,170
just does not like movies and
we're gonna put false there.

2001
01:28:15,170 --> 01:28:17,220
So actually Bob is sunburned.

2002
01:28:17,220 --> 01:28:18,610
So make that true.

2003
01:28:18,610 --> 01:28:21,030
So now what will happen
is when we call the print

2004
01:28:21,030 --> 01:28:23,320
and user function, all
these values are set.

2005
01:28:23,320 --> 01:28:26,550
Now loves popcorn, which
is traditionally true,

2006
01:28:26,550 --> 01:28:29,990
is gonna be set to false
for this function call.

2007
01:28:29,990 --> 01:28:32,640
For the next function
call print user info,

2008
01:28:32,640 --> 01:28:34,690
it's going to be the true
cause I haven't provided it

2009
01:28:34,690 --> 01:28:36,570
up here because it's
using the default value.

2010
01:28:36,570 --> 01:28:38,440
However I'm saying, hey, it is sunburned.

2011
01:28:38,440 --> 01:28:40,600
This time don't use the
false value, use true

2012
01:28:40,600 --> 01:28:42,720
'cause Bob has actually sunburned.

2013
01:28:42,720 --> 01:28:45,070
And then finally we have
the print user function

2014
01:28:45,070 --> 01:28:47,060
down here at the bottom for Sarah.

2015
01:28:47,060 --> 01:28:48,860
And she actually doesn't like movies,

2016
01:28:48,860 --> 01:28:50,550
so we're not going to
default that to true,

2017
01:28:50,550 --> 01:28:51,750
we're gonna set it to false.

2018
01:28:51,750 --> 01:28:54,060
And if we run this
again, we're going to see

2019
01:28:54,060 --> 01:28:56,150
that these values actually
render correctly here.

2020
01:28:56,150 --> 01:28:58,720
So Donn loves popcorn is false.

2021
01:28:59,825 --> 01:29:03,360
The Bob Felker here is a sunburned, true

2022
01:29:03,360 --> 01:29:06,840
and Sarah Felker likes movies, false.

2023
01:29:06,840 --> 01:29:10,870
So these are all of their
default values that you can have

2024
01:29:10,870 --> 01:29:12,160
inside of Kotlin.

2025
01:29:12,160 --> 01:29:15,140
Now, if there is a string, for example,

2026
01:29:15,140 --> 01:29:18,000
we could say that a string,
let's make a string here

2027
01:29:18,000 --> 01:29:22,220
at the end, we'll say favorite color.

2028
01:29:23,710 --> 01:29:25,680
And it could be string and would've say

2029
01:29:25,680 --> 01:29:26,880
that's going to be blue.

2030
01:29:28,438 --> 01:29:31,500
And if you provide that
favorite color, then up here,

2031
01:29:31,500 --> 01:29:35,210
you can override it, otherwise
it will just default to blue.

2032
01:29:35,210 --> 01:29:36,910
So you can do any of these things.

2033
01:29:37,971 --> 01:29:39,680
Could be a built-in primitive
type, could be a class.

2034
01:29:39,680 --> 01:29:42,880
And then like that you can
set to a default value.

2035
01:29:42,880 --> 01:29:45,870
Now, traditionally the default arguments

2036
01:29:45,870 --> 01:29:48,700
are usually placed at the
end of the method call.

2037
01:29:48,700 --> 01:29:50,920
Now this is not a steadfast rule.

2038
01:29:50,920 --> 01:29:52,950
You can actually place them in the middle.

2039
01:29:52,950 --> 01:29:54,800
So if you'd like to
say, well, the last name

2040
01:29:54,800 --> 01:29:57,650
is actually supposed to
be defaulting to Smith

2041
01:29:57,650 --> 01:29:59,590
because we are working
with the Smith family.

2042
01:29:59,590 --> 01:30:03,340
But whatever reason we
realized we gave Sarah

2043
01:30:03,340 --> 01:30:04,850
the wrong last name.

2044
01:30:04,850 --> 01:30:07,060
Now, if we were to run
that again, we could run it

2045
01:30:07,060 --> 01:30:11,190
and we'd see Bob Felker, Donn
Felker and Sarah Smith here.

2046
01:30:11,190 --> 01:30:15,650
So we've used a default
argument right inside

2047
01:30:15,650 --> 01:30:18,400
of the middle of the call site here.

2048
01:30:18,400 --> 01:30:20,910
So right in the middle of
the definition of the method.

2049
01:30:20,910 --> 01:30:22,710
Now, but age has not been specified.

2050
01:30:22,710 --> 01:30:24,120
So you do need to provide that.

2051
01:30:24,120 --> 01:30:28,072
So if we do leave off age,
we're gonna get an error here

2052
01:30:28,072 --> 01:30:30,310
and we'll see that no value
parse for parameter age.

2053
01:30:30,310 --> 01:30:32,450
And because we're using named
values, I can do that up here,

2054
01:30:32,450 --> 01:30:35,290
say, our age is 32.

2055
01:30:35,290 --> 01:30:37,080
And I can move these around
anywhere that I would like,

2056
01:30:37,080 --> 01:30:39,140
because we are using the name parameters.

2057
01:30:39,140 --> 01:30:42,610
And that's how you can use
default arguments parameters

2058
01:30:42,610 --> 01:30:43,970
inside of Kotlin.

2059
01:30:43,970 --> 01:30:47,530
A common pattern in Kotlin
is once your column length

2060
01:30:47,530 --> 01:30:50,040
for your code exceeds the
right-hand margin length,

2061
01:30:50,040 --> 01:30:51,800
which is his right hand line,

2062
01:30:51,800 --> 01:30:54,720
it's common to start placing
values on the next line,

2063
01:30:54,720 --> 01:30:58,730
such as we're doing here, makes
it much more easy to read.

2064
01:30:58,730 --> 01:31:01,540
Now this can get quite old pretty fast

2065
01:31:01,540 --> 01:31:04,200
and can become very slow and error prone.

2066
01:31:04,200 --> 01:31:06,890
Now, thankfully, if we're using an IDE,

2067
01:31:06,890 --> 01:31:09,130
such as IntelliJ, Android
Studio or anything like that,

2068
01:31:09,130 --> 01:31:10,760
this is built into the platform.

2069
01:31:10,760 --> 01:31:12,580
So put your cursor on the left-hand side

2070
01:31:12,580 --> 01:31:15,430
of the open parentheses at Alt and enter,

2071
01:31:15,430 --> 01:31:18,260
and you can say put
arguments on separate lines

2072
01:31:18,260 --> 01:31:20,990
and now it'll put it on
separate lines, which is great.

2073
01:31:20,990 --> 01:31:22,800
So it saves you a lot
of time really quickly.

2074
01:31:22,800 --> 01:31:24,520
So anytime you wanna do that,

2075
01:31:24,520 --> 01:31:26,570
you can use that little shortcut.

2076
01:31:26,570 --> 01:31:29,360
Now we do get these nice
names here that are built in

2077
01:31:29,360 --> 01:31:30,760
from the platform.

2078
01:31:30,760 --> 01:31:32,700
Again, this is the IDE
giving us these names.

2079
01:31:32,700 --> 01:31:34,990
So if we copy these into another IDE,

2080
01:31:34,990 --> 01:31:39,080
such as Visual Studio Code, we
don't get those values back.

2081
01:31:39,080 --> 01:31:42,380
So how do we add those
named values of actual

2082
01:31:42,380 --> 01:31:43,430
those argument names?

2083
01:31:45,124 --> 01:31:48,360
You can go back to IntelliJ,
Android Studio or whatever,

2084
01:31:48,360 --> 01:31:49,520
and start adding them by hand.

2085
01:31:49,520 --> 01:31:51,760
Again, this is gonna take a lot
of time if you're doing this

2086
01:31:51,760 --> 01:31:52,740
over and over and over.

2087
01:31:52,740 --> 01:31:55,120
Thankfully again, place your
cursor on the left-hand side

2088
01:31:55,120 --> 01:31:57,600
of the parentheses and
select the add names

2089
01:31:57,600 --> 01:31:59,310
to call arguments and boom,

2090
01:32:00,443 --> 01:32:02,160
all of a sudden you have
now cleaned up your code

2091
01:32:02,160 --> 01:32:04,210
by placing each of the
arguments on a separate line,

2092
01:32:04,210 --> 01:32:05,610
making it much more readable,

2093
01:32:05,610 --> 01:32:08,010
as well as adding the
names of the arguments

2094
01:32:08,010 --> 01:32:09,300
to each of the parameters,

2095
01:32:09,300 --> 01:32:11,030
which makes it even more readable

2096
01:32:11,030 --> 01:32:13,790
and saves you time at the end of the day.

2097
01:32:13,790 --> 01:32:16,250
Let's assume you have a
function called print book info

2098
01:32:16,250 --> 01:32:18,590
that prints the title of
a book and the author.

2099
01:32:18,590 --> 01:32:20,830
Here, we have green eggs and
ham, and if we were to run it,

2100
01:32:20,830 --> 01:32:23,000
we would see that it's just going to print

2101
01:32:23,000 --> 01:32:25,190
green eggs and ham, the
author is Dr. Seuss.

2102
01:32:25,190 --> 01:32:28,180
Now, however, if we had
the instance where we knew

2103
01:32:28,180 --> 01:32:30,510
that we needed to add
an additional author,

2104
01:32:30,510 --> 01:32:32,850
because sometimes books have coauthors,

2105
01:32:32,850 --> 01:32:36,830
we would have to maybe create
an overload of this function.

2106
01:32:36,830 --> 01:32:38,940
And we'd say this would be author two.

2107
01:32:38,940 --> 01:32:40,420
This would be author an author two

2108
01:32:40,420 --> 01:32:43,350
and then perhaps we might
change it to say authors,

2109
01:32:43,350 --> 01:32:44,510
and then we'd have another comment

2110
01:32:44,510 --> 01:32:46,940
with another string interpolation here.

2111
01:32:46,940 --> 01:32:48,230
It would for author two.

2112
01:32:48,230 --> 01:32:50,774
Now, if the book has three authors,

2113
01:32:50,774 --> 01:32:51,740
we would have to create
another function and four

2114
01:32:51,740 --> 01:32:55,040
and five and six, and you
can see where this is going.

2115
01:32:55,040 --> 01:32:58,600
So thankfully Kotlin has
a way for us to do that

2116
01:32:58,600 --> 01:33:00,250
without having to write extra code really.

2117
01:33:00,250 --> 01:33:02,070
And so what we can do is
take this last parameter

2118
01:33:02,070 --> 01:33:03,790
and turn this into a var arg.

2119
01:33:03,790 --> 01:33:07,010
And that's a keyword var arg,
which means variable argument.

2120
01:33:07,010 --> 01:33:08,960
And then I'm just gonna
change this to authors,

2121
01:33:08,960 --> 01:33:12,300
which means that this value
could take zero to many values.

2122
01:33:12,300 --> 01:33:14,410
So there could be many authors here.

2123
01:33:14,410 --> 01:33:16,830
And since this is going to be an array,

2124
01:33:16,830 --> 01:33:18,740
if we were to print
this now, let's go ahead

2125
01:33:18,740 --> 01:33:20,260
and just add another person in here.

2126
01:33:20,260 --> 01:33:23,460
So maybe I was the coauthor,
which we know I'm not,

2127
01:33:23,460 --> 01:33:24,710
but this is hypothetical.

2128
01:33:25,759 --> 01:33:28,090
We'll run this here and you
can see that we actually have

2129
01:33:28,090 --> 01:33:31,260
open bracket and it's starting
to print the information.

2130
01:33:31,260 --> 01:33:32,350
This is now an array.

2131
01:33:32,350 --> 01:33:34,800
And so this is printing the
information about the array.

2132
01:33:34,800 --> 01:33:36,640
If we actually wanna print
the contents of the array,

2133
01:33:36,640 --> 01:33:37,820
we're gonna hop into a little bit

2134
01:33:37,820 --> 01:33:41,130
of an advanced concept here and we'll use

2135
01:33:41,130 --> 01:33:44,840
a lambda expression and
we'll print it to the screen.

2136
01:33:44,840 --> 01:33:47,590
And it is the key word at the front line.

2137
01:33:48,485 --> 01:33:50,485
And if we're to run it now, we would see

2138
01:33:51,350 --> 01:33:54,000
also this array value here,
which we can get rid of

2139
01:33:55,329 --> 01:33:57,762
and clean it up a little
bit and run it again.

2140
01:33:57,762 --> 01:33:58,800
And you would see that we
have green eggs and ham

2141
01:33:58,800 --> 01:34:01,980
and the author, we should say authors

2142
01:34:01,980 --> 01:34:04,480
would be Dr. Seuss and Donn Felker

2143
01:34:04,480 --> 01:34:06,190
as it's now rendering here.

2144
01:34:06,190 --> 01:34:07,990
We could also take this
and add additional ones.

2145
01:34:07,990 --> 01:34:11,490
So if we had Jane Doe, Jon Doe,

2146
01:34:11,490 --> 01:34:13,330
and we had all kinds of other ones,

2147
01:34:13,330 --> 01:34:15,300
we could keep adding them in there.

2148
01:34:15,300 --> 01:34:16,570
Now the other cool thing is too,

2149
01:34:16,570 --> 01:34:19,720
we could also have the situation
where for whatever reason,

2150
01:34:19,720 --> 01:34:22,800
this book just doesn't have
an author and it's unknown.

2151
01:34:22,800 --> 01:34:24,420
We could run this as well.

2152
01:34:24,420 --> 01:34:26,940
And we would see that
there's no values returned.

2153
01:34:26,940 --> 01:34:30,520
So if you need to have
a function that takes in

2154
01:34:30,520 --> 01:34:33,050
multiple inputs of that particular type,

2155
01:34:33,050 --> 01:34:34,750
you wanna make sure that the var arg

2156
01:34:34,750 --> 01:34:37,130
is the last argument in the function,

2157
01:34:37,130 --> 01:34:40,350
slap on the var arg keyword
and then you can pars

2158
01:34:40,350 --> 01:34:43,170
multiple values in so
such as we're doing here.

2159
01:34:43,170 --> 01:34:47,100
So like X, Y, and Z, and
then all these values

2160
01:34:47,100 --> 01:34:49,190
would then be stuffed
into this author's array

2161
01:34:49,190 --> 01:34:52,893
and you could loop over it
using either a lambda expression

2162
01:34:52,893 --> 01:34:55,990
or any other array manipulation
or iteration techniques.

2163
01:34:58,040 --> 01:35:00,890
Let's assume we had a function
called print user info

2164
01:35:00,890 --> 01:35:02,380
and it just printed a name.

2165
01:35:02,380 --> 01:35:04,750
So very simple, we're just gonna
take the name and print it.

2166
01:35:04,750 --> 01:35:07,050
And it says name Donn Felker.

2167
01:35:07,050 --> 01:35:08,560
Now let's say for whatever reason,

2168
01:35:08,560 --> 01:35:10,760
I also need to have it take

2169
01:35:10,760 --> 01:35:12,210
sometimes it only needs the name,

2170
01:35:12,210 --> 01:35:14,840
sometimes it only needs the age.

2171
01:35:14,840 --> 01:35:16,800
So I'll say, you know what,
I actually kind of need

2172
01:35:16,800 --> 01:35:18,600
another print user info function.

2173
01:35:19,530 --> 01:35:20,990
And this one is going
to have age and this one

2174
01:35:20,990 --> 01:35:22,330
is gonna be int.

2175
01:35:22,330 --> 01:35:25,057
And so at this time I can actually say,

2176
01:35:25,057 --> 01:35:25,940
all right, well, I'm
gonna call this new one,

2177
01:35:25,940 --> 01:35:27,550
it's gonna be a new user.

2178
01:35:27,550 --> 01:35:29,560
And this one's called Jane Doe

2179
01:35:29,560 --> 01:35:32,030
and I'm gonna make her age of 37.

2180
01:35:32,910 --> 01:35:34,920
So now this one print
user info is going to,

2181
01:35:34,920 --> 01:35:36,210
if we go to the definition of it,

2182
01:35:36,210 --> 01:35:37,560
it's gonna go to this function.

2183
01:35:37,560 --> 01:35:39,380
And this one is gonna go to this function.

2184
01:35:39,380 --> 01:35:41,060
This is called function overloading,

2185
01:35:41,060 --> 01:35:44,450
we're overloading the
term print user info.

2186
01:35:44,450 --> 01:35:47,120
So has two different has the same name,

2187
01:35:47,120 --> 01:35:48,770
but it's taking different arguments here.

2188
01:35:48,770 --> 01:35:51,180
Now, if I were to remove this argument,

2189
01:35:51,180 --> 01:35:52,290
you'd see we get some errors here

2190
01:35:52,290 --> 01:35:55,100
because we had the exact
same definition here.

2191
01:35:55,100 --> 01:35:58,380
This is the exact same function
name and function parameters

2192
01:35:58,380 --> 01:36:00,950
right here that are right here

2193
01:36:00,950 --> 01:36:02,330
and that's going to be a problem.

2194
01:36:02,330 --> 01:36:07,010
So because we have a
different parameter here age,

2195
01:36:07,010 --> 01:36:09,490
it's now considered a
different signature to Kotlin

2196
01:36:09,490 --> 01:36:11,490
and say, all right you
can overload that function

2197
01:36:11,490 --> 01:36:14,604
and then of course, we're
probably going to have

2198
01:36:14,604 --> 01:36:15,810
some information here that's
a little bit different.

2199
01:36:17,034 --> 01:36:19,263
Now, again, we could say,
well, now I also want

2200
01:36:19,263 --> 01:36:20,700
their favorite color to be inside of here.

2201
01:36:20,700 --> 01:36:23,550
So I'd say fave color.

2202
01:36:23,550 --> 01:36:26,450
And that might just be
a string for simplicity.

2203
01:36:26,450 --> 01:36:27,960
Now I have three overloads.

2204
01:36:27,960 --> 01:36:31,080
So what we could do here
is I say, print user info.

2205
01:36:31,080 --> 01:36:33,231
You see, I have three different options.

2206
01:36:33,231 --> 01:36:35,030
So one takes a string, one takes integer,

2207
01:36:35,030 --> 01:36:36,120
a string and an integer,

2208
01:36:36,120 --> 01:36:39,030
and one takes string
integer and favorite color.

2209
01:36:39,030 --> 01:36:42,080
And so of course, then
we'd want to change this.

2210
01:36:42,080 --> 01:36:44,230
So it said feed color.

2211
01:36:44,230 --> 01:36:47,500
And this would say using
string interpolation again,

2212
01:36:47,500 --> 01:36:48,980
their favorite color.

2213
01:36:48,980 --> 01:36:51,530
So then I could print this user info.

2214
01:36:51,530 --> 01:36:54,513
And I would say Frank Bendo,

2215
01:36:57,220 --> 01:37:00,850
and we would say that his age is 22

2216
01:37:00,850 --> 01:37:03,100
and his favorite color is purple.

2217
01:37:04,050 --> 01:37:05,970
And at that point in time,
if we were to run these,

2218
01:37:05,970 --> 01:37:09,890
each one of these are going
to run a different function.

2219
01:37:09,890 --> 01:37:11,440
So the top ones are in the top one here,

2220
01:37:11,440 --> 01:37:13,050
the second one's going
to run this one here,

2221
01:37:13,050 --> 01:37:15,680
and the third one's going
to run this one here.

2222
01:37:15,680 --> 01:37:18,718
Now, if you're already
familiar with Kotlin

2223
01:37:18,718 --> 01:37:22,130
and also it's named parameters
and his default values,

2224
01:37:22,130 --> 01:37:24,813
well, then now I'm sure you
can already imagine that

2225
01:37:24,813 --> 01:37:26,940
well, we could actually kind
of clean this up a little bit.

2226
01:37:26,940 --> 01:37:29,715
And to clean this up, you can
actually kind of get right rid

2227
01:37:29,715 --> 01:37:31,030
of this and say, hey, you know what,

2228
01:37:32,016 --> 01:37:33,390
well, age is going to be an integer.

2229
01:37:34,273 --> 01:37:36,070
And if they don't provide it,
I want it to default to zero.

2230
01:37:37,093 --> 01:37:39,870
And a favorite color is going
to be a string, of course.

2231
01:37:39,870 --> 01:37:43,030
And if they don't provide
it will default to purple.

2232
01:37:43,030 --> 01:37:44,270
And so we'll do that.

2233
01:37:44,270 --> 01:37:46,260
Actually no, we can actually default it

2234
01:37:46,260 --> 01:37:47,910
to an empty string if you'd like,

2235
01:37:49,236 --> 01:37:51,210
and then what will allow us
to do is get rid of this,

2236
01:37:51,210 --> 01:37:52,700
see how we have this here.

2237
01:37:52,700 --> 01:37:54,640
It says, hey, there's
a conflicting overload

2238
01:37:54,640 --> 01:37:57,850
because we have this up
here with the same values.

2239
01:37:57,850 --> 01:38:00,710
Now, if I get rid of this,
all of these still work

2240
01:38:00,710 --> 01:38:03,160
because we're using the name parameters.

2241
01:38:03,160 --> 01:38:06,030
Now, of course I would
wanna say age like this

2242
01:38:06,030 --> 01:38:10,810
and fave color, so we can
actually render the stuff

2243
01:38:10,810 --> 01:38:11,643
and it would be there.

2244
01:38:11,643 --> 01:38:14,030
So if I don't provide a favorite
color, just gonna be blank,

2245
01:38:14,030 --> 01:38:16,570
if I don't provide an age, it'll be zero

2246
01:38:16,570 --> 01:38:18,120
and I've kind of cleaned it up.

2247
01:38:19,029 --> 01:38:21,309
And I still have this function
overload options here,

2248
01:38:21,309 --> 01:38:23,020
which I can say, print, user info.

2249
01:38:23,020 --> 01:38:24,740
And then it's gonna give me the option of,

2250
01:38:24,740 --> 01:38:26,440
hey, don't use any default values.

2251
01:38:27,540 --> 01:38:30,400
And that's how you can
overload a function in Kotlin.

2252
01:38:30,400 --> 01:38:34,690
In Kotlin, you can create a
class by using the class keyword

2253
01:38:34,690 --> 01:38:36,930
and give it a name such as user

2254
01:38:36,930 --> 01:38:39,420
we'll do open and close parentheses.

2255
01:38:39,420 --> 01:38:41,620
Now, if you're not familiar
with what a class is,

2256
01:38:41,620 --> 01:38:44,283
a class is a reusable templates.

2257
01:38:44,283 --> 01:38:45,880
So we could actually have
various different variables here.

2258
01:38:45,880 --> 01:38:49,180
So I say variable user equals user,

2259
01:38:49,180 --> 01:38:50,400
and then I could have another one.

2260
01:38:50,400 --> 01:38:54,910
So var friend equals user,

2261
01:38:56,032 --> 01:38:58,305
and there's another own
different instances.

2262
01:38:58,305 --> 01:39:02,730
So friend is a user and
this user object is a user.

2263
01:39:02,730 --> 01:39:06,010
They're two different
instances stored in memory.

2264
01:39:06,010 --> 01:39:10,010
Now this class, this template
per se is not doing anything,

2265
01:39:10,010 --> 01:39:12,190
it doesn't do anything for us right now.

2266
01:39:12,190 --> 01:39:14,640
So what we can do is actually define

2267
01:39:14,640 --> 01:39:15,610
a couple of fields here.

2268
01:39:15,610 --> 01:39:17,700
So we'll say a couple properties.

2269
01:39:17,700 --> 01:39:20,930
We'll say field, call this one first name

2270
01:39:20,930 --> 01:39:22,740
and this one's gonna be a
string, we'll just initialize it

2271
01:39:22,740 --> 01:39:25,550
to an empty string, var last name.

2272
01:39:26,860 --> 01:39:29,509
And we'll go ahead and
initialize this one as well

2273
01:39:29,509 --> 01:39:32,880
to empty string, and now we
have first name and last name.

2274
01:39:32,880 --> 01:39:35,606
So if on the user I
would like to set that,

2275
01:39:35,606 --> 01:39:37,750
I can say user dot and that
will allow me to access

2276
01:39:37,750 --> 01:39:39,930
the two properties last
name and first name.

2277
01:39:39,930 --> 01:39:44,370
So I'll set the first name
to Donn and user.last name

2278
01:39:44,370 --> 01:39:45,203
to Felker.

2279
01:39:47,077 --> 01:39:47,910
Now let's say we have another user.

2280
01:39:47,910 --> 01:39:49,660
Let's say it's friend, of course,

2281
01:39:50,846 --> 01:39:52,290
this one also has a first and last name.

2282
01:39:52,290 --> 01:39:54,140
We'll set the first name here to Jane

2283
01:39:55,242 --> 01:39:58,960
and the friend.last name equal to Doe.

2284
01:39:58,960 --> 01:40:00,430
So we have two different instances.

2285
01:40:00,430 --> 01:40:02,440
Just because I've set
the last name Doe here

2286
01:40:02,440 --> 01:40:03,570
does not mean it overwrites here.

2287
01:40:03,570 --> 01:40:05,750
These are two different things in memory.

2288
01:40:05,750 --> 01:40:08,802
Now class again, it's kind of a template.

2289
01:40:08,802 --> 01:40:11,100
So you can actually, it can
provide functionality as well.

2290
01:40:11,100 --> 01:40:12,870
So we can actually put functions
inside of this user class

2291
01:40:12,870 --> 01:40:16,150
that are scoped to the user class.

2292
01:40:16,150 --> 01:40:19,010
So what I might wanna
say is print full name,

2293
01:40:19,888 --> 01:40:22,060
and then we'll just be a regular function

2294
01:40:22,060 --> 01:40:25,900
and it's not gonna do anything,
but it will print line

2295
01:40:25,900 --> 01:40:28,830
to the screen and or to the output,

2296
01:40:28,830 --> 01:40:32,590
which would be the first
name and the last name.

2297
01:40:32,590 --> 01:40:35,040
We can have another one in here that says

2298
01:40:35,040 --> 01:40:39,400
print with a prefix, which
then would maybe taken a prefix

2299
01:40:39,400 --> 01:40:40,530
of some sort.

2300
01:40:40,530 --> 01:40:41,860
And we could just call that prefix

2301
01:40:41,860 --> 01:40:43,785
and that would be a string.

2302
01:40:43,785 --> 01:40:45,710
And then when we call this function,

2303
01:40:45,710 --> 01:40:47,460
we can do the same thing here.

2304
01:40:47,460 --> 01:40:50,120
We could just say prefix

2305
01:40:50,120 --> 01:40:52,170
and then you have perhaps a last name.

2306
01:40:53,020 --> 01:40:56,130
Now, the way we would use this is up here.

2307
01:40:56,130 --> 01:40:58,990
We might just call user.print full name.

2308
01:41:00,360 --> 01:41:02,520
And if we go down here and do
the same thing with friend,

2309
01:41:03,831 --> 01:41:05,540
friend.print full name,

2310
01:41:05,540 --> 01:41:08,340
we'll actually see two
different pieces of output.

2311
01:41:08,340 --> 01:41:10,457
So let's run this real quick
and what's gonna happen

2312
01:41:10,457 --> 01:41:12,120
is we'll have two things
printed to the screen.

2313
01:41:12,120 --> 01:41:15,810
One is Donn Felker and that's
called by the print full name

2314
01:41:15,810 --> 01:41:17,060
function here.

2315
01:41:17,060 --> 01:41:19,260
The next one is Jane Doe and that's called

2316
01:41:19,260 --> 01:41:21,480
from the print full name
function as well here.

2317
01:41:21,480 --> 01:41:24,340
Again, there are two different instances.

2318
01:41:24,340 --> 01:41:26,860
The contents of the objects,
which are basically instances

2319
01:41:26,860 --> 01:41:29,620
of the class are being
printed to the screen

2320
01:41:29,620 --> 01:41:30,950
with the print line function.

2321
01:41:30,950 --> 01:41:33,800
Now we do have the prefix, so
we'll get to that in a second,

2322
01:41:33,800 --> 01:41:36,090
but let's also do
something different here.

2323
01:41:36,090 --> 01:41:40,940
So let's say we have a
function called update name

2324
01:41:40,940 --> 01:41:45,120
and this update name takes in
a new name and it's a string.

2325
01:41:45,120 --> 01:41:47,470
And what this is going
to do is actually update

2326
01:41:47,470 --> 01:41:48,720
their first name.

2327
01:41:48,720 --> 01:41:52,710
And so we'll say first name
and we're set to new name.

2328
01:41:52,710 --> 01:41:55,210
And then what we'll have here
is a way to update their name.

2329
01:41:55,210 --> 01:41:57,030
So let's come back up here and say,

2330
01:41:57,030 --> 01:41:59,550
you know what, maybe I messed
up when I update their name

2331
01:41:59,550 --> 01:42:02,300
and this is hypothetical and
what I call this one, Bob.

2332
01:42:03,569 --> 01:42:06,790
And then at the same time, I'd
like to user.print full name.

2333
01:42:06,790 --> 01:42:07,730
And so if we run this again,

2334
01:42:07,730 --> 01:42:11,400
what we'll see here is that the
first object is Donn Felker,

2335
01:42:11,400 --> 01:42:15,170
then we update the called
the update name function,

2336
01:42:15,170 --> 01:42:18,280
which goes down here, sets
the name to the new name.

2337
01:42:19,220 --> 01:42:22,080
And then we call print full
name again that says Bob Belker.

2338
01:42:22,080 --> 01:42:24,350
And then we go into the next user

2339
01:42:24,350 --> 01:42:27,310
and this following the line,
sequentially procedurally,

2340
01:42:28,350 --> 01:42:30,450
we see Jane Doe here.

2341
01:42:30,450 --> 01:42:34,510
Now the same thing we can do
say user.print with prefix.

2342
01:42:34,510 --> 01:42:36,520
And maybe I'll say Mr.

2343
01:42:36,520 --> 01:42:38,200
And then in this one, I might actually say

2344
01:42:38,200 --> 01:42:41,850
friend.print with prefix,
and this one might be Ms.

2345
01:42:42,990 --> 01:42:45,510
And if we were to run this
now, what we're going to see

2346
01:42:45,510 --> 01:42:47,200
is of course, Donn Felker, Bob Felker,

2347
01:42:47,200 --> 01:42:51,270
and it will say Mr. Felker,
and then we'll see Jane Doe

2348
01:42:51,270 --> 01:42:54,990
in Ms. Doe here, because
we're actually just printing

2349
01:42:54,990 --> 01:42:55,860
with the values in here.

2350
01:42:55,860 --> 01:43:00,280
So now this class is basically
a template that we can use

2351
01:43:00,280 --> 01:43:01,150
inside of our application.

2352
01:43:01,150 --> 01:43:04,330
Now everything is stored
inside the same file here.

2353
01:43:04,330 --> 01:43:06,490
Now, what you can do is
you don't have to have this

2354
01:43:06,490 --> 01:43:07,560
in the same file at all.

2355
01:43:07,560 --> 01:43:09,480
So what we can do is I'm
gonna open up the project,

2356
01:43:09,480 --> 01:43:12,210
went over here and you see
we just have our main file.

2357
01:43:12,210 --> 01:43:14,900
What we can actually do
is create a file manually,

2358
01:43:16,280 --> 01:43:20,090
like say new Kotlin
and I can say, user.kt.

2359
01:43:22,498 --> 01:43:23,540
And then what I can do
is I can go over here

2360
01:43:23,540 --> 01:43:27,940
and I can cut and paste
this code into user.kt.

2361
01:43:30,154 --> 01:43:31,570
If we go back to the
main, you're gonna see

2362
01:43:31,570 --> 01:43:32,750
that everything still works

2363
01:43:32,750 --> 01:43:34,890
because we're in the same package.

2364
01:43:34,890 --> 01:43:38,210
So it knows that it's going
to look in the same package

2365
01:43:38,210 --> 01:43:39,480
and it found the user class.

2366
01:43:39,480 --> 01:43:42,270
Now this allows us to start
cleaning up the code a lot

2367
01:43:42,270 --> 01:43:46,040
because basically have a template
called the user class here

2368
01:43:46,040 --> 01:43:47,480
in a different file to do that for me.

2369
01:43:47,480 --> 01:43:50,010
Now, what I'm gonna do,
actually, I'm gonna undo this.

2370
01:43:50,010 --> 01:43:54,290
I'm gonna go back to main here,
I'm gonna undo this as well

2371
01:43:54,290 --> 01:43:58,150
and come here and get
rid of that Kotlin class.

2372
01:43:58,150 --> 01:43:59,820
So we're gonna go back
to how we were before.

2373
01:43:59,820 --> 01:44:02,660
There's actually a
shortcut that you can use.

2374
01:44:02,660 --> 01:44:06,079
When you put your cursor over
class, the class name here,

2375
01:44:06,079 --> 01:44:07,180
you'll see this little bulb.

2376
01:44:07,180 --> 01:44:09,600
You can click on it and
you can say, create test,

2377
01:44:09,600 --> 01:44:12,850
rename the file or you say
move user to a separate file.

2378
01:44:12,850 --> 01:44:14,300
Say, yeah, I'd like to do that.

2379
01:44:15,617 --> 01:44:17,260
So right out of the box,
by default, we were given

2380
01:44:17,260 --> 01:44:20,507
this nice little thing that
allows us to create a file.

2381
01:44:20,507 --> 01:44:22,400
And what that did is it
created the file force

2382
01:44:22,400 --> 01:44:24,570
and moved all the contents
of that user class

2383
01:44:24,570 --> 01:44:25,470
over there for us.

2384
01:44:27,280 --> 01:44:28,113
So let's go a little bit further here

2385
01:44:28,113 --> 01:44:29,710
and make one more method.

2386
01:44:29,710 --> 01:44:33,070
And this method might print
the length of the first names.

2387
01:44:33,070 --> 01:44:36,470
We say, function, first name length.

2388
01:44:38,140 --> 01:44:40,637
And what we'll do is we're
gonna print something

2389
01:44:40,637 --> 01:44:42,610
to the screen and then
what we're gonna do here

2390
01:44:42,610 --> 01:44:46,780
is just take the first name
as the first name.length.

2391
01:44:50,428 --> 01:44:51,330
And that's gonna print the
length of the first name.

2392
01:44:51,330 --> 01:44:54,522
So if we, again, this is
kind of like a template.

2393
01:44:54,522 --> 01:44:55,355
It's a class.

2394
01:44:55,355 --> 01:44:57,010
Go back to main Katie and
let's print the length

2395
01:44:57,010 --> 01:44:59,605
of the friend's first name.

2396
01:44:59,605 --> 01:45:04,605
Friend.print, excuse me,
length, first name length.

2397
01:45:04,990 --> 01:45:06,483
There we go.

2398
01:45:06,483 --> 01:45:09,890
And if we run this now,
Kotlin will find a user class

2399
01:45:09,890 --> 01:45:13,320
included here for so we're
running what that user class,

2400
01:45:13,320 --> 01:45:16,017
run the existing code,
which we've seen already,

2401
01:45:16,017 --> 01:45:17,140
Mr. Felker, Bob Felker, et cetera.

2402
01:45:18,292 --> 01:45:19,890
And then we're gonna call the
friend up first name length,

2403
01:45:19,890 --> 01:45:23,170
and it's going to return four
because that's the number

2404
01:45:23,170 --> 01:45:26,145
of characters in the
first name, which is Jane.

2405
01:45:26,145 --> 01:45:27,170
So this is a very simple class,

2406
01:45:27,170 --> 01:45:30,300
but this is how you can
create a class here in Kotlin.

2407
01:45:31,340 --> 01:45:33,440
Let's assume that I
have a class called user

2408
01:45:33,440 --> 01:45:35,910
with first and last name
and a couple of functions

2409
01:45:35,910 --> 01:45:36,840
inside of it.

2410
01:45:36,840 --> 01:45:38,360
If I'd like to use a constructor,

2411
01:45:38,360 --> 01:45:42,190
what I can actually do is
use the keyword constructor.

2412
01:45:42,190 --> 01:45:44,350
Now I can actually bring these properties

2413
01:45:44,350 --> 01:45:45,590
into the constructor.

2414
01:45:45,590 --> 01:45:48,860
So let's actually get rid of
these and actually actually say

2415
01:45:48,860 --> 01:45:53,860
first name and I can say, this
is a string and last name.

2416
01:45:54,410 --> 01:45:55,260
This is a string.

2417
01:45:57,164 --> 01:45:59,350
Now, usually you wanna
default everything to vals

2418
01:45:59,350 --> 01:46:01,570
because it's going to
help you with immutability

2419
01:46:01,570 --> 01:46:03,710
and help you not make as many mistakes.

2420
01:46:03,710 --> 01:46:05,350
But we can try that here,

2421
01:46:05,350 --> 01:46:08,175
but we noticed that there's
actually a problem here.

2422
01:46:08,175 --> 01:46:10,372
So we have the update name method,

2423
01:46:10,372 --> 01:46:11,870
actually updates the first name.

2424
01:46:11,870 --> 01:46:13,986
And if it's a val, we can't do that.

2425
01:46:13,986 --> 01:46:15,209
So let's just change these to vars.

2426
01:46:15,209 --> 01:46:16,990
so the properties that can be mutated,

2427
01:46:16,990 --> 01:46:18,480
which means they can be changed.

2428
01:46:18,480 --> 01:46:21,720
So now we have a constructor
for our user class,

2429
01:46:21,720 --> 01:46:23,140
which takes in the first
name and last name.

2430
01:46:23,140 --> 01:46:25,920
And if we go back to our main
file, we're actually using it.

2431
01:46:25,920 --> 01:46:27,980
You can actually see a
couple of things here.

2432
01:46:27,980 --> 01:46:31,370
First we have in the user class,

2433
01:46:31,370 --> 01:46:33,630
you can actually see when we type user,

2434
01:46:33,630 --> 01:46:35,740
open and close parentheses.

2435
01:46:35,740 --> 01:46:39,630
We have a string for first
name and a last name as well.

2436
01:46:39,630 --> 01:46:42,900
So we put Donn and Felker.

2437
01:46:45,133 --> 01:46:45,966
Now, if I would like to rewrite these,

2438
01:46:45,966 --> 01:46:47,880
I could easily do that with
this property right here

2439
01:46:47,880 --> 01:46:50,730
on line six and seven, I can change these

2440
01:46:50,730 --> 01:46:55,450
to perhaps it should
have been Jason Smith.

2441
01:46:55,450 --> 01:46:58,320
I can reset those here so
I can actually change those

2442
01:46:58,320 --> 01:46:59,460
or I can actually just get rid of them

2443
01:46:59,460 --> 01:47:01,000
'cause I don't need them anymore.

2444
01:47:01,000 --> 01:47:06,000
And then here I'd actually
do Jane changes to Doe,

2445
01:47:08,816 --> 01:47:09,660
I can get rid of the
property setting here.

2446
01:47:09,660 --> 01:47:11,420
And if I to run this again, you'll notice

2447
01:47:11,420 --> 01:47:14,586
that we're gonna get the same
result that we got before,

2448
01:47:14,586 --> 01:47:19,586
this time we've just used a
constructor with the parameters

2449
01:47:21,090 --> 01:47:21,923
and properties inside of here.

2450
01:47:21,923 --> 01:47:24,030
So these parameters are
turned into properties,

2451
01:47:24,939 --> 01:47:26,870
which you can use inside of your class.

2452
01:47:26,870 --> 01:47:28,370
So you can see that down here.

2453
01:47:29,995 --> 01:47:31,730
Now you can also, as you
can probably imagine,

2454
01:47:31,730 --> 01:47:34,859
put your cursor here and
you can add the names

2455
01:47:34,859 --> 01:47:35,692
to the call arguments.

2456
01:47:35,692 --> 01:47:37,740
So you can actually see that
that's actually the first name

2457
01:47:37,740 --> 01:47:39,820
and that's actually the last name.

2458
01:47:39,820 --> 01:47:41,410
So you can actually see
what these values are

2459
01:47:41,410 --> 01:47:43,080
as you parse them in.

2460
01:47:43,080 --> 01:47:46,700
Furthermore, in the user
class, if the constructor

2461
01:47:46,700 --> 01:47:49,280
does not have any modifiers on it,

2462
01:47:50,393 --> 01:47:53,093
such as the internal keyword,
which we'll cover later,

2463
01:47:54,140 --> 01:47:55,900
you can actually, so if it doesn't have

2464
01:47:55,900 --> 01:47:59,980
any of these annotations or modifiers,

2465
01:47:59,980 --> 01:48:02,535
you can actually get rid
of the constructor word

2466
01:48:02,535 --> 01:48:03,368
and this will be the primary constructor.

2467
01:48:03,368 --> 01:48:05,630
So now we've actually cleaned
up the code a little bit more.

2468
01:48:05,630 --> 01:48:06,500
We have the user class,

2469
01:48:06,500 --> 01:48:08,830
which takes in a first
name and a last name.

2470
01:48:09,890 --> 01:48:12,340
So we can see, I hear to
a first name, last name

2471
01:48:12,340 --> 01:48:13,680
works just fine.

2472
01:48:13,680 --> 01:48:16,590
We don't have to have the
constructor keyword on there

2473
01:48:16,590 --> 01:48:17,950
though if you could still
use if you'd like to,

2474
01:48:17,950 --> 01:48:20,890
but it's very common if you
have a primary constructor

2475
01:48:20,890 --> 01:48:24,170
and that's it, you just
remove the constructor word.

2476
01:48:24,170 --> 01:48:26,540
Now, if you wanted to have perhaps this

2477
01:48:26,540 --> 01:48:29,720
to only be for internal and
you wanna have constructor,

2478
01:48:29,720 --> 01:48:32,389
and you tried to get rid
of the constructor word,

2479
01:48:32,389 --> 01:48:34,030
you would see that this
is not going to work,

2480
01:48:34,030 --> 01:48:36,120
use constructor keyword
after any modifiers

2481
01:48:36,120 --> 01:48:37,250
of a primary constructor.

2482
01:48:37,250 --> 01:48:39,460
So we need to put constructor
here if we were to restrict

2483
01:48:39,460 --> 01:48:43,610
the visibility of the
user classes constructor.

2484
01:48:43,610 --> 01:48:45,255
But we're not doing that here.

2485
01:48:45,255 --> 01:48:47,500
So this is a basic class
with a primary constructor.

2486
01:48:47,500 --> 01:48:48,940
One of the additional things you can do

2487
01:48:48,940 --> 01:48:51,280
instead of a constructor
is also set default value.

2488
01:48:51,280 --> 01:48:54,610
So we could set this to be a blank string.

2489
01:48:54,610 --> 01:48:56,370
And perhaps we knew we were
always gonna be working

2490
01:48:56,370 --> 01:48:58,130
with the Smith family for whatever reason,

2491
01:48:58,130 --> 01:48:59,920
we could just say this is Smith.

2492
01:48:59,920 --> 01:49:02,790
And so if I'd like to back
inside of our main file,

2493
01:49:02,790 --> 01:49:04,410
I can actually get rid of the last name.

2494
01:49:04,410 --> 01:49:06,320
If I didn't want that there
fall into override a here

2495
01:49:06,320 --> 01:49:07,310
to be Doe, I could do that.

2496
01:49:07,310 --> 01:49:10,760
And so now this is just gonna
say Donn Smith and Mr. Smith

2497
01:49:10,760 --> 01:49:12,810
and Jane Doe and Ms. Doe,

2498
01:49:12,810 --> 01:49:15,180
because we're using the default values

2499
01:49:15,180 --> 01:49:18,020
inside of this primary constructor.

2500
01:49:18,020 --> 01:49:20,500
Class can have more than one constructor.

2501
01:49:20,500 --> 01:49:22,900
This is a primary constructor up top here.

2502
01:49:22,900 --> 01:49:24,650
We can also have a secondary constructor.

2503
01:49:24,650 --> 01:49:25,950
To create a secondary constructor,

2504
01:49:25,950 --> 01:49:27,980
you can use the constructor keyword,

2505
01:49:27,980 --> 01:49:30,752
and then you wanna parse
in some additional values.

2506
01:49:30,752 --> 01:49:31,585
But first let's get that set up.

2507
01:49:31,585 --> 01:49:35,240
Let's assume that this user
can be of a particular type.

2508
01:49:35,240 --> 01:49:39,860
And so we'll say is platinum
and be perhaps a platinum user

2509
01:49:39,860 --> 01:49:41,620
for a particular,

2510
01:49:41,620 --> 01:49:44,960
you could say it's a
financial institution.

2511
01:49:44,960 --> 01:49:48,120
And so we wanna create
another constructor.

2512
01:49:48,120 --> 01:49:49,830
So sometimes we wanna be able to provide,

2513
01:49:49,830 --> 01:49:53,060
instead of the first
name and the last name,

2514
01:49:53,060 --> 01:49:54,740
we already know by default,
they're not platinum.

2515
01:49:54,740 --> 01:49:58,900
So what we can do is we can
call this constructor here.

2516
01:49:58,900 --> 01:50:02,930
Now this constructor will
take the first and last name,

2517
01:50:02,930 --> 01:50:03,770
but then what we need to do

2518
01:50:03,770 --> 01:50:06,200
is call into the original version.

2519
01:50:06,200 --> 01:50:08,926
So we're say the first
name of parse it in.

2520
01:50:08,926 --> 01:50:11,199
So this first name value
is coming from here.

2521
01:50:11,199 --> 01:50:12,920
And then the last name and
they'll say is platinum,

2522
01:50:12,920 --> 01:50:14,640
we're gonna say false.

2523
01:50:14,640 --> 01:50:16,590
Now, we can to see here
is we no longer have

2524
01:50:16,590 --> 01:50:17,423
any red squigglies.

2525
01:50:17,423 --> 01:50:20,310
What this means is I can
use this new constructor.

2526
01:50:20,310 --> 01:50:23,390
Now I don't have to provide
a body for this here.

2527
01:50:23,390 --> 01:50:25,360
But if I would like to, I
can also provide a body,

2528
01:50:25,360 --> 01:50:26,590
may be able to do something in here.

2529
01:50:26,590 --> 01:50:30,120
Like print line you could say is platinum

2530
01:50:32,270 --> 01:50:33,870
is false by default.

2531
01:50:34,951 --> 01:50:36,890
So if I use this one, if
I use this constructor,

2532
01:50:36,890 --> 01:50:38,040
this line of code will get run.

2533
01:50:38,040 --> 01:50:39,998
So let's go back to our example

2534
01:50:39,998 --> 01:50:42,560
and let's change this one here.

2535
01:50:42,560 --> 01:50:45,960
So by default, both of
these are going to call

2536
01:50:45,960 --> 01:50:48,210
into this here.

2537
01:50:48,210 --> 01:50:50,130
Now, of course we have
not provided a last name,

2538
01:50:50,130 --> 01:50:51,780
so let's provide a last name here

2539
01:50:53,193 --> 01:50:54,660
and that's going to be Felker.

2540
01:50:54,660 --> 01:50:57,160
And then it'll say, it's platinum is true.

2541
01:50:57,160 --> 01:50:59,290
Now I'm a platinum user,
but in this user down here

2542
01:50:59,290 --> 01:51:00,160
is not a platinum user.

2543
01:51:00,160 --> 01:51:04,300
So now if we were to run this
on the second call down here,

2544
01:51:04,300 --> 01:51:09,300
we're gonna see is platinum
is false by default.

2545
01:51:09,590 --> 01:51:11,250
That's because when we go here,

2546
01:51:12,314 --> 01:51:13,147
I'll go to the implementation,

2547
01:51:13,147 --> 01:51:14,890
it's using the secondary constructor.

2548
01:51:14,890 --> 01:51:17,451
Now we can even go even further and say,

2549
01:51:17,451 --> 01:51:18,284
if we want another constructor,

2550
01:51:18,284 --> 01:51:20,180
so multiple constructors
who can keep going to here.

2551
01:51:20,180 --> 01:51:21,480
So I might say first name,

2552
01:51:22,845 --> 01:51:23,678
and then might just skip that and say,

2553
01:51:23,678 --> 01:51:25,941
all right, this which
means, hey, call another one

2554
01:51:25,941 --> 01:51:26,774
of these instructors.

2555
01:51:26,774 --> 01:51:29,430
And this one is going to call
in first name and this time,

2556
01:51:29,430 --> 01:51:31,920
I don't know what the
last name is going to do.

2557
01:51:31,920 --> 01:51:36,160
So I'm gonna call and perhaps I'll watch.

2558
01:51:36,160 --> 01:51:39,068
Just for completion sake, we'll say hey

2559
01:51:39,068 --> 01:51:41,450
in the third constructor.

2560
01:51:42,460 --> 01:51:46,244
And if I go back to the
screen here and let's go ahead

2561
01:51:46,244 --> 01:51:49,220
and create another one, var
we say it's your cousin,

2562
01:51:49,220 --> 01:51:53,060
and I'll say to user, it
we'll say, first name is Nick.

2563
01:51:55,840 --> 01:51:58,060
And then we'll say, we're
not gonna do anything here

2564
01:51:58,060 --> 01:52:00,140
because if we look at this implementation,

2565
01:52:00,140 --> 01:52:02,140
it's using the third constructor here,

2566
01:52:02,140 --> 01:52:04,830
which is gonna say, hey, I'm
in the third constructor,

2567
01:52:04,830 --> 01:52:07,880
but look, something
else is going to happen.

2568
01:52:07,880 --> 01:52:11,730
And what's gonna happen is
when this third is called,

2569
01:52:11,730 --> 01:52:13,740
the word Nick's gonna put
it into the first name

2570
01:52:13,740 --> 01:52:15,130
and then it's gonna call into this.

2571
01:52:15,130 --> 01:52:18,150
It's gonna parse this
first name value into this.

2572
01:52:18,150 --> 01:52:20,960
And it's gonna give an unknown last name.

2573
01:52:20,960 --> 01:52:23,480
Now this is actually gonna
call this constructor,

2574
01:52:24,790 --> 01:52:27,540
which is going to say, boom,
all right, now it's unknown.

2575
01:52:27,540 --> 01:52:30,080
And then it's going to print
as platinum by default.

2576
01:52:30,080 --> 01:52:31,340
So let's actually see that run.

2577
01:52:31,340 --> 01:52:34,120
And then all the values
of course are then parse d

2578
01:52:34,120 --> 01:52:35,670
into the root constructor here,

2579
01:52:37,402 --> 01:52:38,534
and then we can actually see everything.

2580
01:52:38,534 --> 01:52:39,840
So if we run this now, what you'll notice

2581
01:52:39,840 --> 01:52:42,290
is something interesting
is going to happen here.

2582
01:52:43,320 --> 01:52:45,336
Now there's a lot of stuff going on here.

2583
01:52:45,336 --> 01:52:46,169
So let's this up a bit.

2584
01:52:46,169 --> 01:52:47,925
So let's go ahead and just kind of get rid

2585
01:52:47,925 --> 01:52:48,758
of all this stuff here.

2586
01:52:48,758 --> 01:52:51,070
We just wanna see when one of
the constructors is called.

2587
01:52:51,070 --> 01:52:54,500
And so we have have those
methods inside of there

2588
01:52:54,500 --> 01:52:59,060
that's going to call line when
the constructor is called.

2589
01:52:59,060 --> 01:53:01,990
So if we run it now, we'll see is platinum

2590
01:53:01,990 --> 01:53:03,230
is false by default.

2591
01:53:03,230 --> 01:53:04,350
And we see the same thing again

2592
01:53:04,350 --> 01:53:06,280
and then I'm in a third constructor.

2593
01:53:06,280 --> 01:53:08,490
So if we were to go to
this first one here,

2594
01:53:08,490 --> 01:53:10,800
this first one uses the
primary constructor.

2595
01:53:10,800 --> 01:53:12,680
Nothing happens here,
we just set up an object

2596
01:53:12,680 --> 01:53:14,040
and that's the end.

2597
01:53:14,040 --> 01:53:17,710
The second one uses a constructor here

2598
01:53:17,710 --> 01:53:19,150
that uses the first name and the last name

2599
01:53:19,150 --> 01:53:21,400
and then defaults to
platinum field is false.

2600
01:53:22,243 --> 01:53:24,440
And it says it is platinum
is false by default.

2601
01:53:24,440 --> 01:53:27,091
Now the third one is
interesting 'cause the third one

2602
01:53:27,091 --> 01:53:28,650
will say, hey, the first name is Nick.

2603
01:53:28,650 --> 01:53:31,660
It calls into the other constructor here.

2604
01:53:31,660 --> 01:53:34,440
So it'll say the first name
was Nick, last name is unknown.

2605
01:53:34,440 --> 01:53:36,680
And then what happens is
this construct will call

2606
01:53:36,680 --> 01:53:38,120
into the root constructor.

2607
01:53:38,120 --> 01:53:41,870
So it's gonna go this
executes first, this line

2608
01:53:41,870 --> 01:53:43,720
then this line is gonna execute,

2609
01:53:43,720 --> 01:53:46,900
which calls in up to
the primary instructor.

2610
01:53:46,900 --> 01:53:51,170
After that is complete,
which is this line here,

2611
01:53:51,170 --> 01:53:54,130
which calls the primary
constructor up here,

2612
01:53:54,130 --> 01:53:56,580
then it will procedurally call this one.

2613
01:53:56,580 --> 01:53:59,950
And then now that this
whole method is done running

2614
01:53:59,950 --> 01:54:03,780
which is right here,
then it will run this.

2615
01:54:03,780 --> 01:54:07,520
So what we're seeing here is
this is being called first

2616
01:54:07,520 --> 01:54:11,240
because again, this gets
called, which goes into here,

2617
01:54:11,240 --> 01:54:14,070
nothing happens up here, that's complete.

2618
01:54:14,070 --> 01:54:17,040
Then it runs this whatever's
in this constructor,

2619
01:54:17,920 --> 01:54:19,170
which is this call here.

2620
01:54:19,170 --> 01:54:20,420
It says, okay, that's done now.

2621
01:54:20,420 --> 01:54:23,060
Now run finally what's
in your constructor.

2622
01:54:23,060 --> 01:54:23,893
And so these three things are happening.

2623
01:54:23,893 --> 01:54:26,190
So if we really wanna make
it simple, let's go ahead

2624
01:54:26,190 --> 01:54:31,190
and say so third, just to
really make it kind of obvious,

2625
01:54:31,340 --> 01:54:32,910
second and there we go.

2626
01:54:34,047 --> 01:54:35,950
I'm gonna go back back and
we're going to just comment out

2627
01:54:35,950 --> 01:54:37,400
this one.

2628
01:54:37,400 --> 01:54:40,575
And what that'll do is we're
just gonna run this one here

2629
01:54:40,575 --> 01:54:41,980
and we see second then third.

2630
01:54:41,980 --> 01:54:43,750
So first thing that happened
is it printed second

2631
01:54:43,750 --> 01:54:45,230
because it hit this constructor first

2632
01:54:45,230 --> 01:54:47,790
from kind of walking this call chain

2633
01:54:47,790 --> 01:54:48,850
and then it went to the third one.

2634
01:54:48,850 --> 01:54:50,110
Now we could actually get around this here

2635
01:54:50,110 --> 01:54:53,155
and say, hey, this one
here is, we'll just say

2636
01:54:53,155 --> 01:54:55,220
is platinum is false.

2637
01:54:55,220 --> 01:54:57,434
And we could even say true if we want,

2638
01:54:57,434 --> 01:54:59,460
it doesn't really matter, but
let's just leave it false,

2639
01:54:59,460 --> 01:55:00,750
let's do a true actually.

2640
01:55:00,750 --> 01:55:03,070
So if we call this and
we parse in a first name

2641
01:55:03,070 --> 01:55:05,590
or you an unknown last name
and they're a platinum user.

2642
01:55:05,590 --> 01:55:08,470
Now when we run this,
you're just gonna see third

2643
01:55:08,470 --> 01:55:10,640
being printed to the screen
because it's only calling

2644
01:55:10,640 --> 01:55:13,370
the third instructor 'cause by default,

2645
01:55:13,370 --> 01:55:16,270
what happens is this
construct will be instantiated

2646
01:55:16,270 --> 01:55:18,939
in turn it takes its first name value

2647
01:55:18,939 --> 01:55:20,070
and calls the primary constructor.

2648
01:55:20,070 --> 01:55:21,780
So this are here's the primary constructor

2649
01:55:21,780 --> 01:55:24,120
because it has three parameters.

2650
01:55:24,120 --> 01:55:27,040
If we then took this one out, last one,

2651
01:55:27,040 --> 01:55:28,990
it's now going to call
the second constructor.

2652
01:55:28,990 --> 01:55:32,270
So let's assume this wasn't
here, so let's comment it out.

2653
01:55:32,270 --> 01:55:33,370
That's not going to run.

2654
01:55:33,370 --> 01:55:35,320
Now, you'll see that we
don't have a constructor

2655
01:55:35,320 --> 01:55:37,100
that matches the signature,

2656
01:55:37,100 --> 01:55:40,610
which is a string and another string.

2657
01:55:40,610 --> 01:55:43,390
We have a constructor with
two strings and a Boolean.

2658
01:55:43,390 --> 01:55:47,786
So that's why we're seeing
multiple different versions here.

2659
01:55:47,786 --> 01:55:50,230
And again, if we can come
in here this time we run it,

2660
01:55:50,230 --> 01:55:52,540
we're gonna see second and then third.

2661
01:55:53,950 --> 01:55:56,720
Now you can have multiple
different constructors

2662
01:55:56,720 --> 01:55:57,553
inside of here.

2663
01:55:57,553 --> 01:56:01,280
So you can keep creating
different types of constructors.

2664
01:56:01,280 --> 01:56:03,820
You could set them platinum, et cetera.

2665
01:56:03,820 --> 01:56:06,210
Now, of course, some of
these things may not even be

2666
01:56:06,210 --> 01:56:07,043
need to happen.

2667
01:56:07,043 --> 01:56:08,980
So we can say, hey, perhaps
we don't even need this,

2668
01:56:08,980 --> 01:56:11,270
we can use some default
parameters here as well.

2669
01:56:11,270 --> 01:56:12,810
So if the last name is not known,

2670
01:56:12,810 --> 01:56:15,730
then it should use unknown.

2671
01:56:15,730 --> 01:56:19,440
And then if it's by default,
we're gonna set this to false.

2672
01:56:20,376 --> 01:56:21,209
So now if I come back here,

2673
01:56:21,209 --> 01:56:22,980
I can still do this exact same thing.

2674
01:56:22,980 --> 01:56:25,660
Even this would work and still gonna work

2675
01:56:25,660 --> 01:56:27,570
because it's using default parameters

2676
01:56:28,450 --> 01:56:31,819
and the named arguments,
the default argument values.

2677
01:56:31,819 --> 01:56:34,460
And so then we can see
everything how it should be.

2678
01:56:34,460 --> 01:56:37,150
So each of the objects
is going to be created,

2679
01:56:37,150 --> 01:56:39,130
number is going to be
allocated, et cetera.

2680
01:56:39,985 --> 01:56:42,180
And then we kind of get
all that safety right here

2681
01:56:42,180 --> 01:56:43,920
and the various different constructors.

2682
01:56:43,920 --> 01:56:45,900
However, if you do need
different constructors

2683
01:56:45,900 --> 01:56:47,360
for whatever reason,
or you need to perform

2684
01:56:47,360 --> 01:56:49,450
some type of different values,

2685
01:56:49,450 --> 01:56:51,710
you can call it from
functions to do different,

2686
01:56:51,710 --> 01:56:54,240
run all different types of code in here

2687
01:56:54,240 --> 01:56:56,650
and run different code
in here, you can do that,

2688
01:56:56,650 --> 01:56:57,820
just provide a different constructor

2689
01:56:57,820 --> 01:56:59,810
using the constructor keyword

2690
01:56:59,810 --> 01:57:01,290
and you're off to the races.

2691
01:57:01,290 --> 01:57:03,870
Now, additionally, you can also restrict

2692
01:57:03,870 --> 01:57:08,070
some of the constructors using
modifiers, such as protected,

2693
01:57:08,070 --> 01:57:13,040
or you could call internal, et cetera.

2694
01:57:13,040 --> 01:57:14,670
So you can actually lock down who can call

2695
01:57:14,670 --> 01:57:17,560
into a constructor based upon a modifier.

2696
01:57:19,940 --> 01:57:22,400
We have a user class and
instead of a user class,

2697
01:57:22,400 --> 01:57:26,388
you can also have what are
known as initializer blocks.

2698
01:57:26,388 --> 01:57:28,517
And these initializer blocks are created

2699
01:57:28,517 --> 01:57:31,090
with the init keyword and
open and closed curly brace.

2700
01:57:31,090 --> 01:57:34,690
So this would be perhaps
somewhere where you could perform

2701
01:57:34,690 --> 01:57:38,160
some type of initialization
for your class.

2702
01:57:38,160 --> 01:57:41,570
Initializer blocks are called
after the primary constructor

2703
01:57:41,570 --> 01:57:42,403
has been invoked.

2704
01:57:42,403 --> 01:57:45,250
So again, this is the
primary constructor up here.

2705
01:57:45,250 --> 01:57:47,260
So after the primary
constructors have been invoked,

2706
01:57:47,260 --> 01:57:49,460
the initializer block will be called.

2707
01:57:49,460 --> 01:57:51,870
So something interesting that we can do

2708
01:57:51,870 --> 01:57:55,340
is we can just go back
to our main file here

2709
01:57:56,274 --> 01:57:58,310
and we'll create an
instance of our user class.

2710
01:57:58,310 --> 01:58:01,460
And we'll just say Donn
Felker here for the first

2711
01:58:01,460 --> 01:58:02,930
and the last name and we're gonna run it.

2712
01:58:02,930 --> 01:58:04,690
Now we're not putting
it into the screen here,

2713
01:58:04,690 --> 01:58:07,870
but notice how we do see
hello one is output down here

2714
01:58:07,870 --> 01:58:09,400
in the run window.

2715
01:58:09,400 --> 01:58:11,910
The reason for that is
because in the user class,

2716
01:58:11,910 --> 01:58:15,060
inside the initializer block,
I'm printing out hello one.

2717
01:58:16,190 --> 01:58:17,990
Now there's also something
interesting you can do

2718
01:58:17,990 --> 01:58:19,150
with initializer blocks.

2719
01:58:19,150 --> 01:58:21,805
Is where you can have
multiple initializer blocks

2720
01:58:21,805 --> 01:58:25,400
and this initializer
blocks will then operate

2721
01:58:25,400 --> 01:58:28,150
in the order in which they
are defined within the class.

2722
01:58:28,150 --> 01:58:31,040
So what will happen is
the primary constructor

2723
01:58:31,040 --> 01:58:33,880
will be called first and last name,

2724
01:58:33,880 --> 01:58:37,070
and then we'll get hello one
called and then hello two.

2725
01:58:37,070 --> 01:58:39,720
So if we go back and rerun this here,

2726
01:58:39,720 --> 01:58:41,230
what we're going to see
instead of hello one,

2727
01:58:41,230 --> 01:58:44,320
we'll see hello one and hello
two as we see down here.

2728
01:58:45,290 --> 01:58:48,120
If we go back to the user
class just to demonstrate this,

2729
01:58:48,120 --> 01:58:53,120
when we move this below
hello two and we rerun this,

2730
01:58:53,370 --> 01:58:55,840
what will the notice is
we'll see hello two show up

2731
01:58:55,840 --> 01:58:57,010
before hello one.

2732
01:58:58,070 --> 01:59:00,530
Now one last thing here
too, just to demonstrate

2733
01:59:00,530 --> 01:59:04,170
that the initializer and blocks are called

2734
01:59:04,170 --> 01:59:06,370
right after the primary constructor,

2735
01:59:06,370 --> 01:59:08,530
let's go ahead and create
another constructor

2736
01:59:08,530 --> 01:59:11,620
that just perhaps provides the first name,

2737
01:59:11,620 --> 01:59:15,840
which is a string and then
it's just gonna default

2738
01:59:15,840 --> 01:59:16,740
the last name for us.

2739
01:59:16,740 --> 01:59:19,710
So we're gonna call into
this parsing the first name

2740
01:59:19,710 --> 01:59:22,490
and then the last name we'll
just default to Felker here.

2741
01:59:23,762 --> 01:59:25,630
And if I go back to this here,
I'll get rid of my last name,

2742
01:59:25,630 --> 01:59:28,100
which will then use that
second constructor here,

2743
01:59:28,100 --> 01:59:29,600
which we can see here.

2744
01:59:29,600 --> 01:59:32,160
Now what's gonna happen
is we can actually provide

2745
01:59:32,160 --> 01:59:34,370
a block here so we can do something

2746
01:59:34,370 --> 01:59:35,640
after this constructor's call.

2747
01:59:35,640 --> 01:59:37,610
So let's do that here, say constructor,

2748
01:59:39,160 --> 01:59:42,720
second constructor call so we'll say here.

2749
01:59:42,720 --> 01:59:44,870
So our expected output at this time,

2750
01:59:44,870 --> 01:59:48,110
when we create a new class,
you might think would be okay,

2751
01:59:48,110 --> 01:59:51,130
we're gonna call the
second constructor called.

2752
01:59:51,130 --> 01:59:54,670
And then of course it's going
to be the primary constructor

2753
01:59:54,670 --> 01:59:57,850
and then we'll get basically
hello one, hello two

2754
01:59:57,850 --> 02:00:00,219
because that's the order to show up in.

2755
02:00:00,219 --> 02:00:02,360
However, what you'll
notice if we run this,

2756
02:00:02,360 --> 02:00:03,250
that's not the case.

2757
02:00:03,250 --> 02:00:05,260
And as you can see here, it's
actually a little backwards.

2758
02:00:05,260 --> 02:00:06,890
We have hello one, hello two,

2759
02:00:06,890 --> 02:00:09,110
and then second constructor called.

2760
02:00:09,110 --> 02:00:10,520
So it seems kind of backwards.

2761
02:00:10,520 --> 02:00:14,330
But when you think about the
execution of the actual class,

2762
02:00:15,360 --> 02:00:17,290
this here is called immediately.

2763
02:00:17,290 --> 02:00:19,000
So as soon as this constructor is called,

2764
02:00:19,000 --> 02:00:20,710
immediately those values are parse d

2765
02:00:20,710 --> 02:00:22,740
into the primary constructor.

2766
02:00:22,740 --> 02:00:25,210
And then after the primary
constructor is called,

2767
02:00:25,210 --> 02:00:27,220
the initializer blocks are then called.

2768
02:00:27,220 --> 02:00:30,640
After those are called,
then execution will return

2769
02:00:30,640 --> 02:00:34,340
to inside of whatever
constructor you're in,

2770
02:00:34,340 --> 02:00:37,470
which is the second one
here into that block there

2771
02:00:37,470 --> 02:00:40,500
and you'll execute that,
which is why we see hello one,

2772
02:00:40,500 --> 02:00:44,470
hello two and then finally the
second constructor is called.

2773
02:00:44,470 --> 02:00:46,690
Now you can use the
initializer blocks to perform

2774
02:00:46,690 --> 02:00:49,369
some type of initialization
for your class,

2775
02:00:49,369 --> 02:00:50,930
perhaps some basic setup of the class

2776
02:00:50,930 --> 02:00:54,260
and initialization type
of tasks are a great place

2777
02:00:54,260 --> 02:00:55,860
to put it inside the init block.

2778
02:00:58,220 --> 02:01:01,240
In classes, you can also
create properties in line here.

2779
02:01:01,240 --> 02:01:03,970
So I will type a property
called full name,

2780
02:01:03,970 --> 02:01:07,090
and then I can initialize
it with the values

2781
02:01:07,090 --> 02:01:09,800
that are being provided to
me through the constructor.

2782
02:01:09,800 --> 02:01:11,580
So we can use the first name property,

2783
02:01:11,580 --> 02:01:14,040
and I can use the last name property

2784
02:01:14,040 --> 02:01:15,770
to create a full name here.

2785
02:01:15,770 --> 02:01:17,430
Now, if I go back to the main class

2786
02:01:17,430 --> 02:01:19,100
and I decide I would like to print that,

2787
02:01:19,100 --> 02:01:22,710
I could say print ln and
would say user.full name,

2788
02:01:22,710 --> 02:01:24,380
and you see that I have access here too

2789
02:01:24,380 --> 02:01:27,810
because it's in the same
package and so I have access.

2790
02:01:27,810 --> 02:01:30,090
If I were to run this, we would just see

2791
02:01:30,090 --> 02:01:31,600
that Donn Felker is printed.

2792
02:01:32,803 --> 02:01:34,900
Now you also see that
we have an init block

2793
02:01:34,900 --> 02:01:37,430
that's been printed is here as well.

2794
02:01:37,430 --> 02:01:38,500
So we have init blocks.

2795
02:01:38,500 --> 02:01:41,410
And one of the nice too is we can also,

2796
02:01:41,410 --> 02:01:43,210
if let's go back to the main class,

2797
02:01:44,164 --> 02:01:44,997
we can also change this value.

2798
02:01:44,997 --> 02:01:47,280
So since this is a property,
it means it's mutable.

2799
02:01:47,280 --> 02:01:49,585
And we've of course, because we set it

2800
02:01:49,585 --> 02:01:50,490
to be a var type here.

2801
02:01:50,490 --> 02:01:53,270
And so what I can do
here say user.full name,

2802
02:01:53,270 --> 02:01:56,760
and I can actually reassign
this volume, say hello world.

2803
02:01:56,760 --> 02:01:59,570
And it's gonna completely
overwrite that value.

2804
02:01:59,570 --> 02:02:03,110
And then what I'll do here
is I will say print line,

2805
02:02:03,110 --> 02:02:06,170
and then we'll put user.full name again.

2806
02:02:06,170 --> 02:02:07,420
And when we run it this time,

2807
02:02:07,420 --> 02:02:09,620
what we're going to see is the init block

2808
02:02:09,620 --> 02:02:11,020
then we will see Donn Felker

2809
02:02:12,312 --> 02:02:13,780
and then we'll see hello world.

2810
02:02:13,780 --> 02:02:16,920
Now back inside of the class,
there's an interesting thing

2811
02:02:16,920 --> 02:02:18,410
that we can do as well.

2812
02:02:18,410 --> 02:02:22,640
Inside of the init block, I
have access to this property.

2813
02:02:22,640 --> 02:02:25,070
So if I were to type
something inside of here

2814
02:02:25,070 --> 02:02:26,210
for the init block,

2815
02:02:26,210 --> 02:02:28,480
perhaps I just wanted to
print something to the screen.

2816
02:02:28,480 --> 02:02:33,480
I'd say this class is for user
and I could say full name.

2817
02:02:35,915 --> 02:02:37,710
Now what you're gonna notice
is I get a red squiggly here.

2818
02:02:37,710 --> 02:02:39,160
And what that red squiggly is telling me

2819
02:02:39,160 --> 02:02:42,680
is that it's not initialized,
but as we can tell

2820
02:02:42,680 --> 02:02:45,820
it is initialized, but
here's what we need to do.

2821
02:02:45,820 --> 02:02:48,260
We need to actually take that
and move the initialization up

2822
02:02:48,260 --> 02:02:49,093
a little bit higher.

2823
02:02:49,093 --> 02:02:51,360
Now based upon the file format

2824
02:02:51,360 --> 02:02:52,860
and how everything's organized,

2825
02:02:52,860 --> 02:02:56,280
the init block can now see
the full name is there.

2826
02:02:56,280 --> 02:02:58,290
If I come back and run this,

2827
02:02:58,290 --> 02:02:59,790
we're gonna see that the unit block runs.

2828
02:02:59,790 --> 02:03:03,120
It says, hey, I'm in the
init block and this is class,

2829
02:03:04,389 --> 02:03:06,556
or this is class four, user Donn Felker.

2830
02:03:06,556 --> 02:03:07,389
That's really bad English.

2831
02:03:07,389 --> 02:03:11,640
So this is the class for user Donn Felker.

2832
02:03:11,640 --> 02:03:14,360
Of course we rerun that
cause we don't want typos.

2833
02:03:14,360 --> 02:03:16,910
We'll see, this is the
class for user Donn Felker.

2834
02:03:16,910 --> 02:03:19,310
And of course here we're
gonna print the full name

2835
02:03:19,310 --> 02:03:20,180
shows Donn Felker.

2836
02:03:20,180 --> 02:03:23,610
Next we reassign it and
then it shows full name.

2837
02:03:23,610 --> 02:03:26,710
Now each one of these, you
can have multiple of these

2838
02:03:26,710 --> 02:03:28,156
if you'd want.

2839
02:03:28,156 --> 02:03:29,050
They don't have to be initialized

2840
02:03:29,050 --> 02:03:33,270
from a particular instance.

2841
02:03:33,270 --> 02:03:35,870
We could actually just set
it to something like this.

2842
02:03:35,870 --> 02:03:37,210
Say it's zero.

2843
02:03:37,210 --> 02:03:40,110
It could be of any type that
you want your proper to be.

2844
02:03:40,110 --> 02:03:44,260
And I can actually come
here and say user.age equals

2845
02:03:44,260 --> 02:03:48,980
let's say 22, which I'm not
22, but that would be fun.

2846
02:03:48,980 --> 02:03:51,360
And then I can then print
it or do something with it

2847
02:03:51,360 --> 02:03:52,430
at that point in time.

2848
02:03:52,430 --> 02:03:56,250
So that's how you can work with
properties using accessories

2849
02:03:56,250 --> 02:03:59,710
and mutators inside of Kotlin.

2850
02:04:00,760 --> 02:04:02,880
You can also define read-only properties

2851
02:04:02,880 --> 02:04:04,450
inside of your class.

2852
02:04:04,450 --> 02:04:06,700
So you might wanna know
the full name length,

2853
02:04:07,624 --> 02:04:10,180
and decide to store that as an
integer inside of your class.

2854
02:04:10,180 --> 02:04:12,570
And so you can say full name.length.

2855
02:04:12,570 --> 02:04:16,960
Now we'll have a full name
length read only property

2856
02:04:16,960 --> 02:04:20,710
that we can use inside
of our main.kt file.

2857
02:04:20,710 --> 02:04:23,750
So if we say user.full name length,

2858
02:04:23,750 --> 02:04:25,580
we can actually get access to it.

2859
02:04:25,580 --> 02:04:27,600
We can print it to the screen.

2860
02:04:27,600 --> 02:04:32,370
However, if we attempt
to reassign it to 12,

2861
02:04:32,370 --> 02:04:34,200
we'll get a little error
message saying that the val

2862
02:04:34,200 --> 02:04:35,830
cannot be reassigned.

2863
02:04:35,830 --> 02:04:38,670
So these values have been assigned

2864
02:04:38,670 --> 02:04:40,230
based upon the other properties.

2865
02:04:40,230 --> 02:04:43,520
You could also perform
this off of a property

2866
02:04:43,520 --> 02:04:45,730
directly off of the constructor.

2867
02:04:45,730 --> 02:04:49,820
You can also decide to set
this initially such as 12

2868
02:04:49,820 --> 02:04:51,300
or something like this.

2869
02:04:51,300 --> 02:04:53,600
And if you'd like, you can
provide the type as well.

2870
02:04:54,570 --> 02:04:56,390
And let's assume inside
of your user class,

2871
02:04:56,390 --> 02:05:00,100
you wanted to decide that
anytime someone requested

2872
02:05:00,100 --> 02:05:01,430
the full name property,

2873
02:05:01,430 --> 02:05:04,260
you wanted to make sure it was
prefixed with the word name.

2874
02:05:04,260 --> 02:05:08,730
We can do that very easily
by providing an override

2875
02:05:08,730 --> 02:05:13,190
of the accessor for
the full name property.

2876
02:05:13,190 --> 02:05:15,070
Now, what we can do here is
we can actually type in name

2877
02:05:15,070 --> 02:05:17,000
and then what we can actually type in here

2878
02:05:17,000 --> 02:05:18,090
is the word field.

2879
02:05:18,090 --> 02:05:20,780
And what the word field means
is this field right here,

2880
02:05:20,780 --> 02:05:23,200
whatever is stored in this property,

2881
02:05:23,200 --> 02:05:25,150
go ahead and we're gonna
use that right here.

2882
02:05:25,150 --> 02:05:30,150
So anytime someone calls a get
on this, which is by default,

2883
02:05:30,428 --> 02:05:32,582
anytime we call something like this,

2884
02:05:32,582 --> 02:05:33,450
it's actually calling the get,

2885
02:05:34,782 --> 02:05:35,920
it's going to return name:field.

2886
02:05:36,967 --> 02:05:39,095
So in this instance,
if we were to run this,

2887
02:05:39,095 --> 02:05:39,928
we're gonna see something
like John Franks.

2888
02:05:39,928 --> 02:05:42,540
But instead of that, we'll
see name: John Franks.

2889
02:05:42,540 --> 02:05:46,130
Now, if I were to leave
this off or comment that out

2890
02:05:46,130 --> 02:05:47,690
where to rerun this again,

2891
02:05:47,690 --> 02:05:50,310
we would see that the
name is just John Franks,

2892
02:05:50,310 --> 02:05:52,530
because it's just printing out the field,

2893
02:05:52,530 --> 02:05:56,380
which is been stored by
default as initialized

2894
02:05:57,320 --> 02:05:58,770
with the first and last name.

2895
02:05:59,964 --> 02:06:02,990
Now here, I was able to
override the get implementation

2896
02:06:02,990 --> 02:06:05,780
so I can say, yeah,
anytime someone requests

2897
02:06:05,780 --> 02:06:09,140
the first or last name,
then we're going to go ahead

2898
02:06:09,140 --> 02:06:13,320
and say name: John Frank.

2899
02:06:13,320 --> 02:06:15,930
Now it'd probably make more
sense if we just said full name

2900
02:06:15,930 --> 02:06:18,550
so it wouldn't match
the variable name there.

2901
02:06:18,550 --> 02:06:21,350
And then once we run it with
the full name, John Franks.

2902
02:06:22,520 --> 02:06:25,260
One important thing to note, this field

2903
02:06:25,260 --> 02:06:28,740
is actually the backing field
for this full name property.

2904
02:06:28,740 --> 02:06:31,040
So this is what contains the contents

2905
02:06:31,040 --> 02:06:32,530
of the full name property.

2906
02:06:32,530 --> 02:06:34,430
So this is known as the backing field.

2907
02:06:35,590 --> 02:06:37,750
Now I can also override the setter,

2908
02:06:37,750 --> 02:06:38,720
also known as the mutator.

2909
02:06:38,720 --> 02:06:39,640
I could say set.

2910
02:06:40,833 --> 02:06:43,560
And by default, the
value that's parse d in

2911
02:06:43,560 --> 02:06:46,060
to the full name when it's
changed is gonna be called value.

2912
02:06:46,060 --> 02:06:50,770
So if I were to say something
like this user.full name

2913
02:06:50,770 --> 02:06:54,850
equals Jon, like this
was a school lowercase,

2914
02:06:54,850 --> 02:06:59,610
jon without the H, then what
would happen is this Jon

2915
02:07:00,607 --> 02:07:02,739
would be shoved into full name,

2916
02:07:02,739 --> 02:07:03,990
which then would call this code block here

2917
02:07:03,990 --> 02:07:07,980
and what would be inside
of this value variable

2918
02:07:09,191 --> 02:07:11,400
would be these three letters, J-O-N.

2919
02:07:11,400 --> 02:07:12,630
Now I can actually do some stuff,

2920
02:07:12,630 --> 02:07:13,860
anything I'd like to do in here.

2921
02:07:13,860 --> 02:07:17,540
So I can actually say
if value starts with,

2922
02:07:17,540 --> 02:07:19,040
maybe I wanna know if it
starts with something.

2923
02:07:19,040 --> 02:07:21,730
I say, hey, if it starts with Jon, J-O-N,

2924
02:07:21,730 --> 02:07:25,220
then what I want this field to be equal to

2925
02:07:25,220 --> 02:07:29,810
is going to be Jon Doe.

2926
02:07:30,910 --> 02:07:33,150
So if anyone says, sets us to Jon

2927
02:07:33,150 --> 02:07:36,390
and then our to print line anything else

2928
02:07:36,390 --> 02:07:40,650
for user's full name, it
should now say Jon Doe.

2929
02:07:40,650 --> 02:07:42,860
So if we've run this, we'll have in here

2930
02:07:42,860 --> 02:07:44,720
is we'll see John Franks, of course,

2931
02:07:45,610 --> 02:07:47,520
we're printing that the
first time we've reset this

2932
02:07:47,520 --> 02:07:50,251
to say, hey, the full
name is actually Jon,

2933
02:07:50,251 --> 02:07:51,084
which we know is not the real case,

2934
02:07:51,084 --> 02:07:53,120
but if we look at the
mutator, the setter here,

2935
02:07:54,135 --> 02:07:56,500
we're saying, hey, if
the first name is Jon,

2936
02:07:56,500 --> 02:07:59,030
then go ahead and actually
set the backing field

2937
02:07:59,030 --> 02:08:01,020
to actually equal Jon
Doe, for whatever reason,

2938
02:08:01,020 --> 02:08:03,300
maybe we have some business requirement

2939
02:08:03,300 --> 02:08:05,514
that states that we need to do that.

2940
02:08:05,514 --> 02:08:06,410
And then once I print the full name,

2941
02:08:06,410 --> 02:08:08,500
of course, it's going to say full name

2942
02:08:08,500 --> 02:08:10,480
and then print that backing field,

2943
02:08:10,480 --> 02:08:12,330
which has now been turned to Jon Doe.

2944
02:08:13,500 --> 02:08:15,820
Now we do have a problem here actually,

2945
02:08:15,820 --> 02:08:18,500
if I were to attempt to reassign full name

2946
02:08:18,500 --> 02:08:23,390
to something else, such
as let's say Jane Sparks.

2947
02:08:23,390 --> 02:08:26,410
And if I were to try to print
that to the screen as well,

2948
02:08:26,410 --> 02:08:28,510
what we would end up seeing immediately

2949
02:08:28,510 --> 02:08:30,860
is something we probably wouldn't expect,

2950
02:08:30,860 --> 02:08:34,370
which is we're still
gonna see Jon Doe printed.

2951
02:08:34,370 --> 02:08:36,760
But hold on, I set it to Jane Sparks,

2952
02:08:36,760 --> 02:08:38,080
why isn't that working?

2953
02:08:38,080 --> 02:08:41,300
The reason that it's not
working is because the full name

2954
02:08:41,300 --> 02:08:44,340
property we have overrided the setter,

2955
02:08:44,340 --> 02:08:49,010
we're checking the value that
was set to that backfield.

2956
02:08:49,010 --> 02:08:51,090
If it started with Jon Doe and
then we set at the Jon Doe,

2957
02:08:51,090 --> 02:08:53,090
but what we didn't take into account is,

2958
02:08:53,960 --> 02:08:54,890
hey, what about the else condition here?

2959
02:08:54,890 --> 02:08:56,850
So we needed to do an else condition.

2960
02:08:56,850 --> 02:08:58,970
If this value starts with this,

2961
02:08:58,970 --> 02:09:01,635
it starts with Jon and set the Jon Doe

2962
02:09:01,635 --> 02:09:02,800
otherwise set the field equal to the value

2963
02:09:02,800 --> 02:09:04,180
that was parse d in.

2964
02:09:04,180 --> 02:09:07,190
So now if we come back here
and we were to run this,

2965
02:09:07,190 --> 02:09:09,340
we'll now see that we have John Franks,

2966
02:09:09,340 --> 02:09:12,040
Jon Doe and Jane Sparks that are returned.

2967
02:09:12,040 --> 02:09:14,660
So you wanna make sure that
you handle all of the various

2968
02:09:14,660 --> 02:09:17,050
different types of scenarios you can have.

2969
02:09:17,050 --> 02:09:19,490
This could very well be a valid scenario

2970
02:09:19,490 --> 02:09:20,620
for your application.

2971
02:09:20,620 --> 02:09:24,450
You may only wanna decide
that only you can change

2972
02:09:24,450 --> 02:09:28,760
that value to certain
values or there's some type

2973
02:09:28,760 --> 02:09:31,580
of logic for the setter
that you need to adhere to.

2974
02:09:31,580 --> 02:09:34,002
However, if you need an else condition,

2975
02:09:34,002 --> 02:09:35,980
be sure to also implement
that so that your property

2976
02:09:35,980 --> 02:09:37,590
does act like a normal property,

2977
02:09:38,579 --> 02:09:41,179
which can have the properties
red and have them set.

2978
02:09:42,310 --> 02:09:44,540
Let's assume that you wanna
have multiple properties

2979
02:09:44,540 --> 02:09:46,980
in a class, you can easily do that.

2980
02:09:46,980 --> 02:09:49,480
So of course we have
these properties up here,

2981
02:09:49,480 --> 02:09:52,380
but let's assume that you
also want another property

2982
02:09:52,380 --> 02:09:56,160
in your class called age,
and you're gonna default that

2983
02:09:56,160 --> 02:09:59,330
to zero and then perhaps
you have a favorite color

2984
02:10:00,580 --> 02:10:03,980
and that's a string, and you're
gonna default that to blue.

2985
02:10:05,009 --> 02:10:07,730
So you can have multiple of
these inside of your application

2986
02:10:07,730 --> 02:10:10,900
and it can easily be accessed and modified

2987
02:10:13,710 --> 02:10:18,210
through the property
accessor's and mutators,

2988
02:10:18,210 --> 02:10:19,070
which are default.

2989
02:10:19,070 --> 02:10:23,043
So say first name, age X, age equals 30.

2990
02:10:25,650 --> 02:10:28,590
And I can say, use the
user that favorite color

2991
02:10:28,590 --> 02:10:30,770
equals green.

2992
02:10:30,770 --> 02:10:32,240
And so these are all possible.

2993
02:10:32,240 --> 02:10:35,540
You can have as many these
properties as you would like

2994
02:10:35,540 --> 02:10:38,060
inside of your class, just like functions.

2995
02:10:38,060 --> 02:10:41,960
You can have more functions
and new, like you say, say hi,

2996
02:10:41,960 --> 02:10:45,820
and this could just be a
simple little print line

2997
02:10:45,820 --> 02:10:48,520
that just says hi.

2998
02:10:48,520 --> 02:10:53,520
And so of course we could say, user.say hi

2999
02:10:54,268 --> 02:10:55,101
and that would print to the screen.

3000
02:10:55,101 --> 02:10:56,900
I could come in here and
change that of course,

3001
02:10:56,900 --> 02:11:00,170
to hi, full name and then it would say,

3002
02:11:00,170 --> 02:11:02,710
hi, Donn Felker in this case.

3003
02:11:02,710 --> 02:11:05,190
So you can easily put
multiple properties here

3004
02:11:05,190 --> 02:11:07,330
wanting to add another
one, we can do that here,

3005
02:11:07,330 --> 02:11:09,080
et cetera, et cetera, et cetera,

3006
02:11:09,080 --> 02:11:10,880
and put as many there as you'd like.

3007
02:11:11,960 --> 02:11:14,650
You can also add functions to your classes

3008
02:11:14,650 --> 02:11:17,640
and you just go inside
of your class definition

3009
02:11:17,640 --> 02:11:19,070
and start typing your function name.

3010
02:11:19,070 --> 02:11:20,940
So we'll create a
function called full name,

3011
02:11:20,940 --> 02:11:22,960
which will return a string.

3012
02:11:22,960 --> 02:11:24,500
And then inside of here, we'll just use

3013
02:11:24,500 --> 02:11:28,150
some string interpolation,
we'll say first name

3014
02:11:28,150 --> 02:11:30,560
and then we'll say last
name with the dollar bracket

3015
02:11:30,560 --> 02:11:32,910
syntax there and it will return us

3016
02:11:32,910 --> 02:11:34,340
the full name of the user.

3017
02:11:35,517 --> 02:11:37,440
Now you may be noticing
I'm not using the brackets

3018
02:11:37,440 --> 02:11:38,440
around here.

3019
02:11:38,440 --> 02:11:42,540
If I need to use the
brackets, only time we would

3020
02:11:42,540 --> 02:11:45,214
is if we're using some
property off of this.

3021
02:11:45,214 --> 02:11:47,425
So maybe I wanted to get
the length and you'll notice

3022
02:11:47,425 --> 02:11:48,723
how IntelliJ added those
brackets there for me.

3023
02:11:48,723 --> 02:11:53,723
Anytime I'm doing anything off
of this main expression here,

3024
02:11:54,700 --> 02:11:57,020
it's going to require
we put it in brackets.

3025
02:11:57,020 --> 02:11:59,080
Now, if I do remove this, I
could still have brackets here.

3026
02:11:59,080 --> 02:12:00,400
This will compile and this'll work.

3027
02:12:00,400 --> 02:12:02,270
But notice there's a
little gray squiggly here,

3028
02:12:02,270 --> 02:12:03,800
it's kind of hard to see.

3029
02:12:03,800 --> 02:12:06,092
If I put that there, I'll
get a little light bulb

3030
02:12:06,092 --> 02:12:08,180
and click on it or hit
alt+enter, and it will see

3031
02:12:08,180 --> 02:12:09,760
remove curly braces.

3032
02:12:09,760 --> 02:12:11,820
And if I do that, it'll just
automatically remove them

3033
02:12:11,820 --> 02:12:13,630
because we don't need them here.

3034
02:12:13,630 --> 02:12:15,200
Now this could also be cleaned up

3035
02:12:15,200 --> 02:12:16,440
a little bit further as well.

3036
02:12:16,440 --> 02:12:19,060
So we could kind of turn us
into a single line function

3037
02:12:19,060 --> 02:12:22,230
really easily, and we can
just click and get rid of this

3038
02:12:22,230 --> 02:12:25,530
and make it equal that.

3039
02:12:25,530 --> 02:12:28,810
And we can make it a Parry,
small, succinct little function.

3040
02:12:28,810 --> 02:12:33,073
Now, to call this, we would
go back to our main file here

3041
02:12:33,073 --> 02:12:34,373
and we say user.full name.

3042
02:12:35,699 --> 02:12:37,340
So we'd actually see that
if they function here.

3043
02:12:37,340 --> 02:12:39,367
And of course, if we now run it,

3044
02:12:39,367 --> 02:12:42,110
we will see that we have
the name, first name John,

3045
02:12:42,110 --> 02:12:45,000
last name, Franks, and it
just puts out John Franks.

3046
02:12:45,000 --> 02:12:47,220
And again, if we wanted to
again, do something different,

3047
02:12:47,220 --> 02:12:49,500
we could do dot length.

3048
02:12:49,500 --> 02:12:52,004
And for whatever reason
it would say, John,

3049
02:12:52,004 --> 02:12:53,950
and then the length of
the actual last name,

3050
02:12:53,950 --> 02:12:56,430
which we'd see here,
as soon as it compiles.

3051
02:12:56,430 --> 02:13:00,542
John six, because the word
Franks has six characters in it.

3052
02:13:00,542 --> 02:13:03,020
And so you can continually keep adding

3053
02:13:03,020 --> 02:13:04,130
different functions here.

3054
02:13:04,130 --> 02:13:06,150
So you could even add a
different function here.

3055
02:13:06,150 --> 02:13:09,470
say, full name length, and
this one could be very similar.

3056
02:13:09,470 --> 02:13:12,200
Again, this one might
return it int this time

3057
02:13:12,200 --> 02:13:14,990
and we could either do it
on a single line expression,

3058
02:13:14,990 --> 02:13:17,230
or multiline like we're doing here.

3059
02:13:17,230 --> 02:13:19,030
And we could do something
even call it one function

3060
02:13:19,030 --> 02:13:20,940
call another function and say,

3061
02:13:20,940 --> 02:13:22,990
let me see you get the length of that.

3062
02:13:24,204 --> 02:13:27,020
And then we can also print
this here and I'll go ahead

3063
02:13:27,020 --> 02:13:30,590
and go to full name length.

3064
02:13:31,664 --> 02:13:33,300
And when we this again, we're going to see

3065
02:13:33,300 --> 02:13:36,240
that we get the John six again,
'cause we did the full name.

3066
02:13:36,240 --> 02:13:38,390
Let's fix that real fast
'cause we don't want

3067
02:13:38,390 --> 02:13:40,860
the length anymore on the last name.

3068
02:13:40,860 --> 02:13:44,530
We just want it to say John
Franks as the actual output.

3069
02:13:44,530 --> 02:13:47,960
And then we want to actually
show the length of the name.

3070
02:13:47,960 --> 02:13:49,410
And so we're doing that here.

3071
02:13:50,252 --> 02:13:52,140
So we say John Franks and then
the full name length is 11.

3072
02:13:52,140 --> 02:13:54,940
So we have one function here,
it's calling another function.

3073
02:13:54,940 --> 02:13:56,650
We don't have to do this.

3074
02:13:56,650 --> 02:14:00,390
I could replicate this
functionality down here

3075
02:14:00,390 --> 02:14:03,205
by doing this, I'm gonna comment this out.

3076
02:14:03,205 --> 02:14:06,778
And I could say return this
dot length and would give us

3077
02:14:06,778 --> 02:14:07,611
the same exact thing.

3078
02:14:07,611 --> 02:14:09,790
But at this point we have
some code duplication

3079
02:14:09,790 --> 02:14:11,190
and that's just usually not a good thing

3080
02:14:11,190 --> 02:14:14,100
because if for some reason
I decide that I want

3081
02:14:14,100 --> 02:14:16,320
the full name to have a hyphen in it,

3082
02:14:16,320 --> 02:14:20,180
well, now this length here
is not going to be the same

3083
02:14:20,180 --> 02:14:21,060
as a full name length.

3084
02:14:21,060 --> 02:14:23,040
That kind of depends on what
kind of app you're building

3085
02:14:23,040 --> 02:14:25,220
and if you need that functionality.

3086
02:14:25,220 --> 02:14:27,960
So I usually recommend, okay,
if you already have a function

3087
02:14:27,960 --> 02:14:30,010
that provides that value, just go ahead

3088
02:14:30,010 --> 02:14:31,860
and call that function and
then it will be updated.

3089
02:14:31,860 --> 02:14:34,402
So in this case, it's gonna add us

3090
02:14:34,402 --> 02:14:35,235
two additional characters here

3091
02:14:35,235 --> 02:14:38,480
because we have an additional
space and a hyphen.

3092
02:14:38,480 --> 02:14:42,500
So instead of the 11,
we should get back a 13

3093
02:14:43,340 --> 02:14:44,550
as we have here.

3094
02:14:44,550 --> 02:14:47,770
And that's how you add
just very basic functions

3095
02:14:47,770 --> 02:14:49,823
to your actual class.

3096
02:14:49,823 --> 02:14:52,200
And you can continue
adding as many as you like

3097
02:14:52,200 --> 02:14:53,280
inside of the class body here.

3098
02:14:53,280 --> 02:14:54,730
They can reference the members,

3099
02:14:54,730 --> 02:14:57,230
they can perform different operations,

3100
02:14:57,230 --> 02:14:59,230
they can even alter the members as well.

3101
02:14:59,230 --> 02:15:01,420
So if we wanted to do that, we'd say fun,

3102
02:15:02,970 --> 02:15:07,970
update full name for
whatever reason with suffix.

3103
02:15:08,680 --> 02:15:11,100
And we might have parse d
in a suffix of some sort

3104
02:15:11,100 --> 02:15:13,600
and that suffix might be a string

3105
02:15:14,520 --> 02:15:15,880
and we might do something like this.

3106
02:15:15,880 --> 02:15:19,490
first name equals, let's say suffix.

3107
02:15:20,730 --> 02:15:22,380
And then we would say first name.

3108
02:15:23,920 --> 02:15:26,020
And then what we would
do here is we'd go back

3109
02:15:26,020 --> 02:15:29,260
to this area here on our main file.

3110
02:15:29,260 --> 02:15:32,640
And we wanna say user to
update full name of suffix.

3111
02:15:32,640 --> 02:15:34,650
And it will say Mr.

3112
02:15:34,650 --> 02:15:38,590
And then as it prints,
it should say, Mr. John,

3113
02:15:38,590 --> 02:15:41,800
which sounds a little weird,
but that's how it's gonna look.

3114
02:15:41,800 --> 02:15:45,360
And we see Mr. John down
here and the output,

3115
02:15:45,360 --> 02:15:47,980
and that's how you can
add and continually add

3116
02:15:47,980 --> 02:15:50,080
additional functions inside of your class.

3117
02:15:51,280 --> 02:15:53,490
To create a companion
object, what you'll do

3118
02:15:53,490 --> 02:15:56,060
is inside of your clash
you'll type companion object,

3119
02:15:57,382 --> 02:15:58,530
and then you can start typing
the name of your function.

3120
02:15:58,530 --> 02:16:01,030
So in this case, it's create
a function called create user.

3121
02:16:01,030 --> 02:16:02,640
It will return a new user.

3122
02:16:03,630 --> 02:16:05,440
In order to do that, we
actually need the first name

3123
02:16:05,440 --> 02:16:06,273
and a last name.

3124
02:16:06,273 --> 02:16:07,960
So we'll need that provided to us.

3125
02:16:09,080 --> 02:16:10,950
That's not what we want first name,

3126
02:16:10,950 --> 02:16:12,450
and then we'll have last name.

3127
02:16:13,671 --> 02:16:15,958
And then of course, what we'll
do is we'll have this return

3128
02:16:15,958 --> 02:16:16,791
a new user.

3129
02:16:16,791 --> 02:16:19,260
And it's very simple, just
kind of knew what the user

3130
02:16:19,260 --> 02:16:21,160
with the first name and the last name.

3131
02:16:23,440 --> 02:16:26,130
Now, companion object is
a function or property

3132
02:16:26,130 --> 02:16:28,170
that's going to be tied
directly to the class

3133
02:16:28,170 --> 02:16:30,310
or rather than it's exact instances.

3134
02:16:30,310 --> 02:16:33,000
And we it's very much like a static method

3135
02:16:33,000 --> 02:16:35,490
that you would see inside
of something like Java

3136
02:16:35,490 --> 02:16:37,390
and a companion object is a Singleton,

3137
02:16:37,390 --> 02:16:39,810
so meaning that is tied to
the actual class itself.

3138
02:16:39,810 --> 02:16:40,780
So what does that mean?

3139
02:16:40,780 --> 02:16:44,033
Let's go take a look at
this implementation here.

3140
02:16:44,033 --> 02:16:46,610
I can do this, say user.create user Fu

3141
02:16:46,610 --> 02:16:49,670
and then we'll say bar,
and I'll say val user.

3142
02:16:52,316 --> 02:16:53,820
And then what we can do
here is I'm just print line

3143
02:16:53,820 --> 02:16:55,670
the user, they'll say print the user.

3144
02:16:56,651 --> 02:16:58,953
And what we've done here
is we've actually created

3145
02:16:58,953 --> 02:17:00,120
a basically static type of method

3146
02:17:00,120 --> 02:17:02,310
attached to the user class.

3147
02:17:02,310 --> 02:17:04,830
So now you notice how I didn't
create an instance of user,

3148
02:17:04,830 --> 02:17:08,870
I just called a method that
was directly on the user class,

3149
02:17:08,870 --> 02:17:11,620
and that is going to be
the create user method.

3150
02:17:11,620 --> 02:17:15,010
So see, create user and we
can treat this like a factory

3151
02:17:15,010 --> 02:17:16,200
to create objects for us.

3152
02:17:16,200 --> 02:17:19,270
Now we could go a little
bit further too, as well.

3153
02:17:19,270 --> 02:17:22,870
And let's say that we had
maybe we wanted to create,

3154
02:17:22,870 --> 02:17:25,132
a way to create a bunch of
users and I say, create users.

3155
02:17:25,132 --> 02:17:28,500
And then what we can do
inside of here to say,

3156
02:17:28,500 --> 02:17:30,400
how many users we would like to create

3157
02:17:30,400 --> 02:17:32,535
and maybe parse into value.

3158
02:17:32,535 --> 02:17:35,970
What we're gonna do is
return a list of users.

3159
02:17:37,010 --> 02:17:38,870
So in order to do that,
let's go ahead and create

3160
02:17:38,870 --> 02:17:41,510
a quick class level Singleton variable.

3161
02:17:41,510 --> 02:17:46,133
So it will say foul users
equals a mutable list of users.

3162
02:17:47,250 --> 02:17:50,080
Now we'll be able to
access that via the class.

3163
02:17:50,080 --> 02:17:55,080
And what we can say here is
for I in zero to the count,

3164
02:17:57,020 --> 02:17:59,440
which meaning from count
from zero up to the number

3165
02:17:59,440 --> 02:18:00,980
provided count here.

3166
02:18:00,980 --> 02:18:04,480
We want to add an item to the users list,

3167
02:18:04,480 --> 02:18:06,060
and we'll go ahead and say user,

3168
02:18:06,060 --> 02:18:09,320
and we'll just kind of
do something first name,

3169
02:18:09,320 --> 02:18:11,910
and then we'll provide some type of value

3170
02:18:11,910 --> 02:18:14,220
such as the index here.

3171
02:18:14,220 --> 02:18:17,280
And then we'll do the same
thing here, last name,

3172
02:18:17,280 --> 02:18:19,850
and then we'll do something
like the index as well.

3173
02:18:19,850 --> 02:18:21,180
And as you can see here,

3174
02:18:22,423 --> 02:18:23,256
it says we can remove the curly braces.

3175
02:18:23,256 --> 02:18:24,830
So we can do that here and here,

3176
02:18:24,830 --> 02:18:28,520
because we're just doing
a very simple expression.

3177
02:18:28,520 --> 02:18:31,690
And then of course we'll return the users,

3178
02:18:31,690 --> 02:18:34,040
which is a steep to member variable.

3179
02:18:34,040 --> 02:18:35,970
So let's go take a look
at how we would use this.

3180
02:18:35,970 --> 02:18:38,800
So let's go over here, val users equals,

3181
02:18:40,240 --> 02:18:42,470
and we could say user dot create users.

3182
02:18:43,565 --> 02:18:45,954
So maybe you wanna have this
to create a number of users

3183
02:18:45,954 --> 02:18:47,800
or objects or one out of a type.

3184
02:18:47,800 --> 02:18:50,360
And then we can say print line
and they'll actually print

3185
02:18:50,360 --> 02:18:51,740
those users out.

3186
02:18:51,740 --> 02:18:53,430
And when we run this,
what we're gonna notice

3187
02:18:53,430 --> 02:18:56,670
is that we see all of
them printed on one line.

3188
02:18:56,670 --> 02:18:59,240
And the reason for that is
this is basically Kotlin's way

3189
02:18:59,240 --> 02:19:02,690
of showing us, hey, this looks
like some type of collection

3190
02:19:06,265 --> 02:19:07,160
because we have a square bracket
and a closed square bracket

3191
02:19:07,160 --> 02:19:09,300
up here, open and close square brackets.

3192
02:19:09,300 --> 02:19:12,170
And this is the first
element inside of our lists.

3193
02:19:12,170 --> 02:19:16,140
So zero one, two, three, four, five.

3194
02:19:16,140 --> 02:19:18,840
So actually, if we're to
make this a little bit easier

3195
02:19:18,840 --> 02:19:21,500
to read, we can actually
use one of the collection

3196
02:19:21,500 --> 02:19:23,780
helper methods called Foreach.

3197
02:19:23,780 --> 02:19:26,385
And it basically iterates over each item.

3198
02:19:26,385 --> 02:19:28,280
And then inside of there,
we can off the item,

3199
02:19:28,280 --> 02:19:31,340
which there'll be, it's
called it by default.

3200
02:19:31,340 --> 02:19:33,870
And if we run this, we'll see
that we actually have them

3201
02:19:33,870 --> 02:19:36,230
printed on all on each individual line.

3202
02:19:36,230 --> 02:19:38,330
But now the interesting thing is we said,

3203
02:19:38,330 --> 02:19:42,730
let's create five users, one,
two, three, four, five, six.

3204
02:19:43,593 --> 02:19:44,426
Now the reason why we have six

3205
02:19:44,426 --> 02:19:46,840
is because this range
is starting from zero.

3206
02:19:46,840 --> 02:19:50,743
So we could change this to
count, to count minus one,

3207
02:19:50,743 --> 02:19:51,640
or we could just kind of
make it simple saying,

3208
02:19:51,640 --> 02:19:53,260
hey, go from one up to the count.

3209
02:19:53,260 --> 02:19:55,990
So now if we run this again,
we'll see that we only have

3210
02:19:55,990 --> 02:19:57,300
one, two, three, four, five.

3211
02:19:57,300 --> 02:20:00,800
Now we could count this
up to 15, which is great.

3212
02:20:00,800 --> 02:20:03,350
And we can go in and
create 15 different users.

3213
02:20:03,350 --> 02:20:04,710
And it's all pretty simple to do.

3214
02:20:04,710 --> 02:20:06,760
Now also, the cool thing is here as well,

3215
02:20:07,667 --> 02:20:08,840
let's go ahead and comment this out,

3216
02:20:08,840 --> 02:20:11,630
is that we've not created our users,

3217
02:20:11,630 --> 02:20:14,620
but perhaps we could say users too.

3218
02:20:14,620 --> 02:20:17,470
So kind of new variable
here, I'll say user.users.

3219
02:20:17,470 --> 02:20:21,000
Remember this is a property,
the Singleton property

3220
02:20:21,000 --> 02:20:23,110
that's on the user class.

3221
02:20:23,110 --> 02:20:28,110
So this method create users
actually modified this list here

3222
02:20:29,320 --> 02:20:30,660
by adding to it.

3223
02:20:30,660 --> 02:20:32,550
Now, again, back here,
we're not doing anything

3224
02:20:32,550 --> 02:20:35,631
with the users, we're just
kind of leaving it there.

3225
02:20:35,631 --> 02:20:36,993
So technically I could
just kind of get rid of it

3226
02:20:36,993 --> 02:20:38,750
if I wanted to, and
then I could say users,

3227
02:20:38,750 --> 02:20:40,350
and then I could say print line.

3228
02:20:42,030 --> 02:20:43,770
Let's actually go ahead
and copy this up here.

3229
02:20:43,770 --> 02:20:46,980
To make it easier, I'll say users two.

3230
02:20:48,190 --> 02:20:49,320
And of course that's not there.

3231
02:20:49,320 --> 02:20:50,870
So I'll say users two print line.

3232
02:20:50,870 --> 02:20:53,210
And if we run this, what we'll notice

3233
02:20:53,210 --> 02:20:55,920
is that the user's object of course,

3234
02:20:55,920 --> 02:20:57,620
was populated via the create user.

3235
02:20:57,620 --> 02:21:00,780
So now, if I were to come
up here and say zero,

3236
02:21:01,670 --> 02:21:03,330
so don't create any
users, it's gonna to see,

3237
02:21:03,330 --> 02:21:05,020
like, we have an empty basic list.

3238
02:21:05,020 --> 02:21:07,730
We see foo bar, that's this one up here.

3239
02:21:07,730 --> 02:21:09,980
So if we were to get
rid of this guy up here,

3240
02:21:11,689 --> 02:21:12,522
we wouldn't have that.

3241
02:21:12,522 --> 02:21:13,650
And we're not gonna have anything output

3242
02:21:14,513 --> 02:21:16,820
to the output of the window
because we don't have it there.

3243
02:21:16,820 --> 02:21:19,750
So that's how you would
build a companion object

3244
02:21:19,750 --> 02:21:21,340
inside of your Kotlin class.

3245
02:21:22,324 --> 02:21:24,433
You use the companion object, keywords,

3246
02:21:24,433 --> 02:21:25,400
open and closed curly braces,

3247
02:21:25,400 --> 02:21:27,680
and any functions and properties
that are inside of here

3248
02:21:27,680 --> 02:21:30,520
are class level and it's
basically Singleton scoped.

3249
02:21:31,980 --> 02:21:33,480
Let's say that you
would like to keep track

3250
02:21:33,480 --> 02:21:35,270
of a user's favorite food,

3251
02:21:36,600 --> 02:21:38,760
or even just a favorite
food for your application.

3252
02:21:38,760 --> 02:21:41,510
Let's assume that it has some ingredients

3253
02:21:43,030 --> 02:21:46,930
and those ingredients are
a mutable list of string.

3254
02:21:46,930 --> 02:21:50,950
And let's also assume that there is a name

3255
02:21:50,950 --> 02:21:52,890
of a favorite food here,

3256
02:21:52,890 --> 02:21:56,690
and I should make this
one mutable as well,

3257
02:21:56,690 --> 02:21:59,050
and this one's gonna be a
string and we can go ahead

3258
02:21:59,050 --> 02:22:02,170
and default this to a known because maybe

3259
02:22:02,170 --> 02:22:03,830
you wanna change it later.

3260
02:22:03,830 --> 02:22:07,080
Now with a Singleton and
software development,

3261
02:22:07,080 --> 02:22:12,080
we only want one instance of
this to be created at any time.

3262
02:22:12,360 --> 02:22:14,850
So if I have one favorite
food, I can't have multiple.

3263
02:22:14,850 --> 02:22:16,480
I mean, I could have
multiple favorite foods,

3264
02:22:16,480 --> 02:22:18,730
but let's say my most favorite
food in the whole world

3265
02:22:18,730 --> 02:22:20,590
is X, Y, and Z.

3266
02:22:20,590 --> 02:22:22,770
I only want one instance
of this to be created.

3267
02:22:22,770 --> 02:22:26,030
But however, if I were to set
this up, I say, favorite food.

3268
02:22:26,030 --> 02:22:27,600
I can create one instance of it here,

3269
02:22:27,600 --> 02:22:31,650
I can create another instance here.

3270
02:22:31,650 --> 02:22:34,270
And how would we do that now in utterly.

3271
02:22:34,270 --> 02:22:37,090
So, as you can see, I have
multiple of these instances,

3272
02:22:37,090 --> 02:22:40,410
and I only wanna be able
to restrict the user

3273
02:22:40,410 --> 02:22:43,750
from creating basically
one instance of this.

3274
02:22:43,750 --> 02:22:45,030
So how would I go about doing that?

3275
02:22:45,030 --> 02:22:46,650
Well in other languages, what you would do

3276
02:22:46,650 --> 02:22:49,200
is you would mark the constructor private

3277
02:22:49,200 --> 02:22:50,730
and it's a private constructor.

3278
02:22:50,730 --> 02:22:52,550
And now of course, we're
not gonna have the ability

3279
02:22:52,550 --> 02:22:53,383
to create this.

3280
02:22:53,383 --> 02:22:55,870
But now what we need is
some type of helper method

3281
02:22:55,870 --> 02:22:56,703
to create this.

3282
02:22:56,703 --> 02:23:00,050
So maybe we have a companion object

3283
02:23:00,050 --> 02:23:04,660
and this companion object has
a new method called instance.

3284
02:23:04,660 --> 02:23:08,140
And this instance just
basically create a favorite food

3285
02:23:08,140 --> 02:23:13,140
for us, so it's basically a private method

3286
02:23:13,690 --> 02:23:16,290
that creates a favorite food for us.

3287
02:23:16,290 --> 02:23:19,475
But now even then,
we're gonna keep getting

3288
02:23:19,475 --> 02:23:20,308
new instances here.

3289
02:23:20,308 --> 02:23:23,047
So even if we did this,
let's do those things.

3290
02:23:23,047 --> 02:23:24,570
We could say favorite food at instance,

3291
02:23:25,410 --> 02:23:28,190
we're still gonna get
multiple different instances

3292
02:23:28,190 --> 02:23:29,160
of this food.

3293
02:23:29,160 --> 02:23:30,580
So what we'd have to do is inside of this,

3294
02:23:30,580 --> 02:23:32,851
we have to kind of lock this down and say,

3295
02:23:32,851 --> 02:23:34,946
all right, it's gonna
return a favorite food.

3296
02:23:34,946 --> 02:23:38,420
And then inside of here, we're
gonna have to possibly need

3297
02:23:38,420 --> 02:23:43,413
a let me say vowel instance
equals favorite food.

3298
02:23:49,820 --> 02:23:52,080
And we start getting a lot
into a lot of code here

3299
02:23:52,080 --> 02:23:53,100
to kind of start managing this.

3300
02:23:53,100 --> 02:23:54,900
You can kind of start to
see that we're gonna start

3301
02:23:54,900 --> 02:23:58,320
getting out of control,
we need to start handling,

3302
02:23:58,320 --> 02:24:01,070
create the new instance here, et cetera.

3303
02:24:01,070 --> 02:24:03,240
Now, thankfully in Kotlin,
this is a lot easier.

3304
02:24:03,240 --> 02:24:04,410
We don't even need to do all this.

3305
02:24:04,410 --> 02:24:06,510
This is already handled for us.

3306
02:24:06,510 --> 02:24:09,200
And to create a Singleton in Kotlin,

3307
02:24:09,200 --> 02:24:10,250
it's actually really easy.

3308
02:24:10,250 --> 02:24:11,950
So I'm gonna delete this
private constructor.

3309
02:24:11,950 --> 02:24:14,890
All we have to do is change
this class to object.

3310
02:24:15,760 --> 02:24:19,250
Now time, we only have one
instance of favorite food

3311
02:24:19,250 --> 02:24:20,360
at any time.

3312
02:24:20,360 --> 02:24:22,000
So now if I go favorite food,

3313
02:24:25,408 --> 02:24:26,630
so just give me a favorite food.name,

3314
02:24:29,723 --> 02:24:32,920
excuse me, I could say print line of this,

3315
02:24:32,920 --> 02:24:35,280
favorite food.name and
we're gonna see unknown.

3316
02:24:35,280 --> 02:24:37,940
So if we run this, we'll see unknown.

3317
02:24:37,940 --> 02:24:39,130
Of course, this will say unknown.

3318
02:24:39,130 --> 02:24:40,340
Now, if I were to change this,

3319
02:24:40,340 --> 02:24:45,340
I'd say favorite food.name
equals maybe you love.

3320
02:24:46,070 --> 02:24:47,650
I know I do, I love watermelon.

3321
02:24:48,795 --> 02:24:51,570
So I'd say watermelon
and our to run it again.

3322
02:24:51,570 --> 02:24:54,940
We could see still unknown
because we didn't print it here.

3323
02:24:54,940 --> 02:24:56,140
So let's print it again.

3324
02:24:57,090 --> 02:24:59,320
If I print it now, it'll say watermelon.

3325
02:24:59,320 --> 02:25:02,710
So I've just only have one
instance of this at all.

3326
02:25:02,710 --> 02:25:05,590
So now even if I were
to create a function,

3327
02:25:05,590 --> 02:25:09,250
so I'll say fun, let's
just call it do stuff.

3328
02:25:09,250 --> 02:25:11,000
And then do stuff is
going to do something.

3329
02:25:11,000 --> 02:25:13,370
And so I'm gonna say, favorite food.name

3330
02:25:16,162 --> 02:25:17,462
is maybe it's chicken now.

3331
02:25:18,400 --> 02:25:20,010
Now, if I come back up
here, I'm just gonna say,

3332
02:25:20,010 --> 02:25:21,210
call, do stuff.

3333
02:25:21,210 --> 02:25:22,043
Oops.

3334
02:25:24,920 --> 02:25:25,860
Say, do stuff.

3335
02:25:27,390 --> 02:25:30,290
Actually we need to define
it before I call it.

3336
02:25:30,290 --> 02:25:32,390
So I'm actually gonna take
this and move this outside

3337
02:25:32,390 --> 02:25:35,470
of our method here.

3338
02:25:37,370 --> 02:25:39,890
So there we go, let's say, do stuff.

3339
02:25:39,890 --> 02:25:42,460
It's gonna call do stuff and
then we'll say print line.

3340
02:25:44,072 --> 02:25:46,650
I want you to print my
favorite food.name again.

3341
02:25:46,650 --> 02:25:48,890
So what we should see here
is we should see unknown

3342
02:25:48,890 --> 02:25:51,004
then we should print watermelon.

3343
02:25:51,004 --> 02:25:52,350
And then by the time we get
here, it should say chicken.

3344
02:25:52,350 --> 02:25:54,930
So even though we're calling
instead of the do stuff method,

3345
02:25:54,930 --> 02:25:57,930
we're calling favorite food
instead of a different scope.

3346
02:25:57,930 --> 02:25:59,470
Right now we're in a main
function scope of here,

3347
02:25:59,470 --> 02:26:01,860
we're in the do stuff method scope.

3348
02:26:01,860 --> 02:26:04,120
What we're gonna see here
is that this is treated

3349
02:26:04,120 --> 02:26:06,180
as a singleton because
there's only one instance

3350
02:26:06,180 --> 02:26:07,013
of it lying around.

3351
02:26:07,013 --> 02:26:09,640
So once we run it, we should
see unknown watermelon

3352
02:26:09,640 --> 02:26:11,790
and chicken as we do here.

3353
02:26:11,790 --> 02:26:14,180
So the same thing can go inside of here.

3354
02:26:14,180 --> 02:26:18,060
For example, if we wanted
to, let's do this right here.

3355
02:26:18,060 --> 02:26:22,250
So favorite food.ingredients.add
let's just say salt,

3356
02:26:25,540 --> 02:26:26,570
everyone loves salt.

3357
02:26:28,247 --> 02:26:30,730
And then I can actually print here.

3358
02:26:30,730 --> 02:26:33,340
So print line, how many
ingredients are here,

3359
02:26:33,340 --> 02:26:34,700
I'll just print the first one's

3360
02:26:34,700 --> 02:26:36,820
a favorite food.ingredients.first.

3361
02:26:37,890 --> 02:26:40,940
It'll print the first one here and then,

3362
02:26:41,795 --> 02:26:43,430
and maybe instead of do so
let's actually run that to see

3363
02:26:43,430 --> 02:26:44,870
what that looks like.

3364
02:26:44,870 --> 02:26:47,530
So we'll see that the salt
is the first ingredient

3365
02:26:47,530 --> 02:26:48,363
that's printed there.

3366
02:26:48,363 --> 02:26:51,500
Now inside of do stuff, again
just to demonstrate this,

3367
02:26:51,500 --> 02:26:54,150
let's just go ahead and say
favorite food.ingredients.clear.

3368
02:26:54,150 --> 02:26:56,300
So we're gonna clear out that list

3369
02:26:56,300 --> 02:26:57,890
and now I wanna print this.

3370
02:26:57,890 --> 02:27:01,180
So kind of put that, so
it's a little more obvious.

3371
02:27:01,180 --> 02:27:05,970
And there we go, kind of
print break them apart.

3372
02:27:05,970 --> 02:27:08,530
If you run this again,
what we'll see here now

3373
02:27:08,530 --> 02:27:09,960
is that the ingredients have been cleared

3374
02:27:09,960 --> 02:27:12,680
and we'll see that this list is empty.

3375
02:27:12,680 --> 02:27:16,810
So now we get an exception
here on main line 14,

3376
02:27:16,810 --> 02:27:18,030
because I'm calling first.

3377
02:27:18,030 --> 02:27:19,480
So what I can do here, something different

3378
02:27:19,480 --> 02:27:22,030
like first or null and
that would actually give me

3379
02:27:22,030 --> 02:27:25,670
a null value sheets should
print null there, which it does.

3380
02:27:25,670 --> 02:27:27,040
So we could say print null.

3381
02:27:28,320 --> 02:27:31,090
And so there's nothing in that
list at this point in time.

3382
02:27:31,090 --> 02:27:35,010
So this is one way that
you can create a singleton

3383
02:27:35,010 --> 02:27:36,240
inside of Kotlin very easily.

3384
02:27:36,240 --> 02:27:39,630
So you're just gonna
replace the class keyword

3385
02:27:39,630 --> 02:27:41,090
with object.

3386
02:27:41,090 --> 02:27:43,230
And of course, you can also put methods

3387
02:27:43,230 --> 02:27:44,220
inside of here as well.

3388
02:27:44,220 --> 02:27:48,670
So you can say fun, you can
say number of ingredients,

3389
02:27:50,070 --> 02:27:51,910
and this can be a very simple method

3390
02:27:52,758 --> 02:27:57,580
that kind of just returns
the ingredients.size.

3391
02:27:57,580 --> 02:28:00,400
And of course, we could just
call that from up here as well.

3392
02:28:00,400 --> 02:28:03,600
So print line, we can say,

3393
02:28:03,600 --> 02:28:06,300
favorite food.number of ingredients.

3394
02:28:07,150 --> 02:28:09,600
And if we run that we
should see zero at the end.

3395
02:28:11,180 --> 02:28:13,080
Oops, it's asking us for a return type

3396
02:28:13,999 --> 02:28:15,430
that I did not specify,
so I wanna say int.

3397
02:28:16,780 --> 02:28:19,190
So I run the (indistinct) say zero.

3398
02:28:19,190 --> 02:28:23,290
If we come back up top here
where I added an ingredient,

3399
02:28:23,290 --> 02:28:28,040
we should see one right after we see salt.

3400
02:28:28,040 --> 02:28:31,340
So we'll see one then chicken,
of course it was cleared out

3401
02:28:31,340 --> 02:28:34,320
inside of the do stuff
method, the ingredients were.

3402
02:28:34,320 --> 02:28:37,530
And then of course we printed
the number of ingredients too.

3403
02:28:37,530 --> 02:28:40,258
So we have a singleton,
we can have properties.

3404
02:28:40,258 --> 02:28:42,000
We can have various
different items in here.

3405
02:28:42,000 --> 02:28:42,860
We can have functions,

3406
02:28:42,860 --> 02:28:44,520
but this is now traded as a singleton.

3407
02:28:44,520 --> 02:28:46,820
I can not create multiple instances of it.

3408
02:28:46,820 --> 02:28:49,600
And if I were to print off, if I have two,

3409
02:28:49,600 --> 02:28:53,960
print ln, favorite food
equals equals favorite food.

3410
02:28:53,960 --> 02:28:55,710
What do we think would happen here,

3411
02:28:57,090 --> 02:28:59,730
is this equal to itself,
is this the same instance?

3412
02:28:59,730 --> 02:29:01,660
Let's take a look here
and we'll see down here,

3413
02:29:01,660 --> 02:29:02,670
we have a true,

3414
02:29:04,516 --> 02:29:06,230
so these are actually
the same exact objects

3415
02:29:06,230 --> 02:29:07,063
that are stored in memory.

3416
02:29:07,063 --> 02:29:09,740
And that's how you can
create a singleton in Kotlin.

3417
02:29:09,740 --> 02:29:11,870
To create a constant inside of Kotlin,

3418
02:29:11,870 --> 02:29:13,530
there are a few ways to do it.

3419
02:29:13,530 --> 02:29:16,180
The first is a local constant.

3420
02:29:16,180 --> 02:29:18,610
Now the is actually let me
say, there's a const keyword

3421
02:29:18,610 --> 02:29:19,950
for helping to find a constant.

3422
02:29:19,950 --> 02:29:23,020
But what you'll see here
is the val is only allowed

3423
02:29:23,020 --> 02:29:25,050
on top level const, excuse me.

3424
02:29:25,050 --> 02:29:27,190
If we get rid of file
here, we'll see that const

3425
02:29:27,190 --> 02:29:28,860
is not applicable for a member function

3426
02:29:28,860 --> 02:29:30,680
or properties in that case.

3427
02:29:30,680 --> 02:29:32,680
So we'll need to get rid of that.

3428
02:29:32,680 --> 02:29:36,170
Now, constants are usually
defined in uppercase

3429
02:29:36,170 --> 02:29:38,030
and separated with underscores

3430
02:29:38,030 --> 02:29:40,030
is kind of the defacto standard

3431
02:29:40,030 --> 02:29:42,490
for many JVM based languages.

3432
02:29:42,490 --> 02:29:44,680
But let's say that we have a constant,

3433
02:29:44,680 --> 02:29:46,620
that's a max age of 18.

3434
02:29:46,620 --> 02:29:50,260
Perhaps this is a application
for a children's application

3435
02:29:50,260 --> 02:29:53,400
and we want the max age to
be 18 for whatever reason.

3436
02:29:53,400 --> 02:29:55,480
Now I can use this inside of here,

3437
02:29:55,480 --> 02:29:58,690
I can say max age and I
can do something with it

3438
02:29:59,530 --> 02:30:00,800
and so forth.

3439
02:30:00,800 --> 02:30:04,090
It's a val, it can't be
changed, so it's a mutable.

3440
02:30:04,090 --> 02:30:06,540
Now, if I'm back inside
of the main function,

3441
02:30:06,540 --> 02:30:08,090
I can still access this though.

3442
02:30:08,090 --> 02:30:09,290
So let's say view user.

3443
02:30:10,365 --> 02:30:11,900
If I still want it to be locked down,

3444
02:30:11,900 --> 02:30:14,670
I would have to actually
provide some level of modifier

3445
02:30:14,670 --> 02:30:17,890
on it to see 'cause we can
access max age right here.

3446
02:30:17,890 --> 02:30:19,730
If I didn't wanna access max age,

3447
02:30:19,730 --> 02:30:22,160
what I would need to do is
throw a visibility modifier

3448
02:30:22,160 --> 02:30:23,940
on there saying, hey, this is private,

3449
02:30:23,940 --> 02:30:27,530
which is private to just
the scope of this class.

3450
02:30:27,530 --> 02:30:29,770
Now main, you'll see here,
we don't have access to.

3451
02:30:29,770 --> 02:30:34,166
So can I access max age,
it's private inside of user.

3452
02:30:34,166 --> 02:30:35,720
So that's the first
way that you can do it.

3453
02:30:35,720 --> 02:30:39,060
Now you can also create
this again is all is scoped

3454
02:30:39,060 --> 02:30:41,040
to the instance of the class.

3455
02:30:41,040 --> 02:30:44,390
So if we were to see max age over here,

3456
02:30:44,390 --> 02:30:46,370
let's say user.max age,

3457
02:30:46,370 --> 02:30:51,370
this max age is scoped the
instance of this user here.

3458
02:30:53,776 --> 02:30:54,609
So it's instance of this user.

3459
02:30:54,609 --> 02:30:58,690
So if you want it to be a
more appropriate constant,

3460
02:30:58,690 --> 02:31:01,170
as you see in our languages,
you would think to do this,

3461
02:31:01,170 --> 02:31:03,550
but what we'd actually need
here is a companion object

3462
02:31:03,550 --> 02:31:05,350
inside the companion object.

3463
02:31:05,350 --> 02:31:10,350
We say, we want to say
const, val max age equals 18.

3464
02:31:10,980 --> 02:31:14,410
Now inside of here again, we
can access max age very easily

3465
02:31:14,410 --> 02:31:17,180
inside of our actual class.

3466
02:31:17,180 --> 02:31:19,927
It's local to the class
we have access to it.

3467
02:31:19,927 --> 02:31:23,370
But however, if we say user max age,

3468
02:31:23,370 --> 02:31:25,600
you'll notice that we don't
have a max age on user.

3469
02:31:25,600 --> 02:31:29,630
But we can access it because it's inside

3470
02:31:29,630 --> 02:31:33,540
of a companion object,
it's scoped to the actual

3471
02:31:33,540 --> 02:31:37,100
to be a Singleton as part
of the user class here,

3472
02:31:37,100 --> 02:31:39,960
it's kind of a Singleton
scoped for the value.

3473
02:31:39,960 --> 02:31:42,180
So it user.max age.

3474
02:31:42,180 --> 02:31:45,040
And there we go, now we can
actually view the max age,

3475
02:31:45,040 --> 02:31:47,700
which means that we can use it outside

3476
02:31:47,700 --> 02:31:49,560
in various different locations.

3477
02:31:49,560 --> 02:31:51,700
So it's basically almost
users almost treated

3478
02:31:51,700 --> 02:31:54,100
as some type of namespace.

3479
02:31:54,100 --> 02:31:56,920
Almost, you could see it
as that way for max age.

3480
02:31:56,920 --> 02:31:58,900
So again, we have the
local type we have inside

3481
02:31:58,900 --> 02:32:00,110
of the companion object.

3482
02:32:01,456 --> 02:32:03,610
Now also a lot of times
you'll notice an applications,

3483
02:32:03,610 --> 02:32:08,030
many people prefer to put their constants

3484
02:32:08,030 --> 02:32:11,570
and maybe to a new file,
they'll call it constants.

3485
02:32:11,570 --> 02:32:12,403
constants.kt.

3486
02:32:14,399 --> 02:32:16,150
And then we'll do is we'll
actually create an object

3487
02:32:16,150 --> 02:32:17,650
and they'll call it constants.

3488
02:32:18,798 --> 02:32:20,915
And you remember when we
use the object keyword,

3489
02:32:20,915 --> 02:32:21,748
that's a Singleton.

3490
02:32:21,748 --> 02:32:25,030
And so what we can say inside
of here there is const val

3491
02:32:25,030 --> 02:32:29,350
max age equals 18.

3492
02:32:29,350 --> 02:32:33,110
And then we might want to say, const, val,

3493
02:32:33,110 --> 02:32:35,200
whatever minimum age requirement is five,

3494
02:32:35,200 --> 02:32:36,530
for whatever reason.

3495
02:32:36,530 --> 02:32:38,970
And then back inside of our main class,

3496
02:32:38,970 --> 02:32:42,140
we can then use that as we've
seen in other languages.

3497
02:32:42,140 --> 02:32:47,120
So constants.max age, we
have constant.mean age

3498
02:32:47,120 --> 02:32:49,240
that we can also access as well.

3499
02:32:49,240 --> 02:32:52,240
Now, these all don't have
to be inside of objects

3500
02:32:52,240 --> 02:32:55,230
or classes or anything that
can be also at a top level.

3501
02:32:55,230 --> 02:32:57,340
So it can just kind of
be floating on their own

3502
02:32:57,340 --> 02:32:58,900
in their own files.

3503
02:32:58,900 --> 02:33:03,320
So maybe we wanna have
implementation that looks like this.

3504
02:33:03,320 --> 02:33:08,140
Say, const val max age equals 18.

3505
02:33:08,140 --> 02:33:10,899
Now this could be referenced over here.

3506
02:33:10,899 --> 02:33:11,880
There's max ages in the root of the file.

3507
02:33:11,880 --> 02:33:13,630
I can be over here instead of user.

3508
02:33:14,944 --> 02:33:18,520
I could say something like this, max age.

3509
02:33:18,520 --> 02:33:20,260
Now this is again, when
we go to implementation,

3510
02:33:20,260 --> 02:33:23,328
it's going to this root
level file over here.

3511
02:33:23,328 --> 02:33:25,450
Now, which one should you use?

3512
02:33:25,450 --> 02:33:29,650
I prefer to keep any of the
constants that are applicable

3513
02:33:29,650 --> 02:33:32,250
to the user inside of the user class.

3514
02:33:32,250 --> 02:33:35,030
So I would have a companion object for me,

3515
02:33:35,030 --> 02:33:37,630
and I would put const val max age,

3516
02:33:37,630 --> 02:33:39,580
if this was only pertinent to the user.

3517
02:33:40,442 --> 02:33:42,090
If I have a constant that
is going to be shared

3518
02:33:42,090 --> 02:33:44,660
across many different
parts of the application,

3519
02:33:44,660 --> 02:33:47,230
at that time, I might put
a create a constants file

3520
02:33:47,230 --> 02:33:49,720
where it's an object
and I call it constants.

3521
02:33:49,720 --> 02:33:52,730
And then I have const val, et cetera,

3522
02:33:52,730 --> 02:33:54,600
ABC, whatever the value is,

3523
02:33:54,600 --> 02:33:57,420
and it could be food or whatever.

3524
02:33:57,420 --> 02:33:59,050
And then I can access that from anywhere

3525
02:33:59,050 --> 02:34:02,660
inside of my application
using the constants

3526
02:34:03,940 --> 02:34:07,300
as kind of a default standard there.

3527
02:34:07,300 --> 02:34:09,330
So that's the way that I would do it.

3528
02:34:09,330 --> 02:34:12,290
If you're going to need
constants, I prefer to scope them

3529
02:34:12,290 --> 02:34:13,690
to the class that they have.

3530
02:34:14,891 --> 02:34:17,410
Again, if I don't need this
constant on the outside,

3531
02:34:17,410 --> 02:34:20,210
I don't need it visible
on the outside of this,

3532
02:34:20,210 --> 02:34:22,120
then what you can also do is just go ahead

3533
02:34:22,120 --> 02:34:24,390
and you don't even have to
use the companion object

3534
02:34:24,390 --> 02:34:27,510
if you don't want to and
you can just mark this

3535
02:34:27,510 --> 02:34:31,900
as a private and that can
be just stored as a max age.

3536
02:34:32,890 --> 02:34:35,460
Now, what you so think about
it as if you were on too,

3537
02:34:35,460 --> 02:34:38,300
this is going to be
stored around as a class,

3538
02:34:38,300 --> 02:34:39,420
part of the class as well.

3539
02:34:39,420 --> 02:34:41,530
So if you don't want that
as part of the class,

3540
02:34:41,530 --> 02:34:44,020
you can just put it inside
the companion object

3541
02:34:44,020 --> 02:34:45,620
and you can mark this as private

3542
02:34:46,533 --> 02:34:47,366
inside the companion object.

3543
02:34:47,366 --> 02:34:49,860
It will still be visible
inside of your class.

3544
02:34:49,860 --> 02:34:51,830
So max age here, but if we go back

3545
02:34:51,830 --> 02:34:55,050
to the main implementation
and we say user,

3546
02:34:56,252 --> 02:34:57,540
and we create a new user again,

3547
02:34:59,857 --> 02:35:02,350
and I try to access that
user max age will notice

3548
02:35:02,350 --> 02:35:05,520
that it's not available because
I've marked it as private.

3549
02:35:05,520 --> 02:35:08,850
So now if I remove private
and I go back back to here,

3550
02:35:08,850 --> 02:35:13,170
let's see we have access user.max age.

3551
02:35:14,494 --> 02:35:18,517
If we go here, private
user.max age is not,

3552
02:35:19,500 --> 02:35:20,910
we can't even access it inside of here,

3553
02:35:20,910 --> 02:35:25,140
even though it's scoped to the class V

3554
02:35:25,140 --> 02:35:26,890
in the companion object,
I don't have access

3555
02:35:26,890 --> 02:35:29,320
because we've slapped the
private modifier on there.

3556
02:35:29,320 --> 02:35:34,270
So again, just to recap, if
you wanna have your constants,

3557
02:35:34,270 --> 02:35:36,670
I prefer to keep them
scoped locally to the class

3558
02:35:36,670 --> 02:35:37,503
that they belong to.

3559
02:35:37,503 --> 02:35:39,800
If they can be accessed and
are usable by many classes

3560
02:35:39,800 --> 02:35:41,850
and have kind of cutting concerns,

3561
02:35:42,770 --> 02:35:45,080
I will then usually put them
in some type of constants file.

3562
02:35:45,080 --> 02:35:48,080
I rarely will ever use
them at a root level,

3563
02:35:48,080 --> 02:35:51,910
such as this const val foo
or whatever equals var.

3564
02:35:51,910 --> 02:35:54,640
These are something
things that I don't do,

3565
02:35:54,640 --> 02:35:57,040
some of them, because these
are kind of just randomly

3566
02:35:57,040 --> 02:36:00,560
floating around in some unknown space

3567
02:36:00,560 --> 02:36:02,550
and don't seem to be scoped too well.

3568
02:36:02,550 --> 02:36:04,580
I have to keep things
organized in my application.

3569
02:36:04,580 --> 02:36:06,200
So it depends on what your use cases,

3570
02:36:06,200 --> 02:36:08,960
but that's how you can
create a constant in Kotlin.

3571
02:36:08,960 --> 02:36:12,360
Let's say you're building a
wizard to create a new user

3572
02:36:12,360 --> 02:36:13,330
through some type of screen.

3573
02:36:13,330 --> 02:36:17,750
And you know that you want
a to store the favorite city

3574
02:36:17,750 --> 02:36:19,560
of a particular user in a variable.

3575
02:36:20,460 --> 02:36:22,290
And so you could say it's a string.

3576
02:36:23,210 --> 02:36:26,530
Now, by default, we can't
just leave this uninitialized,

3577
02:36:26,530 --> 02:36:29,208
we're gonna get an error
here that says the property

3578
02:36:29,208 --> 02:36:30,041
must be initialized.

3579
02:36:30,041 --> 02:36:32,840
And so we could say empty
string, now that would work.

3580
02:36:32,840 --> 02:36:36,830
So what we could say here
is when we print this

3581
02:36:36,830 --> 02:36:38,310
to the screen, we don't wanna say,

3582
02:36:38,310 --> 02:36:41,783
so say Donn Felker's favorite city is,

3583
02:36:43,330 --> 02:36:47,536
and then we'd print the
favorite city so forth.

3584
02:36:47,536 --> 02:36:48,501
We can print the favorite city.

3585
02:36:48,501 --> 02:36:51,900
So let's go back to the main file here.

3586
02:36:51,900 --> 02:36:55,580
And inside of here,
what we can say is user,

3587
02:36:55,580 --> 02:36:58,161
we'll create the new user
and it will print the user

3588
02:36:58,161 --> 02:36:59,266
to the screen.

3589
02:36:59,266 --> 02:37:01,080
And when we print it, we'll
see Donn Felker's favorite city

3590
02:37:01,080 --> 02:37:03,930
is blank, but now, however,
this isn't really useful.

3591
02:37:03,930 --> 02:37:06,330
Kotlin does provide us with
the ability to say like,

3592
02:37:06,330 --> 02:37:10,210
hey, I know I'm gonna need a variable

3593
02:37:10,210 --> 02:37:12,160
and I know that I need it populated,

3594
02:37:12,160 --> 02:37:15,380
but I kind of know that
it's not gonna be populated

3595
02:37:15,380 --> 02:37:17,870
just yet, so just go ahead and trust me,

3596
02:37:17,870 --> 02:37:20,120
I'm going to initialize this thing,

3597
02:37:20,120 --> 02:37:22,890
but I'm not gonna do it in right away.

3598
02:37:22,890 --> 02:37:24,410
So basically as soon as it's variable,

3599
02:37:24,410 --> 02:37:29,087
it's properties declared,
it's not ready to use.

3600
02:37:30,470 --> 02:37:31,830
And I'm telling Kotlin, hey, that's okay,

3601
02:37:31,830 --> 02:37:35,280
because I'm going to initialize
it later at some point.

3602
02:37:35,280 --> 02:37:38,490
But let's assume for some reason
that I don't initialize it.

3603
02:37:38,490 --> 02:37:39,790
So what's gonna happen here

3604
02:37:39,790 --> 02:37:42,100
when we call the two string method,

3605
02:37:42,100 --> 02:37:43,330
let's go back to the main file.

3606
02:37:43,330 --> 02:37:47,130
So we haven't told Kotlin
about the favorite city at all.

3607
02:37:47,130 --> 02:37:49,920
Now, if we run this again,
what we're going to notice

3608
02:37:49,920 --> 02:37:52,100
is we're going to get Kotlin blows up here

3609
02:37:52,100 --> 02:37:55,330
and throws an uninitialized
property access exception.

3610
02:37:55,330 --> 02:37:58,325
And it says that the late in it property

3611
02:37:58,325 --> 02:37:59,940
from my favorite city
has not been initialized.

3612
02:37:59,940 --> 02:38:01,620
So Kotlin's basically
letting us know like,

3613
02:38:01,620 --> 02:38:04,890
hey, you told me that you
were going to initialize

3614
02:38:04,890 --> 02:38:07,220
favorite city at some
point before you used it.

3615
02:38:07,220 --> 02:38:12,220
However, you tried to use it
down here on user line eight,

3616
02:38:12,380 --> 02:38:13,790
which were on here.

3617
02:38:13,790 --> 02:38:16,190
You used it down here and
it wasn't initialized.

3618
02:38:17,280 --> 02:38:19,860
We're not allowing that to
happen, we're gonna blow up,

3619
02:38:19,860 --> 02:38:21,660
and Kotlin throws the uninitialized

3620
02:38:22,534 --> 02:38:23,367
property access exceptions.

3621
02:38:23,367 --> 02:38:26,450
So now the nice thing here is easy to fix.

3622
02:38:26,450 --> 02:38:29,840
So this allows me some
kind of some safety to know

3623
02:38:30,731 --> 02:38:32,030
that my application is working correctly,

3624
02:38:32,030 --> 02:38:34,090
that I've actually initialized
this because I do need

3625
02:38:34,090 --> 02:38:36,170
a favorite city, I do need to populate it,

3626
02:38:36,170 --> 02:38:39,093
and I want it to blow up if it doesn't.

3627
02:38:39,093 --> 02:38:40,220
So now it's that user, that favorite city.

3628
02:38:40,220 --> 02:38:42,780
And I could say, let's
go ahead and go with it,

3629
02:38:42,780 --> 02:38:46,820
Newark is a great place,
so Newark and the wide run.

3630
02:38:49,489 --> 02:38:50,322
And that's not really my favorite city,

3631
02:38:50,322 --> 02:38:53,960
but we have Donn Felker's
favorite city is Newark.

3632
02:38:53,960 --> 02:38:55,290
Now we don't get a blowing up anymore.

3633
02:38:55,290 --> 02:38:57,600
So I could even set
this to an empty string.

3634
02:38:57,600 --> 02:38:58,750
That's fine as well.

3635
02:38:58,750 --> 02:39:00,830
But not at least that's been initialized,

3636
02:39:00,830 --> 02:39:04,210
I've told Kotlin like, hey,
I could say Minneapolis,

3637
02:39:05,260 --> 02:39:07,870
which is one of my favorite
cities and we'll print off here.

3638
02:39:07,870 --> 02:39:11,320
So we'll see Minneapolis and
we'll see it's populated.

3639
02:39:11,320 --> 02:39:14,780
So that's one way that you can
do it with a late initialized

3640
02:39:14,780 --> 02:39:16,580
property inside of your application.

3641
02:39:17,575 --> 02:39:18,420
This could be a string, it
could be another object,

3642
02:39:18,420 --> 02:39:19,990
it could be any of that nature.

3643
02:39:19,990 --> 02:39:23,880
You're basically telling
Kotlin, hey, I'm going to need

3644
02:39:23,880 --> 02:39:27,790
some type of variable that
I don't know what it is yet,

3645
02:39:27,790 --> 02:39:30,159
but I do need it populated
before I can use it.

3646
02:39:30,159 --> 02:39:31,780
So I'm not gonna initialize it here,

3647
02:39:31,780 --> 02:39:35,552
it's just gonna be initialized
later, so late init,

3648
02:39:35,552 --> 02:39:37,040
so it's late initialization.

3649
02:39:37,950 --> 02:39:40,110
So just if I don't initialize it, blow up.

3650
02:39:40,110 --> 02:39:41,330
Now, one important thing.

3651
02:39:41,330 --> 02:39:43,430
If we say, hey, well, this
is a mutable property,

3652
02:39:43,430 --> 02:39:44,920
I don't want it to be immutable.

3653
02:39:44,920 --> 02:39:46,620
Well, if we try that,
what we'll notice here

3654
02:39:46,620 --> 02:39:49,996
is we get this error that says
the late and init modifier

3655
02:39:49,996 --> 02:39:50,829
is only allowed on mutable properties.

3656
02:39:50,829 --> 02:39:52,620
And well, if we think
about that, the reason why

3657
02:39:52,620 --> 02:39:57,620
is because we have to
mutate it as soon as,

3658
02:39:57,690 --> 02:39:59,538
whenever we wanna change it.

3659
02:39:59,538 --> 02:40:00,800
So it has to be a mutable variable.

3660
02:40:00,800 --> 02:40:03,240
Otherwise it would be defined immediately.

3661
02:40:03,240 --> 02:40:07,210
So as soon as it's defined,
if this were this way,

3662
02:40:07,210 --> 02:40:08,480
of course, we're gonna get an error.

3663
02:40:08,480 --> 02:40:11,750
But if we were to define this as NYC,

3664
02:40:11,750 --> 02:40:13,410
it would work just fine.

3665
02:40:13,410 --> 02:40:18,410
But since we are using late
init, it has to be a var.

3666
02:40:18,780 --> 02:40:20,840
And that's how you can define a late init

3667
02:40:20,840 --> 02:40:21,890
and use it in Kotlin.

3668
02:40:23,150 --> 02:40:25,720
Let's say that you wanted to have classes

3669
02:40:25,720 --> 02:40:28,980
nested with init themselves,
Kotlin supports that.

3670
02:40:28,980 --> 02:40:32,020
So let's say you have
a class called vehicle

3671
02:40:32,020 --> 02:40:35,350
and the class vehicle has a brand

3672
02:40:35,350 --> 02:40:36,790
and the brand is gonna be string

3673
02:40:36,790 --> 02:40:39,870
and we'll just default that
to unknown at this time.

3674
02:40:39,870 --> 02:40:42,250
Now, perhaps a vehicle also has a type

3675
02:40:42,250 --> 02:40:44,690
of a steering wheel class
for whatever reason.

3676
02:40:44,690 --> 02:40:46,740
So we have a steering wheel.

3677
02:40:46,740 --> 02:40:51,220
So we actually put this class
inside of the vehicle class.

3678
02:40:51,220 --> 02:40:55,290
And then I could say
something like this file name,

3679
02:40:55,290 --> 02:40:58,370
or we made some var or
whatever we wanted to do.

3680
02:40:58,370 --> 02:41:03,277
And we could say the steering
wheel and inside of here,

3681
02:41:05,597 --> 02:41:07,980
we could even provide a
function of some sorts.

3682
02:41:07,980 --> 02:41:11,080
Let's say, fun info and
then we could just say,

3683
02:41:11,080 --> 02:41:14,030
could be a print line of some
sorts of all inline function.

3684
02:41:15,200 --> 02:41:17,870
And we would say name, we print the name.

3685
02:41:17,870 --> 02:41:19,750
Now, if we wanted to use this class,

3686
02:41:19,750 --> 02:41:23,150
we could actually very
easily come up here and say,

3687
02:41:23,150 --> 02:41:25,979
val steering SW for steering wheel,

3688
02:41:25,979 --> 02:41:29,610
say vehicle.steering wheel,
create a new instance of it.

3689
02:41:29,610 --> 02:41:32,220
And then I could say sw.info.

3690
02:41:32,220 --> 02:41:34,820
And if we were to run this,
we will see that it prints

3691
02:41:34,820 --> 02:41:37,280
the steering wheel, which is we see here.

3692
02:41:37,280 --> 02:41:39,910
Now we can also, we're not
limited to just one class,

3693
02:41:39,910 --> 02:41:42,990
we can have multiple different
classes inside of here.

3694
02:41:42,990 --> 02:41:46,470
So we could have a class
and we could call this one

3695
02:41:46,470 --> 02:41:47,560
a transmission.

3696
02:41:48,830 --> 02:41:50,600
And perhaps we just, for whatever reason,

3697
02:41:50,600 --> 02:41:52,750
we're building some automotive software

3698
02:41:52,750 --> 02:41:56,520
and we're going to have a var type

3699
02:41:56,520 --> 02:41:58,970
and it could be run a
default, this to automatic.

3700
02:42:00,360 --> 02:42:03,180
And then of course, maybe
we might have a function

3701
02:42:03,180 --> 02:42:07,360
called shift and we'll
just have it print off

3702
02:42:07,360 --> 02:42:10,430
something like that say, print, print ln.

3703
02:42:12,031 --> 02:42:13,480
And it will say the vehicle has shifted.

3704
02:42:17,250 --> 02:42:19,120
And what now we can do is of course

3705
02:42:20,170 --> 02:42:22,420
we have the steering wheel
where you don't have an instance

3706
02:42:22,420 --> 02:42:27,090
of the transmission, we
would say val transmission

3707
02:42:28,150 --> 02:42:30,510
equals vehicle.transmission.

3708
02:42:32,170 --> 02:42:34,320
Of course, in that we'd
say transmission.shift.

3709
02:42:35,620 --> 02:42:37,220
And of course, we're gonna
see when we run this,

3710
02:42:37,220 --> 02:42:39,030
we'll see the steering
wheel and then we'll see

3711
02:42:39,030 --> 02:42:40,660
the vehicle has shifted.

3712
02:42:40,660 --> 02:42:44,701
So now each time if we were
to run this multiple times,

3713
02:42:44,701 --> 02:42:47,080
we'd see the vehicle
shifted twice, very simple.

3714
02:42:47,080 --> 02:42:50,170
So we can actually nest
classes inside of here.

3715
02:42:50,170 --> 02:42:51,930
Now notice we haven't done
anything with the brand here.

3716
02:42:51,930 --> 02:42:54,100
So we could also have some information

3717
02:42:54,100 --> 02:42:59,100
about the info function here
and this one is just print off

3718
02:42:59,810 --> 02:43:02,760
the brand here of the vehicle.

3719
02:43:03,620 --> 02:43:07,152
And the brand of the vehicle
will kind of print off there.

3720
02:43:07,152 --> 02:43:09,282
And let's actually set this
to a var 'cause we know

3721
02:43:09,282 --> 02:43:10,115
we're probably gonna change that as well.

3722
02:43:10,115 --> 02:43:15,070
So maybe we wanna do something
like this val vehicle

3723
02:43:16,250 --> 02:43:20,300
equals vehicle and move
on to change the vehicle

3724
02:43:20,300 --> 02:43:25,037
to brand equals Fiat vehicle.info.

3725
02:43:27,354 --> 02:43:29,280
So we'll print it, we'll see Fiat

3726
02:43:29,280 --> 02:43:30,900
and then we'll see the steering wheel

3727
02:43:30,900 --> 02:43:34,050
and the vehicle shifted and
the vehicle has shifted.

3728
02:43:34,050 --> 02:43:37,210
So that's how we can nest
classes inside of Kotlin.

3729
02:43:37,210 --> 02:43:40,580
And it's useful for when
things are somewhat related

3730
02:43:40,580 --> 02:43:43,400
and you wanna kind of keep a
class hierarchy accordingly.

3731
02:43:43,400 --> 02:43:44,540
So he might have a vehicle.

3732
02:43:44,540 --> 02:43:46,430
And inside of that,
there's a steering wheel.

3733
02:43:46,430 --> 02:43:49,297
So as we're creating
it, we can kind of see

3734
02:43:49,297 --> 02:43:50,130
that these things are related.

3735
02:43:50,130 --> 02:43:52,030
So there's many different related domains

3736
02:43:52,030 --> 02:43:54,010
that you're gonna encounter in software.

3737
02:43:55,094 --> 02:43:56,960
This is one way to organize
them with nested classes.

3738
02:43:57,970 --> 02:44:00,310
Kotlin is nested classes
are easy to create.

3739
02:44:00,310 --> 02:44:02,760
Inside of another class,
you can have another class

3740
02:44:02,760 --> 02:44:04,850
to create different types of hierarchies.

3741
02:44:04,850 --> 02:44:07,550
However, there are times
when you would like to access

3742
02:44:08,470 --> 02:44:10,870
instance variables and
methods and so forth

3743
02:44:10,870 --> 02:44:12,890
inside of an nesting class.

3744
02:44:12,890 --> 02:44:14,910
So let's assume the steering wheel,

3745
02:44:14,910 --> 02:44:16,430
we wanted to print the brand name.

3746
02:44:16,430 --> 02:44:21,430
So we would say brand of
car is the brand of the car,

3747
02:44:23,100 --> 02:44:27,990
a vehicle with a boom name.

3748
02:44:30,614 --> 02:44:32,687
We'll call it the steering
wheel and we'll call it with

3749
02:44:35,750 --> 02:44:39,400
leather, say leather with
a leather steering wheel.

3750
02:44:41,200 --> 02:44:43,930
Now, notice we have an error
here, brand is not accessible.

3751
02:44:43,930 --> 02:44:47,660
The reason for that is by
default nesting classes

3752
02:44:47,660 --> 02:44:50,890
do not have access to the member variables

3753
02:44:50,890 --> 02:44:52,820
of the outer class.

3754
02:44:52,820 --> 02:44:54,830
If we want to do that, we need to specify

3755
02:44:54,830 --> 02:44:58,330
that this is an inner class of vehicle.

3756
02:44:58,330 --> 02:45:00,880
So vehicle has an inner
class and the inner class

3757
02:45:00,880 --> 02:45:02,700
can now access these variables.

3758
02:45:02,700 --> 02:45:05,310
So, you can see brand is
the brand new vehicle.

3759
02:45:05,310 --> 02:45:07,640
So let's go ahead and get rid of this.

3760
02:45:08,790 --> 02:45:11,750
And then we can say, Fiat
is the brand, vehicle info.

3761
02:45:11,750 --> 02:45:16,110
Now we see here, the steering
wheel is the constructor

3762
02:45:16,110 --> 02:45:18,620
of steering wheel can only
be called with the receiver

3763
02:45:18,620 --> 02:45:19,900
of the containing class.

3764
02:45:20,760 --> 02:45:23,240
Now, what that means is
because steering wheel

3765
02:45:23,240 --> 02:45:25,680
has access to the member variables,

3766
02:45:26,929 --> 02:45:29,900
it's gonna have carries a
reference to the outer class.

3767
02:45:29,900 --> 02:45:33,660
Meaning that we can't use the
actual class name vehicle,

3768
02:45:33,660 --> 02:45:35,240
we actually have to use the instance

3769
02:45:35,240 --> 02:45:37,450
because string was gonna
carry a reference to it.

3770
02:45:37,450 --> 02:45:40,400
So we have an instance of
vehicle here is called vehicle.

3771
02:45:40,400 --> 02:45:41,950
So I'm just gonna go ahead and delete this

3772
02:45:41,950 --> 02:45:44,130
'cause it's the capital
V, which is the class name

3773
02:45:44,130 --> 02:45:46,050
when we go to the lower case V.

3774
02:45:46,050 --> 02:45:49,730
Now, if we wanna just
change this and call my car,

3775
02:45:49,730 --> 02:45:52,190
we can do that, so it's called my car.

3776
02:45:52,190 --> 02:45:54,840
And now I can say my car.steering wheel

3777
02:45:54,840 --> 02:45:57,040
and then we're gonna actually
see, it's gonna create

3778
02:45:57,040 --> 02:45:58,350
an instance of the steering wheel class.

3779
02:45:58,350 --> 02:46:01,370
We're gonna see steering
wheel.info, which is right here.

3780
02:46:01,370 --> 02:46:02,970
Now, if we go to info,
we'll see it's print off

3781
02:46:02,970 --> 02:46:05,950
the brand of the vehicle and
let's go ahead and run this.

3782
02:46:05,950 --> 02:46:09,590
And what we will see now is
that when it runs, it says Fiat,

3783
02:46:09,590 --> 02:46:12,440
Fiat is the brand of vehicle
with leather steering wheel.

3784
02:46:12,440 --> 02:46:16,230
Now, since the transmission
is still a nested class,

3785
02:46:16,230 --> 02:46:19,800
we cannot call my car.transmission.

3786
02:46:20,840 --> 02:46:23,170
So the reason for that
is it's a nested class.

3787
02:46:23,170 --> 02:46:25,870
If we wanted to create a transmission,

3788
02:46:25,870 --> 02:46:30,230
we would have to say vehicle.transmission.

3789
02:46:31,370 --> 02:46:34,590
Now we wanted to make this a inner class,

3790
02:46:34,590 --> 02:46:36,674
of course, we'd slap on the word enter.

3791
02:46:36,674 --> 02:46:37,520
And now of course, this
is not going to work.

3792
02:46:37,520 --> 02:46:40,250
we have to use an instance
because the transmission

3793
02:46:40,250 --> 02:46:42,440
is going to have a reference
to its outer class.

3794
02:46:42,440 --> 02:46:45,630
So in that case, when we create
an instance of transmission,

3795
02:46:46,922 --> 02:46:50,230
it's gonna keep a reference to
the instance of my car here.

3796
02:46:51,450 --> 02:46:53,150
And that's how you create an inner class,

3797
02:46:53,150 --> 02:46:56,110
which can reference an
outer class in Kotlin.

3798
02:46:56,110 --> 02:46:58,150
Often during development,
you'll need to create

3799
02:46:58,150 --> 02:47:01,930
some type of construct that shows you

3800
02:47:01,930 --> 02:47:04,750
what different types
you have to work with.

3801
02:47:04,750 --> 02:47:07,080
And for example, we might
wanna have something

3802
02:47:07,080 --> 02:47:08,120
different account types.

3803
02:47:08,120 --> 02:47:12,630
Maybe we have various different
users who have account types

3804
02:47:12,630 --> 02:47:15,340
and they look something like this.

3805
02:47:15,340 --> 02:47:19,210
So we have one that's
a bronze account type,

3806
02:47:19,210 --> 02:47:21,070
we have a silver account type.

3807
02:47:21,070 --> 02:47:23,650
There's a gold and there's a platinum.

3808
02:47:25,726 --> 02:47:28,540
Very often you'll see these,
for example, the credit cards

3809
02:47:28,540 --> 02:47:30,740
or different types of gym memberships

3810
02:47:30,740 --> 02:47:32,370
or something like that.

3811
02:47:32,370 --> 02:47:34,290
And if you're modeling
something like this,

3812
02:47:34,290 --> 02:47:36,766
you'll wanna create a user defined type.

3813
02:47:36,766 --> 02:47:38,912
And that's typically done with an enum.

3814
02:47:38,912 --> 02:47:41,760
And to define an enum, you will
use the keywords enum class.

3815
02:47:41,760 --> 02:47:44,840
And then for example, I'm gonna
call this one account type.

3816
02:47:44,840 --> 02:47:46,920
And then by default, inside of enums,

3817
02:47:46,920 --> 02:47:49,180
if you give the names of the types,

3818
02:47:49,180 --> 02:47:51,570
which is your user defined
type, you uppercase them.

3819
02:47:51,570 --> 02:47:56,440
So we'll say bronze, and then
they're separated by commas.

3820
02:47:56,440 --> 02:48:00,420
So silver, gold, platinum.

3821
02:48:01,940 --> 02:48:02,800
And then if I wanna use the account types,

3822
02:48:02,800 --> 02:48:04,820
which we'll get rid of this now,

3823
02:48:04,820 --> 02:48:09,100
I can just say account type.gold.

3824
02:48:10,060 --> 02:48:11,840
And now I have an instance of gold,

3825
02:48:11,840 --> 02:48:13,540
so I can start representing
something like that.

3826
02:48:13,540 --> 02:48:16,090
So if I were to just to print line this,

3827
02:48:17,320 --> 02:48:20,290
and these are very useful
inside of various different

3828
02:48:20,290 --> 02:48:22,950
if statements and conditional
clauses and so forth,

3829
02:48:22,950 --> 02:48:24,350
so we can see gold there.

3830
02:48:24,350 --> 02:48:27,450
Now, this is something in Kotlin.

3831
02:48:27,450 --> 02:48:29,190
Anytime you're interacting
with an application,

3832
02:48:29,190 --> 02:48:34,190
a lot of times you'll be
talking to API and perhaps

3833
02:48:34,280 --> 02:48:37,820
you'll get a value down a that's
gold like that from an API.

3834
02:48:37,820 --> 02:48:39,750
And so you need to create
an account type off of that.

3835
02:48:39,750 --> 02:48:44,170
And to do that, you can use
the account type that value of,

3836
02:48:44,170 --> 02:48:46,110
and then perhaps you would say,

3837
02:48:46,110 --> 02:48:48,860
so let's say we had a
string that was given to us

3838
02:48:48,860 --> 02:48:51,230
from an input somewhere, maybe an API,

3839
02:48:52,150 --> 02:48:57,130
and we'll call this account type from API.

3840
02:48:59,161 --> 02:49:00,540
And then we'll just call it gold.

3841
02:49:00,540 --> 02:49:03,580
And if we wanna in turn
this gold right here

3842
02:49:03,580 --> 02:49:08,580
into an actual account type,
then we'll say account type,

3843
02:49:08,760 --> 02:49:12,550
we'll see value of, and we'll
say account type from API.

3844
02:49:12,550 --> 02:49:16,180
Now, if we've run this,
we're gonna run this here

3845
02:49:16,180 --> 02:49:18,330
and we'll see that well, that didn't work.

3846
02:49:18,330 --> 02:49:21,580
There's no enum constant by
the name of account.gold,

3847
02:49:21,580 --> 02:49:23,430
but we do see one here.

3848
02:49:23,430 --> 02:49:25,084
So what's going on here?

3849
02:49:25,084 --> 02:49:26,930
Well, the reason is, is because
this is an uppercase value.

3850
02:49:26,930 --> 02:49:30,460
So we can just say here to uppercase.

3851
02:49:30,460 --> 02:49:32,970
And if we run this again,
we'll see that it runs

3852
02:49:32,970 --> 02:49:34,230
a compile is just fine.

3853
02:49:34,230 --> 02:49:35,540
That gives us our account types.

3854
02:49:35,540 --> 02:49:37,790
So now we can actually say print line

3855
02:49:38,640 --> 02:49:41,230
and we're gonna actually say account type,

3856
02:49:41,230 --> 02:49:44,230
and it'll say gold as we see here.

3857
02:49:44,230 --> 02:49:46,940
So now we actually have an
instance of gold, which is nice.

3858
02:49:46,940 --> 02:49:48,050
So we can actually account type,

3859
02:49:48,050 --> 02:49:50,660
does this actually equal
and account type of gold?

3860
02:49:51,740 --> 02:49:53,640
So this should return
true, which we get running

3861
02:49:53,640 --> 02:49:55,010
and say, it's true.

3862
02:49:55,010 --> 02:49:57,160
So now we can actually enter work with

3863
02:49:57,160 --> 02:49:58,870
these different types of enums.

3864
02:49:58,870 --> 02:50:01,350
Now, a lot of times this is very useful

3865
02:50:01,350 --> 02:50:03,370
inside of conditionals and different types

3866
02:50:03,370 --> 02:50:04,203
of things like that.

3867
02:50:04,203 --> 02:50:06,650
So you might have your user class,

3868
02:50:06,650 --> 02:50:09,120
which if we go back over here
to our typical user class

3869
02:50:09,120 --> 02:50:12,070
that we have, we might have
a user that's associated

3870
02:50:12,070 --> 02:50:12,903
with account type.

3871
02:50:12,903 --> 02:50:16,560
So we might have a var account type,

3872
02:50:16,560 --> 02:50:20,180
and that would be an
account type of whatever,

3873
02:50:23,620 --> 02:50:26,280
and we might wanna default
it to account type.bronze.

3874
02:50:26,280 --> 02:50:28,540
Maybe that's what it defaults to,

3875
02:50:28,540 --> 02:50:32,020
or instead of doing it here,
we could actually just do it,

3876
02:50:32,020 --> 02:50:34,170
put this all up inside of the constructor

3877
02:50:34,170 --> 02:50:36,480
and have it use a default value.

3878
02:50:36,480 --> 02:50:39,220
So account type, and we don't need that

3879
02:50:39,220 --> 02:50:41,010
and say account type
equals, but we do need that.

3880
02:50:41,010 --> 02:50:43,280
Excuse me, account type
people's the bronze.

3881
02:50:43,280 --> 02:50:45,130
And then if we decide to override it,

3882
02:50:45,981 --> 02:50:49,650
for example, we could
say val user equals user,

3883
02:50:52,392 --> 02:50:54,247
and then we don't wanna say Donn Felker.

3884
02:50:55,900 --> 02:50:58,697
And then I don't have it
provide an account type.

3885
02:50:58,697 --> 02:50:59,830
But if I would, if I'd like to, I can say,

3886
02:50:59,830 --> 02:51:02,210
well, he's actually going
to be a platinum account,

3887
02:51:02,210 --> 02:51:03,043
for whatever reason,

3888
02:51:03,043 --> 02:51:05,240
he's a good customer
or something like that.

3889
02:51:06,500 --> 02:51:08,610
And now I can actually
start working with this.

3890
02:51:08,610 --> 02:51:13,610
And then in my application,
I can say user.account type,

3891
02:51:13,840 --> 02:51:16,500
I can then do some
different types of things

3892
02:51:16,500 --> 02:51:19,136
with conditionals inside of that

3893
02:51:19,136 --> 02:51:19,969
and then start working with it.

3894
02:51:19,969 --> 02:51:21,590
And it gives us some user-defined types

3895
02:51:21,590 --> 02:51:23,300
that are basically strongly typed.

3896
02:51:24,321 --> 02:51:26,180
We're not working with strings
doing string comparisons,

3897
02:51:26,180 --> 02:51:28,100
and we can work with them accordingly.

3898
02:51:29,280 --> 02:51:33,560
That's how you can create and
work with very basic enums

3899
02:51:33,560 --> 02:51:35,220
and define them in Kotlin.

3900
02:51:36,340 --> 02:51:38,280
Sometimes it's useful to provide values

3901
02:51:38,280 --> 02:51:39,670
associated with an enum.

3902
02:51:40,752 --> 02:51:42,927
For example, if this was
used for gym membership,

3903
02:51:42,927 --> 02:51:46,590
let's assume that if you're
a bronze account type,

3904
02:51:46,590 --> 02:51:50,490
you're going to then
get, let's say 10% off.

3905
02:51:50,490 --> 02:51:53,840
If you're silver, you're
gonna get 15% off.

3906
02:51:53,840 --> 02:51:56,320
If you're gold, you're gonna get 20% off.

3907
02:51:56,320 --> 02:51:59,620
And if you are a platinum
customer, you're gonna 25% off,

3908
02:51:59,620 --> 02:52:03,360
maybe bronze is a single
member, this is two, this is 10.

3909
02:52:03,360 --> 02:52:04,830
This is more than 10.

3910
02:52:04,830 --> 02:52:07,500
So start getting more
discounts for more members

3911
02:52:07,500 --> 02:52:09,090
on your plan or whatever.

3912
02:52:09,090 --> 02:52:10,250
So how would you define this?

3913
02:52:10,250 --> 02:52:12,330
Now, what you need to do
is provide a constructor

3914
02:52:12,330 --> 02:52:13,770
for your enum.

3915
02:52:13,770 --> 02:52:17,680
And so what you would do is
you'd say val discount percent,

3916
02:52:17,680 --> 02:52:19,730
and this can be any number of things,

3917
02:52:19,730 --> 02:52:22,510
but we'll make this an int, it
could be floats or whatever.

3918
02:52:22,510 --> 02:52:24,210
Now you'll notice we have
a bunch of errors here

3919
02:52:24,210 --> 02:52:27,300
because the enum has
no default constructor.

3920
02:52:27,300 --> 02:52:29,170
So we need to use the parameters.

3921
02:52:30,217 --> 02:52:31,820
But if we were to provide
a default constructor,

3922
02:52:31,820 --> 02:52:33,240
maybe we said 10.

3923
02:52:33,240 --> 02:52:35,160
Now all of these would work
and they would default to 10,

3924
02:52:35,160 --> 02:52:37,029
but let's not do that.

3925
02:52:37,029 --> 02:52:40,160
Let's make the compiler
work for us by defining

3926
02:52:40,160 --> 02:52:43,040
that we actually need to
have a particular value

3927
02:52:43,040 --> 02:52:46,240
parse d into each individual enum.

3928
02:52:46,240 --> 02:52:50,670
So here, we're gonna say 10,
this one's going to be 15.

3929
02:52:50,670 --> 02:52:54,720
Then this one will be 20
and this one will be 25.

3930
02:52:55,600 --> 02:52:57,230
So there we go, pretty simple there.

3931
02:52:57,230 --> 02:52:59,710
And we can go ahead and
delete all this stuff out.

3932
02:53:00,840 --> 02:53:02,910
And now, if we were
actually to print line this

3933
02:53:02,910 --> 02:53:06,180
to the screen, we would
see that we can still do

3934
02:53:06,180 --> 02:53:09,500
account type.gold, and we'd
still be able to print gold.

3935
02:53:09,500 --> 02:53:12,217
And then we can actually
say, discount percent.

3936
02:53:12,217 --> 02:53:13,530
We can actually print
the discount percent.

3937
02:53:13,530 --> 02:53:15,030
So for your to run this,

3938
02:53:15,030 --> 02:53:17,210
we would see that we have gold and 20.

3939
02:53:17,210 --> 02:53:22,046
Now you're not just limited
to a particular number

3940
02:53:22,046 --> 02:53:23,840
of parameters, you can
do another one here.

3941
02:53:23,840 --> 02:53:28,840
So we can say val, say
number of subscriptions

3942
02:53:29,270 --> 02:53:30,690
and this could be an integer value.

3943
02:53:30,690 --> 02:53:32,650
Now you see here again, we're
having the same problem.

3944
02:53:32,650 --> 02:53:36,370
So maybe this is the minimum
number here to reach this one,

3945
02:53:36,370 --> 02:53:39,360
this one you have to have a five,

3946
02:53:39,360 --> 02:53:41,610
this one you have to have 10 people.

3947
02:53:41,610 --> 02:53:44,330
And this one you have to
have at least 15 people.

3948
02:53:44,330 --> 02:53:45,830
And these are perhaps the minimums.

3949
02:53:45,830 --> 02:53:48,100
And now again, I could then say,

3950
02:53:48,100 --> 02:53:49,300
all right, well, what does this one

3951
02:53:49,300 --> 02:53:51,690
five for number of subscriptions?

3952
02:53:51,690 --> 02:53:53,970
And I can start providing
a kind of a known

3953
02:53:53,970 --> 02:53:55,910
simple little data type structure,

3954
02:53:55,910 --> 02:53:57,580
a custom data structure here that says,

3955
02:53:57,580 --> 02:54:01,810
hey, this is enum class,
it's an account type.

3956
02:54:01,810 --> 02:54:05,230
And it's gonna be bronze,
silver, or gold, et cetera.

3957
02:54:06,069 --> 02:54:08,120
And it's gonna have these
discount percentages

3958
02:54:09,450 --> 02:54:10,730
and subscription percentages
or a number of subscriptions

3959
02:54:10,730 --> 02:54:12,860
that are required accordingly.

3960
02:54:12,860 --> 02:54:15,732
And I can start to
define that here in code,

3961
02:54:15,732 --> 02:54:16,565
so it's strongly type.

3962
02:54:16,565 --> 02:54:19,090
And of course, as usual I could actually,

3963
02:54:19,090 --> 02:54:21,530
perhaps maybe even say I only know this

3964
02:54:21,530 --> 02:54:24,240
because it comes down
from an API and I can say

3965
02:54:24,240 --> 02:54:27,950
account type.value of, and
again, I'm gonna use gold

3966
02:54:27,950 --> 02:54:30,500
to uppercase and I can even
do something like this.

3967
02:54:30,500 --> 02:54:33,080
Maybe it's regular case like that.

3968
02:54:33,080 --> 02:54:36,850
And would we be able to see
this, let's take a look here

3969
02:54:36,850 --> 02:54:38,600
and we can actually just say value.

3970
02:54:40,370 --> 02:54:43,170
Actually, this is do instead
of gold, let's do platinum.

3971
02:54:44,590 --> 02:54:46,950
And we'll run this again and we can see

3972
02:54:46,950 --> 02:54:49,150
that we have platinum.

3973
02:54:49,150 --> 02:54:52,875
And now if we actually do
something like this, print line,

3974
02:54:52,875 --> 02:54:56,700
I should just copy this twice,
it will say discount percent

3975
02:54:56,700 --> 02:54:58,290
and number of subscriptions.

3976
02:54:59,490 --> 02:55:00,330
So basically what we've
done at this point in time,

3977
02:55:00,330 --> 02:55:01,750
as we've gotten a string here,

3978
02:55:01,750 --> 02:55:04,840
we have acquired the account type enum

3979
02:55:05,863 --> 02:55:06,920
and then we're able to
print the values off that.

3980
02:55:06,920 --> 02:55:09,870
So let's say that the value
platinum came as a value

3981
02:55:09,870 --> 02:55:11,980
from an API or a database call,

3982
02:55:11,980 --> 02:55:14,690
we could then create this type at runtime.

3983
02:55:14,690 --> 02:55:16,980
It's all right, well, they
are platinum account type

3984
02:55:16,980 --> 02:55:19,250
and it's a 25% discount

3985
02:55:19,250 --> 02:55:21,830
and a minimum number
of subscriptions is 15.

3986
02:55:21,830 --> 02:55:24,210
So that's how you can use
constructor parameters

3987
02:55:24,210 --> 02:55:25,780
with an enum in Kotlin.

3988
02:55:27,170 --> 02:55:29,320
Let's use the discount example again,

3989
02:55:29,320 --> 02:55:32,240
and let's assume that you
need to provide a discount

3990
02:55:32,240 --> 02:55:34,970
for bronze or silver, gold or platinum,

3991
02:55:34,970 --> 02:55:36,840
but you had to be calculated.

3992
02:55:36,840 --> 02:55:38,210
So what you could do is you could define

3993
02:55:38,210 --> 02:55:43,210
an abstract function and you
could say, discount percent,

3994
02:55:44,510 --> 02:55:47,580
let me say calculate discount percent.

3995
02:55:47,580 --> 02:55:49,690
And it's gonna return a,
it's gonna be a function

3996
02:55:49,690 --> 02:55:52,720
and it's gonna return and integer.

3997
02:55:52,720 --> 02:55:56,220
Now what you're gonna see here
is I spelled abstract wrong.

3998
02:56:00,430 --> 02:56:01,800
And now, as soon as we get that fixed,

3999
02:56:01,800 --> 02:56:03,990
we have a bunch of errors
here saying class bronze

4000
02:56:03,990 --> 02:56:07,360
is not abstract and does not
implement the abstract member,

4001
02:56:07,360 --> 02:56:09,800
calculate discount percent as
defined inside of this type.

4002
02:56:09,800 --> 02:56:11,690
And the same thing happens here for silver

4003
02:56:11,690 --> 02:56:13,430
and gold and platinum.

4004
02:56:13,430 --> 02:56:16,780
So what we can do is we can
add some curly braces here,

4005
02:56:16,780 --> 02:56:19,850
and then we can implement that interface.

4006
02:56:19,850 --> 02:56:22,478
And actually we'll see, assuming implement

4007
02:56:22,478 --> 02:56:24,470
that abstract class,
the abstract function.

4008
02:56:24,470 --> 02:56:26,110
And we can either just do it inline here,

4009
02:56:26,110 --> 02:56:27,400
or since this is gonna be...

4010
02:56:27,400 --> 02:56:31,190
If you're gonna perform some
type of complex calculation,

4011
02:56:31,190 --> 02:56:34,110
you could do that in here
and you don't perform

4012
02:56:34,110 --> 02:56:38,380
your logic and so forth
and then finally return

4013
02:56:38,380 --> 02:56:40,560
whatever five or whatever,
whatever you've calculated,

4014
02:56:40,560 --> 02:56:43,250
or if you just know what's
going to be very simple,

4015
02:56:43,250 --> 02:56:44,200
you can also inline it.

4016
02:56:44,200 --> 02:56:46,480
So we might be able to just say five here.

4017
02:56:46,480 --> 02:56:48,110
And the same thing would happen here.

4018
02:56:48,110 --> 02:56:51,150
Again, I would need to
implement that member here,

4019
02:56:51,150 --> 02:56:54,740
and then I could say 10.

4020
02:56:54,740 --> 02:56:56,650
And what I'm gonna do
is just copy this over

4021
02:56:56,650 --> 02:56:57,650
'cause this is easy.

4022
02:56:58,943 --> 02:57:02,150
That way, I have to
space that over what 15.

4023
02:57:03,074 --> 02:57:03,940
And again, these are different percentages

4024
02:57:03,940 --> 02:57:04,840
than I had last time.

4025
02:57:04,840 --> 02:57:09,130
But for the example here
that are all the same here.

4026
02:57:09,130 --> 02:57:11,040
So calculate that accordingly.

4027
02:57:11,930 --> 02:57:15,370
And it looks like it's
expecting a semi-colon

4028
02:57:15,370 --> 02:57:17,530
at the end of this after we've
kind of built all that up.

4029
02:57:17,530 --> 02:57:21,060
Now, what I can say is if we
use that same type of example,

4030
02:57:21,060 --> 02:57:23,450
again, maybe we have
something coming from the API

4031
02:57:23,450 --> 02:57:25,770
and it's just all spelled
kind of really weird

4032
02:57:25,770 --> 02:57:27,450
with weird casing.

4033
02:57:27,450 --> 02:57:29,540
We wouldn't wanna say
we have the account type

4034
02:57:29,540 --> 02:57:33,140
and we got that from the
account type dot value of,

4035
02:57:33,140 --> 02:57:35,270
and then we would take this from API,

4036
02:57:35,270 --> 02:57:37,860
go to uppercase, now we have that type.

4037
02:57:37,860 --> 02:57:39,880
And then we could say print line

4038
02:57:39,880 --> 02:57:43,310
account type.calculate discount percent.

4039
02:57:43,310 --> 02:57:45,360
And if it's gonna be gold,
which we could run it,

4040
02:57:45,360 --> 02:57:48,510
we should see that we're
gonna get 15, which we do.

4041
02:57:48,510 --> 02:57:52,990
If we change this to numb,
which we're just doing

4042
02:57:52,990 --> 02:57:56,290
weird casing here to mess
with it and platinum is 20.

4043
02:57:56,290 --> 02:57:59,700
So that's how you can
implement an abstract method

4044
02:57:59,700 --> 02:58:01,600
inside of an enum.

4045
02:58:01,600 --> 02:58:06,600
This will be very useful,
again, if you are not sure

4046
02:58:07,060 --> 02:58:08,590
what you are going to return.

4047
02:58:09,759 --> 02:58:10,592
Of course, it's gonna end and you need

4048
02:58:10,592 --> 02:58:13,220
a lot larger calculation, you
can use a larger block here.

4049
02:58:13,220 --> 02:58:16,740
So you could do a bunch of work here,

4050
02:58:16,740 --> 02:58:19,430
and then you're gonna return
whatever that value is.

4051
02:58:19,430 --> 02:58:23,590
If it's, for example, maybe
it's gonna be a var percent

4052
02:58:24,970 --> 02:58:27,970
and you wanna start off at
zero, no discount percent,

4053
02:58:27,970 --> 02:58:30,180
and you get to return to percent here.

4054
02:58:30,180 --> 02:58:33,740
And perhaps you're gonna
kind of do calculations

4055
02:58:33,740 --> 02:58:36,456
inside of here based upon maybe some other

4056
02:58:36,456 --> 02:58:37,289
constructor parameters that you have

4057
02:58:37,289 --> 02:58:39,390
inside of the account type,
which we don't have any here.

4058
02:58:39,390 --> 02:58:44,390
But if you did, you can perform
all those calculations here.

4059
02:58:44,460 --> 02:58:47,700
And that's how you can
use abstract function

4060
02:58:47,700 --> 02:58:49,200
inside of a Kotlin enum.

4061
02:58:50,750 --> 02:58:53,150
You can also iterate over all of the types

4062
02:58:53,150 --> 02:58:56,150
inside of an enum very easily

4063
02:58:56,150 --> 02:58:59,860
by using the account type.values.

4064
02:58:59,860 --> 02:59:01,320
So you can use the values method,

4065
02:59:01,320 --> 02:59:02,620
which has built in for you.

4066
02:59:02,620 --> 02:59:04,460
You don't have to define
that, it's just part

4067
02:59:04,460 --> 02:59:06,300
of the enum built in for you.

4068
02:59:06,300 --> 02:59:09,570
And so let's say it's for, say type,

4069
02:59:09,570 --> 02:59:13,400
let's actually say account
type and these types here,

4070
02:59:13,400 --> 02:59:15,450
then I could say print line,

4071
02:59:15,450 --> 02:59:16,840
and then I could say account type.

4072
02:59:16,840 --> 02:59:19,700
And if I were to run this,
then what I would see

4073
02:59:19,700 --> 02:59:22,080
is that when I run it, we're
gonna see all the types here

4074
02:59:22,080 --> 02:59:26,380
print on new line, bronze,
silver, gold, and platinum,

4075
02:59:26,380 --> 02:59:30,140
and the values method returns in array

4076
02:59:30,140 --> 02:59:31,270
of those account types.

4077
02:59:31,270 --> 02:59:33,930
Now, because it's an array
it's so it's a collection

4078
02:59:33,930 --> 02:59:37,880
that's built into Kotlin,
we also get to have access

4079
02:59:37,880 --> 02:59:41,160
to all those nice little helper
functions such as Foreach.

4080
02:59:41,160 --> 02:59:45,350
So I could do the same thing
here and I could use print line

4081
02:59:45,350 --> 02:59:47,360
I could use the kind of built IT.

4082
02:59:47,360 --> 02:59:49,770
It's kind of one line
all of this together,

4083
02:59:49,770 --> 02:59:51,330
instead of having three lines of code

4084
02:59:51,330 --> 02:59:52,720
that does the same exact thing.

4085
02:59:52,720 --> 02:59:55,470
So you can iterate over each one of those.

4086
02:59:55,470 --> 02:59:57,550
And that's how you can
integrate over all the values

4087
02:59:57,550 --> 03:00:02,510
inside of an array, really of
enum as an array, very easily.

4088
03:00:04,950 --> 03:00:06,690
To add a static method to an enum,

4089
03:00:06,690 --> 03:00:08,570
what you wanna use as a companion object.

4090
03:00:08,570 --> 03:00:11,530
But first you wanna
terminate the different enums

4091
03:00:11,530 --> 03:00:14,320
by providing a semi-colon at the end,

4092
03:00:14,320 --> 03:00:16,860
then you'll wanna say a companion object.

4093
03:00:16,860 --> 03:00:19,790
And for example, here, we
could actually have a function

4094
03:00:19,790 --> 03:00:23,850
that says get account type by name.

4095
03:00:23,850 --> 03:00:26,840
We can just parse in the
name and it's a string,

4096
03:00:26,840 --> 03:00:28,190
and this could just be valid.

4097
03:00:28,190 --> 03:00:31,610
We could just use the value
of named.to uppercase.

4098
03:00:31,610 --> 03:00:33,070
And you may be wondering what this is for.

4099
03:00:33,070 --> 03:00:36,127
It's a kind of a nice
little syntactic sugar

4100
03:00:36,127 --> 03:00:40,160
to say account type by
get account type by name.

4101
03:00:40,160 --> 03:00:41,720
And I could just parse it and gold.

4102
03:00:41,720 --> 03:00:44,800
And so I can say account type,

4103
03:00:44,800 --> 03:00:47,980
and now I could actually
print this to the screen

4104
03:00:47,980 --> 03:00:49,240
and say account type.

4105
03:00:50,647 --> 03:00:51,480
And then if we hit run, we should see

4106
03:00:51,480 --> 03:00:53,210
that we're going to
get gold on the screen,

4107
03:00:53,210 --> 03:00:56,190
which we do down here on the
bottom in the output window,

4108
03:00:56,190 --> 03:01:01,190
I could change just to platinum,
which is different casing

4109
03:01:01,570 --> 03:01:02,850
or whatever.

4110
03:01:02,850 --> 03:01:05,521
And then of course, for whatever reason,

4111
03:01:05,521 --> 03:01:06,354
if I just spelled wrong,

4112
03:01:06,354 --> 03:01:10,980
it's going to blow up
because we don't have a value

4113
03:01:11,920 --> 03:01:13,120
with a constant of this type,

4114
03:01:13,120 --> 03:01:15,630
which is what we would
probably want to have happen

4115
03:01:15,630 --> 03:01:18,030
if you're trying to use that
in your production code.

4116
03:01:18,030 --> 03:01:19,390
Now, just an important note here

4117
03:01:19,390 --> 03:01:22,170
is that Kotlin, doesn't have
a concept of a static method.

4118
03:01:22,170 --> 03:01:24,825
This is just Kotlin's
way of kind of providing

4119
03:01:24,825 --> 03:01:26,725
the same functionality out of the box.

4120
03:01:27,660 --> 03:01:31,160
And that's how you can create
a companion object method.

4121
03:01:31,160 --> 03:01:33,520
It kind of acts like a static method

4122
03:01:33,520 --> 03:01:37,040
inside of a Kotlin enum by
using a companion object.

4123
03:01:38,320 --> 03:01:41,110
Kotlin doesn't have a concept
of a switch statement.

4124
03:01:41,110 --> 03:01:43,840
Kotlin's switch statement
is known as a when.

4125
03:01:43,840 --> 03:01:47,300
So let's go ahead and create
a user to work with real fast.

4126
03:01:47,300 --> 03:01:49,880
And this user will have
a first name of Don

4127
03:01:49,880 --> 03:01:51,310
and the last name of Felker.

4128
03:01:52,150 --> 03:01:54,310
Now the when statement
looks something like this.

4129
03:01:54,310 --> 03:01:56,280
You say when and then
you provide the value

4130
03:01:56,280 --> 03:01:59,740
that you're going to evaluate
here as the condition.

4131
03:01:59,740 --> 03:02:02,860
Say, user.first name say, hey,
when the user's first name

4132
03:02:02,860 --> 03:02:05,690
is equal to something and each line here

4133
03:02:05,690 --> 03:02:07,750
will be a condition that we're checking.

4134
03:02:07,750 --> 03:02:11,340
So when the user's first name is Don,

4135
03:02:11,340 --> 03:02:14,600
then we want to go ahead and
perform some type of action

4136
03:02:14,600 --> 03:02:17,460
and we'll put that inside
of some curly braces here,

4137
03:02:17,460 --> 03:02:22,220
and we'll say, print ln, this is Don.

4138
03:02:22,220 --> 03:02:24,100
And then we can run this.

4139
03:02:24,100 --> 03:02:26,720
Now, if we run this here, we'll run

4140
03:02:26,720 --> 03:02:29,890
and we'll see in the output
window that we say, this is Don.

4141
03:02:29,890 --> 03:02:33,890
Now, if for some reason we
changed this username to Dan,

4142
03:02:33,890 --> 03:02:36,860
of course this evaluation's
not going to run,

4143
03:02:36,860 --> 03:02:38,580
and we're not gonna see
anything printed out

4144
03:02:38,580 --> 03:02:40,058
to the screen.

4145
03:02:40,058 --> 03:02:41,640
So what we can do is also
provide a default brand,

4146
03:02:41,640 --> 03:02:44,870
which is known as an
else inside of the when

4147
03:02:44,870 --> 03:02:47,360
and we can provide the
brackets in here too.

4148
03:02:47,360 --> 03:02:50,000
Print ln, this is not to Don.

4149
03:02:50,000 --> 03:02:53,420
Now, if we run this again
because user's name is Dan,

4150
03:02:53,420 --> 03:02:55,810
which I'm sure there's
a Dan Felker somewhere,

4151
03:02:55,810 --> 03:02:57,210
we'll see this is not Don,

4152
03:02:57,210 --> 03:03:00,600
so the else branch has now executed here.

4153
03:03:00,600 --> 03:03:03,820
Now, one of the things,
and you can put multiple

4154
03:03:03,820 --> 03:03:05,370
different things inside of here.

4155
03:03:05,370 --> 03:03:07,930
So we could do a print line, foo var,

4156
03:03:07,930 --> 03:03:10,110
or do some type of logic or whatever.

4157
03:03:10,110 --> 03:03:11,860
These are just basically blocks of code

4158
03:03:11,860 --> 03:03:13,210
that you can do stuff with.

4159
03:03:14,596 --> 03:03:15,940
Now, one of the challenges
that you're going to run into

4160
03:03:15,940 --> 03:03:18,719
when you first start
developing with Kotlin

4161
03:03:18,719 --> 03:03:19,552
is you're not gonna understand

4162
03:03:19,552 --> 03:03:20,510
how to write a when statement.

4163
03:03:20,510 --> 03:03:22,250
At least that was my experience.

4164
03:03:22,250 --> 03:03:25,270
So thankfully the IDE
helps you out a lot here.

4165
03:03:25,270 --> 03:03:27,580
So you may be familiar with
writing something like this,

4166
03:03:27,580 --> 03:03:30,960
user.first name, equal equals Don.

4167
03:03:30,960 --> 03:03:35,210
And then you may have this
print line statement here,

4168
03:03:35,210 --> 03:03:36,600
and then you're gonna have an else.

4169
03:03:36,600 --> 03:03:39,570
And this is very common
in all C style languages,

4170
03:03:39,570 --> 03:03:42,660
which you're probably used
to seeing many times now.

4171
03:03:42,660 --> 03:03:47,660
So if we comment this out,
we'll see here that Dan Felker.

4172
03:03:48,830 --> 03:03:51,530
So we should see, this is
not Don, let's run this now.

4173
03:03:52,622 --> 03:03:54,130
And we'll see, this is not Don.

4174
03:03:54,130 --> 03:03:56,340
If I change this back
to Donn Felker up top,

4175
03:03:56,340 --> 03:04:00,070
we'll see that this Don, so
that condition will be run.

4176
03:04:00,070 --> 03:04:02,620
Now again, I know that
I probably wanna use

4177
03:04:02,620 --> 03:04:06,330
a when statements very
Kotlin idiomatic to do so.

4178
03:04:06,330 --> 03:04:08,688
Now you see as I put my cursor here,

4179
03:04:08,688 --> 03:04:10,220
we get this little yellow
light bulb alt enter

4180
03:04:10,220 --> 03:04:13,720
or hit this and say replace if with when

4181
03:04:13,720 --> 03:04:16,410
and automatically it
rewrote the code for us

4182
03:04:16,410 --> 03:04:18,340
to a little bit different here.

4183
03:04:18,340 --> 03:04:21,220
Now this doesn't look like
the one that's down here,

4184
03:04:21,220 --> 03:04:23,240
yet it does the exact same thing.

4185
03:04:24,770 --> 03:04:26,140
And what this is basically saying is,

4186
03:04:26,140 --> 03:04:29,060
hey, is this username
first name equals Don.

4187
03:04:29,060 --> 03:04:32,830
Now it's going to just say print line.

4188
03:04:32,830 --> 03:04:35,650
Now notice how there's no
brackets here like I have here.

4189
03:04:35,650 --> 03:04:38,190
So let's undo what we just did before.

4190
03:04:38,190 --> 03:04:41,860
If I have multiple statements
in here and I said,

4191
03:04:41,860 --> 03:04:43,280
this is cool.

4192
03:04:43,280 --> 03:04:44,900
And then I come back up here and say

4193
03:04:44,900 --> 03:04:46,450
replace the if with the when,

4194
03:04:47,520 --> 03:04:50,170
the IDE will automatically
provide the brackets for it.

4195
03:04:50,170 --> 03:04:51,920
So if it's a single line statement,

4196
03:04:53,146 --> 03:04:53,979
what will end up happening
is when we replace

4197
03:04:53,979 --> 03:04:55,770
the if with the when,

4198
03:04:55,770 --> 03:04:58,280
it will then turn it into a
single line in line statement.

4199
03:04:58,280 --> 03:04:59,950
So it's easier to read,

4200
03:04:59,950 --> 03:05:02,690
but it's also optimized
it here because it says,

4201
03:05:02,690 --> 03:05:05,980
hey, we don't have to evaluate
the wind for the else here.

4202
03:05:05,980 --> 03:05:08,080
So we're just gonna throw
it in this item here,

4203
03:05:08,080 --> 03:05:12,140
which also means we could
just say, this could be Dan.

4204
03:05:12,140 --> 03:05:14,700
Now at this point, it's
getting kind of redundant.

4205
03:05:14,700 --> 03:05:16,680
So we say, this is Dan.

4206
03:05:16,680 --> 03:05:18,910
And if we were to run this,
now let's run real fast.

4207
03:05:18,910 --> 03:05:21,750
You're gonna see that it's
gonna say this is Don.

4208
03:05:21,750 --> 03:05:25,200
Now, if I put in Dan, say, this is Dan.

4209
03:05:27,260 --> 03:05:29,740
And then if I put in, this is Dana,

4210
03:05:29,740 --> 03:05:31,260
it's not gonna work 'cause this is Dana.

4211
03:05:31,260 --> 03:05:33,450
So then I can rewrite this in my opinion,

4212
03:05:33,450 --> 03:05:34,940
it's a little bit cleaner.

4213
03:05:34,940 --> 03:05:38,150
I can actually just say,
get rid of this stuff here.

4214
03:05:38,150 --> 03:05:40,530
And what this will do is it'll valuate

4215
03:05:40,530 --> 03:05:44,390
when I can put this inside
the, the user.first name.

4216
03:05:45,520 --> 03:05:47,140
So what this is gonna do is only evaluate

4217
03:05:47,140 --> 03:05:50,151
whatever's inside of
the first name variable.

4218
03:05:50,151 --> 03:05:53,520
So what the saying is user's
first name when it equals Don,

4219
03:05:54,588 --> 03:05:55,421
go ahead and print this out here.

4220
03:05:55,421 --> 03:05:57,130
When that equals Dan, print this out here.

4221
03:05:57,130 --> 03:05:59,910
Now, when would you wanna not use that?

4222
03:05:59,910 --> 03:06:00,860
That's a very good example.

4223
03:06:00,860 --> 03:06:03,660
So you could actually say,
well, when the user's first name

4224
03:06:03,660 --> 03:06:05,430
is Don, then we wanna print this as Don.

4225
03:06:05,430 --> 03:06:08,820
But what if we only wanna
print it when it's Donn Felker.

4226
03:06:08,820 --> 03:06:13,820
So user.last name equals, excuse
me, we wanna go over here.

4227
03:06:15,325 --> 03:06:19,470
Username equals Donn and
user.last name equals Felker.

4228
03:06:20,900 --> 03:06:22,910
Then at that point, we
wanna say print this as Don,

4229
03:06:22,910 --> 03:06:24,452
otherwise we don't.

4230
03:06:24,452 --> 03:06:26,530
So let's go back here
and let's change this.

4231
03:06:26,530 --> 03:06:30,860
Again, this go to Dan, let's
go to Donn Felker and run this.

4232
03:06:30,860 --> 03:06:33,760
What you'll see here is
it's gonna say this is Don,

4233
03:06:33,760 --> 03:06:38,470
but what happened if we added just Felker,

4234
03:06:39,399 --> 03:06:41,930
I misspelled whatever, and run it again.

4235
03:06:41,930 --> 03:06:44,120
This is not going to run, it's
gonna say this is not Don,

4236
03:06:44,120 --> 03:06:46,480
because what this one statement is doing

4237
03:06:46,480 --> 03:06:49,140
is using this entire
line as an evaluation.

4238
03:06:49,140 --> 03:06:52,130
And again, once it starts
getting kind of long

4239
03:06:52,130 --> 03:06:54,070
and goes after the initial line break,

4240
03:06:54,070 --> 03:06:56,830
I prefer to put it inside
of a print line here.

4241
03:06:56,830 --> 03:06:58,580
So you kind of start evaluating multiple

4242
03:06:58,580 --> 03:07:00,260
different conditionals inside of here

4243
03:07:00,260 --> 03:07:02,680
using this when statement, and
then of course you can have

4244
03:07:02,680 --> 03:07:05,670
a fall through as the else at the end.

4245
03:07:05,670 --> 03:07:08,570
You can mix having blocks
of code inside of here,

4246
03:07:08,570 --> 03:07:12,190
or you can kind of have
one line evaluations

4247
03:07:12,190 --> 03:07:14,520
and statements here,
which will then evaluate

4248
03:07:14,520 --> 03:07:16,820
these expressions and
print onto the screen.

4249
03:07:16,820 --> 03:07:18,790
You can not put multiple
ones here on the same line,

4250
03:07:18,790 --> 03:07:20,330
as soon as you need to do multiple things,

4251
03:07:20,330 --> 03:07:23,030
you will need to provide a block for that.

4252
03:07:23,030 --> 03:07:24,340
So that's pretty easy to do.

4253
03:07:24,340 --> 03:07:28,240
You can just go ahead and
provide that print all those,

4254
03:07:28,240 --> 03:07:32,630
print ln and accordingly,

4255
03:07:34,640 --> 03:07:38,550
and you can put some other
stuff inside of here, print ln.

4256
03:07:38,550 --> 03:07:41,620
This is ABC, whatever.

4257
03:07:41,620 --> 03:07:43,150
And then that's how you can go ahead

4258
03:07:43,150 --> 03:07:46,740
and use a basic when
statement inside of Kotlin.

4259
03:07:46,740 --> 03:07:47,990
And of course, this can be used

4260
03:07:47,990 --> 03:07:51,660
with different types of
things, such as primitives

4261
03:07:51,660 --> 03:07:54,740
can be used to check
different instance types.

4262
03:07:54,740 --> 03:07:57,370
This is just a conditional
very much like an if.

4263
03:07:57,370 --> 03:08:00,037
And again, if you don't know how to write

4264
03:08:00,037 --> 03:08:01,190
the when statement, you can always go back

4265
03:08:01,190 --> 03:08:03,780
to the if statement,
write your if statement,

4266
03:08:03,780 --> 03:08:07,030
and then go ahead and use the
helper inside of IntelliJ,

4267
03:08:07,030 --> 03:08:11,410
Android Studio or any
other Java IDE that's built

4268
03:08:11,410 --> 03:08:14,320
by JetBrains to have actually have it.

4269
03:08:14,320 --> 03:08:16,430
Go ahead and replace your if statement

4270
03:08:16,430 --> 03:08:17,690
with a when statement.

4271
03:08:19,610 --> 03:08:21,340
There are times in a when statement

4272
03:08:21,340 --> 03:08:23,150
when it's used as an expression

4273
03:08:23,150 --> 03:08:24,700
that it needs to be exhaustive.

4274
03:08:30,120 --> 03:08:32,500
What that means is ln
statement must be provided.

4275
03:08:32,500 --> 03:08:34,800
So let's assume that we
have at when statement

4276
03:08:36,386 --> 03:08:37,219
based upon an account type.

4277
03:08:37,219 --> 03:08:39,410
So if we have an account
type and we'll just say

4278
03:08:39,410 --> 03:08:44,410
account type.gold, and we can
say a when statement here.

4279
03:08:45,250 --> 03:08:48,960
So when an account type,
and then we say gold,

4280
03:08:50,850 --> 03:08:54,890
what we can actually do
here is we can actually

4281
03:08:54,890 --> 03:08:56,620
have some type of code
here and we can say,

4282
03:08:56,620 --> 03:09:01,030
return gold member.

4283
03:09:01,030 --> 03:09:02,960
Maybe we wanna return certain strings

4284
03:09:02,960 --> 03:09:05,400
based upon whatever their status is.

4285
03:09:05,400 --> 03:09:07,380
So you can see here, we
have an error and it says,

4286
03:09:07,380 --> 03:09:11,290
hey, this is by default,
a unit and returns a unit,

4287
03:09:11,290 --> 03:09:12,550
but we're telling you to return a string.

4288
03:09:12,550 --> 03:09:15,790
So what we can actually do
is have when return of value.

4289
03:09:15,790 --> 03:09:19,000
So we actually, val equals message.

4290
03:09:19,000 --> 03:09:21,470
So I wanna say a message
off of this when statement.

4291
03:09:21,470 --> 03:09:24,022
And what you'll see
here is it's telling us,

4292
03:09:24,022 --> 03:09:28,260
hey, well now when the when
expression is used like this,

4293
03:09:28,260 --> 03:09:29,290
it must be exhaustive.

4294
03:09:29,290 --> 03:09:33,180
So we have to actually handle
all of the different scenarios

4295
03:09:33,180 --> 03:09:37,790
because this val must be
populated with something.

4296
03:09:37,790 --> 03:09:38,900
It has to be something.

4297
03:09:38,900 --> 03:09:41,580
And the compiler knows by default.

4298
03:09:41,580 --> 03:09:44,383
Well, account type has different values,

4299
03:09:44,383 --> 03:09:45,590
it has bronze and silver
and gold and platinum.

4300
03:09:45,590 --> 03:09:49,120
If you parse in, if this is platinum,

4301
03:09:49,120 --> 03:09:50,720
it doesn't know what to return.

4302
03:09:50,720 --> 03:09:53,480
So it's telling you,
hey, you have to return

4303
03:09:53,480 --> 03:09:54,840
all of these things inside of here.

4304
03:09:54,840 --> 03:09:56,160
And what it's saying is here,

4305
03:09:56,160 --> 03:09:58,130
you can do this in one of two ways,

4306
03:09:58,130 --> 03:10:00,730
you can add a necessary
bronze, silver, or platinums,

4307
03:10:00,730 --> 03:10:03,070
or add an else branch, so
there's two ways to do this.

4308
03:10:03,070 --> 03:10:07,390
We could say, hey, a gold
member, or we can say,

4309
03:10:08,890 --> 03:10:13,420
what would we say, else
and we could return

4310
03:10:13,420 --> 03:10:18,420
a regular member, something like that.

4311
03:10:20,930 --> 03:10:23,630
We'll see here we have, it
looks like it's returning,

4312
03:10:23,630 --> 03:10:25,200
we don't need to add the
return statement there

4313
03:10:25,200 --> 03:10:26,730
'cause it's actually
used as an expression,

4314
03:10:26,730 --> 03:10:27,940
so we don't need to return anymore.

4315
03:10:27,940 --> 03:10:32,450
And then what we can do here
is say, print line message.

4316
03:10:33,770 --> 03:10:36,270
And when we print this,
well, you're gonna see

4317
03:10:36,270 --> 03:10:37,910
that they are a gold member.

4318
03:10:37,910 --> 03:10:40,260
Now, if I were to type this as platinum,

4319
03:10:43,820 --> 03:10:47,340
we know that this is incorrect
and it says regular member.

4320
03:10:47,340 --> 03:10:49,230
Now that's not correct here.

4321
03:10:49,230 --> 03:10:54,090
So maybe what we wanna do is
if we say, if they are gold,

4322
03:10:55,380 --> 03:10:57,140
then anything else like that,

4323
03:10:57,140 --> 03:10:58,790
where maybe platinum is a highest level,

4324
03:10:58,790 --> 03:11:00,090
we'll say platinum member.

4325
03:11:05,710 --> 03:11:06,740
Platinum.

4326
03:11:06,740 --> 03:11:09,392
And then inside of the classroom,

4327
03:11:09,392 --> 03:11:14,392
we can say not eligible
for special access,

4328
03:11:15,730 --> 03:11:16,690
whatever that might mean.

4329
03:11:16,690 --> 03:11:18,900
And if that's basically
saying this is maybe a string,

4330
03:11:18,900 --> 03:11:21,330
that's going to be
displayed to the screen.

4331
03:11:21,330 --> 03:11:22,830
When they're platinum, then use this,

4332
03:11:22,830 --> 03:11:26,670
otherwise for all other instances,
if they're gold, silver,

4333
03:11:27,654 --> 03:11:29,640
or bronze, then we want them to only see

4334
03:11:29,640 --> 03:11:32,201
not eligible for special access.

4335
03:11:32,201 --> 03:11:33,540
Well, here they're a platinum member.

4336
03:11:33,540 --> 03:11:37,390
So we can actually say
platinum member access allowed.

4337
03:11:39,110 --> 03:11:40,664
And then when we rerun it,

4338
03:11:40,664 --> 03:11:41,500
we'll see platinum member access allowed.

4339
03:11:41,500 --> 03:11:44,400
And then we'll come up
here and changes to silver

4340
03:11:44,400 --> 03:11:45,270
and we're rerun it.

4341
03:11:45,270 --> 03:11:48,530
And it says, hey, you're not
eligible for special access.

4342
03:11:48,530 --> 03:11:50,070
Now that's when we could do it.

4343
03:11:50,070 --> 03:11:52,800
One way we could do it now,
we could also change this

4344
03:11:52,800 --> 03:11:56,770
and provide an implementation
for each individual one.

4345
03:11:56,770 --> 03:11:59,650
Now it doesn't matter, we
could type bronze here,

4346
03:11:59,650 --> 03:12:01,760
we could type the different ones here.

4347
03:12:01,760 --> 03:12:05,830
This would, of course, maybe
there's a bronze access,

4348
03:12:05,830 --> 03:12:07,360
there's bronze member access.

4349
03:12:09,580 --> 03:12:12,090
And so we have this, we'll
change this to silver.

4350
03:12:13,280 --> 03:12:15,160
And notice we still have
the squiggly align up here,

4351
03:12:15,160 --> 03:12:17,520
it's still complaining that
we don't have everything

4352
03:12:17,520 --> 03:12:20,730
that we need and then we
can change this to gold.

4353
03:12:22,289 --> 03:12:23,122
As soon as I provide the gold,

4354
03:12:23,122 --> 03:12:25,690
I've provided all of these values,

4355
03:12:25,690 --> 03:12:27,070
gold member access allowed.

4356
03:12:28,190 --> 03:12:31,000
Now the beautiful part
about this is regardless

4357
03:12:31,000 --> 03:12:33,040
of whatever I've typed inside of here.

4358
03:12:33,040 --> 03:12:34,840
And I look this telling us
we can inline this here,

4359
03:12:34,840 --> 03:12:38,100
we can inline the message,
which we don't really wanna do,

4360
03:12:38,100 --> 03:12:41,320
'cause we're assuming this
comes from an API or database.

4361
03:12:41,320 --> 03:12:42,550
The beautiful part about all this.

4362
03:12:42,550 --> 03:12:45,480
Once we run it, we'll see that
we get the correct bronze,

4363
03:12:46,346 --> 03:12:49,650
silver, gold is that, and just,

4364
03:12:49,650 --> 03:12:51,660
excuse me, I'm gonna reorganize here

4365
03:12:51,660 --> 03:12:54,421
because it just makes more
sense and matches the code,

4366
03:12:54,421 --> 03:12:56,840
is it when we have account types,

4367
03:12:56,840 --> 03:12:57,840
they're gonna have a value,

4368
03:12:57,840 --> 03:13:00,080
which means later on in our application,

4369
03:13:01,410 --> 03:13:03,430
if we decide to, for whatever reason,

4370
03:13:03,430 --> 03:13:06,800
our business needs change
and we add a new level Onyx.

4371
03:13:07,750 --> 03:13:11,420
Now our application will not compile.

4372
03:13:11,420 --> 03:13:12,710
The compiler is gonna check this and say,

4373
03:13:12,710 --> 03:13:14,940
hey, this when statement
is not exhaustive.

4374
03:13:14,940 --> 03:13:18,070
So if this account type
is in another class file

4375
03:13:18,070 --> 03:13:19,940
or another file or application,

4376
03:13:19,940 --> 03:13:21,840
which it's most likely is going to be,

4377
03:13:22,761 --> 03:13:25,000
and we've added Onyx because
it's coming down from the API.

4378
03:13:25,000 --> 03:13:28,360
Cool, we have Onyx now,
we're gonna to add that

4379
03:13:28,360 --> 03:13:30,120
and we're to try to
compile our application

4380
03:13:30,120 --> 03:13:32,550
and the Kotlin compiler's
gonna say no, no, no, no, no,

4381
03:13:32,550 --> 03:13:34,950
you can't do this because
you have to make sure

4382
03:13:34,950 --> 03:13:37,400
that when expression is exhaustive.

4383
03:13:37,400 --> 03:13:40,120
Now of course, that's, of
course can be gotten around

4384
03:13:40,120 --> 03:13:45,120
by if the else is here, then
say unknown member type,

4385
03:13:45,710 --> 03:13:48,253
or whatever and you can
have that and will be,

4386
03:13:48,253 --> 03:13:49,396
you can add it in there.

4387
03:13:49,396 --> 03:13:51,160
So if you add another
one, you can say pink

4388
03:13:51,160 --> 03:13:53,510
and whatever that would
be, maybe it's special,

4389
03:13:55,599 --> 03:13:56,600
cancer awareness or something.

4390
03:13:56,600 --> 03:14:00,200
It pops in there, then you
can have that inside there.

4391
03:14:00,200 --> 03:14:04,010
The different types that you have in here,

4392
03:14:04,010 --> 03:14:04,843
again, this doesn't matter if the bronze

4393
03:14:04,843 --> 03:14:07,101
is the bomb or whatever, the
expression will be evaluated

4394
03:14:07,101 --> 03:14:09,960
and the message will be
returned at that point.

4395
03:14:09,960 --> 03:14:12,696
And that's how you can
work with an exhaustive

4396
03:14:12,696 --> 03:14:14,900
versus non-exhaustive when statement.

4397
03:14:14,900 --> 03:14:17,020
And again, the non-exhaustive
one is going to be

4398
03:14:17,020 --> 03:14:20,860
perhaps if you just want to
perform some type of evaluation.

4399
03:14:20,860 --> 03:14:24,434
So this would be non-exhaustive
one account type.

4400
03:14:24,434 --> 03:14:26,580
And I could say gold.

4401
03:14:28,150 --> 03:14:31,050
And I would say, maybe just
print something to the screen.

4402
03:14:32,130 --> 03:14:34,290
This is gold.

4403
03:14:35,280 --> 03:14:36,880
Now this is non-exhaustive here.

4404
03:14:37,908 --> 03:14:39,890
We're not required to
provide an else statement.

4405
03:14:39,890 --> 03:14:41,390
Because this is using the expression,

4406
03:14:41,390 --> 03:14:42,700
it's gonna be returning a value.

4407
03:14:42,700 --> 03:14:46,170
We have to provide an exhaustive approach.

4408
03:14:46,170 --> 03:14:47,650
We have to exhaust all the options.

4409
03:14:47,650 --> 03:14:50,000
So we need to provide all of the options

4410
03:14:50,000 --> 03:14:51,900
or also provide an else at the bottom

4411
03:14:51,900 --> 03:14:53,010
so we know what to do there.

4412
03:14:53,010 --> 03:14:55,695
And again, there's no Onyx here.

4413
03:14:55,695 --> 03:14:56,712
So it starts complaining and so forth.

4414
03:14:56,712 --> 03:15:01,692
And if we delete the Onyx and we had to go

4415
03:15:01,692 --> 03:15:04,480
to platinum there, we fix
our compiler problems.

4416
03:15:04,480 --> 03:15:05,940
And that's how we work with the exhaustive

4417
03:15:05,940 --> 03:15:08,730
versus non-exhaustive
when statements Kotlin.

4418
03:15:10,800 --> 03:15:13,920
In programming, it's very often
that you'll have in a class,

4419
03:15:13,920 --> 03:15:16,470
this you simply to hold data.

4420
03:15:16,470 --> 03:15:20,890
And so what we might have
is a class called person

4421
03:15:20,890 --> 03:15:24,170
and as string and a last name of string,

4422
03:15:25,479 --> 03:15:26,590
and it doesn't maybe even have a body

4423
03:15:26,590 --> 03:15:29,790
that's just has no properties
or any of them be no functions

4424
03:15:29,790 --> 03:15:31,020
or anything like that.

4425
03:15:32,524 --> 03:15:35,850
So this is a person and we may
define person one as P one.

4426
03:15:35,850 --> 03:15:37,080
And we would say person,

4427
03:15:38,625 --> 03:15:39,660
and we'll save their first name is Don

4428
03:15:39,660 --> 03:15:41,900
and their last name is Felker.

4429
03:15:41,900 --> 03:15:45,740
And I'm gonna create two of
these, so P one and P two.

4430
03:15:45,740 --> 03:15:47,370
Now, if I were to actually say,

4431
03:15:47,370 --> 03:15:50,620
are these equal to each
other, you might think

4432
03:15:50,620 --> 03:15:52,010
of course, that these
are equal to each other.

4433
03:15:52,010 --> 03:15:53,600
They have the same contents,

4434
03:15:53,600 --> 03:15:56,690
they must be equal to each
other, so let's run that here.

4435
03:15:56,690 --> 03:15:59,040
And what we're going to
see is that it's false,

4436
03:15:59,950 --> 03:16:01,780
these do not equal to each other.

4437
03:16:01,780 --> 03:16:06,780
And if we are to print these
out, we're going to see P one

4438
03:16:07,200 --> 03:16:12,200
and P two actually have
different little codes here

4439
03:16:12,260 --> 03:16:15,010
at the end, which we can get
to that in at a later time,

4440
03:16:15,010 --> 03:16:17,777
basically showing that,
look, both of these objects

4441
03:16:17,777 --> 03:16:18,610
are actually different.

4442
03:16:18,610 --> 03:16:20,910
They're different is
not actually comparing

4443
03:16:20,910 --> 03:16:23,140
value equality inside of them.

4444
03:16:23,140 --> 03:16:26,150
Now, thankfully, the
language designers at Kotlin

4445
03:16:26,150 --> 03:16:27,290
have thought about this and said,

4446
03:16:27,290 --> 03:16:30,580
well, there are times when we
just wanna carry data around.

4447
03:16:30,580 --> 03:16:33,730
And so if we have a class
like that, you can then use

4448
03:16:33,730 --> 03:16:35,460
what's known as a data class.

4449
03:16:35,460 --> 03:16:37,590
And to use a data class,
you'll just slap the word data

4450
03:16:37,590 --> 03:16:39,710
at the beginning and then
you also have to have

4451
03:16:39,710 --> 03:16:42,080
at least one parameter and all parameters

4452
03:16:42,080 --> 03:16:44,470
must either be val or var.

4453
03:16:44,470 --> 03:16:47,680
And so we've added that here
and now we can actually say

4454
03:16:47,680 --> 03:16:51,940
print line P one equals equals P two.

4455
03:16:53,451 --> 03:16:54,940
And if we run this, we'll
see that both of these values

4456
03:16:54,940 --> 03:16:55,773
are the same.

4457
03:16:55,773 --> 03:16:57,480
And what will happen behind the scenes

4458
03:16:57,480 --> 03:17:00,960
is it's actually comparing the values.

4459
03:17:00,960 --> 03:17:03,000
Now there's a couple of things
that are making this happen.

4460
03:17:03,000 --> 03:17:06,060
The Kotlin compiler is actually overriding

4461
03:17:06,060 --> 03:17:10,630
and creating the equals operator
and the hash code operator,

4462
03:17:10,630 --> 03:17:13,900
as well as the two string and
a couple of other functions,

4463
03:17:13,900 --> 03:17:15,460
which we'll talk about soon.

4464
03:17:15,460 --> 03:17:18,730
So if we're gonna take a look
at the equals and hashcode

4465
03:17:18,730 --> 03:17:22,090
is what's kind of helping
us with the equality here.

4466
03:17:22,090 --> 03:17:26,240
However, with the print
line, we can actually,

4467
03:17:26,240 --> 03:17:29,180
as we remember print line will
call the two string method

4468
03:17:29,180 --> 03:17:30,531
by default.

4469
03:17:30,531 --> 03:17:33,700
So we can say P one and
then what will happen

4470
03:17:33,700 --> 03:17:35,500
if let's actually go
back a little bit here

4471
03:17:35,500 --> 03:17:37,460
and take this off.

4472
03:17:38,422 --> 03:17:41,040
If we run this just as
this is as a regular class,

4473
03:17:41,040 --> 03:17:43,410
we'll see that we have,
if we do a print line,

4474
03:17:43,410 --> 03:17:48,000
we'll see person at 49476842,
so it's not too helpful.

4475
03:17:48,000 --> 03:17:52,400
However, if this is a data
class, what you'll notice here

4476
03:17:52,400 --> 03:17:55,540
is that the data class
has a two string method,

4477
03:17:55,540 --> 03:17:56,590
which has implemented for us,

4478
03:17:56,590 --> 03:17:58,760
which is a very nice format here,

4479
03:17:58,760 --> 03:18:01,381
which has person first name, last name.

4480
03:18:01,381 --> 03:18:03,528
And let's say we add
the age inside of here.

4481
03:18:03,528 --> 03:18:07,050
So val age int, and we'll
put some numbers here,

4482
03:18:07,050 --> 03:18:10,560
30, and let's just do the same thing 30,

4483
03:18:10,560 --> 03:18:12,020
and we run it again.

4484
03:18:12,020 --> 03:18:14,570
You'll see that the print line method

4485
03:18:14,570 --> 03:18:16,270
also outputs that parameter.

4486
03:18:16,270 --> 03:18:18,670
So it'll actually output
each of the parameters

4487
03:18:18,670 --> 03:18:22,040
as a value in the two string method.

4488
03:18:22,040 --> 03:18:23,420
So this is all generated for us.

4489
03:18:23,420 --> 03:18:25,900
The equals the hash
code and the two string.

4490
03:18:25,900 --> 03:18:27,970
And this is how you
can create a data class

4491
03:18:27,970 --> 03:18:29,220
inside of Kotlin.

4492
03:18:29,220 --> 03:18:31,600
Now you can also have
functions inside of here.

4493
03:18:31,600 --> 03:18:34,180
So you might be able to say full name.

4494
03:18:34,180 --> 03:18:36,550
And this is very similar
to our other user object,

4495
03:18:36,550 --> 03:18:37,470
which we've seen before.

4496
03:18:37,470 --> 03:18:38,870
This will return the string,

4497
03:18:40,180 --> 03:18:42,870
and this will be returned like this.

4498
03:18:42,870 --> 03:18:47,870
We'll say return, first
name and then last name.

4499
03:18:49,460 --> 03:18:52,640
And we can actually come up
here and print the full name.

4500
03:18:52,640 --> 03:18:56,600
And if we run it, we will see Donn Felker

4501
03:18:56,600 --> 03:18:59,350
and of course we can have
do other things such as this

4502
03:18:59,350 --> 03:19:00,650
such as name, length.

4503
03:19:02,128 --> 03:19:04,720
If we wanna have a method
that perhaps returns an int,

4504
03:19:04,720 --> 03:19:06,770
and all that does is full name.length.

4505
03:19:07,740 --> 03:19:09,340
And we can do the same thing up here,

4506
03:19:09,340 --> 03:19:12,570
full name or name length,

4507
03:19:12,570 --> 03:19:14,460
and that will provide a
full length of the name

4508
03:19:14,460 --> 03:19:17,570
and characters at the
character council at 11.

4509
03:19:17,570 --> 03:19:19,890
And that's how you can
create a very simple class

4510
03:19:19,890 --> 03:19:23,410
in Kotlin, very simple
data class in Kotlin

4511
03:19:23,410 --> 03:19:26,550
and how it can perform
data equality and so forth.

4512
03:19:28,060 --> 03:19:31,480
If you would like your data
class to be constructor list

4513
03:19:31,480 --> 03:19:32,900
or seem like it's constructor list,

4514
03:19:32,900 --> 03:19:35,900
you will need to provide default
values for each of those.

4515
03:19:35,900 --> 03:19:39,910
So you could say first unknown here,

4516
03:19:39,910 --> 03:19:42,750
and that was gonna go to
first unknown known here,

4517
03:19:42,750 --> 03:19:44,160
last unknown.

4518
03:19:44,160 --> 03:19:45,620
These are just values I'm typing in there.

4519
03:19:45,620 --> 03:19:47,500
They could be anything, an age

4520
03:19:48,544 --> 03:19:50,140
we could just default to zero.

4521
03:19:50,140 --> 03:19:52,038
Then of course, it's getting kind of long,

4522
03:19:52,038 --> 03:19:54,340
so it's gonna put these
on a separate lines.

4523
03:19:54,340 --> 03:19:56,913
So now we have our class
kind of broken apart

4524
03:19:56,913 --> 03:19:57,746
into separate lines.

4525
03:19:57,746 --> 03:19:59,720
And then if I like to
create a P three up here,

4526
03:19:59,720 --> 03:20:02,960
I could very easily do. So
Val P three equals person,

4527
03:20:02,960 --> 03:20:04,230
and I have to provide any values

4528
03:20:04,230 --> 03:20:05,810
because they're all default.

4529
03:20:05,810 --> 03:20:08,420
Now, again, I can't have
another value in here.

4530
03:20:08,420 --> 03:20:11,080
Val is just Fu, which is a
string it's not provided.

4531
03:20:11,080 --> 03:20:13,500
We'll see, we get a bunch of
errors here, even up here,

4532
03:20:13,500 --> 03:20:17,220
because there's no value unless
I defaulted to something.

4533
03:20:17,220 --> 03:20:19,170
But at that point, these are all vals.

4534
03:20:19,170 --> 03:20:24,170
And then of course, if
we print ln, the P three,

4535
03:20:25,500 --> 03:20:30,360
delete these, you're
going to see that we have

4536
03:20:30,360 --> 03:20:32,160
the default values that are output.

4537
03:20:32,160 --> 03:20:35,700
So first unknown, last
known, known, and age zero.

4538
03:20:35,700 --> 03:20:38,300
And that's how you can
simulate having a parameter

4539
03:20:38,300 --> 03:20:40,560
list constructor in a data class.

4540
03:20:40,560 --> 03:20:43,410
Kotlin data classes by
default will generate

4541
03:20:43,410 --> 03:20:45,490
what are known as component methods.

4542
03:20:45,490 --> 03:20:48,480
So if P1, we'll see component,
we have component one,

4543
03:20:48,480 --> 03:20:49,880
which is a string,

4544
03:20:49,880 --> 03:20:53,200
and this is going to
be the first name P one

4545
03:20:53,200 --> 03:20:58,200
dot component two, is going
to be for the second item

4546
03:20:58,600 --> 03:21:00,490
in the parameter list, which is a string.

4547
03:21:00,490 --> 03:21:03,210
So in the order in which they
occur is what the components

4548
03:21:03,210 --> 03:21:04,043
will occur.

4549
03:21:04,043 --> 03:21:08,640
And so this would be val
first name, val last name.

4550
03:21:11,120 --> 03:21:12,602
What do you call that?

4551
03:21:12,602 --> 03:21:13,435
And then as you can see here,

4552
03:21:13,435 --> 03:21:15,950
we do not have any more
components because that's all.

4553
03:21:15,950 --> 03:21:18,970
So P1.component, component
one, component two.

4554
03:21:18,970 --> 03:21:21,800
However, if we come down here
and add another item here,

4555
03:21:21,800 --> 03:21:26,730
so Val age, enter int, and
let's provide a value up here.

4556
03:21:28,453 --> 03:21:30,680
30.

4557
03:21:30,680 --> 03:21:33,360
Now, if we insert P one dot component.

4558
03:21:33,360 --> 03:21:35,438
We see we have another one.

4559
03:21:35,438 --> 03:21:37,350
And this one is an integer
type because this is the third

4560
03:21:37,350 --> 03:21:38,400
parameter up here.

4561
03:21:38,400 --> 03:21:39,820
This is the Int.

4562
03:21:40,775 --> 03:21:43,010
So it's the third component
in the parameter list.

4563
03:21:43,010 --> 03:21:46,990
And so we say Val age
equals component three.

4564
03:21:46,990 --> 03:21:49,630
And these are generated
for you behind the scenes

4565
03:21:49,630 --> 03:21:51,800
by the Kotlin compiler.

4566
03:21:51,800 --> 03:21:54,380
So if we were to print line
all of these things out there,

4567
03:21:54,380 --> 03:21:57,490
we could say first name,
and we say print line,

4568
03:21:59,540 --> 03:22:01,620
last name and print lane.

4569
03:22:02,540 --> 03:22:03,500
We can not do age.

4570
03:22:04,935 --> 03:22:06,850
And if were to run this,
we will see Donn Felker, 30

4571
03:22:06,850 --> 03:22:08,340
being printed out to the screen.

4572
03:22:08,340 --> 03:22:09,550
Now, of course, we could just replace this

4573
03:22:09,550 --> 03:22:12,470
with P one dot component one

4574
03:22:15,550 --> 03:22:19,520
and P one dot component two.

4575
03:22:19,520 --> 03:22:22,190
And we just copy this here, save time.

4576
03:22:22,190 --> 03:22:23,810
It would do component
three and we can delete

4577
03:22:23,810 --> 03:22:26,650
these other ones here
and delete all these.

4578
03:22:28,280 --> 03:22:29,660
And if we run this,
we'll see the same thing

4579
03:22:29,660 --> 03:22:32,280
we just saw before: Donn Felker, 30.

4580
03:22:32,280 --> 03:22:34,460
So component one, component
two, component three.

4581
03:22:34,460 --> 03:22:36,300
Now, if I switch this around,

4582
03:22:36,300 --> 03:22:40,690
so I'm gonna put 30 here
and see if I'm gonna get

4583
03:22:40,690 --> 03:22:43,200
a competitor error at
first, so I'll say 30.

4584
03:22:43,200 --> 03:22:45,550
I need to switch the
parameter order down here.

4585
03:22:47,590 --> 03:22:48,740
I can actually do this.

4586
03:22:54,630 --> 03:22:56,620
Then component one, two, and
three are gonna be different.

4587
03:22:56,620 --> 03:22:58,670
Component one will be Don,
component two will be 30,

4588
03:22:58,670 --> 03:23:00,800
components three will be Felker.

4589
03:23:00,800 --> 03:23:02,480
Let's put it back to how it was before

4590
03:23:02,480 --> 03:23:03,840
with the age at the end.

4591
03:23:03,840 --> 03:23:06,730
And one more thing that we can
ask you actually do here too,

4592
03:23:06,730 --> 03:23:09,570
is we can actually specify
these in correct order.

4593
03:23:09,570 --> 03:23:11,210
So let's do this.

4594
03:23:11,210 --> 03:23:16,210
Let's just say age equals
30, last name equals Felker.

4595
03:23:18,480 --> 03:23:22,810
First name equals Don.

4596
03:23:23,800 --> 03:23:26,093
And actually let's even flip these two.

4597
03:23:26,093 --> 03:23:27,490
Let's flip these two right here.

4598
03:23:27,490 --> 03:23:29,750
So we're completely out
of order at this point,

4599
03:23:29,750 --> 03:23:32,410
but however we're using
named parameters and Kotlin

4600
03:23:32,410 --> 03:23:35,420
is gonna figure that out
for us in a way anyway,

4601
03:23:35,420 --> 03:23:37,260
because this is the way
that they're defined.

4602
03:23:37,260 --> 03:23:38,750
So these are the way that the components

4603
03:23:38,750 --> 03:23:39,990
are going to be adjusted.

4604
03:23:39,990 --> 03:23:42,070
Not in the order in
which they're parse d in,

4605
03:23:42,070 --> 03:23:44,710
but in a way that they're
defined in the data class.

4606
03:23:44,710 --> 03:23:46,480
So first name is component one.

4607
03:23:46,480 --> 03:23:49,510
Last name is component two
and age is component three.

4608
03:23:49,510 --> 03:23:52,490
So even if I use name
parameters in a different order,

4609
03:23:52,490 --> 03:23:55,150
Kotlin will figure that out
behind the scenes and correctly

4610
03:23:55,150 --> 03:23:57,660
render them in the correct order
with the correct component.

4611
03:23:57,660 --> 03:24:01,030
As we can see here,
component one is Donn Felker.

4612
03:24:01,030 --> 03:24:04,730
Here is component two and
component three is 30.

4613
03:24:04,730 --> 03:24:06,480
And that's how you can
work with the components

4614
03:24:06,480 --> 03:24:09,380
that are generated inside of data class.

4615
03:24:09,380 --> 03:24:11,190
And I do have one more
use and that's going to be

4616
03:24:11,190 --> 03:24:13,730
de-structuring, which is coming soon.

4617
03:24:15,980 --> 03:24:19,230
One of the main reasons for the
component values that we see

4618
03:24:19,230 --> 03:24:21,680
inside of data classes,
such as component one,

4619
03:24:21,680 --> 03:24:24,180
component two, component
three is for de-structuring.

4620
03:24:24,180 --> 03:24:26,710
So component one,
references the first name,

4621
03:24:26,710 --> 03:24:28,840
which is the first parameter as defined

4622
03:24:28,840 --> 03:24:30,270
inside of the data class.

4623
03:24:30,270 --> 03:24:32,610
Component two will be the
second parameter here.

4624
03:24:32,610 --> 03:24:34,760
And component three will
be the third one here.

4625
03:24:34,760 --> 03:24:36,420
This is used for de-structuring.

4626
03:24:36,420 --> 03:24:39,060
So we can say val, and
we can say first name.

4627
03:24:41,260 --> 03:24:44,070
And then we say last
name and we can say age.

4628
03:24:44,070 --> 03:24:45,550
And I'm gonna say equals person.

4629
03:24:45,550 --> 03:24:48,190
So as we've defined the
person here on line two,

4630
03:24:49,330 --> 03:24:50,590
what we're doing here is
we're actually defining

4631
03:24:50,590 --> 03:24:53,170
these three variables
and we're de-structuring

4632
03:24:53,170 --> 03:24:54,970
the person object.

4633
03:24:54,970 --> 03:24:57,550
And what's happening behind
the scenes is Kotlin is using

4634
03:24:57,550 --> 03:24:59,860
component one, component
two and component three

4635
03:24:59,860 --> 03:25:02,210
to shove it into these variables here.

4636
03:25:02,210 --> 03:25:04,450
So now let's print line each one of these

4637
03:25:04,450 --> 03:25:06,602
to see what they look like.

4638
03:25:06,602 --> 03:25:10,020
I'll say first name print line,

4639
03:25:10,020 --> 03:25:14,260
last name, it will say print line, age.

4640
03:25:14,260 --> 03:25:15,450
And if we run this,

4641
03:25:16,620 --> 03:25:20,270
what we're going to see here
is that we see Donn Felker 30.

4642
03:25:20,270 --> 03:25:21,580
So this is great.

4643
03:25:21,580 --> 03:25:25,400
Now this isn't based upon
the name of these variables.

4644
03:25:25,400 --> 03:25:26,780
So I could actually switch these around.

4645
03:25:26,780 --> 03:25:30,440
I could say last name, age, first name.

4646
03:25:31,510 --> 03:25:32,343
Now watch.

4647
03:25:32,343 --> 03:25:34,720
If I run this, it's not gonna
be Donn Delker, 30 anymore.

4648
03:25:34,720 --> 03:25:36,750
It's not gonna print these in that way.

4649
03:25:36,750 --> 03:25:38,800
So it's gonna print 30 Donn Felker.

4650
03:25:38,800 --> 03:25:41,500
Now, the reason is it's based
upon the de-structuring.

4651
03:25:41,500 --> 03:25:42,810
So this is component one.

4652
03:25:42,810 --> 03:25:44,900
This is actually gonna be the first name.

4653
03:25:44,900 --> 03:25:47,210
So last name right here,
which we print right here.

4654
03:25:47,210 --> 03:25:50,012
This is the second one,
that's Don, that's correct.

4655
03:25:50,012 --> 03:25:51,280
Then we have first name,

4656
03:25:51,280 --> 03:25:53,550
which was actually using
component three's location.

4657
03:25:53,550 --> 03:25:56,310
Component three, so we're
just gonna see first name,

4658
03:25:56,310 --> 03:25:58,060
component three's location, which is age,

4659
03:25:58,060 --> 03:26:00,250
which is why we see 30 printed first here.

4660
03:26:00,250 --> 03:26:01,440
And the last thing that was printed,

4661
03:26:01,440 --> 03:26:04,210
I have listed as the
name of the age variable,

4662
03:26:04,210 --> 03:26:06,310
is showing Felker because that's actually

4663
03:26:06,310 --> 03:26:07,380
the second component here.

4664
03:26:07,380 --> 03:26:10,390
So this doesn't matter what
these variable names are.

4665
03:26:10,390 --> 03:26:14,240
So in essence, I could
actually just rename these two

4666
03:26:14,240 --> 03:26:19,240
component one, component two,

4667
03:26:21,790 --> 03:26:25,190
which I would have, these names
don't really mean anything.

4668
03:26:25,190 --> 03:26:27,190
And I would never do this in production,

4669
03:26:28,210 --> 03:26:30,940
but this is just an example
that it doesn't matter

4670
03:26:30,940 --> 03:26:33,390
the name of the actual values

4671
03:26:33,390 --> 03:26:34,500
that you're destructuring into.

4672
03:26:34,500 --> 03:26:36,500
It'll still print those values.

4673
03:26:36,500 --> 03:26:39,060
So let's go ahead and
move this component one,

4674
03:26:39,060 --> 03:26:40,150
component two, component three.

4675
03:26:40,150 --> 03:26:42,130
Let's print them in a proper order again.

4676
03:26:42,130 --> 03:26:44,170
So there was Donn Felker 30.

4677
03:26:44,170 --> 03:26:47,060
So again, I could just call
this F name for first name.

4678
03:26:47,060 --> 03:26:50,940
I could call this L name for last name.

4679
03:26:50,940 --> 03:26:52,890
It could be, you know, whatever casing.

4680
03:26:53,940 --> 03:26:56,580
L name, and then we could call it

4681
03:26:58,550 --> 03:27:02,070
go, and this could be person age.

4682
03:27:04,200 --> 03:27:07,480
It doesn't matter what, as
long as whatever is in this

4683
03:27:07,480 --> 03:27:09,540
third component is this
is the third component

4684
03:27:09,540 --> 03:27:11,190
is gonna be shoved into
this variable here.

4685
03:27:11,190 --> 03:27:14,680
And that's how you can
de structure a data class

4686
03:27:14,680 --> 03:27:17,780
into values here, just in one quick line,

4687
03:27:17,780 --> 03:27:19,570
because if you were to
do it the other way,

4688
03:27:19,570 --> 03:27:21,350
you might have to do something like this.

4689
03:27:21,350 --> 03:27:25,440
First name equals person
dot first name Val,

4690
03:27:26,370 --> 03:27:29,090
last name equals person dot last name,

4691
03:27:30,040 --> 03:27:31,630
and there's nothing wrong with doing this.

4692
03:27:31,630 --> 03:27:34,180
It's just, you can also use destructuring

4693
03:27:34,180 --> 03:27:39,180
to your advantage very easily
by turning this three lines

4694
03:27:39,180 --> 03:27:43,390
of code into one line of code.

4695
03:27:43,390 --> 03:27:48,005
And that's de-structuring
data classes in Kotlin.

4696
03:27:48,005 --> 03:27:53,005
It's very often in development
that you'll need to create

4697
03:27:55,470 --> 03:27:56,950
a copy of some data.

4698
03:27:56,950 --> 03:28:00,140
So perhaps you need to
create a copy of this person

4699
03:28:00,140 --> 03:28:02,560
and you'll want to create a sibling.

4700
03:28:02,560 --> 03:28:04,760
And the sibling will, then
you can easily do that

4701
03:28:04,760 --> 03:28:07,810
with the data class with
the built-in copy method.

4702
03:28:07,810 --> 03:28:11,050
And the copy method will
automatically create a copy

4703
03:28:11,050 --> 03:28:12,520
of everything inside of the class

4704
03:28:12,520 --> 03:28:13,590
and give you a new instance.

4705
03:28:13,590 --> 03:28:17,650
So if we were to create, to
print this to the screen here,

4706
03:28:17,650 --> 03:28:20,430
we would see person and then
if we were to come down here,

4707
03:28:20,430 --> 03:28:23,090
we could see sibling and we would run it.

4708
03:28:23,090 --> 03:28:27,170
We would see that the two
classes had the exact same data.

4709
03:28:27,170 --> 03:28:28,890
Now it's very often, you
may only wanna change

4710
03:28:28,890 --> 03:28:30,640
a couple of the attributes
and you can do that

4711
03:28:30,640 --> 03:28:32,500
with the named parameters.

4712
03:28:32,500 --> 03:28:35,240
And so I could say something like Sam.

4713
03:28:35,240 --> 03:28:36,500
Change the first name to Sam.

4714
03:28:36,500 --> 03:28:37,470
And if I were to run that here,

4715
03:28:37,470 --> 03:28:39,780
we'd see the rest of
the data stays the same,

4716
03:28:39,780 --> 03:28:41,720
except for the first name changes to Sam.

4717
03:28:41,720 --> 03:28:44,470
And maybe Sam is perhaps an older sibling

4718
03:28:44,470 --> 03:28:46,650
and Sam's age is 44.

4719
03:28:47,490 --> 03:28:48,420
And we were to run that.

4720
03:28:48,420 --> 03:28:51,320
And now we could see Sam Felker age 44.

4721
03:28:51,320 --> 03:28:52,980
Now this is an easy way to do this.

4722
03:28:52,980 --> 03:28:56,280
This is very useful if you
have a very large object graph.

4723
03:28:56,280 --> 03:29:00,870
So perhaps you have a
person, or maybe you have a,

4724
03:29:00,870 --> 03:29:03,470
perhaps a data class with a order.

4725
03:29:03,470 --> 03:29:07,140
And that order has an
amount which is an int.

4726
03:29:07,140 --> 03:29:09,990
And then the order belongs
to an action needs to be,

4727
03:29:09,990 --> 03:29:12,400
have a Val or a VAR amount,

4728
03:29:12,400 --> 03:29:15,020
and then actually belongs to a person

4729
03:29:15,020 --> 03:29:16,150
which could be the customer.

4730
03:29:16,150 --> 03:29:18,620
And that will be a person instance.

4731
03:29:18,620 --> 03:29:22,570
So if you were to do this, you
could actually come up here,

4732
03:29:22,570 --> 03:29:24,560
let's go ahead and create this order.

4733
03:29:24,560 --> 03:29:25,700
So we say Val order.

4734
03:29:26,870 --> 03:29:30,420
And this order would be, let
me say the amount is equal

4735
03:29:30,420 --> 03:29:35,420
to 100 and the person equals let's say

4736
03:29:35,420 --> 03:29:36,520
it equals the sibling.

4737
03:29:37,938 --> 03:29:41,860
Excuse me, the customer is the sibling.

4738
03:29:41,860 --> 03:29:44,140
And of course, if we print line this,

4739
03:29:44,140 --> 03:29:48,210
we're going to see that the
order has the amount of 100.

4740
03:29:49,350 --> 03:29:50,310
And then inside of there,

4741
03:29:50,310 --> 03:29:53,330
the customer is that person
instance with the age of 44.

4742
03:29:53,330 --> 03:29:55,710
So let's say I wanted to copy that order.

4743
03:29:55,710 --> 03:29:56,860
And so I say new order,

4744
03:29:59,060 --> 03:30:00,970
and I know let's say the
customer is the same,

4745
03:30:00,970 --> 03:30:02,720
but I just wanna change the amount.

4746
03:30:03,687 --> 03:30:06,750
I can say order, and I'd say
the amount is 200 this time,

4747
03:30:06,750 --> 03:30:08,420
perhaps they purchased
a different product,

4748
03:30:08,420 --> 03:30:10,430
but it's gonna be the same customer.

4749
03:30:10,430 --> 03:30:12,270
I could easily do that.

4750
03:30:12,270 --> 03:30:13,103
Oops, excuse me.

4751
03:30:13,103 --> 03:30:15,060
We'll say order dot copy.

4752
03:30:16,150 --> 03:30:18,400
And the amount will be 200.

4753
03:30:20,110 --> 03:30:21,560
And once we get the 200 here,

4754
03:30:22,452 --> 03:30:24,690
we can print line that for the new order.

4755
03:30:26,280 --> 03:30:27,950
And then once this runs,

4756
03:30:27,950 --> 03:30:29,660
we'll see that we have another order here

4757
03:30:29,660 --> 03:30:32,460
for the amount of 200, with
the same exact customer.

4758
03:30:32,460 --> 03:30:34,480
Now, this could also be, you know,

4759
03:30:34,480 --> 03:30:36,970
let's take this something
a new route here.

4760
03:30:36,970 --> 03:30:41,800
So let's say Val new order two,
I could say order dot copy.

4761
03:30:41,800 --> 03:30:44,120
And perhaps I want it
to create another order

4762
03:30:44,120 --> 03:30:45,320
of the same exact thing

4763
03:30:45,320 --> 03:30:47,380
but this time I have a different customer.

4764
03:30:47,380 --> 03:30:50,790
And this time the customer
would be the person.

4765
03:30:50,790 --> 03:30:52,510
Now I can say print line and we can see

4766
03:30:52,510 --> 03:30:54,130
what this would look like.

4767
03:30:54,130 --> 03:30:56,890
And it would say new order
two, and we'd run it here.

4768
03:30:56,890 --> 03:31:00,210
We can actually see that the
order amount is still 100

4769
03:31:00,210 --> 03:31:03,300
but this time the person
has actually changed.

4770
03:31:03,300 --> 03:31:06,940
And that's how you copy a
data class in Kotlin, period.

4771
03:31:06,940 --> 03:31:10,630
It's important to note that
this is not a full deep copy

4772
03:31:10,630 --> 03:31:12,110
if you're using lists and so forth,

4773
03:31:12,110 --> 03:31:13,940
a lot of these items
will be shallow copies.

4774
03:31:13,940 --> 03:31:15,970
So be careful copying lists this way.

4775
03:31:17,940 --> 03:31:19,410
You can build your own data classes,

4776
03:31:19,410 --> 03:31:21,890
but there are a couple of
useful data classes built

4777
03:31:21,890 --> 03:31:23,580
into the standard library.

4778
03:31:23,580 --> 03:31:27,430
One is known as a pair and
it's just a pair of values.

4779
03:31:27,430 --> 03:31:32,430
So you could have foo and
then you could have bar,

4780
03:31:33,310 --> 03:31:35,310
and these are just a pair of
values and they're accessed

4781
03:31:35,310 --> 03:31:38,610
via the first and second parameter values.

4782
03:31:41,151 --> 03:31:41,984
So you can have a pair of value.

4783
03:31:41,984 --> 03:31:43,960
So you don't have to create a,

4784
03:31:43,960 --> 03:31:46,240
if you have two values
you need to parse around,

4785
03:31:46,240 --> 03:31:47,880
you don't feel like creating
a custom class for it,

4786
03:31:47,880 --> 03:31:49,480
you can use a pair.

4787
03:31:49,480 --> 03:31:53,010
And of course, when you
print line these to screen,

4788
03:31:53,010 --> 03:31:57,887
you're going to see that
we have the following.

4789
03:31:59,500 --> 03:32:02,740
So we have the first just
foo and the second is bar.

4790
03:32:02,740 --> 03:32:05,850
Now there's also another
way another syntax

4791
03:32:05,850 --> 03:32:06,750
you can use for this.

4792
03:32:06,750 --> 03:32:09,090
And you'll see convert to two here.

4793
03:32:09,090 --> 03:32:11,550
And this is a syntax using the two syntax.

4794
03:32:11,550 --> 03:32:15,330
So basically we have foo
is going to match to bar.

4795
03:32:15,330 --> 03:32:16,163
It's a pair.

4796
03:32:16,163 --> 03:32:19,060
So this is another way to
create a pair is foo to bar.

4797
03:32:19,060 --> 03:32:22,410
It's a syntactic sugar
over the application.

4798
03:32:22,410 --> 03:32:26,350
And this is inside of the
Kotlin standard library.

4799
03:32:26,350 --> 03:32:28,588
And you can look at the
implementation here,

4800
03:32:28,588 --> 03:32:31,120
creates a (indistinct)
pair from this and that.

4801
03:32:31,120 --> 03:32:33,980
So this and that is
basically the two values.

4802
03:32:33,980 --> 03:32:35,580
So you don't have to worry
about the implementation,

4803
03:32:35,580 --> 03:32:38,370
but you can either use a pair like this

4804
03:32:38,370 --> 03:32:40,640
or if you want, you can go ahead and use

4805
03:32:40,640 --> 03:32:43,880
the regular pair method like this.

4806
03:32:43,880 --> 03:32:46,910
We have a small error
and there's our pair.

4807
03:32:46,910 --> 03:32:47,743
Now there's another one here.

4808
03:32:47,743 --> 03:32:50,120
If you have three values,
you can call it a triple.

4809
03:32:51,390 --> 03:32:53,150
And a triple is the same type of thing.

4810
03:32:53,150 --> 03:32:58,150
So we can say foo bar is or whatever,

4811
03:32:58,470 --> 03:32:59,860
and we have three values.

4812
03:32:59,860 --> 03:33:00,850
And the same thing happens here.

4813
03:33:00,850 --> 03:33:05,640
You can say triple.first.second.third.

4814
03:33:07,353 --> 03:33:08,210
And these are all very similar.

4815
03:33:08,210 --> 03:33:09,540
Now they don't have to be strength.

4816
03:33:09,540 --> 03:33:10,640
They can be whatever you want.

4817
03:33:10,640 --> 03:33:13,370
If you want them to be an
integer and you want this one

4818
03:33:13,370 --> 03:33:16,190
to be Boolean, you could do that.

4819
03:33:16,190 --> 03:33:18,260
And this is up to you, how
you would like to have them.

4820
03:33:18,260 --> 03:33:20,070
And then of course, as we see here,

4821
03:33:20,070 --> 03:33:23,950
the triple dot second is gonna be Boolean

4822
03:33:23,950 --> 03:33:25,420
as we see right here.

4823
03:33:25,420 --> 03:33:27,760
We see the third is gonna be integer,

4824
03:33:29,252 --> 03:33:30,260
and then we can see we can also copy that

4825
03:33:30,260 --> 03:33:31,510
'cause it's a built-in data class,

4826
03:33:31,510 --> 03:33:34,260
so we can copy these and
work with them as they would

4827
03:33:34,260 --> 03:33:35,770
with regular data classes.

4828
03:33:35,770 --> 03:33:40,640
So these are the two built
in data classes right now

4829
03:33:40,640 --> 03:33:42,830
that are inside of the
Kotlin standard library.

4830
03:33:42,830 --> 03:33:44,010
Of course, more to come,

4831
03:33:44,010 --> 03:33:45,770
if you're watching this in the future.

4832
03:33:45,770 --> 03:33:48,720
It's pair and triple, they're
both in the standard library.

4833
03:33:50,110 --> 03:33:54,670
Adding a protected modifier to
a variable in Kotlin is easy.

4834
03:33:54,670 --> 03:33:57,910
All you have to do is
inside of your class,

4835
03:33:57,910 --> 03:34:02,100
add the protected modifier
to your variable name

4836
03:34:02,100 --> 03:34:03,630
prior to the declaration.

4837
03:34:03,630 --> 03:34:06,820
So here I've added
protected two favorite food.

4838
03:34:06,820 --> 03:34:08,260
Now let's go ahead and
remove that real quick

4839
03:34:08,260 --> 03:34:10,770
and see what the cause of that happens is.

4840
03:34:10,770 --> 03:34:13,040
Back in the main file,
I've created a new instance

4841
03:34:13,040 --> 03:34:15,930
of the person class, and this person class

4842
03:34:15,930 --> 03:34:17,860
has a favorite food property on it.

4843
03:34:17,860 --> 03:34:21,040
So I could set perhaps watermelon.

4844
03:34:21,040 --> 03:34:22,620
Now this works just fine,

4845
03:34:22,620 --> 03:34:24,930
works as a regular setter and getter.

4846
03:34:24,930 --> 03:34:27,140
I have a property that
we're used to working with.

4847
03:34:27,140 --> 03:34:30,810
However, if I were to add
the protected keyword here,

4848
03:34:30,810 --> 03:34:32,890
this now modifies this variable.

4849
03:34:32,890 --> 03:34:35,020
So it's only visible from
within the current class,

4850
03:34:35,020 --> 03:34:40,020
in any of the classes that
it get inherit from it.

4851
03:34:40,040 --> 03:34:42,640
So if we come back here, we
now see in the main class,

4852
03:34:42,640 --> 03:34:45,160
I no longer have access to set this value.

4853
03:34:45,160 --> 03:34:49,350
And if I try via intellisense
or code completion

4854
03:34:49,350 --> 03:34:52,600
to see favorite food, we're
gonna see that it's not there.

4855
03:34:52,600 --> 03:34:54,780
And the reason for that is
because it's now protected.

4856
03:34:54,780 --> 03:34:58,380
So only this class and any
of the classes that inherit

4857
03:34:58,380 --> 03:34:59,880
from it are going to see it.

4858
03:34:59,880 --> 03:35:01,060
So let's see that in action here.

4859
03:35:01,060 --> 03:35:03,930
And I've actually already created
another class called chef.

4860
03:35:03,930 --> 03:35:06,260
And remember, I have had
to add the open keyword

4861
03:35:06,260 --> 03:35:09,480
so I can extend the person class.

4862
03:35:09,480 --> 03:35:11,682
I've created person and chef.

4863
03:35:11,682 --> 03:35:12,630
So basically a chef just extends person.

4864
03:35:12,630 --> 03:35:16,410
Now, maybe if I have a chef
class, for whatever reason,

4865
03:35:16,410 --> 03:35:18,590
the chef can have a favorite food.

4866
03:35:18,590 --> 03:35:22,350
So I'll say fav food, and
we're just gonna say string.

4867
03:35:22,350 --> 03:35:24,520
And so when I create a chef now,

4868
03:35:24,520 --> 03:35:26,470
I have to provide a favorite food.

4869
03:35:26,470 --> 03:35:28,950
And then what I can do is
I can actually set that.

4870
03:35:28,950 --> 03:35:30,930
I'm gonna create an initializer block,

4871
03:35:30,930 --> 03:35:33,840
which will be called as
soon as we create the class.

4872
03:35:33,840 --> 03:35:35,340
And then I can say
actually, favorite food.

4873
03:35:35,340 --> 03:35:36,690
See there's favorite food.

4874
03:35:36,690 --> 03:35:38,580
And if I go to the
declaration of it's actually

4875
03:35:38,580 --> 03:35:41,400
gonna take me right up here to line five.

4876
03:35:41,400 --> 03:35:44,070
Now back here on line
15, I say favorite food

4877
03:35:44,070 --> 03:35:47,500
equals my favorite food
that I just parse d in.

4878
03:35:47,500 --> 03:35:48,940
So that's interesting.

4879
03:35:48,940 --> 03:35:52,460
I can access it from within side of chef.

4880
03:35:52,460 --> 03:35:54,860
Now, if say for whatever reason,

4881
03:35:54,860 --> 03:35:59,453
I don't want to allow
regular persons to modify

4882
03:36:01,050 --> 03:36:03,730
the favorite food variable.

4883
03:36:03,730 --> 03:36:05,970
I only want it to allow the chef to do it.

4884
03:36:05,970 --> 03:36:08,620
So I've not really
restricted anything up here.

4885
03:36:08,620 --> 03:36:10,920
I could still come here
and say favorite food

4886
03:36:12,347 --> 03:36:13,180
and I can still change here,

4887
03:36:13,180 --> 03:36:16,580
but maybe I don't want to
have a public API per se,

4888
03:36:16,580 --> 03:36:19,640
that allows me or any callers to modify.

4889
03:36:19,640 --> 03:36:21,470
So I don't ever want the person variable.

4890
03:36:21,470 --> 03:36:25,840
So I never want the person not
favorite food to be called.

4891
03:36:25,840 --> 03:36:28,950
Now, if I were to call a
chef, so, or create a chef,

4892
03:36:28,950 --> 03:36:32,660
I would say, perhaps something
like this, and we can say,

4893
03:36:33,610 --> 03:36:37,930
Bob and Bob is 33 and Bob's
favorite food is ribs.

4894
03:36:39,110 --> 03:36:41,860
Then we can see here that
now I can actually set

4895
03:36:41,860 --> 03:36:42,810
the favorite food here,

4896
03:36:42,810 --> 03:36:44,860
because this is being set right here,

4897
03:36:44,860 --> 03:36:48,210
which in turn is being set
inside the initializer block.

4898
03:36:48,210 --> 03:36:50,230
But let's go ahead and assume
that I want them to only allow

4899
03:36:50,230 --> 03:36:51,090
chef to change it.

4900
03:36:51,090 --> 03:36:54,850
So I create a function, as
I say set favorite food,

4901
03:36:54,850 --> 03:36:57,260
and they may a parse in the food.

4902
03:36:57,260 --> 03:37:01,090
And then what I would do
is this a favorite food

4903
03:37:01,090 --> 03:37:01,970
equals food.

4904
03:37:03,810 --> 03:37:05,830
Now we have an interesting error here.

4905
03:37:05,830 --> 03:37:06,740
We're getting a squiggly line.

4906
03:37:06,740 --> 03:37:08,650
And if we put our cursor over it,

4907
03:37:08,650 --> 03:37:12,146
we'll see that we get an error
of an accidental override.

4908
03:37:12,146 --> 03:37:14,170
And what this is basically
telling us is that,

4909
03:37:14,170 --> 03:37:16,700
hey, Kotlin actually does us a favor here.

4910
03:37:16,700 --> 03:37:19,500
When we declare a property
up here automatically

4911
03:37:19,500 --> 03:37:21,020
what's being created behind the scenes

4912
03:37:21,020 --> 03:37:25,170
for other JVM based languages
such as Java and so forth,

4913
03:37:25,170 --> 03:37:27,670
are variables like this.

4914
03:37:27,670 --> 03:37:29,390
Excuse me, methods like this.

4915
03:37:29,390 --> 03:37:30,610
We have a set favorite food,

4916
03:37:30,610 --> 03:37:33,700
which is going to allow
us to parse in a value,

4917
03:37:33,700 --> 03:37:35,830
which is a setter, which can be string.

4918
03:37:36,750 --> 03:37:39,100
And then there's also a
getter, so an accessor.

4919
03:37:40,330 --> 03:37:44,690
And these two methods
are created simply for,

4920
03:37:44,690 --> 03:37:46,720
it's gonna return a string,

4921
03:37:46,720 --> 03:37:49,590
interoperability with other JVM languages.

4922
03:37:49,590 --> 03:37:53,540
Anytime you've worked in
traditional Java environments,

4923
03:37:53,540 --> 03:37:54,770
anytime you declare a variable,

4924
03:37:54,770 --> 03:37:56,860
you need to provide a
mutator and an accessor.

4925
03:37:56,860 --> 03:37:58,560
So a setter and a getter.

4926
03:37:58,560 --> 03:38:02,400
And this is typically the
method in which you do it.

4927
03:38:02,400 --> 03:38:06,660
You prefix the set,
whatever variable name is

4928
03:38:06,660 --> 03:38:09,910
and proper, of course, camel case.

4929
03:38:09,910 --> 03:38:13,950
And then of course, if there is a getter,

4930
03:38:13,950 --> 03:38:16,410
which are usually is in this
case, you wanna get the value,

4931
03:38:16,410 --> 03:38:18,020
you have the getter in the same format.

4932
03:38:18,020 --> 03:38:20,310
So prefix it with the word get.

4933
03:38:20,310 --> 03:38:23,080
So set and get, these are
generated automatically

4934
03:38:23,080 --> 03:38:24,080
for you behind the scenes.

4935
03:38:24,080 --> 03:38:27,670
So Kotlin's saying, "Hey,
we can't really do that.

4936
03:38:28,630 --> 03:38:29,463
"You shouldn't do this.

4937
03:38:29,463 --> 03:38:32,530
"We're already gonna generate
this for you, so no dice."

4938
03:38:32,530 --> 03:38:34,690
So I'm just gonna go and
rename and set my favorite food

4939
03:38:34,690 --> 03:38:36,270
just for an example.

4940
03:38:36,270 --> 03:38:38,460
So now if I go back to my main class,

4941
03:38:38,460 --> 03:38:41,560
what I can actually do is
that the chef can actually set

4942
03:38:41,560 --> 03:38:43,032
my favorite food.

4943
03:38:43,032 --> 03:38:45,032
And maybe I wanna change that to celery.

4944
03:38:46,240 --> 03:38:47,600
I don't know who likes celery that much,

4945
03:38:47,600 --> 03:38:49,830
but that's beyond the scope of this.

4946
03:38:49,830 --> 03:38:52,560
So we have a favorite
food that set the celery.

4947
03:38:52,560 --> 03:38:56,410
But now if we try to change the
food to set my favorite food

4948
03:38:56,410 --> 03:38:59,690
on the person, well, that
method of course does not exist

4949
03:38:59,690 --> 03:39:01,230
in the person class.

4950
03:39:01,230 --> 03:39:02,580
So that's interesting thing.

4951
03:39:02,580 --> 03:39:05,310
But what we can do is
we can actually print

4952
03:39:06,240 --> 03:39:10,913
with my favorite food from the superclass.

4953
03:39:12,500 --> 03:39:13,350
And that's very easy to do.

4954
03:39:13,350 --> 03:39:14,220
Say print line.

4955
03:39:16,080 --> 03:39:17,430
And inside that print line,

4956
03:39:19,519 --> 03:39:20,520
we'll go ahead and say the favorite food.

4957
03:39:21,395 --> 03:39:22,228
So that's pretty simple.

4958
03:39:22,228 --> 03:39:23,420
Now, if we were actually gonna call this

4959
03:39:23,420 --> 03:39:26,620
from the person class, P
dot print my favorite food,

4960
03:39:26,620 --> 03:39:28,080
that'll work.

4961
03:39:28,080 --> 03:39:28,920
And if we're gonna do it down here.

4962
03:39:28,920 --> 03:39:31,180
C dot, let's actually do it two times,

4963
03:39:31,180 --> 03:39:34,540
C dot print my favorite food
and then same thing down here,

4964
03:39:34,540 --> 03:39:35,480
print my favorite food.

4965
03:39:35,480 --> 03:39:39,880
Because again, I am extending
the person class over here.

4966
03:39:41,860 --> 03:39:44,260
So the chef class is
extending the person class.

4967
03:39:45,400 --> 03:39:48,900
I then can call any of the
methods that are available to it.

4968
03:39:48,900 --> 03:39:51,250
So that are not private based.

4969
03:39:51,250 --> 03:39:52,860
And I'm calling print my favorite food.

4970
03:39:52,860 --> 03:39:54,070
Now for the person class,

4971
03:39:54,070 --> 03:39:56,880
this is gonna show up as
unknown because we are not able

4972
03:39:56,880 --> 03:39:59,180
to set the favorite food of that person

4973
03:40:00,220 --> 03:40:02,120
unless we're using a chef instance.

4974
03:40:02,120 --> 03:40:04,230
So the favorite food is just
going to show up as unknown

4975
03:40:04,230 --> 03:40:08,100
for the chef we're actually
gonna see it twice.

4976
03:40:09,682 --> 03:40:10,515
So we'll say print my
favorite food, it'll say ribs.

4977
03:40:10,515 --> 03:40:12,456
We're gonna change it to celery.

4978
03:40:12,456 --> 03:40:15,150
And then once we print it
again, it'll show as celery.

4979
03:40:15,150 --> 03:40:20,150
So this is us enabling to work
with a protected variable.

4980
03:40:20,410 --> 03:40:22,310
So if there's anything that
you would like to protect

4981
03:40:22,310 --> 03:40:25,970
from any outside callers,
you wanna hold some state

4982
03:40:25,970 --> 03:40:28,190
inside of your class, but
maybe you still wanted

4983
03:40:28,190 --> 03:40:32,710
to be available to other
children classes via inheritance.

4984
03:40:32,710 --> 03:40:35,730
Then you can go ahead and
provide a protected variable

4985
03:40:35,730 --> 03:40:36,563
and you can do that.

4986
03:40:36,563 --> 03:40:39,460
And of course this works
with objects and value types,

4987
03:40:39,460 --> 03:40:40,360
et cetera.

4988
03:40:40,360 --> 03:40:42,250
Now, of course, if we were to run this,

4989
03:40:42,250 --> 03:40:43,450
here's what we would see.

4990
03:40:44,513 --> 03:40:46,460
We would see unknown, which is the person

4991
03:40:46,460 --> 03:40:48,640
knowing see ribs and we'd see celery.

4992
03:40:48,640 --> 03:40:51,050
And that's how you can work
with protected variables

4993
03:40:51,050 --> 03:40:51,883
in Kotlin.

4994
03:40:53,470 --> 03:40:57,260
You can also make a
method protected as well.

4995
03:40:57,260 --> 03:40:59,870
So we're going to use the same
example here that was used

4996
03:40:59,870 --> 03:41:02,830
in the variable protected modifier lesson.

4997
03:41:04,000 --> 03:41:07,100
And so here we have the print,
my favorite food method,

4998
03:41:07,100 --> 03:41:09,500
which can be used back
inside of this main class.

4999
03:41:09,500 --> 03:41:14,500
So again, like I say
p.print my favorite food.

5000
03:41:16,338 --> 03:41:18,340
And when you say c.print my favorite food,

5001
03:41:20,260 --> 03:41:22,400
and that's going to print
the actual favorite food,

5002
03:41:22,400 --> 03:41:24,990
which is called from the person class.

5003
03:41:24,990 --> 03:41:27,470
Now, for whatever reason
inside of your application,

5004
03:41:27,470 --> 03:41:29,780
you may determine that
you do not want this

5005
03:41:29,780 --> 03:41:32,297
to be part of your public API.

5006
03:41:32,297 --> 03:41:35,880
And what I mean by public
API is a part of your class

5007
03:41:35,880 --> 03:41:39,340
that can be called anywhere
that's perhaps public,

5008
03:41:39,340 --> 03:41:40,870
and this would be a public method.

5009
03:41:40,870 --> 03:41:43,170
So we can actually access it publicly.

5010
03:41:43,170 --> 03:41:44,530
Let's say for whatever reason you want it

5011
03:41:44,530 --> 03:41:47,770
to only access this within
the current instance

5012
03:41:47,770 --> 03:41:50,170
of person or any of the children classes

5013
03:41:50,170 --> 03:41:51,480
such as chef or whatever.

5014
03:41:52,690 --> 03:41:54,040
To do that all you're gonna wanna do

5015
03:41:54,040 --> 03:41:57,100
is slap on the protected keyword.

5016
03:41:57,100 --> 03:42:00,060
And now this modifier was now applied

5017
03:42:00,060 --> 03:42:02,880
the per print my favorite
food to only be available

5018
03:42:02,880 --> 03:42:05,890
from within this class and
from within this class.

5019
03:42:05,890 --> 03:42:07,950
So let's go back to the
main file and take a look

5020
03:42:07,950 --> 03:42:09,150
what happened.

5021
03:42:09,150 --> 03:42:13,040
Now we can see that the print
my favorite food is protected.

5022
03:42:13,040 --> 03:42:13,930
So what does that mean?

5023
03:42:13,930 --> 03:42:16,570
Let's take a look here
and the auto-complete,

5024
03:42:17,470 --> 03:42:19,640
we don't see print my
favorite food anymore.

5025
03:42:19,640 --> 03:42:23,370
However, if we were to go
perhaps into the info class here,

5026
03:42:23,370 --> 03:42:25,150
we can say, print my favorite food.

5027
03:42:25,150 --> 03:42:27,940
We could still call it from
within the person class.

5028
03:42:27,940 --> 03:42:29,630
So give us a little flexibility here.

5029
03:42:29,630 --> 03:42:33,660
And also any of perhaps other classes,

5030
03:42:33,660 --> 03:42:35,340
perhaps that we wanted
to set my favorite food

5031
03:42:35,340 --> 03:42:38,370
and then print it for
the console or whatever,

5032
03:42:38,370 --> 03:42:39,650
we can call it from within any

5033
03:42:39,650 --> 03:42:41,180
of the other children classes as well.

5034
03:42:41,180 --> 03:42:43,710
So now let's say that's what we wanna do,

5035
03:42:43,710 --> 03:42:46,680
we only wanna print it when
we set the favorite food

5036
03:42:46,680 --> 03:42:47,513
for whatever reason.

5037
03:42:47,513 --> 03:42:49,400
So we can say, print my favorite food.

5038
03:42:49,400 --> 03:42:51,710
Now we can come back here.

5039
03:42:51,710 --> 03:42:55,190
And of course, if we cannot
print or have anything

5040
03:42:55,190 --> 03:42:57,740
to do with the favorite food
from a person perspective,

5041
03:42:57,740 --> 03:43:00,330
because maybe that's
just part of the given,

5042
03:43:00,330 --> 03:43:02,620
the way you're designing application,

5043
03:43:02,620 --> 03:43:04,490
but we can actually say
set my favorite food.

5044
03:43:04,490 --> 03:43:07,020
So we know that the person's
food was ribs before,

5045
03:43:08,164 --> 03:43:10,030
but for whatever reason,
we wanna change it now

5046
03:43:10,030 --> 03:43:12,890
and change it to be a potato.

5047
03:43:15,810 --> 03:43:18,610
And so if we were to run this
now, what we should see happen

5048
03:43:18,610 --> 03:43:22,550
is it's gonna be set from ribs to potato,

5049
03:43:22,550 --> 03:43:24,794
and then it's gonna print
potato to the screen.

5050
03:43:24,794 --> 03:43:26,510
Let me see print potato to the screen.

5051
03:43:26,510 --> 03:43:28,660
And the reason why is
because inside of the set

5052
03:43:28,660 --> 03:43:30,320
my favorite food method,

5053
03:43:30,320 --> 03:43:32,911
we're setting the favorite
food to a different food

5054
03:43:32,911 --> 03:43:34,000
and then we're calling
print my favorite food,

5055
03:43:34,000 --> 03:43:36,330
which is protected inside of here.

5056
03:43:36,330 --> 03:43:38,990
Now, of course we could,
maybe there's no need for this

5057
03:43:38,990 --> 03:43:39,900
to be inside of here.

5058
03:43:39,900 --> 03:43:43,280
And maybe the food does not
even need to be inside of here,

5059
03:43:43,280 --> 03:43:46,170
which when you start
thinking about it perhaps,

5060
03:43:46,170 --> 03:43:49,040
the person, we don't need to
know anything about the person

5061
03:43:49,040 --> 03:43:50,920
having a favorite food.

5062
03:43:50,920 --> 03:43:53,540
So maybe we just need
to move both of these

5063
03:43:53,540 --> 03:43:56,130
into this class down here.

5064
03:43:57,980 --> 03:43:58,990
And this would both work here.

5065
03:43:58,990 --> 03:44:00,430
So we're gonna see favorite food now,

5066
03:44:00,430 --> 03:44:03,120
is not going to have a problem here.

5067
03:44:03,120 --> 03:44:05,230
So what is it saying can vary by...

5068
03:44:05,230 --> 03:44:07,730
Variable cannot be initialized
before declaration.

5069
03:44:08,580 --> 03:44:10,000
So what we can then do here.

5070
03:44:10,000 --> 03:44:12,510
So we've trying to initialize it before,

5071
03:44:12,510 --> 03:44:13,810
it's really been declared,

5072
03:44:14,793 --> 03:44:15,626
there's a couple of
things we could do here.

5073
03:44:15,626 --> 03:44:16,500
So we just kind of go
ahead and remove this

5074
03:44:16,500 --> 03:44:17,920
and we could actually remove this as well,

5075
03:44:17,920 --> 03:44:20,950
because let's assume that every
chef needs a favorite food.

5076
03:44:20,950 --> 03:44:22,900
So to get access to this
and since we're mutating it,

5077
03:44:22,900 --> 03:44:24,410
we're gonna change this to a variable.

5078
03:44:24,410 --> 03:44:26,380
So throw the var word on
there and now we can print it

5079
03:44:26,380 --> 03:44:28,740
and now we can also mutate it as well.

5080
03:44:28,740 --> 03:44:31,390
And if we go back to our main class now,

5081
03:44:32,630 --> 03:44:34,670
we've kind of cleaned
up our API a little bit.

5082
03:44:34,670 --> 03:44:36,530
So we definitely do have our person class

5083
03:44:36,530 --> 03:44:38,730
and we do have the chef class,

5084
03:44:38,730 --> 03:44:40,460
and this will still run accordingly

5085
03:44:40,460 --> 03:44:44,100
because the person is very
kind of a just a shell

5086
03:44:46,048 --> 03:44:46,881
of a class.

5087
03:44:46,881 --> 03:44:48,808
And of course we print and we see potato.

5088
03:44:48,808 --> 03:44:50,766
And what I mean by that
is the person class

5089
03:44:50,766 --> 03:44:51,777
just contains the name of the age.

5090
03:44:51,777 --> 03:44:53,800
And it's just a very basic
information about a person

5091
03:44:53,800 --> 03:44:55,920
and we've extended it using inheritance.

5092
03:44:55,920 --> 03:44:57,720
And we've created a chef
and added a favorite food

5093
03:44:57,720 --> 03:44:58,830
for that chef.

5094
03:44:58,830 --> 03:45:00,620
And this chef males will
have additional methods

5095
03:45:00,620 --> 03:45:03,330
like cook their favorite
meal or anything like that,

5096
03:45:03,330 --> 03:45:05,440
or prepare foods.

5097
03:45:05,440 --> 03:45:07,730
And as we start building
an application out,

5098
03:45:07,730 --> 03:45:10,060
we can start separating
it into different classes,

5099
03:45:10,060 --> 03:45:13,540
yet also having values
in here that are perhaps

5100
03:45:14,800 --> 03:45:19,800
more protected and the
modifiers are in way

5101
03:45:20,740 --> 03:45:22,620
such that they can only
be seen by children.

5102
03:45:22,620 --> 03:45:24,920
So, which kind of brings up a good point

5103
03:45:24,920 --> 03:45:29,520
that if you had a chef class,
well, you could also have

5104
03:45:30,700 --> 03:45:33,000
a class, you have a sous chef class.

5105
03:45:34,020 --> 03:45:36,880
And this one would take in
taking the name and a string

5106
03:45:36,880 --> 03:45:41,880
and an age and int and
a favorite food perhaps.

5107
03:45:44,360 --> 03:45:46,390
And this one would inherit from chef.

5108
03:45:48,700 --> 03:45:50,700
And so we have name, age, favorite food.

5109
03:45:52,630 --> 03:45:53,630
There we go.

5110
03:45:56,030 --> 03:45:58,280
We just gonna renew this
to fave food or whatever,

5111
03:46:00,280 --> 03:46:01,780
we'll call this the fave food.

5112
03:46:02,680 --> 03:46:04,907
And then of course we
could have inside of here,

5113
03:46:04,907 --> 03:46:05,740
something else, we have some other classes

5114
03:46:05,740 --> 03:46:08,820
and stuff inside here,
or you can actually,

5115
03:46:08,820 --> 03:46:12,427
if you would like to, you can
say inside of your inner block

5116
03:46:14,600 --> 03:46:16,240
whatever reason you
wanted to print something

5117
03:46:16,240 --> 03:46:18,380
when it was created, you
could do that side of here.

5118
03:46:18,380 --> 03:46:21,600
And so for my favorite
food is not accessible

5119
03:46:21,600 --> 03:46:24,080
to the outside world,
it's not a public API.

5120
03:46:24,080 --> 03:46:29,080
So I can't call c.print my
favorite food, which is a chef.

5121
03:46:30,910 --> 03:46:33,700
I can't call it anywhere in
public because it's protected.

5122
03:46:33,700 --> 03:46:35,510
However, any of the children classes

5123
03:46:35,510 --> 03:46:36,580
can then still call this.

5124
03:46:36,580 --> 03:46:39,650
So here person is just giving us

5125
03:46:39,650 --> 03:46:42,120
some root level inheritance.

5126
03:46:42,120 --> 03:46:43,680
Now we're kind of created chef class

5127
03:46:43,680 --> 03:46:45,030
has some stuff around it.

5128
03:46:45,030 --> 03:46:46,260
And then we've got a sous chef class

5129
03:46:46,260 --> 03:46:47,750
that maybe has some other
things inside of here.

5130
03:46:47,750 --> 03:46:51,850
And you might wanna have
something like prep foods methods

5131
03:46:51,850 --> 03:46:54,800
and stuff like that or something
that a sous chef would do.

5132
03:46:55,910 --> 03:46:58,650
And that's how you can create a method,

5133
03:46:58,650 --> 03:47:01,350
which has a visibility
modifier of protected.

5134
03:47:03,470 --> 03:47:06,560
How do we use the internal
modifier on a class?

5135
03:47:07,800 --> 03:47:09,613
And what does it use for?

5136
03:47:09,613 --> 03:47:10,500
It's a great question.

5137
03:47:10,500 --> 03:47:13,260
So the vehicle class that we have here

5138
03:47:13,260 --> 03:47:17,500
is a very simple class that
just takes a color of a vehicle,

5139
03:47:17,500 --> 03:47:18,550
and then we can print it out.

5140
03:47:18,550 --> 03:47:21,470
Now, of course, this class would
have a lot more information

5141
03:47:21,470 --> 03:47:23,750
about a particular vehicle, et cetera.

5142
03:47:23,750 --> 03:47:27,700
However, let's go ahead and
assume that this vehicle

5143
03:47:27,700 --> 03:47:28,860
has some axles.

5144
03:47:28,860 --> 03:47:29,910
So we knew another class.

5145
03:47:29,910 --> 03:47:32,600
So we're gonna create a class called axle

5146
03:47:32,600 --> 03:47:34,050
and we're gonna have a count.

5147
03:47:34,920 --> 03:47:37,820
And this count is gonna be,
actually let's call it number.

5148
03:47:39,292 --> 03:47:40,125
And it's gonna be entered your value

5149
03:47:40,125 --> 03:47:42,295
and that's basically the number of wheels.

5150
03:47:42,295 --> 03:47:44,420
So we'll say number of wheels on the axle.

5151
03:47:45,470 --> 03:47:47,510
And then of course it would be
a whole bunch of other stuff

5152
03:47:47,510 --> 03:47:51,200
inside of this axle class
that would do things for us,

5153
03:47:51,200 --> 03:47:53,290
but we're gonna leave
that out for brevity here.

5154
03:47:53,290 --> 03:47:56,700
Now we know that the vehicle is gonna have

5155
03:47:56,700 --> 03:47:57,870
a number of axles.

5156
03:47:57,870 --> 03:48:00,599
So let's go and say axles,
and then we're gonna have it

5157
03:48:00,599 --> 03:48:02,670
as an array of axle.

5158
03:48:02,670 --> 03:48:04,300
Now, of course, we don't know what that is

5159
03:48:04,300 --> 03:48:05,480
given this period in time.

5160
03:48:05,480 --> 03:48:07,720
So we're gonna actually go
ahead and apply the late init

5161
03:48:07,720 --> 03:48:10,820
modifier saying, Kotlin, I
don't know what it is right now

5162
03:48:10,820 --> 03:48:11,700
at compile time.

5163
03:48:11,700 --> 03:48:12,890
I'm gonna initialize it later.

5164
03:48:12,890 --> 03:48:15,050
Don't worry about it,
I'll take care of it.

5165
03:48:15,050 --> 03:48:15,940
So this all makes sense.

5166
03:48:15,940 --> 03:48:18,240
We have a public class, we have axles,

5167
03:48:18,240 --> 03:48:20,270
and then we might even
have something else,

5168
03:48:20,270 --> 03:48:21,460
like another class.

5169
03:48:21,460 --> 03:48:25,130
And this one's gonna be a
truck because perhaps we know

5170
03:48:25,130 --> 03:48:27,430
that the truck is going to be,

5171
03:48:28,380 --> 03:48:30,360
of course, it's going to be a vehicle

5172
03:48:30,360 --> 03:48:32,860
and we need to parse it in the color.

5173
03:48:32,860 --> 03:48:36,080
And then for whatever reason,
we already know that a truck,

5174
03:48:36,080 --> 03:48:38,320
this truck that we're
building or all trucks

5175
03:48:38,320 --> 03:48:40,420
in our application are
gonna have some axles.

5176
03:48:40,420 --> 03:48:43,950
So we say axles equal, we'll say array of,

5177
03:48:45,080 --> 03:48:48,200
and allows us to create an
array and I could say axle.

5178
03:48:48,200 --> 03:48:50,230
And perhaps this first access to wheels,

5179
03:48:50,230 --> 03:48:54,030
and this next axle has four wheels,

5180
03:48:54,030 --> 03:48:55,270
basically, meaning we have two axles,

5181
03:48:55,270 --> 03:48:57,700
one with two wheels in the
front, four on the back.

5182
03:48:57,700 --> 03:48:59,710
So this all makes sense, this is great.

5183
03:48:59,710 --> 03:49:01,450
If we go back to our main class,

5184
03:49:01,450 --> 03:49:05,360
we can easily create a
vehicle as I've done here.

5185
03:49:05,360 --> 03:49:08,280
I can actually say vehicle that
axles, I can see the axles.

5186
03:49:08,280 --> 03:49:13,280
I can say, val truck equals
truck and I can parse in blue.

5187
03:49:14,110 --> 03:49:17,470
And the truck's gonna have
axles that can have access to,

5188
03:49:17,470 --> 03:49:20,710
but let's go ahead and
assume for whatever reason

5189
03:49:20,710 --> 03:49:25,530
that we do not want anybody
outside of our current module

5190
03:49:25,530 --> 03:49:27,720
to know about this axle class.

5191
03:49:27,720 --> 03:49:32,060
Maybe we only want to expose
things about vehicles,

5192
03:49:32,060 --> 03:49:35,110
but internally for
organizational purposes,

5193
03:49:35,110 --> 03:49:38,920
we want to be able to have a
class that represents an axle.

5194
03:49:38,920 --> 03:49:40,850
Maybe it has a bunch of utility methods

5195
03:49:40,850 --> 03:49:44,100
that just helps us do things
inside of our application,

5196
03:49:45,343 --> 03:49:47,270
but we don't want other people
to know about this class

5197
03:49:47,270 --> 03:49:48,460
or even be able to use it,

5198
03:49:48,460 --> 03:49:50,820
we just kind of wanna
keep it internal to us.

5199
03:49:50,820 --> 03:49:55,240
Like this is our class it's
for us to do work with.

5200
03:49:55,240 --> 03:49:56,810
We don't want anyone else using it.

5201
03:49:56,810 --> 03:49:59,409
There is a way to do
that and you can apply

5202
03:49:59,409 --> 03:50:01,500
the internal modifier to the class.

5203
03:50:01,500 --> 03:50:03,140
Now notice we got a bunch
of errors automatically

5204
03:50:03,140 --> 03:50:04,480
right out of the gate.

5205
03:50:04,480 --> 03:50:06,950
So right here in axles
that says public property

5206
03:50:06,950 --> 03:50:09,260
exposes an internal type argument axle,

5207
03:50:09,260 --> 03:50:12,470
which means bill over here in main,

5208
03:50:12,470 --> 03:50:16,130
if I were to type t.axles,

5209
03:50:16,130 --> 03:50:18,040
well, we would have the
ability to have this.

5210
03:50:18,040 --> 03:50:20,280
So now this can be interesting

5211
03:50:20,280 --> 03:50:21,490
if we don't want that to happen.

5212
03:50:21,490 --> 03:50:22,900
So what I can do is I can actually say,

5213
03:50:22,900 --> 03:50:26,190
hey, you know what, I
don't want axles to be...

5214
03:50:27,330 --> 03:50:31,220
Basically Kotlin saying, hey,
look, you can not expose axles

5215
03:50:31,220 --> 03:50:33,720
because axles' internal to this module.

5216
03:50:33,720 --> 03:50:36,010
Meaning that you can
use it in this module.

5217
03:50:36,010 --> 03:50:38,580
We'll compile everything together inside

5218
03:50:38,580 --> 03:50:40,470
of perhaps you're building a library.

5219
03:50:40,470 --> 03:50:42,370
We'll compile everything together,

5220
03:50:42,370 --> 03:50:45,750
but we're only going to
expose vehicle and truck

5221
03:50:45,750 --> 03:50:47,350
because those ones are public.

5222
03:50:47,350 --> 03:50:50,430
However, you said, here's an axle class,

5223
03:50:50,430 --> 03:50:52,640
it's internal, so don't expose it,

5224
03:50:52,640 --> 03:50:55,690
but you're trying to expose
it here, so don't do that.

5225
03:50:55,690 --> 03:50:58,100
So in this case, what I really
need to do is actually say,

5226
03:50:58,100 --> 03:51:00,300
put private axles.

5227
03:51:00,300 --> 03:51:03,330
Now, as we see here, oh,
now we have another problem.

5228
03:51:03,330 --> 03:51:05,400
Okay, can I access because it's private.

5229
03:51:05,400 --> 03:51:06,990
So what we can do is then
we say, you know what,

5230
03:51:06,990 --> 03:51:10,090
let's change this to protected
'cause we have a child class.

5231
03:51:10,090 --> 03:51:12,340
Now, if protected, then
what do we have here?

5232
03:51:13,600 --> 03:51:17,020
Protected exposes its
internal type argument.

5233
03:51:17,020 --> 03:51:19,410
So now we have a whole different situation

5234
03:51:19,410 --> 03:51:22,100
of maybe we don't want
to expose these axles.

5235
03:51:22,100 --> 03:51:24,220
So you have to start
rethinking your API design

5236
03:51:24,220 --> 03:51:26,510
at this point in time
if you want your axles

5237
03:51:26,510 --> 03:51:29,860
available inside of
these other types here.

5238
03:51:29,860 --> 03:51:31,780
And so maybe you don't wanna do that,

5239
03:51:31,780 --> 03:51:35,800
maybe you wanna put it as
private just like this.

5240
03:51:35,800 --> 03:51:38,800
So now you have your
axles that are private.

5241
03:51:38,800 --> 03:51:42,030
And then perhaps you want
to say the number of axles

5242
03:51:42,030 --> 03:51:44,400
in the wheels and you just
wanna expose this as a function.

5243
03:51:44,400 --> 03:51:45,610
So you could do that.

5244
03:51:45,610 --> 03:51:50,610
So you say, add axle and you
say a number of wheels int.

5245
03:51:55,080 --> 03:51:56,230
And then what you could do is you could do

5246
03:51:56,230 --> 03:51:57,697
something like this.

5247
03:51:57,697 --> 03:52:01,480
And all this would do
is, would say axles dot.

5248
03:52:03,520 --> 03:52:05,280
You know, we just turn
this into a list actually

5249
03:52:05,280 --> 03:52:08,029
to make it a little bit
easier to work with,

5250
03:52:08,029 --> 03:52:11,310
let's say axles dot and
we need to make this

5251
03:52:11,310 --> 03:52:15,220
actually a mutable list so
we can actually change it

5252
03:52:16,210 --> 03:52:18,600
otherwise we have a read only list.

5253
03:52:18,600 --> 03:52:20,710
Add, and then we'll say axle,

5254
03:52:22,980 --> 03:52:25,220
and then we'll parse in
the number of wheels.

5255
03:52:25,220 --> 03:52:26,210
And there we go.

5256
03:52:26,210 --> 03:52:27,580
Now we can actually have that.

5257
03:52:27,580 --> 03:52:31,097
And so if we know that we need
this, we can say, add axle.

5258
03:52:31,097 --> 03:52:34,510
I see two, add axle four.

5259
03:52:36,120 --> 03:52:39,440
Now what this is allowing us
to do is have this axle class

5260
03:52:39,440 --> 03:52:42,950
inside of our module, but not allow it

5261
03:52:42,950 --> 03:52:44,230
outside of the public API.

5262
03:52:44,230 --> 03:52:49,230
So if we are over here, now
we could say t.add axle.

5263
03:52:49,540 --> 03:52:51,320
So I could still kind
of work with the axles,

5264
03:52:51,320 --> 03:52:53,960
but it's hidden behind an API here.

5265
03:52:53,960 --> 03:52:56,930
So I said add axle on a vehicle.

5266
03:52:56,930 --> 03:52:58,730
So the vehicle can also add an axle.

5267
03:53:00,680 --> 03:53:03,810
But if I were to try to
do anything with that axle

5268
03:53:04,800 --> 03:53:07,147
such as return, and maybe I want to say,

5269
03:53:07,147 --> 03:53:08,562
all right, well let's return the axle,

5270
03:53:08,562 --> 03:53:09,850
someone might think so.

5271
03:53:09,850 --> 03:53:14,850
So we say, get axle, so you get axle info.

5272
03:53:18,040 --> 03:53:20,400
And what we're gonna do is
we return all the axles,

5273
03:53:21,640 --> 03:53:23,430
we'll turn a list of axle.

5274
03:53:26,160 --> 03:53:29,200
Well, as you can already
see, we have a problem.

5275
03:53:29,200 --> 03:53:32,300
Public function exposes
internal return type axle.

5276
03:53:32,300 --> 03:53:37,080
So even if I wanted this get axle info,

5277
03:53:38,025 --> 03:53:39,600
this is not gonna work
because Kotlin would say,

5278
03:53:39,600 --> 03:53:40,830
look, this is internal.

5279
03:53:40,830 --> 03:53:43,290
You're trying to expose
us as a public API.

5280
03:53:43,290 --> 03:53:45,140
We're not gonna allow that to happen.

5281
03:53:45,140 --> 03:53:47,860
So perhaps I need to just
expose some additional

5282
03:53:47,860 --> 03:53:49,750
information, I exposed the strings

5283
03:53:49,750 --> 03:53:52,200
and then maybe for whatever
reason I iterate over them

5284
03:53:52,200 --> 03:53:53,033
or whatever.

5285
03:53:53,033 --> 03:53:55,820
Now, if I do need my class
to be accessible outside,

5286
03:53:55,820 --> 03:53:57,030
then internal is not gonna work.

5287
03:53:57,030 --> 03:53:58,980
However, it's very useful.

5288
03:53:58,980 --> 03:54:01,710
If you have a particular
function class where you need

5289
03:54:01,710 --> 03:54:03,070
to encapsulate behavior,

5290
03:54:04,188 --> 03:54:05,070
but you don't wanna expose this behavior

5291
03:54:05,070 --> 03:54:07,640
and all of its intricacies
to the outside public

5292
03:54:07,640 --> 03:54:09,740
and you don't want anyone
to be able to call it.

5293
03:54:09,740 --> 03:54:12,690
You want that to be perhaps
any of the interaction

5294
03:54:12,690 --> 03:54:16,570
with that internal class to
happen through its public API,

5295
03:54:16,570 --> 03:54:18,800
such as we're doing
here in the main class.

5296
03:54:18,800 --> 03:54:22,860
If I wanna add a axle to a vehicle,

5297
03:54:22,860 --> 03:54:27,860
I can number of wheels
three or four or whatever.

5298
03:54:28,000 --> 03:54:30,710
And maybe this method perhaps
does a bunch of validation

5299
03:54:30,710 --> 03:54:33,220
and a bunch of checking
before it actually creates

5300
03:54:33,220 --> 03:54:34,090
this axle class,

5301
03:54:34,090 --> 03:54:36,360
or maybe it has to do a
whole bunch of other things

5302
03:54:36,360 --> 03:54:38,530
that if at your application maybe goes out

5303
03:54:38,530 --> 03:54:41,520
and checks to see if
are any access available

5304
03:54:41,520 --> 03:54:44,490
at the manufacturer, can we
even add an axle right now?

5305
03:54:44,490 --> 03:54:46,920
What is an axle, et cetera.

5306
03:54:46,920 --> 03:54:48,370
So there's a whole bunch
of things you can do,

5307
03:54:48,370 --> 03:54:52,020
but it allows you to lock
down your API internally.

5308
03:54:52,020 --> 03:54:54,406
And so you kind of wanna play with it

5309
03:54:54,406 --> 03:54:55,239
and see what works best for you,

5310
03:54:55,239 --> 03:54:59,040
but it's very useful
for hiding bits of code

5311
03:54:59,040 --> 03:55:01,590
and functionality and logic
inside of your application,

5312
03:55:01,590 --> 03:55:03,790
but still providing you with the ability

5313
03:55:03,790 --> 03:55:05,720
to be organized inside of your module.

5314
03:55:07,840 --> 03:55:10,120
To create an abstract class in Kotlin,

5315
03:55:10,120 --> 03:55:12,680
all you're gonna do is
slap the abstract keyword

5316
03:55:12,680 --> 03:55:13,980
right on the class itself.

5317
03:55:15,083 --> 03:55:15,916
Now you have an abstract class.

5318
03:55:17,050 --> 03:55:18,881
Let's go ahead and delete that though.

5319
03:55:18,881 --> 03:55:20,570
And back at the main file
and see how this impacts it.

5320
03:55:21,650 --> 03:55:23,620
By default classes are open.

5321
03:55:23,620 --> 03:55:26,000
So we can go ahead and create
instances of them in Kotlin.

5322
03:55:26,000 --> 03:55:28,640
So now I have a vehicle,
I wanna provide the color,

5323
03:55:28,640 --> 03:55:31,280
which would be red and I can
create many different vehicles.

5324
03:55:31,280 --> 03:55:36,017
So I create, we'll call this
one A, this will be blue

5325
03:55:38,190 --> 03:55:40,490
and I can create many more, et cetera.

5326
03:55:40,490 --> 03:55:43,670
However, if I want this to be abstract,

5327
03:55:44,980 --> 03:55:48,180
all I have to do is add
the abstract keyword,

5328
03:55:48,180 --> 03:55:50,720
which is a modifier to the class.

5329
03:55:50,720 --> 03:55:53,370
Now I am not allowed to create an instance

5330
03:55:53,370 --> 03:55:54,490
of an abstract class.

5331
03:55:55,751 --> 03:55:57,910
Now you may be wondering why
would you not wanna create

5332
03:55:57,910 --> 03:56:00,370
an instance of an abstract class?

5333
03:56:00,370 --> 03:56:04,080
If you think about it, when
we're designing type systems,

5334
03:56:04,080 --> 03:56:07,090
we have various different types
we're trying to represent.

5335
03:56:07,090 --> 03:56:09,460
In this case, we might be
building an application

5336
03:56:09,460 --> 03:56:11,200
which works with vehicles,

5337
03:56:11,200 --> 03:56:14,280
but we do not want
users of our application

5338
03:56:14,280 --> 03:56:16,510
to create just a vehicle instance,

5339
03:56:16,510 --> 03:56:19,910
we want them to create actual
implementations of a car

5340
03:56:19,910 --> 03:56:21,740
and a truck and so forth.

5341
03:56:21,740 --> 03:56:25,350
And so a lot of these vehicles
will have some similar things

5342
03:56:25,350 --> 03:56:27,750
to them, for example,
they may all have a color.

5343
03:56:28,620 --> 03:56:30,460
They all may have a number of wheels.

5344
03:56:30,460 --> 03:56:33,190
So we say val number of wheels,

5345
03:56:35,880 --> 03:56:38,320
they may all have various
different things and doors

5346
03:56:38,320 --> 03:56:40,579
and so forth that are all similar.

5347
03:56:40,579 --> 03:56:42,130
So we could say number of doors as well.

5348
03:56:42,130 --> 03:56:44,790
So val number of doors.

5349
03:56:47,020 --> 03:56:48,280
Now, for whatever reason,

5350
03:56:49,210 --> 03:56:54,210
this vehicle may actually
drive a certain way.

5351
03:56:54,500 --> 03:56:56,450
So it may need to shift
gears a certain way.

5352
03:56:56,450 --> 03:56:59,050
So it may be an automatic,
it might be a manual,

5353
03:56:59,050 --> 03:57:01,610
different type of vehicle.

5354
03:57:01,610 --> 03:57:04,030
And we may not know what that is.

5355
03:57:04,030 --> 03:57:07,360
So we may wanna actually
have, if we, for example,

5356
03:57:07,360 --> 03:57:12,360
wants to provide a method to
tell the vehicle how to drive.

5357
03:57:13,490 --> 03:57:16,580
And so that function might
be just be called drive.

5358
03:57:17,670 --> 03:57:20,770
Now this perhaps does something.

5359
03:57:20,770 --> 03:57:24,210
Well, now depending upon the vehicle,

5360
03:57:24,210 --> 03:57:26,520
drive can mean one thing or another.

5361
03:57:26,520 --> 03:57:29,720
For example, in a car
that's not a automatic,

5362
03:57:29,720 --> 03:57:31,310
we just step on the accelerator

5363
03:57:32,144 --> 03:57:33,610
as long as we're in the
drive position, it drives.

5364
03:57:33,610 --> 03:57:37,740
However, if you're in a manual
transmission environment

5365
03:57:37,740 --> 03:57:39,010
where you have to shift gears manually,

5366
03:57:39,010 --> 03:57:42,390
well, drive is gonna
require a few more steps.

5367
03:57:42,390 --> 03:57:44,870
So we cannot abstract all this information

5368
03:57:44,870 --> 03:57:47,060
into just this class
here and too abstract.

5369
03:57:47,060 --> 03:57:50,490
So this class we might
wanna actually say abstract,

5370
03:57:51,700 --> 03:57:54,960
abstract function drive.

5371
03:57:54,960 --> 03:57:57,294
Now I'm not gonna provide
an implementation here

5372
03:57:57,294 --> 03:57:59,113
because the implementation is gonna change

5373
03:57:59,113 --> 03:58:01,860
based upon each different
implementation of the class.

5374
03:58:01,860 --> 03:58:04,650
Now, one thing that may be
the same as everything else

5375
03:58:05,700 --> 03:58:07,370
is a function called open door.

5376
03:58:09,540 --> 03:58:11,790
And this function just
simply opens the door.

5377
03:58:13,350 --> 03:58:15,696
And all that does is open the door.

5378
03:58:15,696 --> 03:58:16,529
Now it's gonna be the same,

5379
03:58:16,529 --> 03:58:18,118
perhaps for every single vehicle you have,

5380
03:58:18,118 --> 03:58:18,951
you pull on the handle and the door opens.

5381
03:58:18,951 --> 03:58:21,020
Now, of course, this is
different if in real world,

5382
03:58:21,020 --> 03:58:23,080
we're gonna have electric
cars and electric doors

5383
03:58:23,080 --> 03:58:25,390
and electronic doors and manual doors.

5384
03:58:25,390 --> 03:58:28,410
But for the brevity and situation here,

5385
03:58:28,410 --> 03:58:31,360
perhaps just assume that every
door is opened the same way.

5386
03:58:32,197 --> 03:58:33,420
And so we can leave that
inside of our class.

5387
03:58:33,420 --> 03:58:34,420
Here's an abstract class.

5388
03:58:34,420 --> 03:58:37,500
We can start having other
different things inside of here,

5389
03:58:37,500 --> 03:58:38,950
such as function called stop.

5390
03:58:39,950 --> 03:58:42,030
What would a stop do,
it just stops the car

5391
03:58:42,030 --> 03:58:45,160
and maybe even better say, turn off.

5392
03:58:46,940 --> 03:58:48,970
Every car can be turned off,
vehicle we could turn it off.

5393
03:58:48,970 --> 03:58:51,150
Let's just turn off the ignition.

5394
03:58:51,150 --> 03:58:53,190
And if we only wanna be real specific,

5395
03:58:54,390 --> 03:58:56,190
say, turn off ignition.

5396
03:58:56,190 --> 03:58:57,920
And perhaps this is gonna
turn off the ignition,

5397
03:58:57,920 --> 03:59:00,489
whatever that implementation looks like

5398
03:59:00,489 --> 03:59:01,322
is what it looks like.

5399
03:59:01,322 --> 03:59:03,010
However, we now have an abstract class

5400
03:59:03,010 --> 03:59:05,600
that does a couple of things
for us that we don't have

5401
03:59:05,600 --> 03:59:07,700
to re-implement everywhere else.

5402
03:59:07,700 --> 03:59:09,200
And this is the vehicle class,

5403
03:59:10,047 --> 03:59:12,520
this is how we can define natural class,

5404
03:59:12,520 --> 03:59:14,070
but we can not implement it.

5405
03:59:16,250 --> 03:59:18,230
So we actually have to
implement it in another class

5406
03:59:18,230 --> 03:59:22,330
somehow, but so we can have
a function that's abstract,

5407
03:59:22,330 --> 03:59:24,740
which means, hey,
whoever's going to extend

5408
03:59:24,740 --> 03:59:29,280
this vehicle class at that
point has to also implement

5409
03:59:29,280 --> 03:59:31,520
this drive method
because it's gonna differ

5410
03:59:31,520 --> 03:59:32,910
between different classes.

5411
03:59:33,840 --> 03:59:36,850
However, they can go ahead
and use the open door

5412
03:59:36,850 --> 03:59:38,350
and turn off ignition methods.

5413
03:59:40,070 --> 03:59:43,700
And that's how we can develop
a very simple abstract class

5414
03:59:43,700 --> 03:59:45,370
and define it in Kotlin.

5415
03:59:45,370 --> 03:59:47,450
To implement a abstract class in Kotlin

5416
03:59:47,450 --> 03:59:48,570
is actually pretty easy.

5417
03:59:48,570 --> 03:59:50,560
So let's say that you
wanna have a car class

5418
03:59:50,560 --> 03:59:51,920
that extends this vehicle class.

5419
03:59:51,920 --> 03:59:55,180
So we'd have class car.

5420
03:59:55,180 --> 03:59:57,604
And for whatever reason, when you say

5421
03:59:57,604 --> 03:59:59,230
we're also gonna have a color,
which is gonna be string

5422
03:59:59,230 --> 04:00:02,480
or have number of wheels
as integer and number,

5423
04:00:03,400 --> 04:00:07,290
this needs to be bow number of doors.

5424
04:00:17,200 --> 04:00:19,330
And then what you can do as
you're just gonna go ahead

5425
04:00:19,330 --> 04:00:21,560
and extend the vehicle class.

5426
04:00:21,560 --> 04:00:23,320
And vehicle of course
is gonna need that color

5427
04:00:23,320 --> 04:00:26,650
and number of wheels and number of doors,

5428
04:00:26,650 --> 04:00:28,900
because those are constructed parameters.

5429
04:00:28,900 --> 04:00:31,110
However, notice we have
a red squiggly here.

5430
04:00:31,110 --> 04:00:34,350
And the reason why we
have that is the car class

5431
04:00:34,350 --> 04:00:35,870
is not an abstract and does not implement

5432
04:00:35,870 --> 04:00:39,150
the abstract base class member drive.

5433
04:00:39,150 --> 04:00:44,150
So what this is saying
is, look, maybe you can do

5434
04:00:44,151 --> 04:00:44,984
one of two things here.

5435
04:00:44,984 --> 04:00:49,060
You can have an abstract class
extend an abstract class.

5436
04:00:49,060 --> 04:00:50,600
So you could map this one here

5437
04:00:52,140 --> 04:00:54,834
and you can maybe even call this a two,

5438
04:00:54,834 --> 04:00:55,667
let's call this a two door car.

5439
04:00:58,250 --> 04:01:01,092
So call us a two door car,
and I'm gonna go ahead

5440
04:01:01,092 --> 04:01:01,980
and break this into a new line here

5441
04:01:01,980 --> 04:01:03,170
so it's easier to read.

5442
04:01:05,010 --> 04:01:07,870
And so instead of parsing
in the doors here,

5443
04:01:07,870 --> 04:01:10,460
I already know that this is
gonna be my two door sports car

5444
04:01:10,460 --> 04:01:12,050
for whatever reason.

5445
04:01:12,050 --> 04:01:14,150
And now I have an abstract class here

5446
04:01:14,150 --> 04:01:15,490
and this one might have a function here,

5447
04:01:15,490 --> 04:01:16,540
an abstract function,

5448
04:01:18,370 --> 04:01:20,170
and so I'm gonna call it drive fast.

5449
04:01:21,340 --> 04:01:22,860
Of course, I don't know
what dry fast means

5450
04:01:22,860 --> 04:01:24,610
'cause in this two door
car, it could be a Porsche,

5451
04:01:24,610 --> 04:01:27,710
it could be a Lamborghini, it
could be any number of cars,

5452
04:01:27,710 --> 04:01:30,430
but I know that this two door
car is going to drive fast

5453
04:01:30,430 --> 04:01:33,470
and how it does that depends
on the implementation.

5454
04:01:33,470 --> 04:01:35,390
Maybe it's an electric car.

5455
04:01:35,390 --> 04:01:37,210
So that's one way I could do it.

5456
04:01:37,210 --> 04:01:38,980
I could also just go
ahead and implement a car

5457
04:01:38,980 --> 04:01:41,820
if I just know that I want
perhaps a simple TownCar

5458
04:01:42,930 --> 04:01:47,930
or this is called a hatchback,
even simpler, hatchback car,

5459
04:01:49,110 --> 04:01:51,190
so you know it has
little hatch in the back.

5460
04:01:51,190 --> 04:01:55,250
And then I say color of course
is string number of wheels

5461
04:01:55,250 --> 04:02:00,060
gonna compute any variable,
number of doors it's gonna be,

5462
04:02:00,060 --> 04:02:02,870
who knows, same thing here,
I'm gonna put in a new line.

5463
04:02:02,870 --> 04:02:05,010
This one's gonna implement vehicle

5464
04:02:05,010 --> 04:02:07,910
and it's gonna be the
color number of wheels,

5465
04:02:07,910 --> 04:02:09,940
number of doors, et cetera.

5466
04:02:09,940 --> 04:02:11,420
Now, again, I'm going to get this

5467
04:02:11,420 --> 04:02:12,810
because I'm gonna get this error

5468
04:02:12,810 --> 04:02:15,180
saying that we have not
implemented the drive function.

5469
04:02:15,180 --> 04:02:18,120
So what I can do is implement that member.

5470
04:02:18,970 --> 04:02:22,210
And basically what we're telling here is,

5471
04:02:22,210 --> 04:02:26,270
hey Kotlin, I have now
implemented the hatchback car.

5472
04:02:26,270 --> 04:02:29,470
It is of type vehicle and
this one is going to drive

5473
04:02:29,470 --> 04:02:30,710
a certain way.

5474
04:02:30,710 --> 04:02:33,770
And so when the drive method is called,

5475
04:02:33,770 --> 04:02:37,080
it will then call this
implementation right here.

5476
04:02:37,080 --> 04:02:40,920
Now I can have many different
implementations of this car.

5477
04:02:40,920 --> 04:02:45,290
So I'm gonna actually copy
this and paste it right above.

5478
04:02:45,290 --> 04:02:46,710
And then I'm gonna call this one,

5479
04:02:46,710 --> 04:02:49,670
perhaps, call this a TownCar.

5480
04:02:53,672 --> 04:02:56,510
I'll call it a TownCar and
same thing we have drive.

5481
04:02:57,670 --> 04:02:59,170
So we have different implementations here.

5482
04:02:59,170 --> 04:03:02,500
And this TownCar might
have something different

5483
04:03:02,500 --> 04:03:04,270
where it has a very smooth ride.

5484
04:03:06,400 --> 04:03:08,670
And this one is a very basic smooth,

5485
04:03:10,549 --> 04:03:11,780
and this one is very basic.

5486
04:03:13,640 --> 04:03:15,090
It's very just hatchback car.

5487
04:03:16,194 --> 04:03:18,070
So we're gonna have many
different implementations here,

5488
04:03:18,070 --> 04:03:19,530
however, in order to
implement an abstract class,

5489
04:03:19,530 --> 04:03:23,360
you also have to implement
the abstract functions here.

5490
04:03:23,360 --> 04:03:25,980
So, which is interesting, let's
go with this two door car.

5491
04:03:25,980 --> 04:03:27,790
Let's create some space
here and let's implement

5492
04:03:27,790 --> 04:03:28,890
this two door car.

5493
04:03:28,890 --> 04:03:30,590
So we've already seen
how we can do it once.

5494
04:03:30,590 --> 04:03:32,960
But now we have an
abstract class that extends

5495
04:03:32,960 --> 04:03:34,340
an abstract class.

5496
04:03:34,340 --> 04:03:35,540
What does that look like?

5497
04:03:35,540 --> 04:03:38,370
And so let's go ahead and
implement something here.

5498
04:03:38,370 --> 04:03:43,370
So we'll call this Lambo
and of course it will,

5499
04:03:44,730 --> 04:03:47,720
perhaps we just are gonna
assume that every Lambo

5500
04:03:47,720 --> 04:03:51,030
is gonna have, so it's
gonna be extended vehicle.

5501
04:03:51,900 --> 04:03:54,311
I'm not even gonna provide this things

5502
04:03:54,311 --> 04:03:56,130
inside of the class
Lambbo 'cause every Lambo

5503
04:03:56,130 --> 04:03:59,190
that we're going to create is gonna be red

5504
04:03:59,190 --> 04:04:01,450
and it's gonna have four wheels

5505
04:04:01,450 --> 04:04:03,630
and it's gonna have two doors.

5506
04:04:03,630 --> 04:04:04,600
There we go, simple enough.

5507
04:04:04,600 --> 04:04:06,490
Now we have this little error here saying,

5508
04:04:06,490 --> 04:04:10,950
hey, look, drive has not been implemented.

5509
04:04:10,950 --> 04:04:13,640
And actually we know it's
gonna be a two-door car,

5510
04:04:13,640 --> 04:04:15,950
so let's change this to two door

5511
04:04:15,950 --> 04:04:17,450
and we can get rid of this right here.

5512
04:04:19,453 --> 04:04:20,286
And now we have Lambo says,

5513
04:04:20,286 --> 04:04:22,870
look, drive fast has not been implemented.

5514
04:04:22,870 --> 04:04:25,020
So let's go ahead and
implement drive fast.

5515
04:04:27,060 --> 04:04:28,130
Okay, look, we have two things here.

5516
04:04:28,130 --> 04:04:29,610
Well, let's just go ahead
and put and drive fast

5517
04:04:29,610 --> 04:04:31,050
'cause that's what it
was complaining about.

5518
04:04:31,050 --> 04:04:34,910
And we'll say, and whatever
this is going to look like,

5519
04:04:37,280 --> 04:04:38,200
is what it's gonna look like.

5520
04:04:38,200 --> 04:04:39,590
Depends on your implementation.

5521
04:04:39,590 --> 04:04:40,960
Now we also have another
error here saying,

5522
04:04:40,960 --> 04:04:42,630
hey, the drive has not been implemented.

5523
04:04:42,630 --> 04:04:43,480
And why is that?

5524
04:04:43,480 --> 04:04:47,100
Well, because drive fast method

5525
04:04:47,100 --> 04:04:50,350
came from this abstract
class and the drive method

5526
04:04:50,350 --> 04:04:51,370
comes from the vehicle.

5527
04:04:51,370 --> 04:04:55,500
So because two-door car extends vehicle

5528
04:04:55,500 --> 04:04:58,170
and our Lambo class extends to door,

5529
04:04:58,170 --> 04:05:00,530
we basically getting the entire object

5530
04:05:00,530 --> 04:05:02,070
that we need to implement here.

5531
04:05:02,070 --> 04:05:04,280
So as you can see, this can be beneficial,

5532
04:05:04,280 --> 04:05:07,980
depends on how you are
developing your classes.

5533
04:05:07,980 --> 04:05:12,980
However, it can also be very
difficult if you decide,

5534
04:05:13,240 --> 04:05:16,510
let's say you have 20
implementations of vehicle

5535
04:05:16,510 --> 04:05:18,814
and the subclasses are majors 100

5536
04:05:18,814 --> 04:05:21,660
and you decide to add one abstract method

5537
04:05:21,660 --> 04:05:24,060
to the top where the
people must implement it.

5538
04:05:24,060 --> 04:05:27,680
Well, now it's gonna repl
throughout your code base

5539
04:05:27,680 --> 04:05:29,786
and you're gonna have to implement that

5540
04:05:29,786 --> 04:05:30,690
in each of your child classes.

5541
04:05:30,690 --> 04:05:32,390
So it's something to think about

5542
04:05:32,390 --> 04:05:34,210
that you'll encounter from time to time.

5543
04:05:34,210 --> 04:05:35,330
Sometimes that's necessary,

5544
04:05:35,330 --> 04:05:37,690
sometimes that's what
you expect to happen.

5545
04:05:37,690 --> 04:05:39,510
Maybe you need to implement
some type of method,

5546
04:05:39,510 --> 04:05:42,280
like a safety check to ensure
that all of the vehicles

5547
04:05:42,280 --> 04:05:45,260
have meet a particular safety rating

5548
04:05:45,260 --> 04:05:46,800
and you have to implement
that in each class

5549
04:05:46,800 --> 04:05:48,650
and that's what you need and that's okay.

5550
04:05:48,650 --> 04:05:50,280
However, other times you're gonna realize,

5551
04:05:50,280 --> 04:05:53,330
well, maybe I don't need
that method to be abstract,

5552
04:05:53,330 --> 04:05:55,190
and that's gonna be on
a case by case basis.

5553
04:05:55,190 --> 04:05:57,440
Now over here, of course, we can go ahead

5554
04:05:57,440 --> 04:05:59,788
and start implementing all of these.

5555
04:05:59,788 --> 04:06:01,960
So if I wanna say var or val Lambo

5556
04:06:03,690 --> 04:06:07,780
that I can just say equals Lambo.

5557
04:06:09,860 --> 04:06:10,890
Now I've got a Lambo.

5558
04:06:10,890 --> 04:06:13,315
And remember, I didn't have to
provide any variables there.

5559
04:06:13,315 --> 04:06:14,148
Well, why didn't I,
because I already knew,

5560
04:06:14,148 --> 04:06:17,010
could I said, hey, all of
our Lambos are gonna be red

5561
04:06:17,010 --> 04:06:18,330
and are four wheels.

5562
04:06:18,330 --> 04:06:19,890
And since this is a two door car,

5563
04:06:19,890 --> 04:06:21,000
we already know it has two doors.

5564
04:06:21,000 --> 04:06:22,050
I don't have to provide anything,

5565
04:06:22,050 --> 04:06:23,660
I already have a Lambo now.

5566
04:06:23,660 --> 04:06:26,190
And so if we wanted to
provide a method up here,

5567
04:06:26,190 --> 04:06:28,370
we could say what kind they are.

5568
04:06:28,370 --> 04:06:33,370
Another thing you can
also do is let's go ahead

5569
04:06:33,390 --> 04:06:35,040
and create a couple of
these other cars here.

5570
04:06:35,040 --> 04:06:40,040
Var two door equals let's say TownCar.

5571
04:06:42,530 --> 04:06:43,590
Equals TownCar.

5572
04:06:45,620 --> 04:06:46,670
Now of course, what are we missing?

5573
04:06:46,670 --> 04:06:49,560
We're missing the color,
so let's call brown.

5574
04:06:49,560 --> 04:06:51,710
It's gonna have four
wheels and four doors.

5575
04:06:52,920 --> 04:06:54,040
And now I have my two cars.

5576
04:06:54,040 --> 04:06:57,050
And again, I could have multiple
other ones inside of here.

5577
04:06:57,050 --> 04:06:58,510
I've got my Lambo, I've got my TownCar,

5578
04:06:58,510 --> 04:06:59,960
I've got my hatchback.

5579
04:06:59,960 --> 04:07:02,480
I've got all these
different types of cars.

5580
04:07:02,480 --> 04:07:04,850
So one thing I could do here,
so we have a hatchback too.

5581
04:07:09,297 --> 04:07:10,130
So, we have a hatchback car.

5582
04:07:10,130 --> 04:07:11,210
This one's gonna be silver.

5583
04:07:11,210 --> 04:07:14,390
It's gonna have four wheels and two doors.

5584
04:07:14,390 --> 04:07:16,736
So this point, you might realized,

5585
04:07:16,736 --> 04:07:18,260
well, some hatchbacks
have for some have two.

5586
04:07:18,260 --> 04:07:21,080
So that's why we need the,
have the number of doors

5587
04:07:22,880 --> 04:07:25,296
in a way that we can configure them.

5588
04:07:25,296 --> 04:07:28,320
So this is how you can
implement an abstract class

5589
04:07:28,320 --> 04:07:29,710
and you can also have an abstract class

5590
04:07:29,710 --> 04:07:32,757
extend another abstract
class implement that.

5591
04:07:32,757 --> 04:07:34,670
And then you can see
how the abstract methods

5592
04:07:34,670 --> 04:07:38,360
and members are required
inside of each individual class

5593
04:07:38,360 --> 04:07:41,270
itself and you're required
to implement them.

5594
04:07:41,270 --> 04:07:43,480
So for example, our Lambo here extended

5595
04:07:43,480 --> 04:07:47,870
from the two-door car, which
extended the vehicle car.

5596
04:07:47,870 --> 04:07:49,440
So we had to implement the drive method

5597
04:07:49,440 --> 04:07:51,940
and we also had to implement
the dry fast method

5598
04:07:51,940 --> 04:07:55,670
in order to fulfill the
requirements of the abstract class.

5599
04:07:55,670 --> 04:07:57,540
And basically what the abstract
method is saying is like,

5600
04:07:57,540 --> 04:08:00,800
look, we don't know what drive does,

5601
04:08:00,800 --> 04:08:03,990
but we know that every
person or every class

5602
04:08:03,990 --> 04:08:07,350
that implements this
vehicle class has to provide

5603
04:08:07,350 --> 04:08:08,390
an implementation of drive

5604
04:08:08,390 --> 04:08:10,340
and the same thing down here.

5605
04:08:10,340 --> 04:08:11,880
And we didn't have to
implement it down here

5606
04:08:11,880 --> 04:08:13,730
is because this is an abstract class.

5607
04:08:14,725 --> 04:08:16,510
And that means like, hey,
there's nobody who can create

5608
04:08:16,510 --> 04:08:18,140
an instance of two-door car.

5609
04:08:18,140 --> 04:08:21,220
But if you are going to use two-door car,

5610
04:08:21,220 --> 04:08:24,500
then we do know that you
have a drive fast method

5611
04:08:24,500 --> 04:08:25,500
for whatever reason.

5612
04:08:26,812 --> 04:08:27,645
And whenever you implement that,

5613
04:08:27,645 --> 04:08:29,422
you have to also implement whatever else

5614
04:08:29,422 --> 04:08:30,255
vehicle is asking here.

5615
04:08:30,255 --> 04:08:34,070
So if I were to throw another
abstract method on here,

5616
04:08:34,070 --> 04:08:38,150
so abstract fun stop.

5617
04:08:38,150 --> 04:08:40,500
Now notice one thing, Lambo
is gonna give us an error.

5618
04:08:40,500 --> 04:08:42,480
And if we scroll down also, so is TownCar,

5619
04:08:42,480 --> 04:08:43,750
and so it was hatchback.

5620
04:08:43,750 --> 04:08:45,410
Well, why is that?

5621
04:08:45,410 --> 04:08:50,180
Well, simply because stop is
implemented everywhere else.

5622
04:08:50,180 --> 04:08:53,760
So I would have to go into
TownCar, implement stop.

5623
04:08:53,760 --> 04:08:56,690
I would have to go into
hatchback, implement stop.

5624
04:08:56,690 --> 04:08:58,320
Now here's an interesting thing,

5625
04:08:58,320 --> 04:09:01,020
maybe I know that all of my two-door cars,

5626
04:09:01,020 --> 04:09:04,240
the only way to stop them
is to slam on the e-brake.

5627
04:09:04,240 --> 04:09:08,410
And so what I can do
is I can implement stop

5628
04:09:08,410 --> 04:09:10,060
inside of my abstract class here.

5629
04:09:11,210 --> 04:09:14,820
I'd say pull e-brake, which
is the emergency brake.

5630
04:09:14,820 --> 04:09:16,720
That's how we stopped these two door cars,

5631
04:09:16,720 --> 04:09:17,810
just as an example.

5632
04:09:19,180 --> 04:09:22,270
So in this case, Lambo
doesn't have to implement

5633
04:09:22,270 --> 04:09:24,200
the stop method because
that's just handled

5634
04:09:24,200 --> 04:09:25,340
in the two-door car level.

5635
04:09:25,340 --> 04:09:29,440
So I've actually can
override an abstract method

5636
04:09:29,440 --> 04:09:32,450
inside of an abstract class
of the parent abstract class.

5637
04:09:32,450 --> 04:09:37,250
So again, this stop is
actually from up here

5638
04:09:37,250 --> 04:09:38,230
inside of this stop.

5639
04:09:38,230 --> 04:09:40,980
So you can go here and you
can right click on that

5640
04:09:40,980 --> 04:09:42,410
and you can say navigate,

5641
04:09:43,450 --> 04:09:44,283
excuse me, not navigate.

5642
04:09:44,283 --> 04:09:46,110
You can go to command U on Mac,

5643
04:09:46,110 --> 04:09:48,980
it'll take you to the
implementation of where this is at.

5644
04:09:48,980 --> 04:09:51,880
And I think it's control+U for windows.

5645
04:09:51,880 --> 04:09:54,860
So this abstract class has
implemented one member,

5646
04:09:54,860 --> 04:09:57,830
but it's still parsing this
member down further below.

5647
04:09:57,830 --> 04:10:01,300
So we're still saying,
hey, drive needs to happen.

5648
04:10:01,300 --> 04:10:02,540
And what we can also
say is, you know what,

5649
04:10:02,540 --> 04:10:05,800
well maybe any time a
two-door car is driving.

5650
04:10:05,800 --> 04:10:09,087
Well, we also know that
we are going to drive,

5651
04:10:12,700 --> 04:10:14,550
we're just actually just gonna drive fast.

5652
04:10:16,060 --> 04:10:18,890
So anytime you drive two
door cars, only drive fast.

5653
04:10:18,890 --> 04:10:22,470
So notice one thing, I can
actually get rid of this

5654
04:10:22,470 --> 04:10:27,470
down here, because the Lambo
now is using the drive method.

5655
04:10:28,290 --> 04:10:30,960
If anyone calls drive, it's
just gonna call drive fast,

5656
04:10:30,960 --> 04:10:32,870
which calls this drive fast method.

5657
04:10:32,870 --> 04:10:34,300
So let's really see this in action.

5658
04:10:34,300 --> 04:10:36,400
Let's go over here into our main file.

5659
04:10:37,440 --> 04:10:40,420
And inside of our drive fast,

5660
04:10:40,420 --> 04:10:43,120
let's go ahead and just do
a print line, driving fast.

5661
04:10:47,880 --> 04:10:50,690
So if we have a two door
car, it's gonna drive fast

5662
04:10:50,690 --> 04:10:52,900
and let's do a another two-door car here

5663
04:10:55,440 --> 04:10:57,490
and let's create another one here called,

5664
04:10:59,359 --> 04:11:00,696
let's do another one.

5665
04:11:00,696 --> 04:11:01,529
Let's call this one Honda.

5666
04:11:02,579 --> 04:11:03,490
And maybe you were saying,
hey, you might like

5667
04:11:03,490 --> 04:11:05,730
this really fast Honda or let's do Acura.

5668
04:11:07,410 --> 04:11:09,360
And this one's gonna be a two door car,

5669
04:11:12,761 --> 04:11:14,010
a two door car.

5670
04:11:14,010 --> 04:11:17,550
It's gonna be blue and it's
gonna have four wheels,

5671
04:11:18,400 --> 04:11:19,240
there we go.

5672
04:11:19,240 --> 04:11:23,240
However, we do need to
implement this Acura

5673
04:11:24,140 --> 04:11:24,973
drive fast method.

5674
04:11:24,973 --> 04:11:29,020
So we're gonna say print line zoom zoom.

5675
04:11:31,960 --> 04:11:33,850
And what am I getting at with this?

5676
04:11:33,850 --> 04:11:36,840
What we're gonna see here is when we call

5677
04:11:36,840 --> 04:11:40,770
the drive method here on a two-door car,

5678
04:11:40,770 --> 04:11:42,330
it's gonna delegate to the drive fast.

5679
04:11:42,330 --> 04:11:44,140
Now the drive fast has no implementation,

5680
04:11:44,140 --> 04:11:45,820
we don't know what that does yet.

5681
04:11:45,820 --> 04:11:47,740
However, that's gonna delegate down

5682
04:11:47,740 --> 04:11:50,800
into the actual implementation
of the abstract class.

5683
04:11:50,800 --> 04:11:54,210
So the two door car has
a drive fast method.

5684
04:11:54,210 --> 04:11:58,530
So anytime we call drive,
it'll call drive fast,

5685
04:11:58,530 --> 04:12:00,310
which then calls the drive fast method,

5686
04:12:00,310 --> 04:12:02,660
which is implemented
in the abstract class.

5687
04:12:02,660 --> 04:12:06,270
So let's go here and
let's go ahead and create.

5688
04:12:06,270 --> 04:12:08,220
We'll have our Lambo move that down here.

5689
04:12:08,220 --> 04:12:09,860
We can get rid of these two for now.

5690
04:12:10,907 --> 04:12:14,437
And let me say val Acura equals Acura.

5691
04:12:17,260 --> 04:12:20,140
And now what we can do is we
can say something like this.

5692
04:12:20,140 --> 04:12:25,140
Let me say Lambo drive and Acura drive.

5693
04:12:27,390 --> 04:12:28,230
Now they're both gonna drive,

5694
04:12:28,230 --> 04:12:30,110
they both drive the same, whatever.

5695
04:12:30,110 --> 04:12:32,720
They have the same abstract class,

5696
04:12:32,720 --> 04:12:34,300
they have the same interface
so I can work with them.

5697
04:12:34,300 --> 04:12:35,490
They're both vehicles.

5698
04:12:35,490 --> 04:12:37,340
Now we see it on here, one is driving fast

5699
04:12:37,340 --> 04:12:39,690
and one is going, zoom, zoom.

5700
04:12:39,690 --> 04:12:41,840
Now an interesting thing
that you can do here

5701
04:12:43,108 --> 04:12:43,941
is you can start creating

5702
04:12:43,941 --> 04:12:46,008
all different types of implementations.

5703
04:12:46,008 --> 04:12:48,350
Now I can still we'll call drive fast.

5704
04:12:50,740 --> 04:12:54,820
That's not restricted, I can
still say Acura.drive fast.

5705
04:12:56,760 --> 04:12:58,700
and I can still do this and
everything will still work

5706
04:12:58,700 --> 04:12:59,890
and we'll still get the same results.

5707
04:12:59,890 --> 04:13:02,920
So driving fast, driving fast zoom, zoom.

5708
04:13:02,920 --> 04:13:06,080
'Cause remember, drive, if
you go to implementation

5709
04:13:06,080 --> 04:13:08,590
command B, it takes us
to the two-door car,

5710
04:13:08,590 --> 04:13:10,770
which is just going to delegate
down to the drive fast.

5711
04:13:10,770 --> 04:13:12,890
Now implement the drive method.

5712
04:13:12,890 --> 04:13:15,440
That drive method was from
the original vehicle class.

5713
04:13:16,817 --> 04:13:18,040
This is an accidental import.

5714
04:13:20,270 --> 04:13:23,190
And so that's how you can
create an implementation

5715
04:13:23,190 --> 04:13:26,670
and instance of implement
an abstract class

5716
04:13:26,670 --> 04:13:29,420
and have it also extend other
abstract classes as well.

5717
04:13:31,060 --> 04:13:34,180
One of the more interesting
things about abstract classes

5718
04:13:34,180 --> 04:13:35,580
is the word abstract.

5719
04:13:36,470 --> 04:13:38,310
Anytime you think of an abstract class,

5720
04:13:38,310 --> 04:13:40,620
think about the definition
of the word abstract.

5721
04:13:40,620 --> 04:13:41,965
What does it mean?

5722
04:13:41,965 --> 04:13:43,160
It means to basically pull
something away from it,

5723
04:13:43,160 --> 04:13:45,070
to abstract the details away.

5724
04:13:46,300 --> 04:13:48,710
In software when you use abstract classes,

5725
04:13:48,710 --> 04:13:51,110
especially in Kotlin, it
means you can kind of use this

5726
04:13:51,110 --> 04:13:52,510
as an abstraction of source.

5727
04:13:53,382 --> 04:13:54,215
So let's assume that we've created

5728
04:13:54,215 --> 04:13:55,048
these four different cars.

5729
04:13:55,048 --> 04:13:59,450
All of them all inherit
from a base abstract class

5730
04:13:59,450 --> 04:14:00,380
called vehicle.

5731
04:14:00,380 --> 04:14:02,787
So we have vehicle, we
have a two-door car,

5732
04:14:02,787 --> 04:14:03,650
which extends vehicle.

5733
04:14:03,650 --> 04:14:05,880
We have a Lambo which
extends a two-door car

5734
04:14:05,880 --> 04:14:08,580
and an Acura, which
takes is a two-door car,

5735
04:14:08,580 --> 04:14:10,810
a TownCar and hatchback.

5736
04:14:10,810 --> 04:14:13,160
And each one of these have a drive method.

5737
04:14:14,410 --> 04:14:15,243
So the hatchback says driving a hatchback,

5738
04:14:15,243 --> 04:14:17,300
drive for TownCars is so smooth,

5739
04:14:18,255 --> 04:14:20,140
the drive method for
Acura says zoom, zoom,

5740
04:14:20,140 --> 04:14:23,340
and the drive method for
Lambo says driving fast.

5741
04:14:23,340 --> 04:14:25,770
Notice you say drive fast
and why don't I implement

5742
04:14:25,770 --> 04:14:27,520
the drive because that's implemented

5743
04:14:27,520 --> 04:14:29,930
in its superclass up here.

5744
04:14:29,930 --> 04:14:32,260
And anytime someone calls drive,

5745
04:14:32,260 --> 04:14:33,550
we just call the dry fast method

5746
04:14:33,550 --> 04:14:35,950
because we're just going
to assume two-door cars

5747
04:14:35,950 --> 04:14:37,860
just drive fast for whatever reason.

5748
04:14:39,891 --> 04:14:40,780
So we have all of our cars here.

5749
04:14:40,780 --> 04:14:43,350
Now, if we wanted to call
drive on each one of these,

5750
04:14:43,350 --> 04:14:45,550
what we could do is we
could say lamo.drive,

5751
04:14:48,412 --> 04:14:51,950
we have call acura.drive.

5752
04:14:51,950 --> 04:14:54,690
Now this is great and all, or
we could even say drive fast

5753
04:14:54,690 --> 04:14:56,820
if we know we want it to just drive fast.

5754
04:14:56,820 --> 04:14:59,230
However, there are a lot
of instances in power

5755
04:14:59,230 --> 04:15:02,860
when we know that we wanna
rely on the abstraction.

5756
04:15:02,860 --> 04:15:05,160
So we'll say drive vehicle,
let's create a method

5757
04:15:05,160 --> 04:15:08,710
called drive vehicle, which
just tells the vehicle to drive.

5758
04:15:08,710 --> 04:15:09,720
Vehicle.

5759
04:15:09,720 --> 04:15:10,553
And then what we're gonna do

5760
04:15:10,553 --> 04:15:11,960
is we're gonna take in a vehicle

5761
04:15:13,000 --> 04:15:15,150
and inside of here, what we're gonna do

5762
04:15:15,150 --> 04:15:16,250
is say, vehicle.drive.

5763
04:15:17,650 --> 04:15:19,670
Now this vehicle is an abstraction.

5764
04:15:19,670 --> 04:15:21,500
We're not creating an instance
of it, we're just saying,

5765
04:15:21,500 --> 04:15:24,310
hey, this method is gonna
take an instance of a vehicle.

5766
04:15:24,310 --> 04:15:26,140
We don't care what kind it is,

5767
04:15:26,140 --> 04:15:28,810
we just want a vehicle and
we're gonna tell it to drive.

5768
04:15:28,810 --> 04:15:32,310
So what we can do here is
then you could say, Lambo,

5769
04:15:32,310 --> 04:15:36,620
you say drive vehicle
Lambo parsing instance.

5770
04:15:38,030 --> 04:15:40,999
So I'm gonna just
duplicate this a few times

5771
04:15:40,999 --> 04:15:44,080
and I'll say Acura and then
I'm going to say hatchback

5772
04:15:44,080 --> 04:15:44,913
and TownCar.

5773
04:15:45,990 --> 04:15:49,240
Now, when I run, this what's
gonna happen is drive vehicle

5774
04:15:49,240 --> 04:15:50,073
is gonna call in.

5775
04:15:50,073 --> 04:15:52,870
So we're gonna say Lambo,
we're gonna get an instance

5776
04:15:52,870 --> 04:15:54,010
of a Lambo.

5777
04:15:54,010 --> 04:15:56,230
It's in the call this drive
method, which is gonna say,

5778
04:15:56,230 --> 04:15:58,380
all right, who's implementing
this drive method.

5779
04:15:58,380 --> 04:16:01,090
Well, a two-door cars
implementing the drive method

5780
04:16:01,090 --> 04:16:03,183
because well, who is implementing,

5781
04:16:03,183 --> 04:16:05,190
okay, it's going to call drive

5782
04:16:05,190 --> 04:16:07,800
'cause Lambo is a two door car

5783
04:16:07,800 --> 04:16:09,860
and say, oh well, I'm
gonna implement drive fast,

5784
04:16:09,860 --> 04:16:11,160
which is this method.

5785
04:16:11,160 --> 04:16:12,868
Well, who's implementing dry fast.

5786
04:16:12,868 --> 04:16:14,340
And to say one Acura and Lambo are.

5787
04:16:15,422 --> 04:16:17,540
So that case is gonna go
here and call driving fast.

5788
04:16:17,540 --> 04:16:20,440
So if we were to run
this, what we're gonna see

5789
04:16:20,440 --> 04:16:23,730
really easy is we're gonna
see each one of these methods,

5790
04:16:23,730 --> 04:16:26,560
method invocations are gonna dive down

5791
04:16:26,560 --> 04:16:27,830
and call the appropriate methods.

5792
04:16:27,830 --> 04:16:30,340
So for a Lambo, it's driving fast,

5793
04:16:30,340 --> 04:16:32,200
for an Acura, it's zoom zoom,

5794
04:16:32,200 --> 04:16:34,690
for a hatchback, would
say driving a hatchback

5795
04:16:34,690 --> 04:16:37,290
and for TownCar, it's so smooth.

5796
04:16:37,290 --> 04:16:41,110
And so abstract class thing, again,

5797
04:16:41,110 --> 04:16:43,900
think of the word abstract,
allows you to abstract

5798
04:16:43,900 --> 04:16:47,570
the details behind some type
of, almost like a contract.

5799
04:16:47,570 --> 04:16:50,470
So this is the contract
of all the vehicles

5800
04:16:50,470 --> 04:16:51,303
are going to have.

5801
04:16:51,303 --> 04:16:52,880
They're gonna have color,
they have number of wheels

5802
04:16:52,880 --> 04:16:54,700
and have number of doors.

5803
04:16:54,700 --> 04:16:56,120
There have a drive and a stop,

5804
04:16:56,120 --> 04:16:57,920
which is different for each vehicle.

5805
04:16:59,260 --> 04:17:00,580
And then it's those
child classes implement

5806
04:17:00,580 --> 04:17:04,010
can either decide to
override and implement things

5807
04:17:04,010 --> 04:17:05,940
or if it's an abstract class,

5808
04:17:05,940 --> 04:17:09,930
it can leave it as is and
let the implementers downline

5809
04:17:09,930 --> 04:17:13,110
implement it themselves, such
as TownCar is doing here,

5810
04:17:13,110 --> 04:17:14,870
what it needs to implement drive.

5811
04:17:15,720 --> 04:17:17,570
So again, you could have an addition.

5812
04:17:19,216 --> 04:17:23,460
You could extend two-door car
to be a slow two-door car.

5813
04:17:23,460 --> 04:17:25,970
And instead of it being dry fast,

5814
04:17:25,970 --> 04:17:28,290
you could override that
to, I could drive slow.

5815
04:17:28,290 --> 04:17:31,840
So, and then again, up
in your main file here,

5816
04:17:31,840 --> 04:17:34,530
you could still just use
this method to call drive

5817
04:17:34,530 --> 04:17:38,100
and that class would
then react accordingly

5818
04:17:38,100 --> 04:17:40,030
and you can start performing
all different types

5819
04:17:40,030 --> 04:17:43,490
of operations with
different types of vehicles,

5820
04:17:43,490 --> 04:17:46,700
but have them have the same
type of type signatures.

5821
04:17:46,700 --> 04:17:50,480
And that's how you can use
abstract classes as abstractions

5822
04:17:50,480 --> 04:17:51,680
on a very simple manner.

5823
04:17:52,530 --> 04:17:54,530
So when do you want to use an interface?

5824
04:17:55,530 --> 04:17:56,950
Let's take the simple example of you

5825
04:17:56,950 --> 04:17:58,280
going to eat at arraystaurant.

5826
04:17:58,280 --> 04:18:00,060
So here you are, you're getting ready

5827
04:18:00,060 --> 04:18:02,170
to go eat at the restaurant

5828
04:18:02,170 --> 04:18:07,170
and the waiter brings you out a menu.

5829
04:18:08,420 --> 04:18:11,430
Now the menu I want you to
think of as an interface.

5830
04:18:11,430 --> 04:18:12,570
And what is an interface?

5831
04:18:12,570 --> 04:18:14,120
Well, an interface is a contract saying,

5832
04:18:14,120 --> 04:18:16,290
what are the things
that we can do for you?

5833
04:18:16,290 --> 04:18:18,890
So here at the restaurant,
this is an Italian restaurant.

5834
04:18:18,890 --> 04:18:20,760
They say, well, here we
can make you spaghetti

5835
04:18:20,760 --> 04:18:23,840
and meatballs, we can make you bakesidi.

5836
04:18:23,840 --> 04:18:28,320
We can make you lasagna, we can
make linguine and clam sauce

5837
04:18:29,520 --> 04:18:31,790
and shrimp and garlic and
all kinds of stuff like that.

5838
04:18:31,790 --> 04:18:34,480
And you determine the one
thing I would really like

5839
04:18:34,480 --> 04:18:35,830
is spaghetti and meatballs.

5840
04:18:36,990 --> 04:18:39,000
And so what you're using is this contract.

5841
04:18:39,000 --> 04:18:39,910
You're reading the contract saying,

5842
04:18:39,910 --> 04:18:42,490
hey, what are the available
options, which this menu is.

5843
04:18:42,490 --> 04:18:46,470
It's the list of available
options of what this restaurant

5844
04:18:46,470 --> 04:18:48,110
over here can produce.

5845
04:18:48,110 --> 04:18:49,770
And this is the restaurant.

5846
04:18:49,770 --> 04:18:52,920
And the menu is the interface between you

5847
04:18:52,920 --> 04:18:53,753
and the restaurant.

5848
04:18:53,753 --> 04:18:56,020
So the restaurant says,
this is what we provide,

5849
04:18:56,020 --> 04:18:58,880
this is our contract of
goods that we can do for you

5850
04:18:59,729 --> 04:19:00,562
or things we can build.

5851
04:19:00,562 --> 04:19:02,150
And then what you do is you communicate

5852
04:19:02,150 --> 04:19:04,740
through this interface
here, this menu and say,

5853
04:19:04,740 --> 04:19:06,040
hey, I want to order this.

5854
04:19:06,040 --> 04:19:09,580
And so you tell the
waiter, hey, I wanna order

5855
04:19:09,580 --> 04:19:10,620
this spaghetti and meatballs.

5856
04:19:10,620 --> 04:19:13,860
So this order gets go
over here to the kitchen.

5857
04:19:13,860 --> 04:19:16,202
And then what they end
up doing is they end up

5858
04:19:16,202 --> 04:19:18,160
making your spaghetti and meatballs

5859
04:19:18,160 --> 04:19:20,540
and they end up making it
blah, blah, blah, blah, blah.

5860
04:19:20,540 --> 04:19:23,675
And here's all the noodles
and it kind of looks

5861
04:19:23,675 --> 04:19:24,740
like a smiley face now.

5862
04:19:24,740 --> 04:19:26,750
Anyway, there's some
spaghetti and meatballs.

5863
04:19:27,690 --> 04:19:29,580
And then what ends up happening from there

5864
04:19:29,580 --> 04:19:32,740
is that gets directly returned back to you

5865
04:19:32,740 --> 04:19:34,270
and then you get to enjoy it.

5866
04:19:34,270 --> 04:19:39,270
And you are now a happy camper
because you are enjoying

5867
04:19:39,370 --> 04:19:43,070
your spaghetti and meatballs,
so it's a pretty good thing.

5868
04:19:43,070 --> 04:19:44,220
All right, there we go.

5869
04:19:45,150 --> 04:19:47,510
So your spaghetti meatballs,
now this is the contract.

5870
04:19:47,510 --> 04:19:49,790
Now here's the thing, let's
assume that this restaurant

5871
04:19:49,790 --> 04:19:52,560
has many different locations.

5872
04:19:52,560 --> 04:19:56,090
So this locations, you
could have another location,

5873
04:19:56,090 --> 04:19:57,450
which is over here.

5874
04:19:58,420 --> 04:19:59,290
It maybe some different town,

5875
04:19:59,290 --> 04:20:01,860
but they're owned by the same company.

5876
04:20:01,860 --> 04:20:05,380
But when you go to this restaurant
to this chain restaurant,

5877
04:20:05,380 --> 04:20:07,730
you're like, you realize
that, hey, you know what,

5878
04:20:07,730 --> 04:20:10,210
I really like the spaghetti and meatballs.

5879
04:20:10,210 --> 04:20:12,530
And so you go to the blue one here,

5880
04:20:12,530 --> 04:20:13,840
which is the same company.

5881
04:20:13,840 --> 04:20:15,750
They have the same menu,
so they bring out you

5882
04:20:15,750 --> 04:20:18,350
the menu again and say, all
right, here's all the things

5883
04:20:18,350 --> 04:20:19,450
that we have to offer.

5884
04:20:20,480 --> 04:20:22,940
And these things of course are gonna be

5885
04:20:22,940 --> 04:20:25,440
your spaghetti meatballs and your bakesid

5886
04:20:25,440 --> 04:20:27,320
and your linguine and clam
sauce and et cetera, et cetera,

5887
04:20:27,320 --> 04:20:28,630
et cetera, et cetera.

5888
04:20:28,630 --> 04:20:30,740
And of course you say immediately,

5889
04:20:30,740 --> 04:20:34,010
well, I like the spaghetti
meatballs from this place.

5890
04:20:34,010 --> 04:20:36,275
Again, it's owned by the same company.

5891
04:20:36,275 --> 04:20:38,110
So again, you're gonna make an order again

5892
04:20:38,110 --> 04:20:39,710
say, I want spaghetti and meatballs.

5893
04:20:39,710 --> 04:20:42,070
The order goes over to here,
spaghetti and meatballs.

5894
04:20:42,070 --> 04:20:44,680
And then what you don't
know behind the scenes

5895
04:20:44,680 --> 04:20:47,390
is, well, this is just the contract,

5896
04:20:47,390 --> 04:20:50,320
like you don't care how the
spaghetti meatballs are done,

5897
04:20:50,320 --> 04:20:52,680
you just want the spaghetti and meatballs.

5898
04:20:52,680 --> 04:20:54,550
And so what ends up happening is maybe

5899
04:20:54,550 --> 04:20:56,420
because of the way that
the business is built

5900
04:20:56,420 --> 04:20:57,670
or the software is built.

5901
04:20:58,640 --> 04:21:00,850
In this instance, when
I'm running over here,

5902
04:21:00,850 --> 04:21:02,890
instead of building and
making the spaghetti

5903
04:21:02,890 --> 04:21:06,630
and meatballs myself, they
actually kind of just go over

5904
04:21:06,630 --> 04:21:09,140
here and say, hey folks,
we need some spaghetti

5905
04:21:09,140 --> 04:21:10,425
and meatballs.

5906
04:21:10,425 --> 04:21:11,258
And maybe they've already pre-packaged

5907
04:21:11,258 --> 04:21:13,570
those spaghetti and meatballs before.

5908
04:21:13,570 --> 04:21:15,000
And they actually have already delivered

5909
04:21:15,000 --> 04:21:17,950
a box of those spaghetti and meatballs.

5910
04:21:17,950 --> 04:21:20,330
And the spaghetti and meatballs
are already pre-packaged

5911
04:21:20,330 --> 04:21:21,200
and ready to go.

5912
04:21:22,516 --> 04:21:23,349
And then as you can see here,

5913
04:21:23,349 --> 04:21:25,660
they got all these
little meat balls in here

5914
04:21:25,660 --> 04:21:27,920
and you're ready to eat them,

5915
04:21:27,920 --> 04:21:30,314
or they're ready to warm them up.

5916
04:21:30,314 --> 04:21:31,490
And so at this point in time, you, again,

5917
04:21:31,490 --> 04:21:34,270
you've just ordered the say, I
want spaghetti and meatballs.

5918
04:21:34,270 --> 04:21:37,060
The restaurants are also
adhering to this contract

5919
04:21:37,060 --> 04:21:39,860
and saying, okay, spaghetti
and meatballs came in, cool.

5920
04:21:39,860 --> 04:21:42,200
If you're at this
restaurant, we make it fresh

5921
04:21:42,200 --> 04:21:43,033
because we're the main restaurant.

5922
04:21:43,033 --> 04:21:45,840
If you're at our other location,
we've already made a bunch

5923
04:21:45,840 --> 04:21:47,690
and kind of pre-packaged it.

5924
04:21:47,690 --> 04:21:49,560
So this location can kind of get it done

5925
04:21:49,560 --> 04:21:52,000
because we have a special way of making it

5926
04:21:52,000 --> 04:21:53,690
that only two people know how to do.

5927
04:21:53,690 --> 04:21:55,430
And so now over at this location,

5928
04:21:55,430 --> 04:21:57,530
what they do is they come
over here and they say,

5929
04:21:57,530 --> 04:21:58,363
all right, cool.

5930
04:21:58,363 --> 04:22:02,250
Well, let's go ahead and take
some spaghetti meatballs here

5931
04:22:02,250 --> 04:22:04,610
and we'll head and put it on the plate

5932
04:22:04,610 --> 04:22:06,620
and we're gonna warm it
up and we'll do whatever

5933
04:22:06,620 --> 04:22:07,910
we wanna do to it.

5934
04:22:07,910 --> 04:22:09,840
And here's the spaghetti
and meatballs or whatever.

5935
04:22:09,840 --> 04:22:11,600
And then at that point,
we're gonna go ahead.

5936
04:22:11,600 --> 04:22:14,083
And once that's done, we're gonna go ahead

5937
04:22:14,083 --> 04:22:16,570
and deliver it back to you and boom,

5938
04:22:16,570 --> 04:22:18,730
there you go right into your stomach.

5939
04:22:18,730 --> 04:22:21,330
So now you have spaghetti
and meat balls over here.

5940
04:22:21,330 --> 04:22:23,830
The key thing is here
from a user perspective,

5941
04:22:23,830 --> 04:22:27,580
this is the user who is
perhaps consuming a library,

5942
04:22:27,580 --> 04:22:29,880
your code or whatever,
this is your interface.

5943
04:22:30,813 --> 04:22:33,253
Your interface says, hey,
here's the things we can do.

5944
04:22:33,253 --> 04:22:35,370
And then the implementations
are these restaurants.

5945
04:22:35,370 --> 04:22:37,140
These are who implemented the interface.

5946
04:22:37,140 --> 04:22:38,910
This restaurant A
implemented the interface

5947
04:22:38,910 --> 04:22:41,680
and restaurant B implemented
the same interface.

5948
04:22:41,680 --> 04:22:44,780
They both said, hey, we
can both make you spaghetti

5949
04:22:44,780 --> 04:22:45,770
and meatballs.

5950
04:22:45,770 --> 04:22:48,910
Now how they do that, you
really don't care about.

5951
04:22:48,910 --> 04:22:51,270
The caller of that from
the interface perspective

5952
04:22:51,270 --> 04:22:52,180
doesn't care about it.

5953
04:22:52,180 --> 04:22:54,590
The caller says, hey, I want
spaghetti and meatballs.

5954
04:22:55,450 --> 04:22:58,083
At the end of the day, you
know that you've just been

5955
04:22:58,083 --> 04:23:00,295
delivered the spaghetti and
meatballs that you want,

5956
04:23:00,295 --> 04:23:01,648
you don't care how it's done.

5957
04:23:01,648 --> 04:23:02,481
Now behind the scenes,

5958
04:23:02,481 --> 04:23:03,314
the implementation could be different.

5959
04:23:03,314 --> 04:23:04,950
For example, this is code.

5960
04:23:04,950 --> 04:23:07,210
This code might call into a
completely different module

5961
04:23:07,210 --> 04:23:11,700
to generate something or this
code might generated itself.

5962
04:23:11,700 --> 04:23:14,090
It all really depends
on how you're doing it.

5963
04:23:14,090 --> 04:23:18,020
But what it allows you to do
from a developer perspective

5964
04:23:18,020 --> 04:23:21,340
is say, hey, I have this
known interface here.

5965
04:23:21,340 --> 04:23:24,170
And so anyone who interacts
with us just needs to parse us

5966
04:23:24,170 --> 04:23:28,030
an instance at this interface
and call this interface

5967
04:23:28,030 --> 04:23:29,750
and whoever implements it over here

5968
04:23:29,750 --> 04:23:31,780
will do whatever they
need to do to return back

5969
04:23:31,780 --> 04:23:32,760
what they want.

5970
04:23:32,760 --> 04:23:35,080
And so you can have one,
you can have multiple

5971
04:23:35,080 --> 04:23:37,770
different implementations
of these over here.

5972
04:23:37,770 --> 04:23:40,280
You could have, we have two colors here,

5973
04:23:40,280 --> 04:23:41,570
but you can keep going.

5974
04:23:41,570 --> 04:23:44,940
And there could be all different
types of implementations

5975
04:23:44,940 --> 04:23:47,040
of this interface and they
could be all over the place.

5976
04:23:47,040 --> 04:23:49,270
They could be ones up here,
there could be hundreds

5977
04:23:49,270 --> 04:23:50,640
of different of the implementations,

5978
04:23:50,640 --> 04:23:54,140
but they all, every single one of them

5979
04:23:54,140 --> 04:23:57,690
adhere to the same
interface, the same contract.

5980
04:23:57,690 --> 04:24:01,020
So it doesn't matter if
you're ordering spaghetti

5981
04:24:01,020 --> 04:24:04,000
and meatballs from this
location or this location

5982
04:24:04,000 --> 04:24:05,970
or any of these locations, they all know

5983
04:24:05,970 --> 04:24:08,620
how to return back to you
the spaghetti and meatballs

5984
04:24:09,502 --> 04:24:10,640
that you want, all done
through this interface.

5985
04:24:10,640 --> 04:24:13,360
Now, if you take this a step
further and we can go ahead

5986
04:24:13,360 --> 04:24:15,240
and kind of clear this thing out,

5987
04:24:16,080 --> 04:24:17,848
again, you have yourself over here

5988
04:24:17,848 --> 04:24:20,640
and now this is we're going
to a futuristic restaurant.

5989
04:24:21,889 --> 04:24:22,920
And this futuristic restaurant now has

5990
04:24:22,920 --> 04:24:24,830
just a digital ordering pad.

5991
04:24:25,730 --> 04:24:27,930
And you come in here and you
get to press on some buttons.

5992
04:24:27,930 --> 04:24:31,010
So I want, spaghetti and
meatballs or baked ZD or whatever.

5993
04:24:32,239 --> 04:24:33,072
This is just an interface too,

5994
04:24:33,072 --> 04:24:34,320
think about it like a graphical interface.

5995
04:24:34,320 --> 04:24:36,490
This is an interface
that's been implemented.

5996
04:24:36,490 --> 04:24:39,030
Now, depends on where you're going.

5997
04:24:39,030 --> 04:24:41,030
You don't really care
who's implemented it,

5998
04:24:41,030 --> 04:24:42,340
you just wanna know that you're gonna get

5999
04:24:42,340 --> 04:24:45,364
either your spaghetti and meatballs,

6000
04:24:45,364 --> 04:24:47,064
or you're gonna get your baked ZD.

6001
04:24:48,443 --> 04:24:50,650
And you really just don't
care where all these different

6002
04:24:50,650 --> 04:24:53,371
types of things are coming
from because to you,

6003
04:24:53,371 --> 04:24:56,480
you interacting with whoever
agreed to that contract.

6004
04:24:57,410 --> 04:24:58,840
And then at that point in time.

6005
04:24:58,840 --> 04:25:01,380
So for example, let's even
take this a step further.

6006
04:25:01,380 --> 04:25:05,070
You could have two
different implementations

6007
04:25:05,070 --> 04:25:06,440
of that interface.

6008
04:25:06,440 --> 04:25:10,630
So this is gonna number
one will be up here

6009
04:25:11,780 --> 04:25:13,540
and number two will be down here.

6010
04:25:14,770 --> 04:25:16,810
And as you order this item here,

6011
04:25:16,810 --> 04:25:19,410
right in this little section,
so I wanna order this.

6012
04:25:20,360 --> 04:25:22,850
And at this point in time,
you're gonna kind of go down

6013
04:25:22,850 --> 04:25:24,730
this path right here.

6014
04:25:24,730 --> 04:25:27,330
Well, cool, that means I'm gonna go ahead

6015
04:25:27,330 --> 04:25:29,260
and this automatically then says,

6016
04:25:29,260 --> 04:25:30,890
okay, let's spaghetti and meatballs.

6017
04:25:30,890 --> 04:25:33,000
We're gonna go to this module and generate

6018
04:25:33,000 --> 04:25:34,880
whatever we need to generate.

6019
04:25:34,880 --> 04:25:36,070
And for whatever reason,

6020
04:25:36,070 --> 04:25:38,800
you're going down this path over here,

6021
04:25:40,030 --> 04:25:41,970
well, all that's just kind
of, we have custom codes

6022
04:25:41,970 --> 04:25:43,358
for everything.

6023
04:25:43,358 --> 04:25:44,191
So everything is just
kind of done right here

6024
04:25:44,191 --> 04:25:45,250
in this whole section.

6025
04:25:45,250 --> 04:25:47,640
So what that allows you to
do, the interface allows you

6026
04:25:47,640 --> 04:25:51,530
to hide the implementation
behind a particular interface.

6027
04:25:51,530 --> 04:25:53,240
It's the contract that this is the things

6028
04:25:53,240 --> 04:25:55,060
that we can do for you.

6029
04:25:55,060 --> 04:25:56,760
So anytime you want something to adhere

6030
04:25:56,760 --> 04:25:58,660
to the same contract, you can do that.

6031
04:25:59,662 --> 04:26:01,847
And that's exactly what has happened over

6032
04:26:01,847 --> 04:26:04,052
inside of the examples here.

6033
04:26:04,052 --> 04:26:06,340
In this case, we're using
mammals so we can have a mammal

6034
04:26:06,340 --> 04:26:09,040
and it can be a cow, it
can be a human or whatever.

6035
04:26:09,040 --> 04:26:11,846
We noticed that it walks,
it can speak, whatever.

6036
04:26:11,846 --> 04:26:14,100
All we know is it with a mammal interface,

6037
04:26:14,100 --> 04:26:16,470
if I tell a man what
to walk, it will walk.

6038
04:26:16,470 --> 04:26:17,830
Now I don't care how it walks.

6039
04:26:17,830 --> 04:26:20,420
Does it walk on four feet,
two feet, 12 feet, 15,

6040
04:26:20,420 --> 04:26:23,900
I don't know, don't care,
I just know that it walks.

6041
04:26:23,900 --> 04:26:26,190
And so when you have an
interface, it means that,

6042
04:26:26,190 --> 04:26:28,630
hey, these are the things we can do.

6043
04:26:28,630 --> 04:26:30,570
To implement an interface in Kotlin,

6044
04:26:31,409 --> 04:26:32,242
you'll type the word interface

6045
04:26:32,242 --> 04:26:33,590
and then the name of the interface.

6046
04:26:34,530 --> 04:26:36,520
I'm going to call this one discountable

6047
04:26:37,870 --> 04:26:40,310
as in something might
be able to be discounted

6048
04:26:40,310 --> 04:26:42,930
such as a physical product, or
maybe even a digital product,

6049
04:26:42,930 --> 04:26:45,140
but I just want it to be discountable.

6050
04:26:45,140 --> 04:26:48,010
And instead of there, I can
declare values or excuse me,

6051
04:26:48,010 --> 04:26:52,180
functions that I would want
the implementer to implement.

6052
04:26:52,180 --> 04:26:54,811
So here I'm going to implement a function

6053
04:26:54,811 --> 04:26:56,600
called discount percent,

6054
04:26:56,600 --> 04:26:59,450
which will then return the percent amount

6055
04:26:59,450 --> 04:27:02,730
that whatever the discounted
item is going to be

6056
04:27:02,730 --> 04:27:03,940
will be discountable.

6057
04:27:03,940 --> 04:27:05,730
So now I have created an interface

6058
04:27:05,730 --> 04:27:07,280
that is called discountable.

6059
04:27:07,280 --> 04:27:09,730
It has one function, I
create another function

6060
04:27:09,730 --> 04:27:10,730
that could do something else.

6061
04:27:10,730 --> 04:27:13,430
Perhaps I'd call it a foo
and maybe it doesn't have

6062
04:27:13,430 --> 04:27:15,530
a return type, it doesn't have to be,

6063
04:27:15,530 --> 04:27:19,893
it might be something such
as calculate something

6064
04:27:20,840 --> 04:27:22,740
or you could just do whatever you wanna do

6065
04:27:22,740 --> 04:27:24,990
inside of your function.

6066
04:27:24,990 --> 04:27:26,310
So it doesn't have to have a return type

6067
04:27:26,310 --> 04:27:28,190
and return types can be anything you want.

6068
04:27:28,190 --> 04:27:30,950
And that's how you create
an interface in Kotlin.

6069
04:27:32,060 --> 04:27:34,470
To implement an interface in Kotlin,

6070
04:27:34,470 --> 04:27:36,750
you'll want to actually create a class.

6071
04:27:36,750 --> 04:27:40,170
So you say class, it might
wanna have a physical product.

6072
04:27:40,170 --> 04:27:43,060
So we'll just go ahead
and say generic toy.

6073
04:27:44,020 --> 04:27:46,890
And this class is going
to extend and implement

6074
04:27:46,890 --> 04:27:49,920
the discountable interface.

6075
04:27:49,920 --> 04:27:51,910
So here we have the red
squiggly and we can click

6076
04:27:51,910 --> 04:27:53,900
on this button and say, implement members

6077
04:27:53,900 --> 04:27:55,840
and it'll ask us which ones.

6078
04:27:55,840 --> 04:27:57,650
We could select discount percent.

6079
04:27:57,650 --> 04:27:59,640
And then what we have to
do is we have to implement

6080
04:27:59,640 --> 04:28:01,310
whatever that value is.

6081
04:28:02,421 --> 04:28:03,254
And of course, if we do not implement it,

6082
04:28:03,254 --> 04:28:05,840
we can leave the default
to do here, which will then

6083
04:28:05,840 --> 04:28:08,420
if we look at the
implementation, will go ahead

6084
04:28:08,420 --> 04:28:10,870
and throw a null implemented exception.

6085
04:28:10,870 --> 04:28:12,310
So if we run it, we'll
kind of get something

6086
04:28:12,310 --> 04:28:15,160
in our log saying that this
has not been implemented

6087
04:28:15,160 --> 04:28:17,720
for later, but this is how you
can implement the interface.

6088
04:28:17,720 --> 04:28:20,460
Now, if you do add
additional member on here,

6089
04:28:20,460 --> 04:28:22,870
so let's just call this
foo for whatever reason,

6090
04:28:22,870 --> 04:28:24,950
we're gonna get a compilation error again.

6091
04:28:24,950 --> 04:28:26,980
So we won't be able to compile
until we implement that

6092
04:28:26,980 --> 04:28:29,590
on anyone else who has
implemented discountable.

6093
04:28:29,590 --> 04:28:32,390
So we may also have another
class called digital product

6094
04:28:33,370 --> 04:28:37,440
and digital product is also
going to implement discountable

6095
04:28:37,440 --> 04:28:39,130
because perhaps you can
discount that as well.

6096
04:28:39,130 --> 04:28:42,160
And you will also need to
implement both of these values

6097
04:28:42,160 --> 04:28:44,040
on to both of these as well.

6098
04:28:44,040 --> 04:28:46,200
So they'll both be discountable.

6099
04:28:46,200 --> 04:28:49,320
And that's how you implement
an interface in Kotlin.

6100
04:28:50,910 --> 04:28:53,700
And some examples of this
might be you build an interface

6101
04:28:53,700 --> 04:28:54,980
for your file system.

6102
04:28:55,990 --> 04:28:57,900
So if you build a file
file system interface,

6103
04:28:57,900 --> 04:28:59,610
you might have something like this.

6104
04:28:59,610 --> 04:29:02,020
Interface, we'll call it fs for five.

6105
04:29:02,020 --> 04:29:04,120
It's very comical file
system and I think nobody

6106
04:29:04,120 --> 04:29:05,290
even has one called fs.

6107
04:29:06,745 --> 04:29:10,180
And we might have a method called reader,

6108
04:29:10,180 --> 04:29:12,380
which is going to read
back and give us back

6109
04:29:13,778 --> 04:29:17,640
a list of string is called files.

6110
04:29:17,640 --> 04:29:22,640
We could have function read file,

6111
04:29:22,800 --> 04:29:24,750
and it's gonna return us back a string.

6112
04:29:25,607 --> 04:29:26,440
And we can have a whole
bunch of other things

6113
04:29:26,440 --> 04:29:27,273
inside of here.

6114
04:29:27,273 --> 04:29:29,160
Now, what we could do is,

6115
04:29:29,160 --> 04:29:30,350
I'm actually just gonna rename this

6116
04:29:30,350 --> 04:29:31,650
so it's a little bit more,

6117
04:29:33,010 --> 04:29:34,830
make some more sense of file system.

6118
04:29:35,735 --> 04:29:37,290
Then what we could do is we
could have an implementation

6119
04:29:37,290 --> 04:29:38,600
of the file system,

6120
04:29:38,600 --> 04:29:41,810
and we might wanna call
that a real file system,

6121
04:29:43,060 --> 04:29:47,540
or you know what, let's just
call it a fat 32 file system,

6122
04:29:47,540 --> 04:29:49,600
which is a real file system.

6123
04:29:49,600 --> 04:29:51,320
And it's gonna implement file system.

6124
04:29:53,019 --> 04:29:54,969
And then what we'd have here implement,

6125
04:29:56,040 --> 04:29:58,090
oops, implement these members.

6126
04:29:59,573 --> 04:30:01,300
And then we have to do something

6127
04:30:01,300 --> 04:30:03,100
with each one of these members here.

6128
04:30:04,056 --> 04:30:06,280
So we would read the
file in a fat 32 method,

6129
04:30:06,280 --> 04:30:10,730
and we would read the
directory in a fat 32 method.

6130
04:30:10,730 --> 04:30:12,350
And then there's other file systems here.

6131
04:30:12,350 --> 04:30:15,320
So let's just go to return an empty list,

6132
04:30:15,320 --> 04:30:17,220
just so we don't get a compiler error

6133
04:30:17,220 --> 04:30:21,100
and let's just go ahead
and return an empty string.

6134
04:30:22,774 --> 04:30:24,750
And of course, we would
read a file that the file

6135
04:30:24,750 --> 04:30:26,571
would probably have a path of whatever,

6136
04:30:26,571 --> 04:30:28,310
and we're leaving it off
for brevity at this point.

6137
04:30:28,310 --> 04:30:30,120
Then if we wanna have it ext file system.

6138
04:30:30,120 --> 04:30:35,120
So class ext files, we've
gotta have a file system here.

6139
04:30:38,300 --> 04:30:40,950
Same thing, we need to
implement those members,

6140
04:30:40,950 --> 04:30:42,960
and we need to actually
implement the other one too.

6141
04:30:44,730 --> 04:30:47,324
And it's gonna leave us to do there

6142
04:30:47,324 --> 04:30:48,230
so we don't have the error.

6143
04:30:49,429 --> 04:30:52,644
Now, this is great because
we have the ext file system.

6144
04:30:52,644 --> 04:30:54,775
We have the fat 32 file
system, and we know

6145
04:30:54,775 --> 04:30:55,610
that anytime we're working
with a file system,

6146
04:30:55,610 --> 04:30:57,090
we need to do something.

6147
04:30:57,090 --> 04:31:00,950
Now, lastly, we may have
a very interesting one,

6148
04:31:00,950 --> 04:31:02,060
we have right here.

6149
04:31:02,060 --> 04:31:05,170
So I have class memory file system.

6150
04:31:07,333 --> 04:31:08,900
Why would we want this?

6151
04:31:08,900 --> 04:31:10,920
Now, this is very interesting here,

6152
04:31:10,920 --> 04:31:15,920
because we might just have
something that allows us to,

6153
04:31:16,160 --> 04:31:18,310
let's go ahead and
implement these members.

6154
04:31:19,640 --> 04:31:22,480
And we might be able to
have an implementation here

6155
04:31:22,480 --> 04:31:25,040
of memory file system, where we take in

6156
04:31:25,040 --> 04:31:27,230
and a constructor here.

6157
04:31:27,230 --> 04:31:29,320
Watch this, we say read directory.

6158
04:31:29,320 --> 04:31:31,250
We take in files.

6159
04:31:31,250 --> 04:31:32,980
So we've taken a list of strings.

6160
04:31:34,340 --> 04:31:36,470
And look what we're gonna do here,

6161
04:31:40,387 --> 04:31:43,400
and we take in the file content, B string,

6162
04:31:45,081 --> 04:31:47,430
and now all I'm gonna do
here is just return files.

6163
04:31:50,450 --> 04:31:52,130
That needs to be a val,
so we can actually work

6164
04:31:52,130 --> 04:31:53,530
with the inside of the class

6165
04:31:55,210 --> 04:32:00,210
and the same thing down here,
return the file contents.

6166
04:32:02,230 --> 04:32:03,930
So the interesting thing
here is if we go back

6167
04:32:03,930 --> 04:32:06,060
to our main application.

6168
04:32:07,750 --> 04:32:11,450
If for whatever reason inside
of our main function here,

6169
04:32:13,058 --> 04:32:13,891
we wanted...

6170
04:32:13,891 --> 04:32:15,930
If we were to work with
just the file system,

6171
04:32:15,930 --> 04:32:17,640
so it will say file system.

6172
04:32:18,561 --> 04:32:20,710
And we were broke with
the fat 32 file system.

6173
04:32:22,058 --> 04:32:23,650
And then we're gonna do
something with the file system,

6174
04:32:25,810 --> 04:32:26,643
blah, blah, blah.

6175
04:32:26,643 --> 04:32:28,520
We could actually say, I'm
gonna read this directory

6176
04:32:28,520 --> 04:32:29,890
and it's gonna read the directory.

6177
04:32:29,890 --> 04:32:33,150
Now this would be very pertinent
to file 32 fast system.

6178
04:32:33,150 --> 04:32:34,630
Well, what if we wanted our application

6179
04:32:34,630 --> 04:32:37,174
to run on the ext file system?

6180
04:32:37,174 --> 04:32:39,370
Well, now we're gonna
have to do like some,

6181
04:32:40,547 --> 04:32:42,000
if the FL statements to
check what file system

6182
04:32:42,000 --> 04:32:45,550
we're on or whatever, or
what could be provided to us

6183
04:32:45,550 --> 04:32:49,220
during real time is actually a interface.

6184
04:32:49,220 --> 04:32:51,910
So we might actually
say something like this.

6185
04:32:52,920 --> 04:32:57,920
Val file system, file system right here.

6186
04:32:58,630 --> 04:33:00,480
Remember, this is the interface here,

6187
04:33:01,448 --> 04:33:04,290
and we can say equals fat 32 file system.

6188
04:33:04,290 --> 04:33:06,895
Now that's still works and
we can still kind of do

6189
04:33:06,895 --> 04:33:07,728
the same kind of thing we did before.

6190
04:33:07,728 --> 04:33:10,840
And if we were using something
like dependency injection,

6191
04:33:10,840 --> 04:33:13,830
we could actually get
this from a constructor,

6192
04:33:13,830 --> 04:33:15,010
which is beyond the scope of this,

6193
04:33:15,010 --> 04:33:17,730
but we get from a constructor or a setter

6194
04:33:19,080 --> 04:33:21,880
or something like that,
some variable, some type,

6195
04:33:23,018 --> 04:33:25,590
in which, we could set up pretty easily.

6196
04:33:25,590 --> 04:33:27,450
Now the real power from this comes in

6197
04:33:27,450 --> 04:33:29,360
when we determined later on.

6198
04:33:29,360 --> 04:33:31,290
So let's actually do that now.

6199
04:33:32,136 --> 04:33:33,030
We actually just create a method here,

6200
04:33:34,802 --> 04:33:36,452
call get file system to function.

6201
04:33:39,234 --> 04:33:41,834
Get file system is going
to return us a file system,

6202
04:33:45,300 --> 04:33:47,790
turned fat 32 files, okay, there we go.

6203
04:33:47,790 --> 04:33:51,860
And all we can do here is
just say this file system.

6204
04:33:54,240 --> 04:33:55,190
Create file system.

6205
04:33:59,742 --> 04:34:00,575
Now at that point in time, we can do this.

6206
04:34:00,575 --> 04:34:02,630
Now, the interesting thing
here is if this was inside

6207
04:34:02,630 --> 04:34:05,357
of a dependency injection or whatever,

6208
04:34:05,357 --> 04:34:06,990
we could use the in-memory version.

6209
04:34:06,990 --> 04:34:10,320
So if I'm writing a test,
maybe I've just moved this code

6210
04:34:10,320 --> 04:34:12,660
into like a helper function somewhere.

6211
04:34:12,660 --> 04:34:13,980
And then what I do is instead of this one,

6212
04:34:13,980 --> 04:34:16,930
I say return memory file system.

6213
04:34:16,930 --> 04:34:21,803
And then what I do is I
know list of no path to file

6214
04:34:25,260 --> 04:34:30,260
another paths, so remember
this path of file pars,

6215
04:34:30,680 --> 04:34:35,200
file content go here.

6216
04:34:37,490 --> 04:34:39,110
So what I'm doing is I'm actually creating

6217
04:34:39,110 --> 04:34:42,770
a in-memory file system, kind
of faking the whole thing.

6218
04:34:42,770 --> 04:34:44,380
And then inside of my
application, I could say,

6219
04:34:44,380 --> 04:34:46,310
filed.read directory.

6220
04:34:46,310 --> 04:34:47,580
And then what I can do is actually give

6221
04:34:47,580 --> 04:34:51,400
a known list of files here.

6222
04:34:51,400 --> 04:34:54,710
And so now I've actually
and I've enabled myself

6223
04:34:54,710 --> 04:34:56,420
to have different implementations.

6224
04:34:56,420 --> 04:34:57,253
This is the contract.

6225
04:34:57,253 --> 04:35:00,550
Remember the contract says,
hey, I'm gonna redirect

6226
04:35:00,550 --> 04:35:01,630
and I know how to read a file.

6227
04:35:01,630 --> 04:35:03,560
And if I read a file, I'm
gonna get back a string

6228
04:35:03,560 --> 04:35:05,890
and if I read a directory and
to get back a list of strings.

6229
04:35:05,890 --> 04:35:08,550
That's all I know how to do,
I don't care how it's done,

6230
04:35:08,550 --> 04:35:11,180
but I'm a fat 32 system
it's done differently

6231
04:35:11,180 --> 04:35:13,160
than an ext file system.

6232
04:35:13,160 --> 04:35:16,110
And you know what, I may also
build a memory file system,

6233
04:35:16,110 --> 04:35:18,200
which allows me to provide the values

6234
04:35:20,401 --> 04:35:21,740
to the actual file
system so I can actually

6235
04:35:21,740 --> 04:35:25,050
basically do this in memory
or for testing, et cetera.

6236
04:35:25,050 --> 04:35:29,321
So interfaces allow you to
separate and think of them

6237
04:35:29,321 --> 04:35:30,154
almost like shims.

6238
04:35:30,154 --> 04:35:32,540
They allow you to kind of really
decouple your application.

6239
04:35:32,540 --> 04:35:34,360
And so they're just a way
for you to communicate.

6240
04:35:34,360 --> 04:35:38,130
It's a known contract between
you and your application

6241
04:35:38,130 --> 04:35:39,080
and what it can do.

6242
04:35:39,970 --> 04:35:42,690
When creating interfaces, it's
very often that you'll do it

6243
04:35:42,690 --> 04:35:44,660
in an anonymous fashion.

6244
04:35:44,660 --> 04:35:47,550
Here, I have set up an interface
called on click listener.

6245
04:35:47,550 --> 04:35:49,795
This is something you've probably seen

6246
04:35:49,795 --> 04:35:51,245
in various other UI toolkits.

6247
04:35:52,140 --> 04:35:54,420
And this on click listener
has an on click method

6248
04:35:54,420 --> 04:35:57,400
that is called when a
particular view was clicked.

6249
04:35:57,400 --> 04:35:59,850
And so we have a class here called view.

6250
04:35:59,850 --> 04:36:03,220
This could be such as like
a button, a text view,

6251
04:36:03,220 --> 04:36:06,540
an image view, some type of
map or anything like that.

6252
04:36:06,540 --> 04:36:09,620
And it has a listener that's
going to be assigned to it.

6253
04:36:09,620 --> 04:36:12,460
Now, we're just gonna very
simply here use the late init

6254
04:36:12,460 --> 04:36:15,690
modifier to say at some point,
this will be called and set.

6255
04:36:18,165 --> 04:36:18,998
And we're not doing
any null checking here,

6256
04:36:18,998 --> 04:36:19,831
so this is not production quality,

6257
04:36:19,831 --> 04:36:21,670
but this illustrates the example.

6258
04:36:22,648 --> 04:36:24,840
So anytime the view is
clicked, it'll then instantiate

6259
04:36:24,840 --> 04:36:27,370
the click listener and
then whatever happens

6260
04:36:27,370 --> 04:36:28,720
inside the click listener will happen.

6261
04:36:28,720 --> 04:36:31,866
So that's the interface
here, on click listener

6262
04:36:31,866 --> 04:36:32,699
with the on click method.

6263
04:36:32,699 --> 04:36:34,830
So we have a few other
classes that extend view

6264
04:36:34,830 --> 04:36:36,360
such as button image and map.

6265
04:36:37,558 --> 04:36:38,710
So let's assume we create a button here.

6266
04:36:38,710 --> 04:36:41,620
If I wanted to set the click listener,

6267
04:36:41,620 --> 04:36:43,450
I could set it to an instance
of the click listener

6268
04:36:43,450 --> 04:36:45,730
if I had implemented it
in an instance of it,

6269
04:36:45,730 --> 04:36:48,820
in which I could do my own
custom one, like this class,

6270
04:36:50,660 --> 04:36:51,493
my listener.

6271
04:36:52,630 --> 04:36:56,190
And that would be on click
listener and then be like this.

6272
04:36:58,347 --> 04:37:02,440
And then perhaps I wanna say
print line and I say clicked.

6273
04:37:02,440 --> 04:37:05,290
And I can do that very easily
by just saying new listener

6274
04:37:06,130 --> 04:37:07,790
to list my listener.

6275
04:37:09,850 --> 04:37:11,830
And there we go, now that
click listener will work.

6276
04:37:11,830 --> 04:37:14,010
And if I call button.click,

6277
04:37:15,300 --> 04:37:17,580
the listener will now get invoked.

6278
04:37:17,580 --> 04:37:20,170
So if we run this here,
we should see clicked

6279
04:37:20,170 --> 04:37:23,340
in the output window, we do see clicked.

6280
04:37:23,340 --> 04:37:26,360
Now this is not an
anonymous implementation,

6281
04:37:26,360 --> 04:37:27,193
this is a concrete implementation.

6282
04:37:27,193 --> 04:37:28,280
So let's go ahead and get rid of this.

6283
04:37:28,280 --> 04:37:30,210
This is not what we want here.

6284
04:37:30,210 --> 04:37:33,290
There's a way we can do
it directly in line here.

6285
04:37:33,290 --> 04:37:34,810
So what we're going to do is
we use this word called object.

6286
04:37:34,810 --> 04:37:38,710
We're basically creating an
object right here in place,

6287
04:37:38,710 --> 04:37:40,160
and we'll say click listener,

6288
04:37:41,250 --> 04:37:42,900
and then open and close brackets.

6289
04:37:43,989 --> 04:37:45,040
And then you'll see object is highlight

6290
04:37:46,279 --> 04:37:47,980
and you hit alt+enter for Mac
and implement the members.

6291
04:37:47,980 --> 04:37:50,220
And it will just allow you
to implement that member,

6292
04:37:50,220 --> 04:37:52,990
which is on click and then we
can just do print line here.

6293
04:37:55,454 --> 04:37:56,287
Let's say this was clicked.

6294
04:37:57,490 --> 04:37:59,020
And of course, now if we run this,

6295
04:37:59,020 --> 04:38:01,890
what will happen is this basically created

6296
04:38:01,890 --> 04:38:03,100
an inline object here.

6297
04:38:03,990 --> 04:38:07,340
A we've done it in line object,
which is an implementation

6298
04:38:07,340 --> 04:38:09,760
of the on click listener directly in line.

6299
04:38:10,920 --> 04:38:14,280
And it was called here and
directly set up accordingly.

6300
04:38:14,280 --> 04:38:16,960
So that's how you can create
a new instance of that.

6301
04:38:16,960 --> 04:38:20,210
Now, sometimes you'll also see methods

6302
04:38:20,210 --> 04:38:22,350
perhaps that allow you to set listener.

6303
04:38:22,350 --> 04:38:26,660
So to say, set my listener,
we'll just call it that.

6304
04:38:28,330 --> 04:38:31,500
And this is gonna have a click listener,

6305
04:38:36,933 --> 04:38:38,200
and this click listener is going to be

6306
04:38:38,200 --> 04:38:43,200
this dot click listener
equals click listener.

6307
04:38:45,180 --> 04:38:47,430
And so what it basically
says, this one is gonna be set

6308
04:38:47,430 --> 04:38:48,730
equal to this one up here.

6309
04:38:50,234 --> 04:38:52,392
And so that's another way
you could do that there too.

6310
04:38:52,392 --> 04:38:56,150
So inside of here, we say
button.set click listener,

6311
04:38:56,150 --> 04:38:57,310
which is a method now.

6312
04:38:58,210 --> 04:39:01,060
And so I can actually just
cut and paste this out of here

6313
04:39:02,440 --> 04:39:03,990
in the same thing.

6314
04:39:03,990 --> 04:39:04,930
I'm gonna use an object,

6315
04:39:04,930 --> 04:39:07,380
so object: the name of the interface,

6316
04:39:07,380 --> 04:39:09,970
open and close brackets and then implement

6317
04:39:09,970 --> 04:39:12,050
the required methods in the middle.

6318
04:39:12,050 --> 04:39:14,930
So the abstract methods
and this place on click

6319
04:39:14,930 --> 04:39:18,130
and an instance of on click
list will be anonymously created

6320
04:39:18,130 --> 04:39:21,270
and set into this value here.

6321
04:39:21,270 --> 04:39:24,250
So when the click button is called,

6322
04:39:24,250 --> 04:39:26,040
it will then say this was clicked.

6323
04:39:26,040 --> 04:39:28,340
And just to show some differences here,

6324
04:39:29,698 --> 04:39:30,810
let's say this was clicked ABC.

6325
04:39:30,810 --> 04:39:33,710
And if we run this again,
when it gets to button.click,

6326
04:39:33,710 --> 04:39:37,060
we'll see this was clicked ABC.

6327
04:39:37,060 --> 04:39:42,060
Now the same thing happens
here for the map and the image.

6328
04:39:43,150 --> 04:39:46,530
So you could then eat it
very easily and say map.

6329
04:39:48,198 --> 04:39:52,270
So val map equals map and we
would say map.click listener

6330
04:39:52,270 --> 04:39:55,240
equals, and you could do the
object thing here as well.

6331
04:39:58,680 --> 04:40:01,630
Is that on click listener and
then open and close brackets.

6332
04:40:04,100 --> 04:40:05,490
And there you go.

6333
04:40:05,490 --> 04:40:06,670
And then you can do
something inside of there.

6334
04:40:06,670 --> 04:40:08,820
And then of course, if
the map was clicked.

6335
04:40:10,970 --> 04:40:12,520
Now, what this allows you to do is have

6336
04:40:12,520 --> 04:40:16,640
the very common interface,
a contract of, one of you

6337
04:40:16,640 --> 04:40:19,150
is clicked, it'll just invoke a function.

6338
04:40:19,150 --> 04:40:22,330
And then you get to decide what
to do when a map was clicked

6339
04:40:22,330 --> 04:40:24,810
or what to do when this
particular button is clicked.

6340
04:40:24,810 --> 04:40:27,230
And so this is a very common
pattern you'll have seen

6341
04:40:27,230 --> 04:40:28,690
inside of various UI platforms.

6342
04:40:28,690 --> 04:40:31,720
So that's how you can create
an anonymous interface

6343
04:40:31,720 --> 04:40:33,710
implementation in Kotlin.

6344
04:40:34,930 --> 04:40:37,920
You can easily create a raise in Kotlin.

6345
04:40:37,920 --> 04:40:39,010
So let's do that real quick.

6346
04:40:39,010 --> 04:40:41,580
We'll create a variable called items,

6347
04:40:41,580 --> 04:40:45,490
and you can say array
of and then you parse in

6348
04:40:45,490 --> 04:40:46,323
some primitive.

6349
04:40:46,323 --> 04:40:49,040
So we can say one, two, three, four, five,

6350
04:40:49,040 --> 04:40:50,640
and then we can do
something with that array.

6351
04:40:50,640 --> 04:40:52,720
So now we have an array of integers.

6352
04:40:52,720 --> 04:40:55,100
So we can say items.foreach.

6353
04:40:55,100 --> 04:40:57,830
And what we're using is
the extinction function

6354
04:40:57,830 --> 04:40:59,930
on the array class.

6355
04:40:59,930 --> 04:41:02,803
There is a foreach extension method

6356
04:41:02,803 --> 04:41:04,380
built inside of the arrays
instead of the Kotlin

6357
04:41:04,380 --> 04:41:05,250
standard library.

6358
04:41:06,090 --> 04:41:08,383
And so what that allows
us to do is parse in

6359
04:41:08,383 --> 04:41:09,216
a lambda expression,

6360
04:41:09,216 --> 04:41:11,816
and we can actually just
do a print line with value.

6361
04:41:12,814 --> 04:41:15,080
So we can say for each and
print line will then provide

6362
04:41:15,080 --> 04:41:17,940
the, take a value and
print it to the screen.

6363
04:41:17,940 --> 04:41:20,800
IT is the default name of the item

6364
04:41:20,800 --> 04:41:21,800
inside of the lambda expression.

6365
04:41:21,800 --> 04:41:23,420
If we want to change it
to something different,

6366
04:41:23,420 --> 04:41:26,870
we could change it to maybe the word value

6367
04:41:26,870 --> 04:41:29,270
and we would do so like this.

6368
04:41:29,270 --> 04:41:31,720
And then at this point,
we could say value.

6369
04:41:31,720 --> 04:41:33,700
Now that doesn't really provide us

6370
04:41:33,700 --> 04:41:35,350
any additional benefit here.

6371
04:41:36,230 --> 04:41:37,810
If I hit alt enter, we can
see that we can replace

6372
04:41:37,810 --> 04:41:40,710
the explicit parameter
value with the name it,

6373
04:41:40,710 --> 04:41:43,240
and this just kind of cleans
up the code a little bit.

6374
04:41:43,240 --> 04:41:44,970
Now, once we run this, what we will see

6375
04:41:44,970 --> 04:41:47,310
inside of the output window
down here on the bottom

6376
04:41:47,310 --> 04:41:50,030
is all the integers have been printed out.

6377
04:41:50,030 --> 04:41:52,730
Now, an additional cool thing
with some of the built-in

6378
04:41:52,730 --> 04:41:56,470
array classes of Kotlin is we
can also have an int array.

6379
04:41:56,470 --> 04:41:59,190
So by default, we'll
specify how we would like

6380
04:41:59,190 --> 04:42:01,330
some integers, we can
also have a double array.

6381
04:42:01,330 --> 04:42:03,340
And notice this is going
to create a problem here

6382
04:42:03,340 --> 04:42:05,300
because these are not doubled.

6383
04:42:05,300 --> 04:42:08,030
But if we were to turn them into doubles

6384
04:42:08,030 --> 04:42:09,900
by providing a.zero.

6385
04:42:10,955 --> 04:42:12,230
So what is actually a valid double value,

6386
04:42:13,387 --> 04:42:16,680
we can then at that point,
start using the double array

6387
04:42:16,680 --> 04:42:18,160
of call.

6388
04:42:19,342 --> 04:42:20,370
There's multiple other
ones in here as well.

6389
04:42:20,370 --> 04:42:24,970
So we have the array of double
array of, float array of,

6390
04:42:24,970 --> 04:42:27,689
longer range of, of
course, the int array of,

6391
04:42:27,689 --> 04:42:30,150
char array of, shorter arrays, by arrays

6392
04:42:30,150 --> 04:42:32,000
and Boolean arrays.

6393
04:42:32,000 --> 04:42:34,880
Now you'll notice we don't
see a string array in here.

6394
04:42:34,880 --> 04:42:37,260
So what do we do there?

6395
04:42:37,260 --> 04:42:38,380
So that's actually pretty easy.

6396
04:42:38,380 --> 04:42:40,520
We can actually just do array of,

6397
04:42:41,790 --> 04:42:44,759
I know we have to provide
some values in here.

6398
04:42:44,759 --> 04:42:47,240
So Donn Felker via a
simple array of two items.

6399
04:42:47,240 --> 04:42:48,740
And if we were to run this
again, it would just say,

6400
04:42:48,740 --> 04:42:53,010
Donn Felker, one string on each line.

6401
04:42:53,010 --> 04:42:54,690
Now that's not all we can do

6402
04:42:54,690 --> 04:42:56,800
with some of the arrays as well.

6403
04:42:56,800 --> 04:43:01,800
We can also get the array of
objects, so we'd say array of,

6404
04:43:02,350 --> 04:43:04,710
and what I can do here is
since we have our user class,

6405
04:43:04,710 --> 04:43:07,180
which if we remember that
it just has a first name

6406
04:43:07,180 --> 04:43:08,013
and a last name.

6407
04:43:09,270 --> 04:43:11,120
What we'll do here is we'll have user

6408
04:43:12,148 --> 04:43:14,480
and with page, say Donn Felker.

6409
04:43:14,480 --> 04:43:17,890
And then we might have
another one called Jane Doe.

6410
04:43:19,610 --> 04:43:23,700
And now we have two users who
are part of the user array.

6411
04:43:23,700 --> 04:43:25,250
Let's actually call this users.

6412
04:43:26,449 --> 04:43:28,609
And then at that point, we
can actually do the same thing

6413
04:43:28,609 --> 04:43:29,442
that we saw before and then we can iterate

6414
04:43:29,442 --> 04:43:31,960
each over one of them
and we'll call print line

6415
04:43:33,007 --> 04:43:34,157
and we'll call this IT.

6416
04:43:35,229 --> 04:43:38,060
'Cause remember IT at this
point is just a user itself.

6417
04:43:38,060 --> 04:43:40,310
Up here it's going to be a string.

6418
04:43:40,310 --> 04:43:41,610
So the compiler is going to know that.

6419
04:43:41,610 --> 04:43:46,220
If we run this, now we're going
to see the two string value

6420
04:43:46,220 --> 04:43:47,600
of the user class.

6421
04:43:47,600 --> 04:43:50,609
So let's go take a look
at the user class again.

6422
04:43:50,609 --> 04:43:52,290
And the user class, I've
added a quick two string

6423
04:43:52,290 --> 04:43:54,900
implementation, I've
just created an override

6424
04:43:54,900 --> 04:43:58,330
so two string, and we can go
ahead and return something.

6425
04:43:58,330 --> 04:44:01,820
Now its full name and it just
returns this string up here.

6426
04:44:01,820 --> 04:44:05,860
And that's how we can work
with strings and primitives

6427
04:44:05,860 --> 04:44:08,990
and objects and easily
create a raise of them

6428
04:44:08,990 --> 04:44:10,720
and alter them and so forth.

6429
04:44:10,720 --> 04:44:12,760
Now let's assume that we, for some reason,

6430
04:44:12,760 --> 04:44:15,080
we needed to update
the users and we needed

6431
04:44:15,080 --> 04:44:16,738
to add one to it.

6432
04:44:16,738 --> 04:44:18,990
So what we could do is
to say val updated users,

6433
04:44:21,950 --> 04:44:23,980
and we could say users.plus,

6434
04:44:23,980 --> 04:44:25,830
and they're gonna add new user to it.

6435
04:44:27,171 --> 04:44:30,880
And we say, Jon Doe here,
and what this will do

6436
04:44:30,880 --> 04:44:32,880
is if we take a look at
the plus implementation,

6437
04:44:32,880 --> 04:44:35,260
what does it do behind,
underneath the hood.

6438
04:44:35,260 --> 04:44:38,860
It's just an extension
function that creates a copy

6439
04:44:38,860 --> 04:44:41,300
of the array with a one larger index,

6440
04:44:41,300 --> 04:44:44,700
adds the item at that given
index and then returns

6441
04:44:44,700 --> 04:44:46,160
that new array.

6442
04:44:46,160 --> 04:44:48,670
So we have to make sure
we're using that new array.

6443
04:44:48,670 --> 04:44:52,710
And so of course we could
do updated users.foreach

6444
04:44:52,710 --> 04:44:54,030
and it's a print line.

6445
04:44:55,459 --> 04:44:58,239
And then what we could do
inside of here is just say IT.

6446
04:44:58,239 --> 04:45:00,330
And now actually see if we run this again,

6447
04:45:00,330 --> 04:45:04,040
we'll see additional
person down here, Jon Doe

6448
04:45:04,040 --> 04:45:06,522
has now been added to the second array,

6449
04:45:06,522 --> 04:45:07,920
which is these three down at the bottom.

6450
04:45:07,920 --> 04:45:09,840
There's other things you can also do

6451
04:45:09,840 --> 04:45:11,370
with those user objects.

6452
04:45:11,370 --> 04:45:15,050
So you can actually say users
dot there's a little extension

6453
04:45:15,050 --> 04:45:16,479
function on here.

6454
04:45:16,479 --> 04:45:19,540
So you say reverse, this will
give you the reverse array.

6455
04:45:19,540 --> 04:45:23,325
There's a whole bunch of other
collection classes you can do

6456
04:45:23,325 --> 04:45:26,610
and which we'll talk about in
the future here and so forth,

6457
04:45:26,610 --> 04:45:28,150
but you can also get the size.

6458
04:45:28,150 --> 04:45:29,850
You can get a particular value added.

6459
04:45:29,850 --> 04:45:34,850
So if I wanna get the
value at item number zero,

6460
04:45:35,380 --> 04:45:40,250
the location, and I can say
print ln and I can say item,

6461
04:45:40,250 --> 04:45:42,810
that's going to be at that point item zero

6462
04:45:42,810 --> 04:45:44,850
is going to be Donn Felker.

6463
04:45:44,850 --> 04:45:46,500
And then if we run it, you'll see

6464
04:45:46,500 --> 04:45:47,990
that it's just Donn Felker's printed down

6465
04:45:47,990 --> 04:45:49,260
here at the bottom.

6466
04:45:49,260 --> 04:45:50,810
Now you'll see that we
have a squiggly here

6467
04:45:50,810 --> 04:45:53,280
because we can actually
use the indexing operator.

6468
04:45:53,280 --> 04:45:54,820
So we'll place that and
then we can actually do

6469
04:45:54,820 --> 04:45:57,960
the same thing here that
does the same exact method.

6470
04:45:57,960 --> 04:45:59,110
We can set a value.

6471
04:45:59,110 --> 04:46:02,269
So if I wanna set the index of zero

6472
04:46:02,269 --> 04:46:05,480
to be a different user,
so I guess a foo bar.

6473
04:46:06,770 --> 04:46:10,330
And then if I were to
go ahead and get that,

6474
04:46:10,330 --> 04:46:12,530
and if we look at the
implementation of set,

6475
04:46:13,610 --> 04:46:15,070
you'll see it's just gonna return a unit.

6476
04:46:15,070 --> 04:46:16,890
So we don't wanna do
anything with this anymore.

6477
04:46:16,890 --> 04:46:18,990
So now at this point,
we'd want to actually

6478
04:46:18,990 --> 04:46:20,100
get the value again.

6479
04:46:20,100 --> 04:46:25,100
So we'd say val item equals
users dot and we'll just use

6480
04:46:25,100 --> 04:46:27,150
the indexing operator instead of the get.

6481
04:46:28,399 --> 04:46:30,950
If we were to run this,
we'll see here that the item

6482
04:46:30,950 --> 04:46:33,620
that's printed on the bottom is foo bar

6483
04:46:33,620 --> 04:46:35,940
because the first item
in the array was updated.

6484
04:46:35,940 --> 04:46:37,350
Now, again, we see a squiggly here.

6485
04:46:37,350 --> 04:46:40,300
We can update this with an
indexing operator again.

6486
04:46:40,300 --> 04:46:41,450
So we're gonna say, hey the first user

6487
04:46:41,450 --> 04:46:44,680
is actually gonna be equal to
this, go get that first user

6488
04:46:44,680 --> 04:46:46,350
and print it at that point in time.

6489
04:46:46,350 --> 04:46:48,890
So there's all different
kinds of stuff that you can do

6490
04:46:48,890 --> 04:46:50,630
with arrays.

6491
04:46:50,630 --> 04:46:53,240
You can add things, you can
copies, you can reverse them,

6492
04:46:53,240 --> 04:46:55,100
reverse them, slice them.

6493
04:46:55,100 --> 04:46:57,420
There's a tremendous amount of
things you can do with this,

6494
04:46:57,420 --> 04:47:00,410
these collections, such as the
other collections in Kotlin,

6495
04:47:00,410 --> 04:47:01,880
which we will cover.

6496
04:47:01,880 --> 04:47:03,570
And that's how you can work with arrays

6497
04:47:03,570 --> 04:47:05,360
and build them quickly in Kotlin.

6498
04:47:07,270 --> 04:47:10,800
To create a list inside
of Kotlin is pretty easy.

6499
04:47:10,800 --> 04:47:13,520
You can just say let's
create a variable here

6500
04:47:13,520 --> 04:47:16,863
and we can say val item equals list of,

6501
04:47:16,863 --> 04:47:18,980
and then you can provide a list of,

6502
04:47:18,980 --> 04:47:21,202
perhaps a list of primitives
like we have here.

6503
04:47:21,202 --> 04:47:22,120
So we have a list of integers.

6504
04:47:22,120 --> 04:47:24,850
This is very similar to how it's done

6505
04:47:24,850 --> 04:47:28,750
with the array of operator for arrays.

6506
04:47:28,750 --> 04:47:31,620
So if we want to loop
over each one of these

6507
04:47:31,620 --> 04:47:33,830
and print them out to the screen,

6508
04:47:33,830 --> 04:47:38,400
we could say something like
this, say items foreach.

6509
04:47:38,400 --> 04:47:42,420
And then once we compile
this and print it and run it,

6510
04:47:42,420 --> 04:47:44,849
it will then print to the screen

6511
04:47:44,849 --> 04:47:46,350
as we see in the output down here,

6512
04:47:46,350 --> 04:47:48,550
one, two, three, four, and five.

6513
04:47:48,550 --> 04:47:50,480
So we have a list here.

6514
04:47:50,480 --> 04:47:52,450
Now, this is important to note here

6515
04:47:52,450 --> 04:47:56,320
that this is actually an immutable list.

6516
04:47:56,320 --> 04:47:59,930
So if you notice here, I don't
have the add method here.

6517
04:47:59,930 --> 04:48:02,980
I can't add an item to the list at all.

6518
04:48:02,980 --> 04:48:07,370
So if we look at the
implementation of list of,

6519
04:48:07,370 --> 04:48:08,760
we'll see the here, this is gonna return

6520
04:48:08,760 --> 04:48:10,440
a new read only list.

6521
04:48:11,771 --> 04:48:14,180
So that means that we
can not add items to it.

6522
04:48:14,180 --> 04:48:16,860
The same thing goes for, if
you were to create a list

6523
04:48:16,860 --> 04:48:19,110
of perhaps a list of users.

6524
04:48:19,110 --> 04:48:21,781
Let's say list of, and
then we can actually create

6525
04:48:21,781 --> 04:48:22,614
a list of users.

6526
04:48:22,614 --> 04:48:25,880
So I'm just gonna do a new
line here, say Donn Felker,

6527
04:48:27,440 --> 04:48:29,140
and then we can have
another one would say,

6528
04:48:29,140 --> 04:48:33,130
user would be perhaps Jane
Doe and then so forth.

6529
04:48:33,130 --> 04:48:34,930
We could have a number
of them and so forth.

6530
04:48:35,821 --> 04:48:39,290
And of course we could also
iterate over these as well,

6531
04:48:39,290 --> 04:48:40,123
pretty easily.

6532
04:48:40,123 --> 04:48:43,730
So it would say users dot
foreach and inside of this,

6533
04:48:43,730 --> 04:48:45,810
we'd say print line and
inside the print line,

6534
04:48:45,810 --> 04:48:48,070
we could just say, if
we could print the user.

6535
04:48:48,070 --> 04:48:50,100
And that's gonna call the two
string method on the user,

6536
04:48:50,100 --> 04:48:52,670
just like it did when we
did the array version.

6537
04:48:52,670 --> 04:48:55,560
So we'd see a Jane Doe and Jon Doe,

6538
04:48:55,560 --> 04:48:57,810
and actually did print
here and do print line

6539
04:48:58,953 --> 04:48:59,786
to it all put it on the same line.

6540
04:48:59,786 --> 04:49:02,270
Print line will add each
item onto a new line

6541
04:49:02,270 --> 04:49:03,350
as we see here.

6542
04:49:04,983 --> 04:49:06,630
So again, these are immutable lists.

6543
04:49:06,630 --> 04:49:09,040
If we want to add an item to a list,

6544
04:49:09,040 --> 04:49:10,510
we're not gonna be able to do that.

6545
04:49:10,510 --> 04:49:12,690
So we're have to create a mutable list,

6546
04:49:12,690 --> 04:49:14,800
which will be in the next lesson.

6547
04:49:14,800 --> 04:49:18,590
So here we can also get access to items.

6548
04:49:18,590 --> 04:49:20,390
So maybe we wanna do the first item.

6549
04:49:21,532 --> 04:49:25,120
We could say users dot
first, and it's gonna give us

6550
04:49:25,120 --> 04:49:25,953
the first item.

6551
04:49:25,953 --> 04:49:27,030
And notice the first method.

6552
04:49:27,030 --> 04:49:31,500
This is an extension method
on top of a generic list.

6553
04:49:31,500 --> 04:49:34,140
So we have a first item.

6554
04:49:34,140 --> 04:49:38,060
So if for some reason there was a default,

6555
04:49:38,060 --> 04:49:41,120
if we were to print this here,
let's actually do print line,

6556
04:49:41,120 --> 04:49:43,250
just to show you what this looks like.

6557
04:49:43,250 --> 04:49:46,300
We should see Donn Felker again, printed,

6558
04:49:46,300 --> 04:49:47,630
and they're ready to go.

6559
04:49:47,630 --> 04:49:51,840
Now there's also the opportunity
here for us to perhaps

6560
04:49:51,840 --> 04:49:54,490
we need to create a empty
list for whatever reason,

6561
04:49:54,490 --> 04:49:56,870
maybe we have a null value
or something like that.

6562
04:49:56,870 --> 04:49:59,690
So let's say that we have a name.

6563
04:49:59,690 --> 04:50:03,940
So let's say val name
could be a nullable string

6564
04:50:03,940 --> 04:50:05,610
equals whatever.

6565
04:50:05,610 --> 04:50:08,180
And for whatever reason, the code is null.

6566
04:50:08,180 --> 04:50:11,790
And then we wanna create a
new list and we can say stuff.

6567
04:50:11,790 --> 04:50:13,390
We could say, it's going to be.

6568
04:50:18,217 --> 04:50:19,120
If the name is a null.

6569
04:50:22,360 --> 04:50:24,260
So if we wanna do something like this,

6570
04:50:25,370 --> 04:50:27,440
we put it around the if statement.

6571
04:50:27,440 --> 04:50:31,770
if the name is null, then
we could return empty list.

6572
04:50:31,770 --> 04:50:34,650
And that would just
return us an empty list.

6573
04:50:34,650 --> 04:50:39,620
Otherwise we can then
return a list of name.

6574
04:50:41,384 --> 04:50:43,479
And what that's gonna do is
automatically the compiler

6575
04:50:43,479 --> 04:50:46,450
is going to infer, Oh, since
Donn is doing a list of names,

6576
04:50:46,450 --> 04:50:48,050
it's gonna be a list of strings,

6577
04:50:49,860 --> 04:50:50,693
otherwise this is gonna be
an empty list of strings.

6578
04:50:50,693 --> 04:50:53,220
Now notice here, I was
getting a compiler error

6579
04:50:53,220 --> 04:50:56,060
'cause it doesn't know
enough about the type here.

6580
04:50:56,060 --> 04:50:59,550
So if I wanted to specify
the type for empty list,

6581
04:50:59,550 --> 04:51:01,530
I should say string their work.

6582
04:51:02,460 --> 04:51:04,520
And we could say list of name.

6583
04:51:05,510 --> 04:51:07,220
Now, at this point in time, you can see

6584
04:51:07,220 --> 04:51:08,760
that this is grayed out
because the compiler

6585
04:51:08,760 --> 04:51:10,090
can infer the type.

6586
04:51:10,090 --> 04:51:13,470
So I can go ahead and remove
that explicit type argument.

6587
04:51:13,470 --> 04:51:15,670
Now empty list, all it
is again is just some,

6588
04:51:15,670 --> 04:51:18,590
it's just a function just
gives us an implementation

6589
04:51:18,590 --> 04:51:20,240
of what's known as an empty list.

6590
04:51:21,204 --> 04:51:22,150
It doesn't have anything in it.

6591
04:51:22,150 --> 04:51:23,520
There's basically the size.

6592
04:51:23,520 --> 04:51:25,810
If you look at it, the size is zero.

6593
04:51:25,810 --> 04:51:28,560
It is empty, is hard-coded to true.

6594
04:51:28,560 --> 04:51:31,200
So this is just kind of
a general helper method

6595
04:51:31,200 --> 04:51:33,480
inside of our application.

6596
04:51:33,480 --> 04:51:36,960
So if we were to see if this was empty,

6597
04:51:36,960 --> 04:51:39,930
we could actually say stuff.is empty,

6598
04:51:39,930 --> 04:51:40,763
that would return true.

6599
04:51:40,763 --> 04:51:44,040
We'll see a bunch of different
other methods on here as well

6600
04:51:44,040 --> 04:51:45,900
we can see for lifts is empty.

6601
04:51:45,900 --> 04:51:47,510
Again, we can't add anything to it

6602
04:51:47,510 --> 04:51:49,926
because it's an immutable list.

6603
04:51:49,926 --> 04:51:52,590
So that's one way we can
work with an empty list.

6604
04:51:52,590 --> 04:51:55,520
Now we can also grab
the last item of a list.

6605
04:51:56,473 --> 04:51:57,380
So we could say users.last,

6606
04:51:58,868 --> 04:52:01,600
and that will give us the
last item of the list.

6607
04:52:01,600 --> 04:52:04,140
At that point in time, we can
also print that to the screen,

6608
04:52:04,140 --> 04:52:06,810
which is gonna go ahead and show Jane Doe

6609
04:52:06,810 --> 04:52:07,910
at that point in time.

6610
04:52:09,530 --> 04:52:10,840
And then we've got Jane Doe.

6611
04:52:10,840 --> 04:52:14,530
So there's a bunch of
different operators on the list

6612
04:52:14,530 --> 04:52:15,932
you can look at it.

6613
04:52:15,932 --> 04:52:18,480
So you can just say users
and you can use IntelliSense

6614
04:52:18,480 --> 04:52:21,280
to in code completion to check it out.

6615
04:52:21,280 --> 04:52:23,780
You can do last, you can
do last of the prodicate,

6616
04:52:23,780 --> 04:52:24,860
all different types of stuff,

6617
04:52:24,860 --> 04:52:27,390
which we will cover in the future.

6618
04:52:27,390 --> 04:52:29,810
And you can also get the
first value or of null

6619
04:52:29,810 --> 04:52:32,200
if it's nothing's there,
so we'll see here,

6620
04:52:32,200 --> 04:52:35,580
returns the first element or
null if the list is empty.

6621
04:52:35,580 --> 04:52:38,230
So there's a bunch of different things

6622
04:52:38,230 --> 04:52:39,290
that you can check for there as well.

6623
04:52:40,426 --> 04:52:42,220
And that's how you easily can
create a list inside of Kotlin

6624
04:52:42,220 --> 04:52:45,350
with either primitives or you
can create it with objects.

6625
04:52:46,790 --> 04:52:49,220
In another lesson I
showed you how to create

6626
04:52:49,220 --> 04:52:53,650
a immutable list using the list of method.

6627
04:52:53,650 --> 04:52:56,620
The list of method allows
you to create a list

6628
04:52:56,620 --> 04:53:00,700
of some primitives or objects or anything

6629
04:53:00,700 --> 04:53:03,690
of that you desire.

6630
04:53:06,140 --> 04:53:07,940
If you'd like to create a
list in which you can change,

6631
04:53:07,940 --> 04:53:10,090
because let's take a look at this items,

6632
04:53:10,090 --> 04:53:11,320
does not have an add must.

6633
04:53:11,320 --> 04:53:14,900
We can't add or change
or remove or do anything

6634
04:53:14,900 --> 04:53:16,610
of that nature with an immutable list.

6635
04:53:16,610 --> 04:53:19,910
It's just there, it can't be changed.

6636
04:53:19,910 --> 04:53:24,110
If we need to create a
mutable list we can do so

6637
04:53:24,110 --> 04:53:27,120
with the mutable list of,

6638
04:53:29,190 --> 04:53:32,040
and we use mutable list
of, we can provide a type

6639
04:53:32,040 --> 04:53:33,860
if we'd like to such as we can do

6640
04:53:33,860 --> 04:53:36,840
with the list of operators. So
if I know it's gonna be int,

6641
04:53:36,840 --> 04:53:40,070
that I can do that,
and I can say one, two,

6642
04:53:40,070 --> 04:53:41,200
three, four, five.

6643
04:53:43,257 --> 04:53:44,980
But then what will happen is
type inference will kick in

6644
04:53:44,980 --> 04:53:47,980
and the IntelliJ IDE
would let us know saying,

6645
04:53:47,980 --> 04:53:50,620
hey, we don't really need
that explicit type argument,

6646
04:53:50,620 --> 04:53:51,650
so let's go ahead and remove it.

6647
04:53:51,650 --> 04:53:54,700
So at this point in time,
based upon the parameters

6648
04:53:54,700 --> 04:53:59,280
of the mutable list
method, Kotlin can infer

6649
04:53:59,280 --> 04:54:01,100
the types for this list.

6650
04:54:02,067 --> 04:54:03,160
So now I have a mutable list of items.

6651
04:54:03,160 --> 04:54:05,890
Now this work the same
way if I have a list here.

6652
04:54:05,890 --> 04:54:09,210
So if we just do list and we leave that,

6653
04:54:09,210 --> 04:54:10,740
we'll notice that both of these things

6654
04:54:10,740 --> 04:54:13,350
are going to compile just
fine and do the same thing.

6655
04:54:13,350 --> 04:54:16,060
We have the same method for
each, we can print those.

6656
04:54:16,060 --> 04:54:19,160
The differences here though is
that we can add an item here,

6657
04:54:19,160 --> 04:54:21,250
so I can add the number six now.

6658
04:54:21,250 --> 04:54:24,030
And then if I copy this
and I kind of reiterate

6659
04:54:24,030 --> 04:54:27,140
over this again, we'll see
that I have six in here.

6660
04:54:27,140 --> 04:54:30,080
So let's go ahead and print
a line here so we can see

6661
04:54:30,080 --> 04:54:33,890
that there's something
different and let's run this.

6662
04:54:33,890 --> 04:54:36,260
And what we'll see
here, we print one, two,

6663
04:54:36,260 --> 04:54:39,800
three, four, five, and then
we're gonna add an item here

6664
04:54:39,800 --> 04:54:42,485
on number six, and then
I'm gonna run it again

6665
04:54:42,485 --> 04:54:44,260
and say one, two, three, four, five, six.

6666
04:54:44,260 --> 04:54:45,730
So we can also do something else

6667
04:54:45,730 --> 04:54:48,050
and say, we can say items.remove,

6668
04:54:49,040 --> 04:54:50,870
and we could say a whole
bunch of things here.

6669
04:54:50,870 --> 04:54:53,340
We can remove if we meet
a particular condition,

6670
04:54:53,340 --> 04:54:54,830
we could remove all the items.

6671
04:54:54,830 --> 04:54:56,820
We could remove a particular item.

6672
04:54:56,820 --> 04:54:59,810
So I could remove element number zero,

6673
04:54:59,810 --> 04:55:01,900
and we can print this off again.

6674
04:55:01,900 --> 04:55:04,260
So what would happen here
if we were to run this.

6675
04:55:04,260 --> 04:55:08,320
So now we have a list
where we have to make this

6676
04:55:08,320 --> 04:55:10,920
a little more clear, let's
add this in here as well,

6677
04:55:11,870 --> 04:55:13,020
and we'll run it again.

6678
04:55:14,207 --> 04:55:16,550
And we'll see here that we
have now one, two, three,

6679
04:55:16,550 --> 04:55:19,090
four, five, one, two,
three, four, five, six,

6680
04:55:19,090 --> 04:55:20,290
one, two, three, four, five, six.

6681
04:55:20,290 --> 04:55:23,110
So, why didn't we get
anything out of here,

6682
04:55:23,110 --> 04:55:27,140
because we're asking it to
remove a particular item.

6683
04:55:27,140 --> 04:55:30,610
Now it's not finding
the item zero in there,

6684
04:55:30,610 --> 04:55:33,750
so let's tell it to remove number three.

6685
04:55:33,750 --> 04:55:35,160
So let's run that again.

6686
04:55:35,160 --> 04:55:37,330
And then what we will see
down here in the bottom window

6687
04:55:37,330 --> 04:55:40,570
is it was actually
found item number three.

6688
04:55:40,570 --> 04:55:43,492
So it didn't find one, two or three.

6689
04:55:43,492 --> 04:55:45,060
It wasn't the index base,
it was actually the item

6690
04:55:45,060 --> 04:55:46,660
in the list that it was removed.

6691
04:55:47,938 --> 04:55:50,690
So that was able to be
removed out of there.

6692
04:55:50,690 --> 04:55:53,399
Now there's a whole
bunch of other things now

6693
04:55:53,399 --> 04:55:55,360
we can replace items inside of here.

6694
04:55:55,360 --> 04:55:58,110
We're gonna replace all, we
can add a whole bunch of them.

6695
04:55:58,110 --> 04:56:00,799
So if we take a look at the
implementation of add all,

6696
04:56:00,799 --> 04:56:04,190
we can take in our collection
and add another one

6697
04:56:04,190 --> 04:56:06,790
inside of here so we can
add a whole bunch of them.

6698
04:56:06,790 --> 04:56:08,930
So if I had another list,
we can add that list to it.

6699
04:56:08,930 --> 04:56:11,742
We can remove something out of position.

6700
04:56:11,742 --> 04:56:14,040
So let's say we wanna remove
this add position zero,

6701
04:56:14,040 --> 04:56:16,140
let's run this and see what happens.

6702
04:56:16,140 --> 04:56:17,810
Now, notice how this has index.

6703
04:56:18,700 --> 04:56:20,900
So now we have two,
three, four, five, six.

6704
04:56:22,208 --> 04:56:24,060
I'm just gonna delete this
stuff here, just for brevity.

6705
04:56:26,344 --> 04:56:28,475
And we'll run this
again, and we'll see that

6706
04:56:28,475 --> 04:56:30,930
we have two, three, four, five is printed.

6707
04:56:30,930 --> 04:56:33,320
Now, if I were to change
changes to remove,

6708
04:56:33,320 --> 04:56:35,140
just to reiterate here, and we could say,

6709
04:56:35,140 --> 04:56:36,860
I wanna remove a particular element.

6710
04:56:36,860 --> 04:56:39,980
I wanna remove element,
that is the value of three.

6711
04:56:39,980 --> 04:56:43,390
Now we're gonna see one,
four, five is the output

6712
04:56:43,390 --> 04:56:44,223
down here in the bottom.

6713
04:56:44,223 --> 04:56:46,220
So remove at removes it with an index.

6714
04:56:46,220 --> 04:56:48,870
So instead of the index of the list,

6715
04:56:48,870 --> 04:56:50,890
we can find something to remove.

6716
04:56:50,890 --> 04:56:55,424
However, if we wanna move an
actual item given its value,

6717
04:56:55,424 --> 04:56:56,257
we would say remove element.

6718
04:56:56,257 --> 04:57:00,700
Now we can also say we can do
something with a mutable list

6719
04:57:00,700 --> 04:57:01,700
of objects as well.

6720
04:57:01,700 --> 04:57:04,150
So we're gonna say user Donn Felker,

6721
04:57:04,150 --> 04:57:05,890
which is something we have done before

6722
04:57:05,890 --> 04:57:07,340
with the other types of lists

6723
04:57:08,593 --> 04:57:11,000
and we always have a user called Jane Doe.

6724
04:57:11,000 --> 04:57:12,370
So now we have two things in here.

6725
04:57:12,370 --> 04:57:15,720
And if we try to remove
here and we use the,

6726
04:57:15,720 --> 04:57:19,700
I'm using an index here,
because it's the number three,

6727
04:57:19,700 --> 04:57:23,260
even though it's saying,
hey, you're wanting to remove

6728
04:57:23,260 --> 04:57:26,620
something here, removing int is narrow.

6729
04:57:26,620 --> 04:57:29,400
You remove at index
instead because it realizes

6730
04:57:29,400 --> 04:57:31,800
the compiler that I'm
trying to use a number here.

6731
04:57:31,800 --> 04:57:33,160
So it's trying to help me out saying,

6732
04:57:33,160 --> 04:57:36,940
hey, you sure you don't want
to remove a particular index.

6733
04:57:36,940 --> 04:57:39,160
Now what I could do, let me just go ahead

6734
04:57:40,069 --> 04:57:41,720
and comment this out for a second.

6735
04:57:41,720 --> 04:57:44,130
Inside of here is once we let me run this,

6736
04:57:44,130 --> 04:57:45,210
so I'll show you what this looks like.

6737
04:57:45,210 --> 04:57:48,860
We're gonna get basically
two users printed.

6738
04:57:49,740 --> 04:57:52,420
If I wanted to pull this
out into its own variable,

6739
04:57:54,096 --> 04:57:56,217
I could do that and say,
pull it into a variable.

6740
04:57:56,217 --> 04:57:57,230
And I could say, Don.

6741
04:57:57,230 --> 04:57:59,910
Now what I could do inside
of here is I could say,

6742
04:57:59,910 --> 04:58:02,520
remove Donn from the list.

6743
04:58:02,520 --> 04:58:04,670
Now let's print this list
and see what happens.

6744
04:58:04,670 --> 04:58:06,660
What do you think was
gonna see here where see,

6745
04:58:06,660 --> 04:58:08,860
we just have one item in the
list because what happens

6746
04:58:08,860 --> 04:58:10,800
is we have these items.

6747
04:58:10,800 --> 04:58:13,590
So let's actually do two things here.

6748
04:58:13,590 --> 04:58:16,310
Let's do this or print each one of there.

6749
04:58:16,310 --> 04:58:20,160
And then inside of here,
I'm gonna do a print line

6750
04:58:20,160 --> 04:58:22,970
and we'll just print out
a little break there.

6751
04:58:22,970 --> 04:58:26,200
And we're gonna see as both
items are printed first,

6752
04:58:26,200 --> 04:58:27,100
which we see here.

6753
04:58:28,079 --> 04:58:30,654
And then we print this
nice little line break.

6754
04:58:30,654 --> 04:58:32,240
And then we say, hey, I want
to remove Donn from the list.

6755
04:58:32,240 --> 04:58:34,550
Now, remember remove, remove the element,

6756
04:58:34,550 --> 04:58:37,210
it's gonna tell the element
that we'd like to remove.

6757
04:58:37,210 --> 04:58:40,070
Remove at is gonna tell us
we want to remove an index.

6758
04:58:40,070 --> 04:58:42,020
So I can say, hey, if I move index one,

6759
04:58:43,655 --> 04:58:44,488
it's gonna remove Jane Doe.

6760
04:58:44,488 --> 04:58:46,870
Now, if I run this here,
we're gonna see Donn Felker

6761
04:58:46,870 --> 04:58:48,780
and Jane Doe and then we're
going to remove Jane Doe

6762
04:58:48,780 --> 04:58:50,580
and it's just gonna say Donn Felker.

6763
04:58:51,572 --> 04:58:53,210
Now there's a whole bunch
again, this is a mutable list,

6764
04:58:53,210 --> 04:58:56,740
so I can continue to add and
remove items accordingly.

6765
04:58:56,740 --> 04:58:59,010
And the differences it's
beautiful exchanging

6766
04:58:59,010 --> 04:59:00,640
the other one is immutable.

6767
04:59:00,640 --> 04:59:02,660
So if we want to do different
types of things with it,

6768
04:59:02,660 --> 04:59:05,246
you can inspect the various
different operations

6769
04:59:05,246 --> 04:59:07,650
using the code completion here.

6770
04:59:07,650 --> 04:59:10,530
We can remove it out, we
replaced things we can set

6771
04:59:10,530 --> 04:59:13,720
certain values of I would
like to set the first value

6772
04:59:13,720 --> 04:59:14,950
to equal a different user.

6773
04:59:14,950 --> 04:59:19,110
I could say different user
is now going to be Jon Doe

6774
04:59:19,110 --> 04:59:20,820
for whatever reason.

6775
04:59:20,820 --> 04:59:25,820
So let's go ahead and change
that and get this down here.

6776
04:59:26,760 --> 04:59:28,570
Now, what we're gonna
see at this point in time

6777
04:59:28,570 --> 04:59:30,950
is I want to set item one to Jon Doe.

6778
04:59:30,950 --> 04:59:33,468
So the first time through,

6779
04:59:33,468 --> 04:59:34,520
we're gonna see Donn Felker printed,

6780
04:59:34,520 --> 04:59:36,690
and then the next time
through, we're gonna change

6781
04:59:36,690 --> 04:59:40,800
the first, the item index one to Jon Doe.

6782
04:59:40,800 --> 04:59:43,260
So we'll see Donn Felker, Jane Doe.

6783
04:59:43,260 --> 04:59:46,290
We change it and it's
Donn Felker, Jon Doe.

6784
04:59:46,290 --> 04:59:48,640
Now knows we have a little
bit of squiggly here,

6785
04:59:48,640 --> 04:59:49,473
alt enter.

6786
04:59:49,473 --> 04:59:51,150
We'll say we can replace the set call

6787
04:59:51,150 --> 04:59:52,805
with an indexing operator.

6788
04:59:52,805 --> 04:59:55,470
So using the indexing
operator, we can say,

6789
04:59:55,470 --> 04:59:57,360
actually take the first item in the index

6790
04:59:57,360 --> 04:59:58,820
and replace it with this one.

6791
04:59:58,820 --> 05:00:02,190
So it's the same exact code
this does the exact same thing

6792
05:00:02,190 --> 05:00:03,060
as this.

6793
05:00:04,832 --> 05:00:08,060
Now we can also access these
items via the index as well.

6794
05:00:08,060 --> 05:00:12,050
So I might say print, say print line,

6795
05:00:12,050 --> 05:00:14,610
and I wanna do items zero.

6796
05:00:15,634 --> 05:00:16,467
And that's gonna print the first time.

6797
05:00:16,467 --> 05:00:20,380
Now it's gonna be the same
exact thing as if I were to do

6798
05:00:20,380 --> 05:00:25,050
a items.get, and I
could provide the index.

6799
05:00:25,050 --> 05:00:27,070
Now notice again, we're
gonna get the squiggly

6800
05:00:28,152 --> 05:00:30,330
and what IntelliJ is telling us here is,

6801
05:00:30,330 --> 05:00:33,740
hey, we can actually use
the indexing operator.

6802
05:00:33,740 --> 05:00:35,110
So go ahead and do that.

6803
05:00:35,110 --> 05:00:38,020
Now, that's how you create
a very simple mutable list

6804
05:00:38,020 --> 05:00:38,853
inside of Kotlin.

6805
05:00:38,853 --> 05:00:40,950
You can create a mutable
list of primitives,

6806
05:00:40,950 --> 05:00:42,760
could be strings or intergers,

6807
05:00:43,700 --> 05:00:45,900
or could even be something
like an object itself.

6808
05:00:47,070 --> 05:00:49,360
All right, I'm gonna
show you how to filter

6809
05:00:49,360 --> 05:00:51,990
a list of primitive values here.

6810
05:00:51,990 --> 05:00:54,110
I am filtering a list of strings.

6811
05:00:54,110 --> 05:00:57,540
This could be integers
doubles, longs, Boolean values,

6812
05:00:57,540 --> 05:00:58,790
anything of that nature,

6813
05:00:58,790 --> 05:01:01,110
but I've created a list using the list of,

6814
05:01:01,110 --> 05:01:04,210
so this is an immutable
list, a list of names.

6815
05:01:04,210 --> 05:01:07,011
That's why we have Don, Bob, Jane, Jenny,

6816
05:01:07,011 --> 05:01:07,900
Tushar, and Cavita,

6817
05:01:07,900 --> 05:01:10,340
let's assume that we
wanted to filter this list.

6818
05:01:10,340 --> 05:01:13,570
And we only wanted to include,
we wanna include everybody

6819
05:01:13,570 --> 05:01:14,700
but Donn this time.

6820
05:01:14,700 --> 05:01:18,420
And so we would say name.filter,
and then we can parse in

6821
05:01:18,420 --> 05:01:19,600
basically a lambda expression.

6822
05:01:19,600 --> 05:01:20,840
So there's a couple of things we could do,

6823
05:01:20,840 --> 05:01:22,850
we could do open closed parentheses,

6824
05:01:22,850 --> 05:01:25,320
and we need some type of predicate.

6825
05:01:25,320 --> 05:01:27,050
If we look at the implementation of this

6826
05:01:27,050 --> 05:01:30,500
inside of the Kotlin
collection standard library,

6827
05:01:30,500 --> 05:01:33,160
we'll see that we had the filter method

6828
05:01:33,160 --> 05:01:34,510
and we needed a predicate.

6829
05:01:34,510 --> 05:01:37,900
And this predicate is
requiring a lambda expression.

6830
05:01:37,900 --> 05:01:39,890
That's going to return a Boolean value,

6831
05:01:39,890 --> 05:01:43,160
basically return the list
containing only the elements

6832
05:01:43,160 --> 05:01:44,240
matching the predicate.

6833
05:01:44,240 --> 05:01:47,960
So if it's true, it will
be included in the list.

6834
05:01:47,960 --> 05:01:49,120
If it's false, it will not.

6835
05:01:49,120 --> 05:01:50,320
So what does that mean?

6836
05:01:50,320 --> 05:01:52,030
Anything inside this filter we parse in

6837
05:01:52,030 --> 05:01:54,930
which I'm gonna use the
lambda expression version.

6838
05:01:54,930 --> 05:01:57,380
If this equates to true
what happens inside of here,

6839
05:01:57,380 --> 05:01:58,540
it will be included.

6840
05:01:58,540 --> 05:02:03,540
So it's pretty easy using the
default iterator value of it.

6841
05:02:04,000 --> 05:02:09,000
I say it does not equal
Donn it'll be included.

6842
05:02:09,240 --> 05:02:12,620
So what this means is I want
to look through all the names

6843
05:02:12,620 --> 05:02:14,890
and filter it and check to
see if it doesn't equal Don,

6844
05:02:14,890 --> 05:02:16,520
if it doesn't equal Donn then include it.

6845
05:02:16,520 --> 05:02:18,980
So how can we tell if that worked,

6846
05:02:18,980 --> 05:02:21,960
let's print this to the
screen and we'll say filtered,

6847
05:02:22,880 --> 05:02:25,780
and once we run it, you're
gonna see that down here

6848
05:02:25,780 --> 05:02:28,210
in the output window,
we'll see Bob Jane, Jenny

6849
05:02:28,210 --> 05:02:29,090
Tushar and Cavita.

6850
05:02:29,090 --> 05:02:30,540
So Donn was not included.

6851
05:02:32,173 --> 05:02:33,340
Now we could also flip
that around and say,

6852
05:02:33,340 --> 05:02:38,340
we also only want to include
the names if it includes Don.

6853
05:02:39,550 --> 05:02:40,520
So let's do that.

6854
05:02:40,520 --> 05:02:42,220
Say filtered it does equal Don.

6855
05:02:43,313 --> 05:02:44,910
So here we're gonna get
back in array with one value

6856
05:02:44,910 --> 05:02:48,673
in it which is gonna equal
Don, which makes sense.

6857
05:02:48,673 --> 05:02:49,750
Makes sense, it's good enough.

6858
05:02:49,750 --> 05:02:53,400
But sometimes, maybe
inside of your application,

6859
05:02:53,400 --> 05:02:55,300
again, this is a predicate,
a whole number of things

6860
05:02:55,300 --> 05:02:56,536
could happen.

6861
05:02:56,536 --> 05:02:58,580
This could be a bunch of
code that's doing something

6862
05:02:58,580 --> 05:02:59,413
inside of here.

6863
05:03:00,320 --> 05:03:02,740
But let's assume that you
wanna check to see if anyone

6864
05:03:02,740 --> 05:03:05,521
has a letter A and I
only wanna see if someone

6865
05:03:05,521 --> 05:03:06,354
has a letter A.

6866
05:03:06,354 --> 05:03:09,020
So what we might do is
say it.two lowercase

6867
05:03:09,020 --> 05:03:13,510
because I wanna check for
lower upper case.contains

6868
05:03:14,460 --> 05:03:17,500
a character and I wanna see
if it contains the letter A.

6869
05:03:17,500 --> 05:03:19,650
If it contains a letter
A, I want it to go ahead

6870
05:03:19,650 --> 05:03:22,320
and return it, so let's
see what happens here.

6871
05:03:22,320 --> 05:03:24,960
If we run this, we'll
see we get returned Jane,

6872
05:03:24,960 --> 05:03:26,010
Tushar and Kavita.

6873
05:03:26,010 --> 05:03:28,320
That's right, 'cause Don, Bob and Jenny

6874
05:03:29,189 --> 05:03:31,600
do not have the letter A inside of there.

6875
05:03:31,600 --> 05:03:33,600
So you can start filtering based upon

6876
05:03:33,600 --> 05:03:34,950
all different types of things.

6877
05:03:34,950 --> 05:03:39,730
And the same thing will work
if you had a list of ages

6878
05:03:39,730 --> 05:03:40,563
such as this.

6879
05:03:55,020 --> 05:03:56,390
And then you wanted to
actually filter them.

6880
05:03:56,390 --> 05:04:01,390
So you'd say val, over
18, or you say adults,

6881
05:04:01,940 --> 05:04:06,590
which can be over 18,
and you'd say ages.filter

6882
05:04:08,152 --> 05:04:10,430
it.greater than or equal to 18,

6883
05:04:12,560 --> 05:04:14,990
print line that, and we
could see the adults.

6884
05:04:16,270 --> 05:04:18,610
And if we run this, we'll see that we have

6885
05:04:19,620 --> 05:04:24,190
23, 33, 19 and 99, which is
true because if you're 12

6886
05:04:24,190 --> 05:04:26,920
or year nine or 17, you are not an adult.

6887
05:04:26,920 --> 05:04:28,590
One additional thing
you could do is actually

6888
05:04:28,590 --> 05:04:31,000
create a function called is adult.

6889
05:04:31,000 --> 05:04:33,480
And perhaps this function
has a whole bunch of things

6890
05:04:33,480 --> 05:04:34,830
inside of here.

6891
05:04:34,830 --> 05:04:37,770
So we wanna say age,
let's just call it value.

6892
05:04:37,770 --> 05:04:39,030
Let's be int.

6893
05:04:39,030 --> 05:04:41,950
And then inside of here, say if the value,

6894
05:04:42,990 --> 05:04:47,990
so we'll say return value
greater than or equal to 18.

6895
05:04:50,990 --> 05:04:52,750
Again, this is gonna be Boolean.

6896
05:04:53,643 --> 05:04:55,100
So we need to return a value.

6897
05:04:55,100 --> 05:04:57,290
So this function will return
if this person is an adult,

6898
05:04:57,290 --> 05:05:00,597
but now let's assume for whatever reason,

6899
05:05:00,597 --> 05:05:01,430
you have to put a bunch
of if statements in here.

6900
05:05:01,430 --> 05:05:03,380
Maybe in one country and adult is 14

6901
05:05:03,380 --> 05:05:06,920
and the next country it's 21
and the next country it's 18.

6902
05:05:06,920 --> 05:05:09,740
So you might need to
have many different lines

6903
05:05:09,740 --> 05:05:11,210
and logic inside of here,

6904
05:05:12,492 --> 05:05:14,636
but it's gonna return a Boolean value.

6905
05:05:14,636 --> 05:05:17,130
Doing that inside of this
filter is gonna get real messy.

6906
05:05:17,130 --> 05:05:19,100
And so what you can do
is that you actually pars

6907
05:05:19,100 --> 05:05:21,950
a function reference into the filter.

6908
05:05:23,093 --> 05:05:25,250
And you can do this with
a lot of the methods

6909
05:05:25,250 --> 05:05:26,872
inside of Kotlin.

6910
05:05:26,872 --> 05:05:28,394
So here's the age filtering tool,

6911
05:05:28,394 --> 05:05:29,650
it's like colon, colon is adult.

6912
05:05:29,650 --> 05:05:31,920
And what this will do is we'll take this

6913
05:05:32,764 --> 05:05:34,100
as a function reference
and say, as soon as I say,

6914
05:05:34,100 --> 05:05:37,510
age is.filter, it'll
basically parse in the values

6915
05:05:37,510 --> 05:05:40,060
one by one into the is adult function.

6916
05:05:41,008 --> 05:05:41,841
And then we'll run it through everything

6917
05:05:41,841 --> 05:05:43,010
that's inside of here.

6918
05:05:43,010 --> 05:05:46,027
And then whatever the
result is, if it's true,

6919
05:05:46,027 --> 05:05:46,860
it'll be included in the filter.

6920
05:05:46,860 --> 05:05:48,160
Otherwise it will be excluded.

6921
05:05:48,160 --> 05:05:49,990
So if we run this again, we
should get the same result

6922
05:05:49,990 --> 05:05:53,730
as before, so we see 23, 19, 99.

6923
05:05:53,730 --> 05:05:55,680
Now we could change this
and so we could change,

6924
05:05:55,680 --> 05:05:58,580
if we wanna say is adult, we say his child

6925
05:05:59,730 --> 05:06:02,180
and we probably need to
fix the spelling of that.

6926
05:06:06,380 --> 05:06:09,115
And then we can say less than or equal 18.

6927
05:06:09,115 --> 05:06:11,450
And if we rerun this again,
of course this variable name

6928
05:06:11,450 --> 05:06:13,670
is wrong, it's not adult,
that should be children.

6929
05:06:15,290 --> 05:06:16,140
And run it again.

6930
05:06:17,330 --> 05:06:21,730
Well now see 12, nine and 17
for the age of the filter.

6931
05:06:21,730 --> 05:06:26,010
So that's how you can easily
filter a list and array

6932
05:06:26,010 --> 05:06:27,170
and so forth in Kotlin.

6933
05:06:28,880 --> 05:06:30,620
Let's assume you have a list of data

6934
05:06:30,620 --> 05:06:32,720
and you wanna find something
in that list of data.

6935
05:06:32,720 --> 05:06:34,270
This could be primitive as we have here

6936
05:06:34,270 --> 05:06:37,600
such as a list of
strings, or you could have

6937
05:06:37,600 --> 05:06:39,580
a list of objects, anything of that nature

6938
05:06:39,580 --> 05:06:41,050
that you want to filter.

6939
05:06:41,050 --> 05:06:44,040
Not filter, but just find a
particular item in the list,

6940
05:06:44,040 --> 05:06:45,150
how can you go about doing that?

6941
05:06:45,150 --> 05:06:47,712
Well, of course you could use a for-loop.

6942
05:06:47,712 --> 05:06:49,843
However, there's also a built in utilities

6943
05:06:49,843 --> 05:06:50,810
in the Kotlin standard library.

6944
05:06:50,810 --> 05:06:53,700
So Lauren have is I'm gonna
create a result variable.

6945
05:06:53,700 --> 05:06:56,870
And then what I wanna do
is I wanna actually find

6946
05:06:56,870 --> 05:07:00,120
the first instance, excuse me, names.find,

6947
05:07:01,950 --> 05:07:04,110
I wanna find a first instance of Don.

6948
05:07:04,110 --> 05:07:08,490
So let's go ahead and
say it equals equals Don.

6949
05:07:08,490 --> 05:07:10,010
And then I wanna go ahead and print out

6950
05:07:10,010 --> 05:07:10,843
if I actually found it.

6951
05:07:10,843 --> 05:07:13,450
So print ln and a result.

6952
05:07:14,777 --> 05:07:15,700
I we'll go ahead and run that.

6953
05:07:15,700 --> 05:07:18,370
And then what we're gonna
see here is we have Don

6954
05:07:18,370 --> 05:07:19,782
that was returned.

6955
05:07:19,782 --> 05:07:20,910
And that's what we
expect Donn was in there.

6956
05:07:20,910 --> 05:07:23,160
Now however, there is a
kind of a gotcha here.

6957
05:07:23,160 --> 05:07:24,530
So let's just throw something in here

6958
05:07:24,530 --> 05:07:27,490
we know doesn't exist
and let's run it again.

6959
05:07:27,490 --> 05:07:28,370
So I'm gonna use the word foobar.

6960
05:07:28,370 --> 05:07:30,750
Now we have the word foobar,

6961
05:07:30,750 --> 05:07:32,160
of course we're gonna get back null.

6962
05:07:32,160 --> 05:07:36,380
Now we kind of had some help
from Kotlin to find this here.

6963
05:07:36,380 --> 05:07:38,810
So we had find it was
gonna find the first one.

6964
05:07:40,600 --> 05:07:41,470
And if actually look at
this, what it's gonna do

6965
05:07:41,470 --> 05:07:44,696
is it returns the first element
matching the given predicate

6966
05:07:44,696 --> 05:07:46,246
or null if no element is found.

6967
05:07:47,465 --> 05:07:49,310
So fine, kind of helps you,
but now you have to start

6968
05:07:49,310 --> 05:07:51,950
worrying about null values at all times.

6969
05:07:51,950 --> 05:07:54,480
So if you're gonna do
a null value, you say,

6970
05:07:54,480 --> 05:07:58,270
so if you wanna compare
something results equal equals.

6971
05:07:58,270 --> 05:08:01,000
When you say result dot length.

6972
05:08:01,000 --> 05:08:02,460
Well, now you're gonna get a problem here

6973
05:08:02,460 --> 05:08:05,710
because it's saying
this is a null variable.

6974
05:08:05,710 --> 05:08:08,419
So you need to check to
see if it's null first.

6975
05:08:08,419 --> 05:08:11,030
You may have heard too,
that Kotlin will protect you

6976
05:08:11,030 --> 05:08:13,400
from null pointer exceptions,
and doesn't allow you

6977
05:08:13,400 --> 05:08:14,280
to do nulls.

6978
05:08:14,280 --> 05:08:17,090
Well, that's false, as you can
see here, we can use a null.

6979
05:08:17,090 --> 05:08:20,490
However, I prefer to
use things like first.

6980
05:08:20,490 --> 05:08:23,722
Now first will actually
give me the actual value

6981
05:08:23,722 --> 05:08:24,555
first of Don.

6982
05:08:24,555 --> 05:08:28,220
And so if we run this here,
I'm always telling me like,

6983
05:08:28,220 --> 05:08:29,053
I'm always going to get a variable back.

6984
05:08:29,053 --> 05:08:32,318
Now, if I run this, I'll
say result dot length.

6985
05:08:32,318 --> 05:08:34,640
It'll be four 'cause Donn
has four characters in it.

6986
05:08:34,640 --> 05:08:37,210
Now the real interesting
part comes in here.

6987
05:08:38,430 --> 05:08:41,060
It equals equals foobar
which we know foobar

6988
05:08:41,060 --> 05:08:42,640
does not exist in this list.

6989
05:08:43,676 --> 05:08:44,509
But if we run it again,
what we're gonna see

6990
05:08:44,509 --> 05:08:46,240
is we're gonna get an
exception from Kotlin

6991
05:08:46,240 --> 05:08:48,430
and that's the no such element exception.

6992
05:08:49,411 --> 05:08:50,840
And if we look at the
implementation of first here,

6993
05:08:50,840 --> 05:08:52,800
it says it returns the
first element matching,

6994
05:08:52,800 --> 05:08:54,200
or it'll throw an exception.

6995
05:08:55,625 --> 05:08:57,100
So this is something
you need to be aware of.

6996
05:08:57,100 --> 05:09:01,040
And I prefer to use this method
because now I actually have

6997
05:09:01,040 --> 05:09:04,150
a string that's gonna be
returned if it's found.

6998
05:09:05,910 --> 05:09:09,180
Now, but what if I wanna find
the first or the no value?

6999
05:09:09,180 --> 05:09:10,990
I feel that's a decision I need to make

7000
05:09:10,990 --> 05:09:13,930
because I need to be able to
read the code and know that,

7001
05:09:13,930 --> 05:09:17,400
hey, I'm gonna get the
first one or null value

7002
05:09:17,400 --> 05:09:19,660
because it gives me
context into understanding

7003
05:09:19,660 --> 05:09:21,440
what's happening in my code.

7004
05:09:21,440 --> 05:09:24,260
As regards to find, it does make sense,

7005
05:09:24,260 --> 05:09:28,110
but it's not as obvious,
it's not in your face.

7006
05:09:28,110 --> 05:09:31,620
So first has also one
called first or null.

7007
05:09:31,620 --> 05:09:34,130
So I'm gonna take first or null.

7008
05:09:34,130 --> 05:09:36,340
And now again, we get back a string here

7009
05:09:36,340 --> 05:09:37,210
that's gonna be empty.

7010
05:09:37,210 --> 05:09:40,050
So I'm just gonna go ahead
and take that off there,

7011
05:09:40,050 --> 05:09:42,752
just 'cause it's not gonna
work and we'll print it

7012
05:09:42,752 --> 05:09:43,585
and we'll see it says null.

7013
05:09:43,585 --> 05:09:46,030
Now of course I could do
the null operator check.

7014
05:09:46,030 --> 05:09:48,130
Let's give me the null
safety check.length.

7015
05:09:50,580 --> 05:09:52,920
Otherwise I could just go
ahead and do something else,

7016
05:09:52,920 --> 05:09:55,890
do that or that should work.

7017
05:09:58,250 --> 05:10:00,177
I never going to get back null

7018
05:10:00,177 --> 05:10:01,460
because there's no values there.

7019
05:10:01,460 --> 05:10:04,290
So I can find the first instance.

7020
05:10:04,290 --> 05:10:07,380
So what this also means is
if I have another instance

7021
05:10:07,380 --> 05:10:11,080
of Donn in here, well actually
let me say this to say,

7022
05:10:13,110 --> 05:10:15,860
Donovan, let's see, we
have Donovan in here.

7023
05:10:15,860 --> 05:10:19,850
And I wanna see the first instance of,

7024
05:10:19,850 --> 05:10:23,810
watch the always say first.contains.

7025
05:10:23,810 --> 05:10:28,060
So we'll say dot two
lowercase.to contains Don.

7026
05:10:30,481 --> 05:10:31,390
So I just wanna find the
first one that it's gonna find

7027
05:10:31,390 --> 05:10:32,829
in that list.

7028
05:10:32,829 --> 05:10:34,028
So what is it gonna find?

7029
05:10:34,028 --> 05:10:35,250
Well, that's not gonna find anything.

7030
05:10:35,250 --> 05:10:37,786
So let's go back to the result here,

7031
05:10:37,786 --> 05:10:38,619
you didn't get rid of the length.

7032
05:10:40,126 --> 05:10:43,850
First it dot two lowercase contains Don

7033
05:10:43,850 --> 05:10:46,720
and that's not gonna work,
so the capital D there.

7034
05:10:46,720 --> 05:10:50,150
We'll run that and now we'll get back Don.

7035
05:10:51,332 --> 05:10:54,720
But we had we actually
have two instances in here.

7036
05:10:54,720 --> 05:10:59,300
So what if I wanted to
return the last instance,

7037
05:11:02,200 --> 05:11:03,770
we can do last.

7038
05:11:03,770 --> 05:11:06,340
So there's the last operator
we can find the last instance

7039
05:11:06,340 --> 05:11:08,500
of a list Donovan.

7040
05:11:09,510 --> 05:11:11,820
So there's many different
things we can do inside of here.

7041
05:11:11,820 --> 05:11:16,820
We can find names.index of
and what we're gonna see here,

7042
05:11:18,230 --> 05:11:19,990
index of first index of last.

7043
05:11:21,102 --> 05:11:22,110
So I could get the index of the first.

7044
05:11:23,484 --> 05:11:24,317
And what is that gonna return?

7045
05:11:24,317 --> 05:11:25,150
That should return us a zero.

7046
05:11:26,540 --> 05:11:29,980
And if I do index of
last, I can do index last.

7047
05:11:29,980 --> 05:11:32,000
It'll show me the last value here.

7048
05:11:34,850 --> 05:11:38,120
Of course, if I were to throw
something in here and X, Y, Z,

7049
05:11:38,120 --> 05:11:39,790
what do we think would happen here?

7050
05:11:41,384 --> 05:11:42,330
We're getting negative
one, so it's not found.

7051
05:11:42,330 --> 05:11:44,000
So if you look at the
implementation of that

7052
05:11:44,000 --> 05:11:46,637
or negative one, if the
list does not contain

7053
05:11:46,637 --> 05:11:47,689
such an element.

7054
05:11:47,689 --> 05:11:50,070
And this is all within the
Kotlin standard library.

7055
05:11:50,070 --> 05:11:50,903
So there's a number of
things that we can do

7056
05:11:50,903 --> 05:11:53,270
to find values inside of here.

7057
05:11:53,270 --> 05:11:54,540
And just like we had the last before,

7058
05:11:54,540 --> 05:11:56,580
we also have last or null.

7059
05:11:56,580 --> 05:11:58,310
So we can also take last or no as well,

7060
05:11:58,310 --> 05:12:00,160
so we'll just change this back to Don

7061
05:12:01,352 --> 05:12:04,620
and we'll see the last or null
returns us back with Donovan.

7062
05:12:04,620 --> 05:12:07,850
And then we have Donn X,
which there's nothing in there

7063
05:12:07,850 --> 05:12:10,450
with Donn X in there, it will return null.

7064
05:12:10,450 --> 05:12:12,810
So we've got a null value
at that point in time.

7065
05:12:12,810 --> 05:12:15,660
Now, the great thing about
it is I can read this code

7066
05:12:15,660 --> 05:12:17,230
six months down the line and understand

7067
05:12:17,230 --> 05:12:19,210
that I'm sheltering the names list,

7068
05:12:19,210 --> 05:12:21,900
and I wanna find the last
value or give me null.

7069
05:12:21,900 --> 05:12:23,250
And then at that point, I know exactly

7070
05:12:23,250 --> 05:12:24,430
what to expect at this point.

7071
05:12:24,430 --> 05:12:26,270
I'm either gonna have the
value or I'm gonna have null,

7072
05:12:26,270 --> 05:12:28,150
and I need to plan for that accordingly.

7073
05:12:28,150 --> 05:12:30,290
Now, thankfully Kotlin
is not going to allow me

7074
05:12:30,290 --> 05:12:31,890
to just print the length of this

7075
05:12:31,890 --> 05:12:34,000
because this is a nullable type.

7076
05:12:34,000 --> 05:12:36,000
And I need to basically
say, hey, what happens

7077
05:12:36,000 --> 05:12:38,160
if this is null and I'll just provide

7078
05:12:38,160 --> 05:12:39,420
the null safety operator, which says,

7079
05:12:39,420 --> 05:12:41,330
hey, if this is null, just return null,

7080
05:12:41,330 --> 05:12:43,980
otherwise give me the length,
that's what that means.

7081
05:12:45,040 --> 05:12:47,763
You can filter to include certain things

7082
05:12:47,763 --> 05:12:49,220
and you can also filter
to exclude certain things.

7083
05:12:49,220 --> 05:12:51,740
So for example, if we
wanted to have the result

7084
05:12:51,740 --> 05:12:53,240
to include everything from the list,

7085
05:12:53,240 --> 05:12:57,450
except something, we could have
used a inequality expression

7086
05:12:57,450 --> 05:12:59,960
inside of our predicate,
or we can just use

7087
05:13:01,333 --> 05:13:02,483
a names.not filter not.

7088
05:13:03,831 --> 05:13:08,831
And then we can say
it.contained the letter A.

7089
05:13:08,840 --> 05:13:12,580
And what this will do, it
will print line the result.

7090
05:13:12,580 --> 05:13:15,240
And this will go ahead
and include everything

7091
05:13:15,240 --> 05:13:16,680
that doesn't have a letter A.

7092
05:13:16,680 --> 05:13:18,990
So in this case, we're taking the list

7093
05:13:18,990 --> 05:13:21,614
and we're filtering it
to not include anybody

7094
05:13:21,614 --> 05:13:23,278
who has a letter A in their name,

7095
05:13:23,278 --> 05:13:24,111
which is Don, Bob and Jenny.

7096
05:13:24,111 --> 05:13:26,460
And that's how you can use the filter not,

7097
05:13:26,460 --> 05:13:29,240
which is basically the opposite of filter.

7098
05:13:29,240 --> 05:13:30,720
So if we include filter here,

7099
05:13:30,720 --> 05:13:33,230
we're now going to see the
folks who have the letter A

7100
05:13:33,230 --> 05:13:37,100
in their name, which is Jane,
Tushar, Cavita and Donovan.

7101
05:13:37,100 --> 05:13:39,070
So, yeah, filter and filter not,

7102
05:13:39,070 --> 05:13:41,520
which are basically the
exact opposite of each other,

7103
05:13:41,520 --> 05:13:43,840
or you can also just use inequalities

7104
05:13:43,840 --> 05:13:45,020
inside of your expression.

7105
05:13:45,020 --> 05:13:47,780
It just really depends on
what makes sense for you

7106
05:13:47,780 --> 05:13:49,080
and your code readability.

7107
05:13:50,636 --> 05:13:53,610
I prefer to actually use
the different variations,

7108
05:13:53,610 --> 05:13:56,500
so filter and filter not
because it's very readable

7109
05:13:56,500 --> 05:14:00,190
and I have to do less
thinking and cognitive load,

7110
05:14:00,190 --> 05:14:04,100
cognitive load for me
in regular development.

7111
05:14:04,100 --> 05:14:05,580
And in six months from now, I can read it

7112
05:14:05,580 --> 05:14:07,470
as just kind of regular English.

7113
05:14:07,470 --> 05:14:09,720
And that's how you can
filter and not filter.

7114
05:14:10,600 --> 05:14:13,890
You can easily take one list
and then take some values

7115
05:14:13,890 --> 05:14:17,040
out of it and drop it
into another mutable list

7116
05:14:17,040 --> 05:14:18,500
with the filter to commands.

7117
05:14:18,500 --> 05:14:20,810
So we can save names dot filter to,

7118
05:14:22,274 --> 05:14:23,180
and then you have provide the destination,

7119
05:14:23,180 --> 05:14:25,310
which is gonna be where you
want it to be applied to.

7120
05:14:25,310 --> 05:14:26,690
And this has to be a mutable list,

7121
05:14:26,690 --> 05:14:28,510
which is the approved list here.

7122
05:14:28,510 --> 05:14:31,780
So let's take the use case
of you have an approved list

7123
05:14:31,780 --> 05:14:33,670
of people that are going
to be on the guest list

7124
05:14:33,670 --> 05:14:37,930
for a particular event and
you want to randomly choose

7125
05:14:37,930 --> 05:14:40,470
some more people out of this other list.

7126
05:14:40,470 --> 05:14:41,900
And perhaps you wanna say anyone

7127
05:14:41,900 --> 05:14:45,630
who has the letter A in their name,

7128
05:14:46,470 --> 05:14:48,600
we're gonna randomly choose them.

7129
05:14:48,600 --> 05:14:53,540
Not really fair randomized
assessment, but it does work.

7130
05:14:53,540 --> 05:14:58,070
So we'll say print line,
and then we'll say approved.

7131
05:14:58,070 --> 05:15:00,070
And what this is gonna
do is gonna take anyone

7132
05:15:00,070 --> 05:15:03,920
who has not taken just kind of
say anyone who has a name A,

7133
05:15:03,920 --> 05:15:06,320
and we're gonna append
it to this list up here.

7134
05:15:06,320 --> 05:15:10,490
So if we run this here, we'll
see Danielle, Paul, Jane,

7135
05:15:10,490 --> 05:15:12,320
Tushar, Cavita and Donovan.

7136
05:15:13,203 --> 05:15:16,250
And so that's how we
can take one value here,

7137
05:15:16,250 --> 05:15:18,420
which is a list of names and say,

7138
05:15:18,420 --> 05:15:21,740
hey, if anyone in this list has letter A

7139
05:15:21,740 --> 05:15:24,420
or whatever this predicate
is, again, it's true or false.

7140
05:15:24,420 --> 05:15:26,020
It could be a very complex,

7141
05:15:26,870 --> 05:15:30,540
if else switch with a bunch
of things happening behind it.

7142
05:15:31,780 --> 05:15:33,770
If this returns true, then include it

7143
05:15:34,675 --> 05:15:36,270
and drop it and add it
to this mutable list,

7144
05:15:36,270 --> 05:15:37,510
otherwise don't.

7145
05:15:37,510 --> 05:15:40,080
Now we can also do the opposite too,

7146
05:15:40,080 --> 05:15:42,470
filter, not to.

7147
05:15:43,598 --> 05:15:47,060
And what this does is say,
all right, if you don't have

7148
05:15:47,060 --> 05:15:48,940
a letter A in your name,
well, now we're gonna move you

7149
05:15:48,940 --> 05:15:50,910
into this list, it's the exact opposite.

7150
05:15:50,910 --> 05:15:52,670
So we have the inclusion and exclusion.

7151
05:15:52,670 --> 05:15:53,790
So now it's Danielle and Paul,

7152
05:15:53,790 --> 05:15:55,830
they have already existed in the list,

7153
05:15:55,830 --> 05:15:57,830
but now we want anyone who
doesn't have a letter A

7154
05:15:57,830 --> 05:16:01,100
in their name, so Danielle,
Paul, Don, Bob, and Jenny.

7155
05:16:01,100 --> 05:16:02,940
So we're gonna take anyone
who doesn't have letter A

7156
05:16:02,940 --> 05:16:06,470
in this list and apply it to this list.

7157
05:16:06,470 --> 05:16:08,710
And so that's how you can
easily filter from one list

7158
05:16:08,710 --> 05:16:09,890
into another list.

7159
05:16:09,890 --> 05:16:11,730
Now, again, the list has to be mutable.

7160
05:16:11,730 --> 05:16:14,050
So if you were to change
this to just a regular list,

7161
05:16:14,050 --> 05:16:17,430
which is an immutable list,
this is not going to work.

7162
05:16:17,430 --> 05:16:19,610
As you can see here, the error states

7163
05:16:19,610 --> 05:16:23,390
that a required collection
must be mutable.

7164
05:16:23,390 --> 05:16:27,440
So we need to change this
to a mutable list of,

7165
05:16:27,440 --> 05:16:29,430
and we can get rid of the
type parameters there.

7166
05:16:29,430 --> 05:16:31,420
Again, if you want it to
provide them, you could,

7167
05:16:31,420 --> 05:16:34,640
but we don't need to because
it's already being inferred.

7168
05:16:34,640 --> 05:16:36,720
And that's how you can move
one things from one list

7169
05:16:36,720 --> 05:16:39,530
to another using filter
to and filter not to.

7170
05:16:40,510 --> 05:16:42,090
Sometimes in code, you'll find yourself

7171
05:16:42,090 --> 05:16:47,090
having a list of arrays or
basically a list of lists

7172
05:16:47,530 --> 05:16:48,780
and an array of arrays.

7173
05:16:48,780 --> 05:16:51,020
So let's start with the top example here.

7174
05:16:51,020 --> 05:16:54,090
We have an array of think
of a bunch of people

7175
05:16:54,090 --> 05:16:55,760
bringing a bunch of their fruits together,

7176
05:16:55,760 --> 05:16:57,460
and we're gonna have a party

7177
05:16:57,460 --> 05:16:58,770
and everyone's gonna
bring all their fruits,

7178
05:16:58,770 --> 05:17:00,340
and we're gonna combine
all of our fruits together.

7179
05:17:00,340 --> 05:17:02,790
And I need to see which
fruits all of us have

7180
05:17:02,790 --> 05:17:04,870
and we're building an
application for this.

7181
05:17:04,870 --> 05:17:06,930
So mine, I have apples and grapes,

7182
05:17:06,930 --> 05:17:09,750
theirs they have oranges,
pears, and strawberries,

7183
05:17:09,750 --> 05:17:11,830
and there's the other
people were bringing Kiwi

7184
05:17:11,830 --> 05:17:13,060
and watermelon.

7185
05:17:13,060 --> 05:17:14,660
So I need to see exactly what I have.

7186
05:17:14,660 --> 05:17:18,090
And so I am going to combine
all of those together,

7187
05:17:18,090 --> 05:17:20,330
all of these arrays,
because maybe they've come

7188
05:17:20,330 --> 05:17:23,950
into my application at
different periods of time.

7189
05:17:23,950 --> 05:17:25,370
And so I have the three different arrays,

7190
05:17:25,370 --> 05:17:27,020
and now I have an array of arrays.

7191
05:17:27,020 --> 05:17:29,580
So basically I've
created a list of arrays,

7192
05:17:29,580 --> 05:17:31,720
excuse me, and list of lists.

7193
05:17:31,720 --> 05:17:34,170
So I have a list of mine, a
list of theirs and list of.

7194
05:17:34,170 --> 05:17:37,240
And now if I were to print
this, it would show an array.

7195
05:17:38,695 --> 05:17:40,730
It's gonna be a list
with three items in it.

7196
05:17:40,730 --> 05:17:43,950
And this one, the first
item would have two items

7197
05:17:43,950 --> 05:17:46,190
in that list, the second one
have three items on that list

7198
05:17:46,190 --> 05:17:48,440
and the last one would have
two items in that list.

7199
05:17:48,440 --> 05:17:50,280
Now there's actually a
method called flatten.

7200
05:17:50,280 --> 05:17:52,360
And what this will do is
it'll take all these values

7201
05:17:52,360 --> 05:17:56,520
and flatten them out and
basically put them into one list.

7202
05:17:56,520 --> 05:17:59,710
So I'm gonna go in calm
this out so we can run this.

7203
05:18:00,640 --> 05:18:04,050
And you'll see here that down
we have, when we print this,

7204
05:18:05,330 --> 05:18:07,120
these brackets indicate a list.

7205
05:18:07,120 --> 05:18:08,770
So this is one of the lists,

7206
05:18:08,770 --> 05:18:10,470
this is the next list right here.

7207
05:18:11,460 --> 05:18:13,860
And this is the last
list here with the kiwi

7208
05:18:13,860 --> 05:18:14,990
and the watermelon.

7209
05:18:14,990 --> 05:18:17,478
And of course through
the whole thing is inside

7210
05:18:17,478 --> 05:18:18,311
of one set of brackets here,

7211
05:18:18,311 --> 05:18:19,420
which represents that the whole thing

7212
05:18:19,420 --> 05:18:22,770
is inside of a list itself,
so it's a list of lists,

7213
05:18:22,770 --> 05:18:23,720
kind of a mouthful.

7214
05:18:24,632 --> 05:18:25,470
Now, when I call the flatten method,

7215
05:18:25,470 --> 05:18:27,390
what it does is it just
takes all those values

7216
05:18:27,390 --> 05:18:29,360
and flattens it into one list itself.

7217
05:18:29,360 --> 05:18:32,370
So I'm able to combine all of these lists

7218
05:18:32,370 --> 05:18:35,780
if they're inside of one master
list and flatten them out.

7219
05:18:35,780 --> 05:18:38,410
Now you can do the same
exact thing with arrays.

7220
05:18:38,410 --> 05:18:40,970
It's exact same thing, we'll
have an array of arrays here.

7221
05:18:40,970 --> 05:18:43,570
And so we have an array
of the same exact things.

7222
05:18:43,570 --> 05:18:46,080
Instead of using lists,
I'm just using arrays.

7223
05:18:46,080 --> 05:18:48,030
And I'm gonna call it the
same exact method on it.

7224
05:18:48,030 --> 05:18:51,270
And so I'm calling flatten
and both of these actually

7225
05:18:51,270 --> 05:18:52,530
do the exact same thing.

7226
05:18:54,193 --> 05:18:55,430
This one is gonna be iterating on a list.

7227
05:18:56,439 --> 05:18:58,460
And this one is going to
be iterating on an array.

7228
05:18:58,460 --> 05:19:01,510
So you can see they are different
there's different codes.

7229
05:19:01,510 --> 05:19:04,030
So see line 19 inside the arrays file.

7230
05:19:04,030 --> 05:19:08,800
And then we have line 69
of the itterables file.

7231
05:19:08,800 --> 05:19:12,050
So there is different code, but
it does the exact same thing

7232
05:19:12,050 --> 05:19:13,100
in our use case here.

7233
05:19:15,430 --> 05:19:18,330
And so we're going to take
arrays and if we run these here,

7234
05:19:18,330 --> 05:19:21,910
what we'll see as a top two
lines will be for our lists.

7235
05:19:21,910 --> 05:19:25,090
So we have a list up
here and the next one,

7236
05:19:25,090 --> 05:19:27,760
this is the array of arrays,
and it's printing out the,

7237
05:19:27,760 --> 05:19:29,180
hey, there's a bunch of strings in there

7238
05:19:29,180 --> 05:19:31,130
and then it kind of stopped printing

7239
05:19:31,130 --> 05:19:33,790
and then it flattens them
out into one large array.

7240
05:19:33,790 --> 05:19:35,530
So that's how you can go ahead and flatten

7241
05:19:35,530 --> 05:19:38,700
an array of arrays or lists
of lists inside of Kotlin.

7242
05:19:39,680 --> 05:19:41,680
Let's assume you have multiple lists

7243
05:19:41,680 --> 05:19:43,720
that you'd need to combine in Kotlin.

7244
05:19:43,720 --> 05:19:46,270
These are all immutable
lists, so you can not mutate

7245
05:19:46,270 --> 05:19:47,840
any of them, but you
would like to combine them

7246
05:19:47,840 --> 05:19:51,090
and have a list at the end
that contains all the items.

7247
05:19:51,090 --> 05:19:52,130
It's fairly simple.

7248
05:19:52,130 --> 05:19:54,680
All I need to do is you have a variable

7249
05:19:54,680 --> 05:19:55,950
and you actually don't need a variable

7250
05:19:55,950 --> 05:19:57,450
if you're just parsing this,

7251
05:19:57,450 --> 05:20:01,340
you can just say mine.plus theirs.

7252
05:20:01,340 --> 05:20:02,700
This is gonna return a new instance

7253
05:20:02,700 --> 05:20:05,550
and they say .plus others.

7254
05:20:06,430 --> 05:20:09,670
And this is gonna turn all of the values

7255
05:20:09,670 --> 05:20:11,750
of concatenated together.

7256
05:20:11,750 --> 05:20:14,730
So if we were to run this,
you'll now see that the result

7257
05:20:14,730 --> 05:20:17,470
contains apples, grapes,
oranges, pears, strawberries,

7258
05:20:17,470 --> 05:20:18,310
Kiwi, and watermelons.

7259
05:20:18,310 --> 05:20:20,700
So we've combined all
of these immutable lists

7260
05:20:20,700 --> 05:20:23,000
into one final immutable list.

7261
05:20:23,000 --> 05:20:24,830
Furthermore, you can do
something interesting.

7262
05:20:24,830 --> 05:20:27,700
You can, if you have this
list and you want to remove

7263
05:20:27,700 --> 05:20:30,450
a whole bunch of items
from it, you could do this.

7264
05:20:30,450 --> 05:20:33,270
You could say minus, and you
could remove a bunch of items.

7265
05:20:33,270 --> 05:20:36,380
So maybe you wanna remove
theirs from that list.

7266
05:20:36,380 --> 05:20:38,950
And what you're gonna
see here is our result.

7267
05:20:38,950 --> 05:20:41,910
Now is gonna take out
theirs, we're going to remove

7268
05:20:41,910 --> 05:20:44,240
the oranges, pears, and strawberries,

7269
05:20:44,240 --> 05:20:46,560
which on the second line
item here, we've removed

7270
05:20:46,560 --> 05:20:48,860
the oranges, pears, and strawberries.

7271
05:20:48,860 --> 05:20:51,120
Now the minus operator
does allow you to do

7272
05:20:51,120 --> 05:20:51,953
a whole bunch of stuff.

7273
05:20:51,953 --> 05:20:53,740
You can parse in an itterable,

7274
05:20:53,740 --> 05:20:56,140
you can parse in some sequence,

7275
05:20:56,140 --> 05:20:58,470
you can parse in an array elements.

7276
05:20:58,470 --> 05:21:00,960
And you can also parse in
a single element itself.

7277
05:21:00,960 --> 05:21:03,060
So if you just want to remove one item

7278
05:21:03,060 --> 05:21:06,550
and you just wanna remove
Kiwi and you were to run this,

7279
05:21:06,550 --> 05:21:08,820
now you would see that the end that Kiwi

7280
05:21:08,820 --> 05:21:09,800
would then be removed.

7281
05:21:09,800 --> 05:21:11,570
So you can parse in a list

7282
05:21:11,570 --> 05:21:14,140
or an exact element to be removed.

7283
05:21:14,140 --> 05:21:17,310
So that's how you can combine
concatenate lists together

7284
05:21:17,310 --> 05:21:19,560
inside of Kotlin even
if they are immutable.

7285
05:21:21,610 --> 05:21:24,090
One of the most powerful
operators in Kotlin

7286
05:21:24,090 --> 05:21:27,390
on an a collection is going
to be the map operator.

7287
05:21:27,390 --> 05:21:29,420
So we have a list of names here.

7288
05:21:29,420 --> 05:21:31,860
Let's assume that we wanted to
take the first three letters

7289
05:21:31,860 --> 05:21:35,980
of each name, make them uppercase
and make the abbreviation

7290
05:21:35,980 --> 05:21:37,340
for the person's name.

7291
05:21:37,340 --> 05:21:40,018
It's a pretty rudimentary
example, but let's go ahead

7292
05:21:40,018 --> 05:21:40,851
and try to do that.

7293
05:21:40,851 --> 05:21:42,350
We could use a bunch of
different loops to do that,

7294
05:21:42,350 --> 05:21:44,660
or we can use the map operator.

7295
05:21:44,660 --> 05:21:46,510
So when I say items.map.

7296
05:21:46,510 --> 05:21:48,120
And what this allows us to do is parse in

7297
05:21:48,120 --> 05:21:49,790
the lambda function.

7298
05:21:49,790 --> 05:21:52,650
And what we can do here
is start doing something.

7299
05:21:52,650 --> 05:21:54,890
So it is going to be
each name in the list.

7300
05:21:54,890 --> 05:21:57,290
And then we could say sub string,

7301
05:21:57,290 --> 05:21:59,472
we're gonna say zero to three.

7302
05:21:59,472 --> 05:22:02,360
So we'll get the first
three letters.two uppercase.

7303
05:22:02,360 --> 05:22:05,160
Now, what this is going to
do, map is going to return

7304
05:22:05,160 --> 05:22:07,890
a brand new list, so, it
returns a list containing

7305
05:22:07,890 --> 05:22:10,860
the result of applying the
given transformation function

7306
05:22:10,860 --> 05:22:12,850
to each element in the
original collection.

7307
05:22:12,850 --> 05:22:14,300
Okay, what does that mean?

7308
05:22:14,300 --> 05:22:18,930
What that means is for each
item inside of this list,

7309
05:22:18,930 --> 05:22:20,820
when we call map, it's
gonna execute a function.

7310
05:22:20,820 --> 05:22:22,780
That's basically gonna give us that value,

7311
05:22:22,780 --> 05:22:25,170
and then whatever we do with this value,

7312
05:22:25,170 --> 05:22:27,110
it's going to return this back.

7313
05:22:27,110 --> 05:22:29,040
It's gonna return whatever
the result of this is back.

7314
05:22:29,040 --> 05:22:31,330
So let's print it off and
see what happens here.

7315
05:22:31,330 --> 05:22:32,980
All this sub string is doing is taking

7316
05:22:32,980 --> 05:22:35,500
the first three letters of the
name and making it uppercase.

7317
05:22:35,500 --> 05:22:38,090
And so as you can see,
the result is Don, Jan,

7318
05:22:38,090 --> 05:22:41,690
Carl, Pitt and Clar for the three letters

7319
05:22:41,690 --> 05:22:43,908
of each of these names up here.

7320
05:22:43,908 --> 05:22:47,260
Now I could just completely
ignore it and just say, foo.

7321
05:22:47,260 --> 05:22:49,490
Now watch, if I run
this, we're gonna see foo

7322
05:22:49,490 --> 05:22:50,710
over and over and over.

7323
05:22:50,710 --> 05:22:54,220
The reason why, this map,
this function is executed

7324
05:22:54,220 --> 05:22:55,180
every single time.

7325
05:22:55,180 --> 05:22:58,420
So it's executed for Donn
Felker, it gets foo for Jane Doe.

7326
05:22:58,420 --> 05:23:01,080
It gets foo for Karthik,
it gets foo for Peter,

7327
05:23:01,080 --> 05:23:04,440
it gets foo for Clark, it
gets foo it just executes

7328
05:23:04,440 --> 05:23:06,300
each individual time.

7329
05:23:06,300 --> 05:23:09,110
So here, I'm just returning these values.

7330
05:23:09,110 --> 05:23:10,900
So at this point in time, I'm gonna get

7331
05:23:10,900 --> 05:23:12,380
those first three letters.

7332
05:23:12,380 --> 05:23:15,990
Now we can take this a step
further and we could say,

7333
05:23:15,990 --> 05:23:19,080
all right, well, we can break
this into multiple lines

7334
05:23:19,080 --> 05:23:20,750
and say, let's say I
wanted to get the initials

7335
05:23:20,750 --> 05:23:21,583
off of everybody.

7336
05:23:21,583 --> 05:23:24,100
Now there's multiple ways
that I could go doing this.

7337
05:23:24,100 --> 05:23:26,490
Now, what I could do, very kind of,

7338
05:23:26,490 --> 05:23:28,800
this is very naive approach, but it works.

7339
05:23:28,800 --> 05:23:33,020
I could say it.split, and I
wanna split this on the space.

7340
05:23:33,020 --> 05:23:35,044
And now I have some words.

7341
05:23:35,044 --> 05:23:38,390
And then what I can say is
I wanna return basically

7342
05:23:38,390 --> 05:23:41,170
the words with the first word

7343
05:23:41,170 --> 05:23:43,660
and then I wanna sub string that one.

7344
05:23:43,660 --> 05:23:45,400
And that's gonna start from zero to one,

7345
05:23:45,400 --> 05:23:47,800
basically take the first
letter of the first word,

7346
05:23:47,800 --> 05:23:52,720
plus words.sub string is
gonna be the second word,

7347
05:23:54,440 --> 05:23:55,273
.sub string.

7348
05:23:57,073 --> 05:23:58,690
And you take the first
letter of that one as well.

7349
05:23:58,690 --> 05:24:00,310
And so we're gonna see here type mismatch.

7350
05:24:00,310 --> 05:24:02,850
It says, found string required unit.

7351
05:24:02,850 --> 05:24:05,100
So I actually need to just do this.

7352
05:24:05,100 --> 05:24:06,870
And you may notice like,
why am I not returning it?

7353
05:24:06,870 --> 05:24:09,750
Because what happens inside
of the map is the last value

7354
05:24:09,750 --> 05:24:11,650
is what's returned inside of this map,

7355
05:24:11,650 --> 05:24:13,830
which is why it's pointing
with the up arrow.

7356
05:24:13,830 --> 05:24:15,180
It says map inside the IDE.

7357
05:24:16,225 --> 05:24:17,285
So this is a little hint, it says,

7358
05:24:17,285 --> 05:24:19,400
hey, this is the return
value of the map operation.

7359
05:24:19,400 --> 05:24:21,710
So now, if I were run
this, we're gonna see

7360
05:24:21,710 --> 05:24:24,640
that it's just going to return
back the initials, DF, JD,

7361
05:24:24,640 --> 05:24:26,710
KM, PP, and CK.

7362
05:24:26,710 --> 05:24:30,080
Now this is very, this is
not production quality code.

7363
05:24:30,080 --> 05:24:33,270
If the user has multiple
names and multiple spaces

7364
05:24:33,270 --> 05:24:35,090
in their name, this is gonna fail.

7365
05:24:35,090 --> 05:24:37,360
If they only have one
name, this is gonna fail.

7366
05:24:37,360 --> 05:24:38,680
So this is not production quality,

7367
05:24:38,680 --> 05:24:41,620
but this just illustrates
something that you can do

7368
05:24:41,620 --> 05:24:43,560
inside of the map operation.

7369
05:24:43,560 --> 05:24:47,020
So let's go ahead and you
rewind this a little bit here

7370
05:24:47,020 --> 05:24:50,660
and go back to where we were
before with the abbreviations.

7371
05:24:50,660 --> 05:24:52,650
So now I have the abbreviations.

7372
05:24:52,650 --> 05:24:55,440
And just to run it again,
you'll see what we have.

7373
05:24:55,440 --> 05:24:58,350
You have Donn Jan, Car, Pitt, Clar.

7374
05:24:59,300 --> 05:25:02,410
Now, what I might want to
do at this point in time

7375
05:25:02,410 --> 05:25:06,670
is actually go ahead and I
can perform form another map.

7376
05:25:06,670 --> 05:25:08,450
I can map over an existing result.

7377
05:25:08,450 --> 05:25:09,450
I'm just gonna move this over here.

7378
05:25:09,450 --> 05:25:14,450
So whatever the result of
this, which is Don, Jan, Car,

7379
05:25:14,920 --> 05:25:17,310
Pit and Cla, I'm going to go ahead

7380
05:25:17,310 --> 05:25:18,530
and do an operation on that.

7381
05:25:18,530 --> 05:25:20,040
And I can map on top of that.

7382
05:25:20,040 --> 05:25:25,040
So I could say it.length
and we'll return that.

7383
05:25:26,520 --> 05:25:28,900
Now what you're gonna get
back is a list of integers.

7384
05:25:28,900 --> 05:25:29,990
And each one's gonna say three

7385
05:25:29,990 --> 05:25:33,260
'cause each of the
abbreviations was three long.

7386
05:25:33,260 --> 05:25:35,230
So that kind of makes sense.

7387
05:25:35,230 --> 05:25:38,040
Now, what I could also do
is something like this.

7388
05:25:39,140 --> 05:25:42,520
I could decide that maybe
I want to sum something,

7389
05:25:42,520 --> 05:25:46,770
I could sum by a particular
value, say it.length

7390
05:25:47,970 --> 05:25:52,120
and run that and we're gonna
see 15, so some by that.

7391
05:25:52,120 --> 05:25:53,488
But what does that mean?

7392
05:25:53,488 --> 05:25:55,880
It means we've taken
each of the values here

7393
05:25:55,880 --> 05:25:58,750
and then sum them up into 15.

7394
05:25:58,750 --> 05:26:00,720
Now I can also decide if
I don't wanna do a sum,

7395
05:26:00,720 --> 05:26:02,940
maybe I wanted to do a filter.

7396
05:26:02,940 --> 05:26:07,370
So I remember this is applying
to the result of this map.

7397
05:26:07,370 --> 05:26:10,850
So I can say filter I'll
know when I wanna get

7398
05:26:10,850 --> 05:26:15,010
everybody's first three
letters of their name,

7399
05:26:15,010 --> 05:26:17,110
and then if their first
three letters of their name

7400
05:26:17,110 --> 05:26:21,660
have the letter O in it,
so it's it.contained,

7401
05:26:21,660 --> 05:26:24,120
it's all we'll do to
lowercase just in case,

7402
05:26:24,120 --> 05:26:25,670
actually two uppercase.

7403
05:26:27,680 --> 05:26:29,220
Actually it's already uppercase.

7404
05:26:29,220 --> 05:26:30,550
So I say, it.contains.

7405
05:26:32,590 --> 05:26:36,970
Oh, if we run this, we should
only get one value back.

7406
05:26:36,970 --> 05:26:40,390
And that's gonna be Don,
D-O-N because I've now grabbed

7407
05:26:40,390 --> 05:26:42,740
the abbreviation and then
I've now filtered it.

7408
05:26:42,740 --> 05:26:46,014
So I can start stacking these
things on top of each other.

7409
05:26:46,014 --> 05:26:48,150
Now, if I, for some reason,
would like to reverse

7410
05:26:48,150 --> 05:26:50,780
these things, reversed.

7411
05:26:52,951 --> 05:26:56,700
If we run that, you're just gonna see Don.

7412
05:26:56,700 --> 05:26:59,887
So let's say contains and so go ahead

7413
05:26:59,887 --> 05:27:01,530
and flip this filter not.

7414
05:27:01,530 --> 05:27:04,217
So I don't want it if
it contains a letter L

7415
05:27:04,217 --> 05:27:05,700
which should give me all the other ones.

7416
05:27:05,700 --> 05:27:09,510
We're gonna see CLA, PET, KR and JN.

7417
05:27:10,397 --> 05:27:11,900
And now that's because
the array was reversed,

7418
05:27:11,900 --> 05:27:13,150
I've reversed this array.

7419
05:27:15,088 --> 05:27:17,520
And I can continue to
stack different operations

7420
05:27:17,520 --> 05:27:18,510
on top of this.

7421
05:27:18,510 --> 05:27:20,650
So this allows it to be very functional.

7422
05:27:20,650 --> 05:27:23,080
And so I don't have to
perform all of my logic

7423
05:27:23,080 --> 05:27:25,500
directly within one particular map,

7424
05:27:25,500 --> 05:27:28,480
I can map from one thing to
another thing to another thing.

7425
05:27:28,480 --> 05:27:31,280
And this allows you to
have functions that return,

7426
05:27:31,280 --> 05:27:32,710
perhaps a list of something.

7427
05:27:32,710 --> 05:27:35,600
And then inside that list, you
might perform an operation.

7428
05:27:35,600 --> 05:27:37,440
And then you might map over that operation

7429
05:27:37,440 --> 05:27:39,710
and map over something else
and allows you to transform

7430
05:27:39,710 --> 05:27:42,630
your data in real time,
basically as you're typing it,

7431
05:27:42,630 --> 05:27:45,400
it's much more declarative
and easy to read.

7432
05:27:45,400 --> 05:27:47,920
So that's how you can
perform a map operation

7433
05:27:47,920 --> 05:27:50,140
with just regular primitive types.

7434
05:27:50,140 --> 05:27:52,320
Now, of course, you can do this
with other classes as well.

7435
05:27:52,320 --> 05:27:55,070
So let's say we have
a class called person,

7436
05:27:55,070 --> 05:27:58,457
and this person has a
name, which is a string,

7437
05:28:00,600 --> 05:28:02,400
let's do something simple like that.

7438
05:28:03,603 --> 05:28:07,247
And we'll say people, and
we'll say, list of person,

7439
05:28:11,450 --> 05:28:16,140
Donn and then we say person Jane.

7440
05:28:21,180 --> 05:28:22,250
Now I have all my people.

7441
05:28:22,250 --> 05:28:24,710
Well, I can also map right
over these people too.

7442
05:28:26,473 --> 05:28:27,540
We can say people result.

7443
05:28:29,370 --> 05:28:31,620
And what this will be
is I'll say people.map,

7444
05:28:33,517 --> 05:28:36,437
and now I'm gonna have
this IT value as a person.

7445
05:28:36,437 --> 05:28:38,740
So I can say person.name, I
can do something like that.

7446
05:28:38,740 --> 05:28:40,070
So I can just get everybody's name.

7447
05:28:40,070 --> 05:28:42,960
Now, if I were to print
this to the screen,

7448
05:28:42,960 --> 05:28:46,310
I would say people result
with this gonna be,

7449
05:28:46,310 --> 05:28:47,720
is a list of strings,
it's just gonna give you

7450
05:28:47,720 --> 05:28:48,570
everybody's name.

7451
05:28:50,111 --> 05:28:51,650
So this would be Don, Jane, Bob, Cavita.

7452
05:28:51,650 --> 05:28:54,248
So I'm just iterating over, I'm
just getting a list of that.

7453
05:28:54,248 --> 05:28:55,580
So it allows me to transform that data,

7454
05:28:56,540 --> 05:28:57,373
which makes it very, very nice.

7455
05:28:57,373 --> 05:28:59,580
And of course I can map on top of that,

7456
05:28:59,580 --> 05:29:02,600
which might be it.length.

7457
05:29:02,600 --> 05:29:04,880
So I'm gonna get the
length of everybody's name,

7458
05:29:04,880 --> 05:29:07,640
and maybe that would be a useful
function for me somewhere.

7459
05:29:07,640 --> 05:29:10,480
I could put this inside
of a function and say,

7460
05:29:10,480 --> 05:29:13,970
all right, give me the
length of everybody's names.

7461
05:29:13,970 --> 05:29:15,960
And it would give back the
length of everyone's names

7462
05:29:15,960 --> 05:29:17,200
accordingly.

7463
05:29:17,200 --> 05:29:19,930
Now, maybe you would want to
transform a little bit further

7464
05:29:19,930 --> 05:29:21,320
and you could say, all
right, what's the length

7465
05:29:21,320 --> 05:29:25,990
of their name and perhaps also
I would like to show their...

7466
05:29:27,710 --> 05:29:31,080
I want it to include their
name as well with that.

7467
05:29:31,080 --> 05:29:33,310
And then you could create
various different mappings

7468
05:29:33,310 --> 05:29:37,100
and return arrays or raise
arrays list of lists, et cetera.

7469
05:29:37,100 --> 05:29:38,810
The possibilities are endless.

7470
05:29:40,470 --> 05:29:42,730
The map and flat map
operator can sometimes

7471
05:29:42,730 --> 05:29:44,760
be the source of a lot of confusion

7472
05:29:44,760 --> 05:29:46,360
and determining which
one to use can always

7473
05:29:46,360 --> 05:29:49,660
be kind of something that will
confuse you throughout time.

7474
05:29:49,660 --> 05:29:52,130
Very often that I've had
to look the documentation

7475
05:29:52,130 --> 05:29:54,360
and play around with a
few examples to understand

7476
05:29:54,360 --> 05:29:56,170
what I'd normally need to use.

7477
05:29:56,170 --> 05:29:57,920
Now, working with collections most often,

7478
05:29:57,920 --> 05:29:59,320
you wanna use the map operator

7479
05:29:59,320 --> 05:30:01,100
because you just wanna return values

7480
05:30:01,100 --> 05:30:03,260
and perform transformations
on those values

7481
05:30:03,260 --> 05:30:05,070
across all of the items in a list

7482
05:30:05,070 --> 05:30:07,390
or an iterable of some fashion.

7483
05:30:07,390 --> 05:30:09,830
However, let's determine
what the differences are.

7484
05:30:09,830 --> 05:30:12,660
Here we have a class in
line 23 and it represents

7485
05:30:12,660 --> 05:30:13,810
a shopping bag.

7486
05:30:13,810 --> 05:30:16,540
And in each shopping bag,
we have a number of items

7487
05:30:16,540 --> 05:30:17,700
that go into a bag.

7488
05:30:19,151 --> 05:30:20,780
And when you go grocery
shopping, you usually have

7489
05:30:20,780 --> 05:30:21,660
a number of bags.

7490
05:30:21,660 --> 05:30:24,060
So one bag has grapes,
apples, and oranges,

7491
05:30:24,060 --> 05:30:26,030
the next bag has milk, eggs, and pasta

7492
05:30:26,030 --> 05:30:29,460
and the last bag has some
bread, naan and cake in it.

7493
05:30:29,460 --> 05:30:32,620
And we have basically
a list of grocery bags,

7494
05:30:32,620 --> 05:30:34,460
and those are gonna be our
grocery bags that we have

7495
05:30:34,460 --> 05:30:35,610
from the grocery store.

7496
05:30:36,816 --> 05:30:38,736
Now we may have also went
and purchased some clothing.

7497
05:30:38,736 --> 05:30:41,120
And so we went to a few
retail shops and those bags,

7498
05:30:41,120 --> 05:30:42,670
we have three of those as well.

7499
05:30:43,573 --> 05:30:47,000
We have a shirt, pants and
trouser, let's say trousers.

7500
05:30:47,000 --> 05:30:49,970
So we have shirts and trousers,
we have socks and shoes,

7501
05:30:49,970 --> 05:30:52,450
and then another bag
has a jacket, a sweater,

7502
05:30:52,450 --> 05:30:53,283
and a scarf in it.

7503
05:30:53,283 --> 05:30:56,230
So we're gonna use these two lists.

7504
05:30:56,230 --> 05:30:58,070
So basically these two groupings of bags.

7505
05:30:58,070 --> 05:31:00,550
So we have a list of three shopping bags.

7506
05:31:00,550 --> 05:31:02,390
And up here, we have a list
of three shopping bags,

7507
05:31:02,390 --> 05:31:04,280
and we're gonna perform a flat map on it

7508
05:31:04,280 --> 05:31:05,820
and then print the result.

7509
05:31:05,820 --> 05:31:09,720
And then we're gonna perform
a map on the retail bags

7510
05:31:09,720 --> 05:31:10,930
to see what the differences are.

7511
05:31:10,930 --> 05:31:13,180
So here we can take grocery bags.flat map.

7512
05:31:13,180 --> 05:31:15,670
And then what we do is for
the transformation function,

7513
05:31:15,670 --> 05:31:19,140
we just tell it to, hey,
return all of the items.

7514
05:31:19,140 --> 05:31:21,300
And so if we look at the
declaration of flat map,

7515
05:31:21,300 --> 05:31:23,920
it says returns a single
list of all the elements

7516
05:31:23,920 --> 05:31:26,660
yielded from the results
of the transform function

7517
05:31:26,660 --> 05:31:28,930
being invoked on each element
of the original collection.

7518
05:31:28,930 --> 05:31:30,600
That's confusing.

7519
05:31:30,600 --> 05:31:31,890
So basically what it's saying is like,

7520
05:31:31,890 --> 05:31:34,160
look, what's gonna flatten
out, if this is a list,

7521
05:31:34,160 --> 05:31:35,940
it's gonna flatten it all out.

7522
05:31:35,940 --> 05:31:37,430
Now, if we look at the map,

7523
05:31:37,430 --> 05:31:38,590
we've already looked at this before.

7524
05:31:38,590 --> 05:31:40,720
It says returns a list
containing the results

7525
05:31:40,720 --> 05:31:43,164
of applying to give and
transformation function

7526
05:31:43,164 --> 05:31:45,200
to each element in the
original collection.

7527
05:31:45,200 --> 05:31:46,250
So that makes sense.

7528
05:31:46,250 --> 05:31:48,630
All this function is
really doing is saying,

7529
05:31:48,630 --> 05:31:52,420
hey, map over all of the
bags and then we're saying,

7530
05:31:52,420 --> 05:31:54,850
and give me all the items.

7531
05:31:54,850 --> 05:31:58,470
Okay, so let's do something here.

7532
05:31:58,470 --> 05:32:00,690
Let's just run this to
see what the result is.

7533
05:32:02,826 --> 05:32:04,130
If we run this, you'll see down here,

7534
05:32:04,130 --> 05:32:06,560
the flat map actually says,

7535
05:32:06,560 --> 05:32:09,190
hey, I've grabbed a
win inside of each bag,

7536
05:32:09,190 --> 05:32:11,150
I've grabbed the list of
things inside of the bag.

7537
05:32:11,150 --> 05:32:13,950
I've grabbed the list of
groceries that are in each bag.

7538
05:32:13,950 --> 05:32:16,150
And I got back each list of groceries.

7539
05:32:16,150 --> 05:32:16,983
And then basically what it is.

7540
05:32:16,983 --> 05:32:19,880
I flattened them into one single list.

7541
05:32:19,880 --> 05:32:22,230
So it's flattened them
all into one single list.

7542
05:32:22,230 --> 05:32:25,500
In this case, flat map, when
you have a bag of groceries

7543
05:32:25,500 --> 05:32:28,450
and each bag of groceries
has many items in it,

7544
05:32:28,450 --> 05:32:29,880
it's like taking everything
out and putting it

7545
05:32:29,880 --> 05:32:30,840
on the counter.

7546
05:32:30,840 --> 05:32:32,564
So you're flat mapping.

7547
05:32:32,564 --> 05:32:33,430
You flat mapped everything
out on the counter,

7548
05:32:33,430 --> 05:32:35,280
it's all right there in front of you.

7549
05:32:36,225 --> 05:32:38,480
Now, the retail bags and
we're using the map operator.

7550
05:32:38,480 --> 05:32:40,380
What we're basically saying is,

7551
05:32:40,380 --> 05:32:43,550
well, I have a bunch of items in the bag,

7552
05:32:44,410 --> 05:32:45,243
and I may have taken all these items out,

7553
05:32:45,243 --> 05:32:47,350
but I'm still leaving
them in little groups.

7554
05:32:47,350 --> 05:32:50,590
I have a group number one,
which contains the shirts,

7555
05:32:50,590 --> 05:32:52,630
pants and trousers, and
the group, number two,

7556
05:32:52,630 --> 05:32:55,237
the socks and shoes, and
in group number three,

7557
05:32:55,237 --> 05:32:56,070
which is a jacket sweater and scarf.

7558
05:32:56,070 --> 05:32:57,310
But I don't have the bag
anymore because I've taken them

7559
05:32:57,310 --> 05:32:58,330
out of bags.

7560
05:32:58,330 --> 05:32:59,540
And you may be wondering, what do you mean

7561
05:32:59,540 --> 05:33:01,360
I've taken them out of bags.

7562
05:33:01,360 --> 05:33:02,700
So let's do this real quick.

7563
05:33:02,700 --> 05:33:04,450
Let's say print retail bag.

7564
05:33:08,470 --> 05:33:09,590
If I run this again, we're gonna see

7565
05:33:09,590 --> 05:33:11,140
a couple of print lines here.

7566
05:33:11,140 --> 05:33:15,030
So here we go, we have
three shopping bags.

7567
05:33:15,030 --> 05:33:18,210
So if I just print out
the bags themselves,

7568
05:33:18,210 --> 05:33:22,040
that's like putting three
shopping bags on the counter.

7569
05:33:22,040 --> 05:33:25,220
Now, if I were to take
those items out and put them

7570
05:33:25,220 --> 05:33:27,920
on the counter in the same
groups that they were already in,

7571
05:33:27,920 --> 05:33:30,143
that's what retail bags is doing.

7572
05:33:30,143 --> 05:33:30,976
It's just removing the bag,

7573
05:33:30,976 --> 05:33:32,810
but I'm still grouping
everything together.

7574
05:33:32,810 --> 05:33:34,210
Now, flat map basically says,

7575
05:33:34,210 --> 05:33:35,690
hey, look, I've just taken
out all the groceries

7576
05:33:35,690 --> 05:33:36,630
and just put them all on the counter.

7577
05:33:36,630 --> 05:33:37,850
They're all right here in front of me,

7578
05:33:37,850 --> 05:33:40,915
I just kind of put them out
one right next to each other.

7579
05:33:40,915 --> 05:33:42,170
There's no groupings, we're just one,

7580
05:33:42,170 --> 05:33:44,440
one after the other sequential ordering.

7581
05:33:44,440 --> 05:33:47,080
So the best way you usually think of this

7582
05:33:47,080 --> 05:33:49,780
is if you have a list
of a list of something

7583
05:33:49,780 --> 05:33:52,530
to a list of lists, then
at that point in time,

7584
05:33:52,530 --> 05:33:53,470
you need to start thinking about,

7585
05:33:53,470 --> 05:33:54,990
all right, maybe I need to use flat map

7586
05:33:54,990 --> 05:33:57,370
if I need to kind of get
into each individual item

7587
05:33:57,370 --> 05:34:00,360
and combine them into a
larger lists that's congruent.

7588
05:34:00,360 --> 05:34:03,080
However, if I just need
to operate on each item

7589
05:34:03,080 --> 05:34:06,060
in a particular group, then
perhaps I just need to use map.

7590
05:34:06,060 --> 05:34:09,080
So lists of lists think
flat map, everything else

7591
05:34:09,080 --> 05:34:10,750
I default back to map.

7592
05:34:10,750 --> 05:34:13,111
And then of course, if
you ever get confused,

7593
05:34:13,111 --> 05:34:15,040
hop into the documentation,
I hope that helps.

7594
05:34:15,040 --> 05:34:18,280
Sometimes you wanna have a list of data,

7595
05:34:18,280 --> 05:34:20,826
but you don't want items to repeat.

7596
05:34:20,826 --> 05:34:23,320
And so you want the data to
be unique inside of that list.

7597
05:34:23,320 --> 05:34:24,760
That's known as a set.

7598
05:34:24,760 --> 05:34:27,730
And so what we can do is
create a set of values.

7599
05:34:27,730 --> 05:34:30,670
Like I say, set of, and
this is a helper function

7600
05:34:30,670 --> 05:34:32,380
inside of the Kotlin standard library

7601
05:34:32,380 --> 05:34:34,570
and the Kotlin collections library.

7602
05:34:34,570 --> 05:34:36,170
And I'm a create a set of names.

7603
05:34:36,170 --> 05:34:40,460
So I would say Don, and let's
say John, and then Felicia,

7604
05:34:42,760 --> 05:34:45,150
there we go and I can print this out.

7605
05:34:45,150 --> 05:34:48,050
Now what this will do, it should be names.

7606
05:34:49,420 --> 05:34:51,820
When I print this, it'll
look almost similar

7607
05:34:51,820 --> 05:34:54,730
to just like a list that
we have Don, John, Felicia,

7608
05:34:54,730 --> 05:34:56,070
that works well.

7609
05:34:56,070 --> 05:34:59,180
But the benefit of a set is
if we look at the definition

7610
05:34:59,180 --> 05:35:02,120
here of the set of helper method,

7611
05:35:02,120 --> 05:35:05,030
returns a new read only set
what the given elements.

7612
05:35:05,030 --> 05:35:06,650
Element of the set are
iterated in the order

7613
05:35:06,650 --> 05:35:07,590
they are specified.

7614
05:35:07,590 --> 05:35:10,790
And the return set is
realizable, so we can realize it.

7615
05:35:11,880 --> 05:35:12,980
But the interesting thing is here

7616
05:35:12,980 --> 05:35:15,040
is it does not allow duplicate elements.

7617
05:35:15,040 --> 05:35:17,960
If I wanna put Donn in
there twice and I run this,

7618
05:35:17,960 --> 05:35:19,600
you'll see that Donn is not in there.

7619
05:35:19,600 --> 05:35:21,490
Let's see if I tried to
put Felicia twice or John,

7620
05:35:21,490 --> 05:35:26,490
so, let's do John again,
we see this not included.

7621
05:35:26,820 --> 05:35:28,350
So we cannot put that inside of there.

7622
05:35:28,350 --> 05:35:32,720
So with a set, you can't have
duplicate items in there.

7623
05:35:32,720 --> 05:35:34,060
And so that's how we can create a set

7624
05:35:34,060 --> 05:35:36,260
that's basically a read only set.

7625
05:35:36,260 --> 05:35:39,360
If we wanna create a mutable
set, you would actually,

7626
05:35:39,360 --> 05:35:41,490
which through the set you can change.

7627
05:35:41,490 --> 05:35:44,440
And again, you could
specify this differently.

7628
05:35:44,440 --> 05:35:48,940
This is also gonna be known
as basically a set of string.

7629
05:35:48,940 --> 05:35:50,910
That's the way you could do this.

7630
05:35:50,910 --> 05:35:52,880
Instead of string, of course,
this is not the helper method

7631
05:35:52,880 --> 05:35:54,460
doesn't work this way,
but that's what this is,

7632
05:35:54,460 --> 05:35:55,500
is a set of string.

7633
05:35:56,850 --> 05:35:59,399
If you wanna create a mutable set of,

7634
05:35:59,399 --> 05:36:01,130
you would do like this and
we don't need to provide

7635
05:36:01,130 --> 05:36:03,430
the type parameters
because they are inferred.

7636
05:36:04,606 --> 05:36:06,500
If you wanna add something,
you'd just say names.add,

7637
05:36:06,500 --> 05:36:07,780
use the add method.

7638
05:36:07,780 --> 05:36:10,080
And here, we're gonna
go ahead and say, Jenny.

7639
05:36:12,690 --> 05:36:15,430
Yeah, go ahead and print line names.

7640
05:36:16,330 --> 05:36:19,280
And when we print that again,
we should now see Don, John,

7641
05:36:19,280 --> 05:36:20,560
Felicia and Jenny.

7642
05:36:20,560 --> 05:36:24,080
Now what happens here
if we try to add Donn in

7643
05:36:25,379 --> 05:36:27,404
and let's go ahead and print it again.

7644
05:36:27,404 --> 05:36:28,237
Now Donn already exists in there.

7645
05:36:28,237 --> 05:36:30,300
So if we run this and
see what happens now,

7646
05:36:31,230 --> 05:36:33,716
we'll see that Donn is not added again.

7647
05:36:33,716 --> 05:36:35,590
So the set is remaining unique.

7648
05:36:35,590 --> 05:36:37,380
Each item in the set is unique.

7649
05:36:37,380 --> 05:36:40,930
So the supplies for, if you're
gonna have your strings,

7650
05:36:40,930 --> 05:36:42,340
your inner integers, et cetera,

7651
05:36:42,340 --> 05:36:43,960
each item in a set is unique.

7652
05:36:45,860 --> 05:36:47,520
Now let's take this a
little bit further here.

7653
05:36:47,520 --> 05:36:49,740
We've kind of understand what we can do

7654
05:36:49,740 --> 05:36:51,260
for duplicate names here.

7655
05:36:51,260 --> 05:36:53,650
If Donn is up here twice,
it's not gonna show,

7656
05:36:53,650 --> 05:36:55,760
but now what if we have a class?

7657
05:36:56,756 --> 05:36:57,589
So we have an object.

7658
05:36:57,589 --> 05:37:01,980
So an object should not have
duplicate values in there

7659
05:37:03,100 --> 05:37:03,933
for a set.

7660
05:37:05,491 --> 05:37:06,970
Now, however, if I've
added a person class here

7661
05:37:06,970 --> 05:37:11,860
that just has a name, and
then I add two people to this,

7662
05:37:11,860 --> 05:37:14,870
two persons to this people set,

7663
05:37:16,260 --> 05:37:19,630
we should technically only
see one Donn in there.

7664
05:37:19,630 --> 05:37:22,050
Now, when we run this, we
actually see two persons.

7665
05:37:23,345 --> 05:37:24,840
And notice this little
number here at the end.

7666
05:37:24,840 --> 05:37:26,260
I'm not gonna get into
the details of what it is,

7667
05:37:26,260 --> 05:37:28,290
but this basically is saying,

7668
05:37:28,290 --> 05:37:30,010
look, these are different objects.

7669
05:37:31,130 --> 05:37:33,928
And so the equality checks inside of here

7670
05:37:33,928 --> 05:37:34,761
are not being done.

7671
05:37:34,761 --> 05:37:36,350
Now, a way you can implement
these equality checks

7672
05:37:36,350 --> 05:37:38,160
inside of your classes with the equals

7673
05:37:38,160 --> 05:37:42,490
and overriding all the proper
methods to ensure equality

7674
05:37:42,490 --> 05:37:43,340
instead of your classes.

7675
05:37:43,340 --> 05:37:45,670
However, if these are just
classes that are going

7676
05:37:45,670 --> 05:37:48,170
to hold data such as this one is,

7677
05:37:48,170 --> 05:37:49,400
then what you can do is
you can just turn this

7678
05:37:49,400 --> 05:37:50,490
into a data class.

7679
05:37:50,490 --> 05:37:52,880
And use this as a data class
it'll work the same way,

7680
05:37:52,880 --> 05:37:55,080
but all these equality checks
are already done for you.

7681
05:37:55,080 --> 05:37:57,300
It's comparing all the fields, et cetera

7682
05:37:57,300 --> 05:37:59,862
to see if they're exactly the same.

7683
05:37:59,862 --> 05:38:02,462
So now if we run this, I'm
basically adding two Dons

7684
05:38:03,320 --> 05:38:06,070
to the set of the same data class and say,

7685
05:38:06,070 --> 05:38:08,523
nope, no, no, it's not gonna allow it.

7686
05:38:08,523 --> 05:38:09,640
So I could come up here
and add another one.

7687
05:38:10,823 --> 05:38:13,270
Now I'm really sure I don't
wanna add Donn three times.

7688
05:38:13,270 --> 05:38:14,610
What will happen is it
will come back and say,

7689
05:38:14,610 --> 05:38:15,720
nope, there's only one.

7690
05:38:15,720 --> 05:38:18,740
And so then I can actually
maybe just change this one

7691
05:38:18,740 --> 05:38:23,420
to, let's do this one is Janet, run here,

7692
05:38:24,680 --> 05:38:27,180
we'll see there's Don,
there's Janet inside of there.

7693
05:38:27,180 --> 05:38:31,320
So there's the set is
not allowing multiple

7694
05:38:31,320 --> 05:38:34,160
different versions in here of
the different types of folks.

7695
05:38:34,160 --> 05:38:35,330
Again, so you have a mutable set.

7696
05:38:35,330 --> 05:38:39,390
So this is very much a very
kind of Kotlin specific idiom.

7697
05:38:39,390 --> 05:38:41,230
You have immutable and mutable.

7698
05:38:41,230 --> 05:38:42,960
By default everything's immutable.

7699
05:38:42,960 --> 05:38:44,640
So you need to think about this,

7700
05:38:44,640 --> 05:38:46,070
if you want something to be mutable,

7701
05:38:46,070 --> 05:38:48,460
you need to tell Kotlin,
hey, this is a mutable list,

7702
05:38:48,460 --> 05:38:51,580
this is a mutable map,
this is a mutable set.

7703
05:38:51,580 --> 05:38:53,960
And if you need it to be unique,

7704
05:38:53,960 --> 05:38:55,330
like a list of data to be unique,

7705
05:38:55,330 --> 05:38:56,930
then you should be using a set.

7706
05:38:56,930 --> 05:38:58,200
And if you're gonna be using classes,

7707
05:38:58,200 --> 05:38:59,820
you wanna make sure
that the equality checks

7708
05:38:59,820 --> 05:39:01,790
are implemented correctly
in your given class

7709
05:39:01,790 --> 05:39:03,370
or you're using a data class.

7710
05:39:05,560 --> 05:39:08,850
Loops are one of the most common
structures in programming.

7711
05:39:08,850 --> 05:39:10,790
And for loops are gonna be
something you've probably used

7712
05:39:10,790 --> 05:39:11,740
in other languages.

7713
05:39:12,708 --> 05:39:13,660
If not, they're gonna be something

7714
05:39:13,660 --> 05:39:15,770
you'll be very familiar with.

7715
05:39:15,770 --> 05:39:19,950
So let's assume we have a list
of values and those values

7716
05:39:19,950 --> 05:39:24,950
are maybe integers one, two,
three, four, five, six, seven.

7717
05:39:28,430 --> 05:39:31,290
You can iterate over these
or perform various different

7718
05:39:31,290 --> 05:39:33,560
operations of them pretty easily.

7719
05:39:33,560 --> 05:39:35,230
The first thing you can do is
just iterate over the list.

7720
05:39:35,230 --> 05:39:40,230
You can say for number and
values, print line number.

7721
05:39:44,010 --> 05:39:46,980
And what this is, it says for every value

7722
05:39:46,980 --> 05:39:49,472
that's inside of here, we're
gonna give it a variable

7723
05:39:49,472 --> 05:39:51,384
called number, and we
wanna print that number.

7724
05:39:51,384 --> 05:39:52,870
And if we run this, we'll
see one, two, three, four,

7725
05:39:52,870 --> 05:39:54,400
five, six, seven is printed.

7726
05:39:54,400 --> 05:39:55,860
So now I can call this something else.

7727
05:39:55,860 --> 05:39:58,280
This doesn't have to be called number,

7728
05:39:58,280 --> 05:40:02,370
this could be called a chicken,
I mean, just for whatever,

7729
05:40:02,370 --> 05:40:04,120
just for purposes of demonstration,

7730
05:40:04,120 --> 05:40:06,270
this can be anything you want it to be.

7731
05:40:06,270 --> 05:40:07,280
It's gonna print the value.

7732
05:40:07,280 --> 05:40:09,310
And this is each value that's in this list

7733
05:40:09,310 --> 05:40:10,720
will be put inside of here.

7734
05:40:10,720 --> 05:40:13,860
So the same thing goes for
these primitive values.

7735
05:40:13,860 --> 05:40:18,090
It could be names, it could
be anything of that nature.

7736
05:40:18,090 --> 05:40:20,310
And then again, well
that changes from chicken

7737
05:40:20,310 --> 05:40:24,140
'cause doesn't make sense, but
to name, we'll run it again

7738
05:40:25,190 --> 05:40:27,482
and we'll see Don, Bob, Janus.

7739
05:40:27,482 --> 05:40:29,280
That's each one of those
values in that list

7740
05:40:29,280 --> 05:40:32,910
and that's how we can kind of
iterate quickly over a list

7741
05:40:32,910 --> 05:40:34,000
using a four loop.

7742
05:40:34,920 --> 05:40:37,180
Now there's also ways you can do it

7743
05:40:37,180 --> 05:40:38,890
if you wanna do some type of counting.

7744
05:40:38,890 --> 05:40:43,760
For example, if we wanted to
say for I in zero until 10,

7745
05:40:51,110 --> 05:40:52,050
we could print a letter I.

7746
05:40:52,050 --> 05:40:53,930
Now we're used to seeing
I as a counter variable

7747
05:40:53,930 --> 05:40:55,740
in very many languages.

7748
05:40:55,740 --> 05:40:58,590
And you'll see here, what's
happening is I is defined

7749
05:40:58,590 --> 05:41:01,710
as an integer in zero until 10.

7750
05:41:01,710 --> 05:41:04,260
So it says it starts to
zero up until we hit 10,

7751
05:41:04,260 --> 05:41:05,190
We wanna do something.

7752
05:41:05,190 --> 05:41:07,370
So each time it's just
gonna iterate and increment

7753
05:41:07,370 --> 05:41:12,280
the variable value by one, so
we have zero through 10 here.

7754
05:41:12,280 --> 05:41:14,574
Now there's also nothing you can do.

7755
05:41:14,574 --> 05:41:16,710
So that's a very common
way to do some looping

7756
05:41:16,710 --> 05:41:18,080
and you can set this
as a variable up here.

7757
05:41:18,080 --> 05:41:22,540
So 'cause that val say upper limit is 10.

7758
05:41:22,540 --> 05:41:25,330
And so you can say until upper limit.

7759
05:41:26,890 --> 05:41:30,350
Or you could say here's
another way, you stop.

7760
05:41:31,210 --> 05:41:35,770
So stop and then you can make
another one called start.

7761
05:41:35,770 --> 05:41:38,040
So there's all different types
of ways that you can do this

7762
05:41:38,040 --> 05:41:39,311
in your code.

7763
05:41:39,311 --> 05:41:41,310
And it's up to you
depending on the situation.

7764
05:41:43,540 --> 05:41:44,970
For I and start until stop.

7765
05:41:46,030 --> 05:41:47,120
I mean, it doesn't really make sense

7766
05:41:47,120 --> 05:41:48,930
'cause then I have to go find
what start and stop means.

7767
05:41:48,930 --> 05:41:51,790
But as it's just a demonstration
that you can run this

7768
05:41:51,790 --> 05:41:54,148
and it'll still execute accordingly.

7769
05:41:54,148 --> 05:41:55,700
So I'm gonna undo this here
and we're gonna go back

7770
05:41:55,700 --> 05:41:57,770
to how it was before until 10.

7771
05:41:58,940 --> 05:42:00,690
Now you can also perform stepping.

7772
05:42:01,930 --> 05:42:06,855
So what this says is for I in zero to 10,

7773
05:42:06,855 --> 05:42:09,040
I want you to step by two.

7774
05:42:09,040 --> 05:42:12,350
What that means is basically count by two

7775
05:42:12,350 --> 05:42:13,183
as we're iterating.

7776
05:42:13,183 --> 05:42:15,650
So instead of incrementing
by one, increment by two.

7777
05:42:15,650 --> 05:42:18,580
So therefore you see
two, four, six, eight.

7778
05:42:18,580 --> 05:42:21,570
So if I were to jump this
up to, let's go to 100.

7779
05:42:22,460 --> 05:42:24,988
We're gonna see it's gonna count by twos

7780
05:42:24,988 --> 05:42:26,050
all the way up until 100.

7781
05:42:26,050 --> 05:42:27,450
And there it has done here at the bottom.

7782
05:42:27,450 --> 05:42:31,610
Now I can say step 10
and that's gonna iterate

7783
05:42:31,610 --> 05:42:33,110
all the way up to 100.

7784
05:42:34,095 --> 05:42:36,135
So we're gonna see starting
at zero all the way up

7785
05:42:36,135 --> 05:42:37,560
until 100, and I've had to do step five,

7786
05:42:37,560 --> 05:42:40,350
of course is just gonna
run it till it's five

7787
05:42:40,350 --> 05:42:41,900
and then it'll iterate upwards.

7788
05:42:43,110 --> 05:42:46,090
Now you can also do it the opposite way.

7789
05:42:46,090 --> 05:42:48,780
So let's go down to the step,
let's get rid of step again.

7790
05:42:50,500 --> 05:42:53,690
So we have item 100 down to zero.

7791
05:42:53,690 --> 05:42:56,490
So this will be basically
a reverse for loop.

7792
05:42:56,490 --> 05:42:58,460
So it's gonna count from 100 down to zero

7793
05:42:58,460 --> 05:43:00,780
and it's gonna increment
by one by default.

7794
05:43:00,780 --> 05:43:02,680
Now again, I could do step two here

7795
05:43:04,091 --> 05:43:06,891
and that's gonna count down
by two or I could do step 10

7796
05:43:08,784 --> 05:43:09,620
and then we're gonna
have 100 all the way down

7797
05:43:09,620 --> 05:43:11,260
until 10 to zero.

7798
05:43:12,530 --> 05:43:15,560
So we can see here on the
100 all the way down to zero.

7799
05:43:15,560 --> 05:43:17,010
It's all one more step by 10.

7800
05:43:18,750 --> 05:43:20,790
Now the last thing you
could have possibly,

7801
05:43:21,666 --> 05:43:23,040
let's take a simple class like,

7802
05:43:24,054 --> 05:43:26,090
let's create a quick
data class called person.

7803
05:43:28,075 --> 05:43:29,720
And this person of course
is gonna have a name,

7804
05:43:30,770 --> 05:43:32,040
which is a string.

7805
05:43:32,040 --> 05:43:33,280
And let's create a
couple of people up here.

7806
05:43:33,280 --> 05:43:38,280
So we'll say val people
equals list of I'm gonna say

7807
05:43:38,700 --> 05:43:43,700
person Don, person Jane, person Karthik.

7808
05:43:50,890 --> 05:43:53,120
And then what we'll do inside of here,

7809
05:43:53,120 --> 05:43:58,120
we'll say for I and people
we're gonna print the people.

7810
05:44:02,170 --> 05:44:04,330
And so you can iterate
over objects as well.

7811
05:44:04,330 --> 05:44:06,800
So here we're either writing
over each item in a list,

7812
05:44:06,800 --> 05:44:10,064
just using a simple for
loop inside of Kotlin

7813
05:44:10,064 --> 05:44:12,520
and that's how you can
use a for loop and Kotlin.

7814
05:44:13,920 --> 05:44:16,290
A while loop in Kotlin
is very easy to create.

7815
05:44:17,370 --> 05:44:21,570
So we'll say while X is less than 10,

7816
05:44:21,570 --> 05:44:24,114
we wanna perform some type of operation.

7817
05:44:24,114 --> 05:44:26,640
So here we'll say print line X.

7818
05:44:26,640 --> 05:44:28,880
And then what we need to do
is increment the X value.

7819
05:44:28,880 --> 05:44:30,610
So it continues to increment upwards

7820
05:44:30,610 --> 05:44:32,740
as we are progressing through the loop.

7821
05:44:32,740 --> 05:44:35,560
And if we run this, what
we'll see is while X

7822
05:44:35,560 --> 05:44:38,320
is less than 10, we
perform some operation.

7823
05:44:38,320 --> 05:44:40,490
Now a while loop is very
useful where you need

7824
05:44:40,490 --> 05:44:44,210
to do something while a
particular condition is met.

7825
05:44:44,210 --> 05:44:47,830
And so this could be maybe you
need to be running something

7826
05:44:47,830 --> 05:44:50,910
in a loop the entire time and only do it

7827
05:44:50,910 --> 05:44:53,350
when maybe perhaps a
certain button is pressed

7828
05:44:54,598 --> 05:44:55,431
that needs X it out.

7829
05:44:55,431 --> 05:44:58,440
Now, for example, if I forget
to set this X variable here

7830
05:44:58,440 --> 05:45:01,650
and increment it and I run
this, watch the terminal window,

7831
05:45:01,650 --> 05:45:03,530
I'm gonna stop this pretty quickly,

7832
05:45:03,530 --> 05:45:05,150
but then we're gonna stop it now.

7833
05:45:06,120 --> 05:45:10,090
But this is a very long scroll of zeroes.

7834
05:45:10,090 --> 05:45:13,240
I mean I'm scrolling a lot
and it's barely moving.

7835
05:45:13,240 --> 05:45:17,510
If I let that run, most
likely the IDE would have had

7836
05:45:17,510 --> 05:45:21,160
out of memory exception or
stack overflow exception

7837
05:45:21,160 --> 05:45:24,770
because it's continuing to print
line over and over and over

7838
05:45:24,770 --> 05:45:26,340
and over and over and over and over

7839
05:45:26,340 --> 05:45:28,410
and this loop is never going to stop.

7840
05:45:28,410 --> 05:45:30,220
This is basically an
infinite loop at this point

7841
05:45:30,220 --> 05:45:32,630
because there is no termination

7842
05:45:32,630 --> 05:45:34,575
that's being provided by it.

7843
05:45:34,575 --> 05:45:36,590
And when we increment this X value,

7844
05:45:36,590 --> 05:45:39,210
we're actually incrementing
the X and eventually

7845
05:45:39,210 --> 05:45:42,990
this expression will end up being false.

7846
05:45:42,990 --> 05:45:46,640
And so as soon as it hits
false, the loop will exit.

7847
05:45:46,640 --> 05:45:48,210
and then the next line of code will run.

7848
05:45:48,210 --> 05:45:52,503
So say print line, let
me see this all done.

7849
05:45:54,250 --> 05:45:59,250
If we run this now, see all
done is printed afterwards.

7850
05:45:59,510 --> 05:46:02,780
And if we just let this
go for 100 or whatever,

7851
05:46:02,780 --> 05:46:04,250
then it could be a problem.

7852
05:46:04,250 --> 05:46:07,430
Now, a lot of times folks
will actually run these

7853
05:46:07,430 --> 05:46:10,090
while loops in various different
programs in the backend

7854
05:46:10,090 --> 05:46:12,500
and incline applications
while they're waiting

7855
05:46:12,500 --> 05:46:14,150
for a file to process
while they're waiting

7856
05:46:14,150 --> 05:46:15,160
for something to happen.

7857
05:46:15,160 --> 05:46:17,856
Perhaps they put asleep command in here

7858
05:46:17,856 --> 05:46:18,689
for the thread to sleep.

7859
05:46:18,689 --> 05:46:20,530
And again, there's pros
and cons of all this.

7860
05:46:20,530 --> 05:46:22,680
I'm not telling you and
advocating to you sleep

7861
05:46:22,680 --> 05:46:25,870
inside of your code, that's
usually a code smell.

7862
05:46:25,870 --> 05:46:29,300
However you'll wanna
understand when is a good time

7863
05:46:29,300 --> 05:46:30,230
to use a while loop.

7864
05:46:30,230 --> 05:46:32,420
A lot of games, stuff like
that use a lot of while loops

7865
05:46:32,420 --> 05:46:34,650
to keep things running in a game loop.

7866
05:46:34,650 --> 05:46:36,650
So while loops you'll need to make sure

7867
05:46:36,650 --> 05:46:39,150
that everything's going to
run inside of the while loop

7868
05:46:39,150 --> 05:46:41,720
inside of between these two brackets,

7869
05:46:41,720 --> 05:46:44,550
everything is gonna run while
this expression is true.

7870
05:46:45,500 --> 05:46:48,520
And so this could equate
to be some type of value

7871
05:46:48,520 --> 05:46:52,250
and perhaps this root loop
runs until a user presses

7872
05:46:52,250 --> 05:46:53,590
a particular button.

7873
05:46:53,590 --> 05:46:56,180
Maybe it's drawing something on the screen

7874
05:46:56,180 --> 05:46:58,700
and you're determining
where to render things.

7875
05:46:58,700 --> 05:47:01,050
A while loop is a perfect
opportunity to do that.

7876
05:47:01,050 --> 05:47:02,920
I need something to happen
over and over and over

7877
05:47:02,920 --> 05:47:05,990
until an exact particular
condition has been met.

7878
05:47:05,990 --> 05:47:08,200
That's when you're gonna
wanna use while loop.

7879
05:47:08,200 --> 05:47:10,630
And that's what you can
do is this can be a very,

7880
05:47:10,630 --> 05:47:13,067
this could be a method call inside of here

7881
05:47:13,067 --> 05:47:16,430
if you want it to be, this
could be a fun is okay too,

7882
05:47:16,430 --> 05:47:19,600
or like keep going, how would
you want to try Boolean.

7883
05:47:19,600 --> 05:47:23,180
And at this point you could
have some code in here.

7884
05:47:23,180 --> 05:47:26,390
It says return, true or false,

7885
05:47:27,290 --> 05:47:28,520
true or false in this point,

7886
05:47:28,520 --> 05:47:30,210
we'll say true for whatever reason.

7887
05:47:31,140 --> 05:47:33,744
And you could actually just
call it this right here.

7888
05:47:33,744 --> 05:47:34,577
So we'll keep going.

7889
05:47:34,577 --> 05:47:35,730
While keep going, blah, blah, blah.

7890
05:47:35,730 --> 05:47:38,300
And this method in here could be going out

7891
05:47:38,300 --> 05:47:42,280
and checking file system, checking an API,

7892
05:47:43,670 --> 05:47:47,620
waiting for an input or checking the input

7893
05:47:49,600 --> 05:47:52,400
or interrupts some form to say,

7894
05:47:52,400 --> 05:47:54,710
"Hey, should I continue
to go," and so forth.

7895
05:47:54,710 --> 05:47:57,030
So that's when you're gonna
wanna use a while loop

7896
05:47:57,030 --> 05:47:58,430
in Kotlin and how to use it.

7897
05:47:59,280 --> 05:48:02,510
Let's assume that you have a
list of people here in a list.

7898
05:48:02,510 --> 05:48:04,930
Now you could, of course,
go ahead and iterate

7899
05:48:04,930 --> 05:48:08,560
over each one of these
inside of people like this,

7900
05:48:08,560 --> 05:48:09,700
for I and people.

7901
05:48:09,700 --> 05:48:12,840
And you could print line
each one of these people

7902
05:48:12,840 --> 05:48:15,330
inside of this list, and
this will work just fine.

7903
05:48:15,330 --> 05:48:17,310
There's nothing wrong with this.

7904
05:48:17,310 --> 05:48:20,240
In fact, many people
probably do this day to day

7905
05:48:20,240 --> 05:48:21,130
and it works.

7906
05:48:22,596 --> 05:48:24,450
However, there is a more
idiomatic way to do it in Kotlin

7907
05:48:24,450 --> 05:48:26,340
and you can use the Kotlin
collections to view that.

7908
05:48:26,340 --> 05:48:30,190
So you can say, people
dot, you can say for each,

7909
05:48:30,190 --> 05:48:32,660
for each, for each here,

7910
05:48:32,660 --> 05:48:36,200
and then what you can say is
print ln, and then you DIT.

7911
05:48:37,160 --> 05:48:39,830
And that's basically ended
the same exact thing for you.

7912
05:48:39,830 --> 05:48:42,290
It's gonna allow you to
iterate over each item inside

7913
05:48:42,290 --> 05:48:44,280
of the array, but allows you to say,

7914
05:48:44,280 --> 05:48:46,280
"Hey, for each item and this array,

7915
05:48:46,280 --> 05:48:48,600
"do some particular function."

7916
05:48:48,600 --> 05:48:51,710
Anytime I'm working with a list, a map,

7917
05:48:51,710 --> 05:48:54,160
some type of collection
array or whatever it is,

7918
05:48:54,160 --> 05:48:56,760
if it's a, some type of
collection inside of Kotlin,

7919
05:48:57,895 --> 05:48:59,340
I'll always wanna prefer to use iteration

7920
05:48:59,340 --> 05:49:01,360
on the actual list itself.

7921
05:49:01,360 --> 05:49:03,480
It makes it much easier
unless I'm modifying the list

7922
05:49:03,480 --> 05:49:04,810
and I need to do something with a list.

7923
05:49:04,810 --> 05:49:07,410
And then I might use a
different type of loop structure

7924
05:49:07,410 --> 05:49:08,460
around it.

7925
05:49:08,460 --> 05:49:10,490
But for the most part, for
most of the operations,

7926
05:49:10,490 --> 05:49:15,210
I'll have, I'll prefer to use
the actual, each operator.

7927
05:49:15,210 --> 05:49:17,710
So I can iterate each over
each one of those things

7928
05:49:17,710 --> 05:49:18,543
and so forth.

7929
05:49:18,543 --> 05:49:20,000
So another thing that you could do,

7930
05:49:20,000 --> 05:49:21,900
I mean, you can also,
as we've seen before,

7931
05:49:21,900 --> 05:49:25,700
you can perhaps map these
things together and say map,

7932
05:49:25,700 --> 05:49:29,820
I could say a sub string of
each one of these things,

7933
05:49:29,820 --> 05:49:32,900
and it would be it.name.sub string.

7934
05:49:34,210 --> 05:49:36,430
I'll actually just take each
person's name and then I can do

7935
05:49:36,430 --> 05:49:39,290
for each and then I can
perform some operation on that.

7936
05:49:39,290 --> 05:49:43,150
And I could say something
like it.to upper case.

7937
05:49:45,830 --> 05:49:47,320
So I kind of start chaining all these

7938
05:49:47,320 --> 05:49:48,153
different things together.

7939
05:49:48,153 --> 05:49:50,260
And as soon as I get one or two
of these things in the line,

7940
05:49:50,260 --> 05:49:52,010
I'd like to kind of drop them here.

7941
05:49:52,939 --> 05:49:57,090
And then I might say for
each, and I can do a map

7942
05:49:57,090 --> 05:49:57,980
on top of this.

7943
05:49:57,980 --> 05:50:01,740
Actually, I can do another
map here if I want to.

7944
05:50:01,740 --> 05:50:03,810
And then as soon as I have that list down

7945
05:50:03,810 --> 05:50:05,460
and I wanna do something with it,

7946
05:50:06,308 --> 05:50:07,141
I can then do four each over it.

7947
05:50:07,141 --> 05:50:10,260
Now for each returns a unit,
which means it's just a unit.

7948
05:50:10,260 --> 05:50:11,530
It doesn't return on our map,

7949
05:50:11,530 --> 05:50:14,940
which is why I was not able
to add a map operator before.

7950
05:50:14,940 --> 05:50:17,428
So if I wanted to do something
additionally to this,

7951
05:50:17,428 --> 05:50:19,396
to transform these values,

7952
05:50:19,396 --> 05:50:22,960
I would before map here
and say it.to uppercase

7953
05:50:24,340 --> 05:50:28,170
and we can turn through this.reverse.

7954
05:50:32,920 --> 05:50:35,030
And if we ran this, we
would see each person's name

7955
05:50:35,030 --> 05:50:36,490
is upper case and reversed,

7956
05:50:38,180 --> 05:50:41,200
but we did not print it,
which is the problem.

7957
05:50:41,200 --> 05:50:43,460
And here, when we actually
print it to the screen,

7958
05:50:43,460 --> 05:50:48,460
we'll see everything here
will be all the names reversed

7959
05:50:49,390 --> 05:50:51,400
and upper cased in there.

7960
05:50:51,400 --> 05:50:53,630
So again, if you're going to be using

7961
05:50:53,630 --> 05:50:54,780
any of the Kotlin collections,

7962
05:50:54,780 --> 05:50:57,897
I highly recommend using
the for each operator

7963
05:50:57,897 --> 05:50:59,220
to iterate over a collection.

7964
05:50:59,220 --> 05:51:01,340
It's much more idiomatic
and easier to read

7965
05:51:01,340 --> 05:51:02,490
and actually less code.

7966
05:51:04,260 --> 05:51:07,090
Very often in Kotlin you'll
receive multiple lists

7967
05:51:07,961 --> 05:51:09,240
and you need to combine
those lists into a list

7968
05:51:09,240 --> 05:51:11,420
that does not contain duplicate elements.

7969
05:51:12,320 --> 05:51:14,720
Now you could iterate over
both lists and check to see

7970
05:51:14,720 --> 05:51:16,550
if either one contains a value

7971
05:51:16,550 --> 05:51:19,390
and if it does then not include it.

7972
05:51:19,390 --> 05:51:21,700
So each item in the new list is unique.

7973
05:51:21,700 --> 05:51:23,270
And that's usually what you're after.

7974
05:51:23,270 --> 05:51:26,050
Is a list who has a unique values

7975
05:51:26,050 --> 05:51:28,780
but really at the end of the
day what you're looking for

7976
05:51:28,780 --> 05:51:32,950
is actually a set and a
set, if you look at it,

7977
05:51:32,950 --> 05:51:34,740
is a generic unordered
collection of elements

7978
05:51:34,740 --> 05:51:36,820
that does not support duplicate elements.

7979
05:51:36,820 --> 05:51:40,330
And that's line 252 here,
this is in the collections

7980
05:51:40,330 --> 05:51:42,760
class of the Kotlin standard library.

7981
05:51:42,760 --> 05:51:45,510
So basically I set is
an order to collection

7982
05:51:45,510 --> 05:51:48,480
that does not support duplicate elements.

7983
05:51:48,480 --> 05:51:50,750
Now, thankfully, there are some utilities

7984
05:51:50,750 --> 05:51:52,850
built into the Kotlin collections library

7985
05:51:52,850 --> 05:51:54,510
that allow you to do this real easily.

7986
05:51:54,510 --> 05:51:58,340
So here we have two
different lists of people.

7987
05:51:58,340 --> 05:52:00,440
This one is Don, Jake, Janet, Cavita,

7988
05:52:00,440 --> 05:52:05,380
and this list has Don, Janet,
Jumo, Cavita, Kevin and Kathy.

7989
05:52:05,380 --> 05:52:07,780
For whatever reason,
there's in both lists,

7990
05:52:07,780 --> 05:52:08,810
both people are present.

7991
05:52:08,810 --> 05:52:11,760
Now, maybe this could be
because these could be groups

7992
05:52:11,760 --> 05:52:14,400
that are on a popular site that you have,

7993
05:52:14,400 --> 05:52:17,480
or maybe you're building an
event management platform.

7994
05:52:19,344 --> 05:52:21,590
And so Donn and Janet
and Cavita are both going

7995
05:52:21,590 --> 05:52:23,990
to these two events, but
there's some differences here.

7996
05:52:23,990 --> 05:52:27,050
But you wanna find all the
unique people that are there.

7997
05:52:27,050 --> 05:52:30,100
So this could happen for
one, two lists, 100 lists,

7998
05:52:30,100 --> 05:52:32,260
and you need to find out
which ones are unique.

7999
05:52:32,260 --> 05:52:33,930
Now, there is a built-in
operator to do that.

8000
05:52:33,930 --> 05:52:36,410
So say val, unique values.

8001
05:52:37,850 --> 05:52:40,820
And all we really have to
do is say people.union,

8002
05:52:41,690 --> 05:52:43,000
more people.

8003
05:52:43,000 --> 05:52:46,770
And what union will do is
a return a set containing

8004
05:52:46,770 --> 05:52:48,950
all the distinct elements
from both collections.

8005
05:52:48,950 --> 05:52:50,980
And it's gonna return a set of the values.

8006
05:52:50,980 --> 05:52:53,360
So a set of whatever type it is,

8007
05:52:53,360 --> 05:52:55,370
and this tastes we're using persons.

8008
05:52:55,370 --> 05:52:57,200
So what it will do is
it'll look inside of here

8009
05:52:57,200 --> 05:52:59,430
using the equality
operations on the data class,

8010
05:52:59,430 --> 05:53:01,910
which it checks, you know,
the values, et cetera.

8011
05:53:01,910 --> 05:53:04,550
And it'll check to make sure
that there's no duplicate.

8012
05:53:04,550 --> 05:53:09,040
And so now, if we were to run
this, so we'd say print ln,

8013
05:53:09,890 --> 05:53:13,990
unique values, we run this,
we'll see that we will only have

8014
05:53:13,990 --> 05:53:17,140
Donn inside of here once,
Jake is only in here once,

8015
05:53:17,140 --> 05:53:20,140
Janet's only here once to
Cavita, Jumo, Kevin and Kathleen.

8016
05:53:20,140 --> 05:53:23,110
There is no duplicates inside of here.

8017
05:53:23,110 --> 05:53:25,920
So even if you were to add
another one here, say a union

8018
05:53:25,920 --> 05:53:29,330
something else, and you could say person,

8019
05:53:29,330 --> 05:53:30,910
and again, you'd say maybe Donn again.

8020
05:53:30,910 --> 05:53:35,000
So the third time that Donn
is gonna be inside of there,

8021
05:53:35,000 --> 05:53:36,990
you'll see that it's still only added once

8022
05:53:36,990 --> 05:53:41,040
because the union operator will return you

8023
05:53:41,040 --> 05:53:43,610
the set containing all
the distinct elements

8024
05:53:43,610 --> 05:53:45,050
in both collections.

8025
05:53:45,050 --> 05:53:48,070
And that's how you can merge
multiple different lists

8026
05:53:48,070 --> 05:53:50,650
and return unique elements
across all of them

8027
05:53:50,650 --> 05:53:52,050
into one final set.

8028
05:53:53,440 --> 05:53:55,940
When working with list of
data, it's very often to want

8029
05:53:55,940 --> 05:53:59,580
to know the index of an item
as you're iterating over it.

8030
05:53:59,580 --> 05:54:03,090
With Kotlin's built-in for each iterator,

8031
05:54:03,090 --> 05:54:04,810
you don't have access to the index.

8032
05:54:04,810 --> 05:54:07,840
You only have access to the
value, which is the person.

8033
05:54:07,840 --> 05:54:10,410
However, there is an
overload that we can use

8034
05:54:10,410 --> 05:54:11,560
for each indexed.

8035
05:54:12,410 --> 05:54:13,960
This will allow us to use,

8036
05:54:13,960 --> 05:54:16,050
get us the index of the current operation

8037
05:54:16,050 --> 05:54:18,430
and the person at that given index.

8038
05:54:18,430 --> 05:54:20,820
So for example, if we
were to print line this,

8039
05:54:20,820 --> 05:54:22,560
we could see something like this:

8040
05:54:22,560 --> 05:54:25,210
it's an index and we'd use
string interpolation here.

8041
05:54:26,459 --> 05:54:27,650
And then we could say person,

8042
05:54:29,976 --> 05:54:33,500
and if we were to run this
and actually we can use move

8043
05:54:33,500 --> 05:54:36,340
the curly braces there
because the class will give us

8044
05:54:36,340 --> 05:54:37,590
a good two string method.

8045
05:54:39,054 --> 05:54:40,280
We'll see, when we print this out here,

8046
05:54:41,263 --> 05:54:43,140
we have the index zero
and the person objects

8047
05:54:43,140 --> 05:54:45,070
that's associated with the index zero.

8048
05:54:45,070 --> 05:54:47,010
Now this is very useful
if you're doing operations

8049
05:54:47,010 --> 05:54:49,580
in which you need the know the
index of a particular value

8050
05:54:49,580 --> 05:54:52,140
inside of that data structure
for whatever reason,

8051
05:54:52,140 --> 05:54:53,980
you now have the index
and you have the value

8052
05:54:53,980 --> 05:54:56,200
that's associated to that
given index to perform

8053
05:54:56,200 --> 05:54:58,020
whatever operation that you need.

8054
05:54:58,020 --> 05:54:59,410
So if you need that, you'll wanna use

8055
05:54:59,410 --> 05:55:02,360
the for each index operator.

8056
05:55:02,360 --> 05:55:05,007
We're using the lambda
expression version here.

8057
05:55:05,007 --> 05:55:07,560
You may also have seen us
with parentheses like this.

8058
05:55:07,560 --> 05:55:08,610
This will also work.

8059
05:55:08,610 --> 05:55:11,370
However, you'll notice that
IntelliJ or Android Studio,

8060
05:55:11,370 --> 05:55:13,800
whatever you're using,
will give you a hint here

8061
05:55:13,800 --> 05:55:15,280
that it does not need that.

8062
05:55:15,280 --> 05:55:16,410
This is a lambda argument

8063
05:55:16,410 --> 05:55:18,460
so it can be moved out of the parentheses.

8064
05:55:18,460 --> 05:55:20,400
Basically just remove the parentheses

8065
05:55:20,400 --> 05:55:22,460
and the lambda expression is parsed in

8066
05:55:22,460 --> 05:55:23,720
via the Sam operations.

8067
05:55:24,880 --> 05:55:26,880
And that's how you use for each indexed.

8068
05:55:27,920 --> 05:55:31,240
Arranging Kotlin allows us
to specify a range of values.

8069
05:55:32,334 --> 05:55:34,730
So here I'm specifying a range
of values from one to five

8070
05:55:34,730 --> 05:55:37,960
saying if the I is in within
this range of one to five,

8071
05:55:37,960 --> 05:55:42,850
then print the value yes,
otherwise, print the value no.

8072
05:55:42,850 --> 05:55:46,090
So if we were to change
this to 12 and rerun this,

8073
05:55:46,090 --> 05:55:47,790
we would see that the value of 12,

8074
05:55:48,704 --> 05:55:51,310
because I is not within
this range of one to five.

8075
05:55:51,310 --> 05:55:53,520
We can also say for J,

8076
05:55:58,320 --> 05:56:01,760
this will give us a range very
much a for loop variable now.

8077
05:56:01,760 --> 05:56:02,900
So I can say print ln.

8078
05:56:04,376 --> 05:56:07,170
So JN zero to 10, the
range again is zero to 10.

8079
05:56:07,170 --> 05:56:08,820
This is the range that
we're working within.

8080
05:56:08,820 --> 05:56:11,330
And so we could say J
and when we print this,

8081
05:56:12,537 --> 05:56:15,130
we're gonna see one through
10 printed down here.

8082
05:56:15,130 --> 05:56:18,280
Now, again, this is, if you're
familiar with the four loops

8083
05:56:18,280 --> 05:56:21,170
inside of Kotlin, you can
also provide stepping.

8084
05:56:21,170 --> 05:56:23,380
So I might decide to
say, I wanna step by two,

8085
05:56:23,380 --> 05:56:26,040
meaning that instead of
incrementing the value of one

8086
05:56:26,040 --> 05:56:29,790
for the J counter variable,
it's gonna increment by two.

8087
05:56:29,790 --> 05:56:33,580
So it's basically in this
range from zero to 10,

8088
05:56:33,580 --> 05:56:36,910
I want you to execute something
if J is within that value,

8089
05:56:36,910 --> 05:56:38,970
execute some code, count from zero to 10.

8090
05:56:38,970 --> 05:56:41,830
And then I want you to make a step of two,

8091
05:56:41,830 --> 05:56:45,490
which as we're gonna see down
here iterates from zero to two

8092
05:56:45,490 --> 05:56:47,710
to four, six, eight, 10.

8093
05:56:47,710 --> 05:56:49,940
And so every once in a
while, you will use ranges.

8094
05:56:49,940 --> 05:56:52,520
And of course these values
can be variables, et cetera.

8095
05:56:52,520 --> 05:56:55,780
So this is a very simple
implementation of how you can use

8096
05:56:55,780 --> 05:56:57,780
ranges to count inside of Kotlin.

8097
05:56:58,930 --> 05:57:02,470
A map is a very common data
structure in computer science.

8098
05:57:02,470 --> 05:57:04,560
A lot of times this would
be called a map hash map

8099
05:57:04,560 --> 05:57:05,500
or dictionary.

8100
05:57:05,500 --> 05:57:08,380
And basically it's a key
value pair that you can store

8101
05:57:08,380 --> 05:57:09,510
inside of a data structure.

8102
05:57:09,510 --> 05:57:11,180
And this is a map data structure.

8103
05:57:11,180 --> 05:57:14,880
To create one, you can use
the map of helper function

8104
05:57:14,880 --> 05:57:17,930
and this will actually let
you create an immutable map

8105
05:57:17,930 --> 05:57:18,763
of values.

8106
05:57:18,763 --> 05:57:21,740
And what this means is we'll
have a map where the keys

8107
05:57:21,740 --> 05:57:24,370
are strings and the values are strings.

8108
05:57:24,370 --> 05:57:27,404
The keys over here are over here,

8109
05:57:27,404 --> 05:57:29,690
which means NY maps to New York,

8110
05:57:29,690 --> 05:57:33,770
NJ maps to New Jersey and
CA maps to California.

8111
05:57:33,770 --> 05:57:36,800
And of course you can continue
mapping all these down there.

8112
05:57:36,800 --> 05:57:39,020
Then if you wanna get that
value, it's pretty easy.

8113
05:57:39,020 --> 05:57:41,720
You're gonna say, do say states.get,

8114
05:57:44,000 --> 05:57:45,750
and you can parse in the value of NY.

8115
05:57:45,750 --> 05:57:47,370
And then of course, we
would print line this

8116
05:57:47,370 --> 05:57:49,350
and see what the result is.

8117
05:57:49,350 --> 05:57:51,110
Now, as you're executing this,

8118
05:57:52,018 --> 05:57:52,851
you'll see that New
York has been returned.

8119
05:57:52,851 --> 05:57:56,690
However, if I were to type,
let's go FL for Florida

8120
05:57:56,690 --> 05:57:58,610
and run it, we're gonna
see that's not in there

8121
05:57:58,610 --> 05:58:00,860
and a null value is returned.

8122
05:58:00,860 --> 05:58:04,880
That is because it will
return the corresponding value

8123
05:58:04,880 --> 05:58:07,660
if it exists or null if
it's not present in the map.

8124
05:58:07,660 --> 05:58:10,540
So it's very often that
sometimes you'll wanna say

8125
05:58:10,540 --> 05:58:13,860
get or default if you
want a value to be known.

8126
05:58:13,860 --> 05:58:16,320
So I don't wanna work
with a nullable type.

8127
05:58:16,320 --> 05:58:18,790
So I'm gonna say unknown value.

8128
05:58:20,200 --> 05:58:24,350
And then at that point,
when I run FL we'll get back

8129
05:58:24,350 --> 05:58:25,680
unknown value that's printed out

8130
05:58:25,680 --> 05:58:27,900
down to the screen down here.

8131
05:58:27,900 --> 05:58:29,520
So that's one thing you can do.

8132
05:58:30,406 --> 05:58:32,150
You can also use get or else.

8133
05:58:32,150 --> 05:58:36,590
And or else is going to get
or else is gonna allow you

8134
05:58:36,590 --> 05:58:39,010
to provide a function
where you can actually

8135
05:58:40,330 --> 05:58:45,330
return some code, which could
be whatever, could be foo.

8136
05:58:46,470 --> 05:58:48,120
This is function that you're gonna call

8137
05:58:48,120 --> 05:58:51,170
that it's going to be invoked
when the default thing,

8138
05:58:51,170 --> 05:58:53,020
nothing can be found here to match FL.

8139
05:58:53,020 --> 05:58:54,890
So if I were to run this,

8140
05:58:54,890 --> 05:58:57,150
we're going to see that
when we say, get her else,

8141
05:58:57,150 --> 05:58:59,420
foo is being returned.

8142
05:58:59,420 --> 05:59:03,280
Now back to the original
method here of FL,

8143
05:59:03,280 --> 05:59:07,190
we saw that the squiggly
here inside of IntelliJ

8144
05:59:07,190 --> 05:59:09,480
is saying that we can
improve this through the,

8145
05:59:09,480 --> 05:59:12,640
basically the code improvements.

8146
05:59:12,640 --> 05:59:16,520
And when we press the light
bulb here to get that,

8147
05:59:16,520 --> 05:59:19,030
or over here, I'll be
able to just turn this

8148
05:59:19,030 --> 05:59:20,210
into an indexing operator.

8149
05:59:20,210 --> 05:59:23,510
So basically saying, hey,
state's just like an array index.

8150
05:59:23,510 --> 05:59:26,210
Give me the value for the key of FL.

8151
05:59:26,210 --> 05:59:29,003
And then of course it returns
back a nullable string,

8152
05:59:29,003 --> 05:59:30,060
and we're gonna get back null here.

8153
05:59:30,935 --> 05:59:32,090
A couple of other things
that are very useful

8154
05:59:32,090 --> 05:59:33,700
inside of matches.

8155
05:59:33,700 --> 05:59:36,220
You can check to see if a key is there,

8156
05:59:36,220 --> 05:59:38,290
so you can say, is there a key there,

8157
05:59:38,290 --> 05:59:39,640
returns a Boolean value.

8158
05:59:39,640 --> 05:59:41,470
If the key is there it'll return true.

8159
05:59:41,470 --> 05:59:43,670
We can also say, hey,
does this value exist?

8160
05:59:43,670 --> 05:59:47,250
And we know the value NY
does not exist as the values,

8161
05:59:47,250 --> 05:59:49,410
'cause the values are here
in New York, New Jersey,

8162
05:59:49,410 --> 05:59:50,990
California, those are the values.

8163
05:59:50,990 --> 05:59:53,240
These are the keys.

8164
05:59:53,240 --> 05:59:54,940
And so the values don't container.

8165
05:59:55,825 --> 05:59:56,890
So we can do that.

8166
05:59:56,890 --> 05:59:58,410
And so there's a whole
bunch of operations.

8167
05:59:58,410 --> 06:00:00,100
And if you're interested
to see what you can do,

8168
06:00:00,100 --> 06:00:03,540
because a map is part of the
collections library in Kotlin,

8169
06:00:03,540 --> 06:00:05,840
so we can actually get all the entries.

8170
06:00:05,840 --> 06:00:08,480
So, which is gonna be a set,
because remember, in a map,

8171
06:00:08,480 --> 06:00:10,470
we can't have a duplicate.

8172
06:00:10,470 --> 06:00:12,150
We can't have duplicate keys.

8173
06:00:12,150 --> 06:00:13,690
So key has to be unique.

8174
06:00:13,690 --> 06:00:15,550
So when get back to this result,

8175
06:00:15,550 --> 06:00:18,070
if we print this, this
will be a set of strings.

8176
06:00:19,246 --> 06:00:21,010
And we can see here,
there's all of our entries,

8177
06:00:21,010 --> 06:00:22,630
which is gonna be, for all the,

8178
06:00:23,544 --> 06:00:24,377
assuming it's gonna have
the keys and the values,

8179
06:00:24,377 --> 06:00:25,210
all the entries.

8180
06:00:26,140 --> 06:00:29,040
And then what we can do here
is also, we can see the keys.

8181
06:00:30,270 --> 06:00:31,330
So if we wanna look at the keys,

8182
06:00:31,330 --> 06:00:32,750
you can also inspect all of the keys,

8183
06:00:32,750 --> 06:00:35,100
which will return back NY, NJ and CA,

8184
06:00:35,100 --> 06:00:39,240
and of course you can inspect
the values across the board.

8185
06:00:39,240 --> 06:00:41,590
So you can start working with
all of these different types

8186
06:00:41,590 --> 06:00:42,920
of things in a map.

8187
06:00:42,920 --> 06:00:46,600
Now, that's how you can kind
of set up a regular immutable

8188
06:00:46,600 --> 06:00:47,910
map inside of Kotlin.

8189
06:00:49,460 --> 06:00:52,110
Just like lists, which can have a mutable

8190
06:00:52,110 --> 06:00:55,440
and immutable lists, you
can have immutable maps

8191
06:00:55,440 --> 06:00:56,840
and mutable maps.

8192
06:00:56,840 --> 06:01:00,210
And so if you were to create your map,

8193
06:01:00,210 --> 06:01:03,030
so we can just call this map,
actually call this items.

8194
06:01:04,180 --> 06:01:05,760
You can create a mutable map.

8195
06:01:06,630 --> 06:01:09,390
And what a mutable map
will do is it'll allow you

8196
06:01:09,390 --> 06:01:12,780
to add and remove items to the map.

8197
06:01:12,780 --> 06:01:14,240
So what we could say here again,

8198
06:01:14,240 --> 06:01:19,240
we could do the New York to New York.

8199
06:01:19,710 --> 06:01:21,510
And again, this is just gonna create a map

8200
06:01:21,510 --> 06:01:25,290
of basically state abbreviations
in the United States

8201
06:01:25,290 --> 06:01:29,590
to the actual full spelled out version.

8202
06:01:29,590 --> 06:01:31,410
And we'll just do the
same three that we have

8203
06:01:31,410 --> 06:01:33,320
for the immutable version,

8204
06:01:35,660 --> 06:01:38,260
which are New York,
New Jersey, California.

8205
06:01:38,260 --> 06:01:39,460
And of course you could
have all of them in here

8206
06:01:39,460 --> 06:01:40,860
if you want it to.

8207
06:01:40,860 --> 06:01:43,970
Now, at this point in time,
if I wanted to remove an item,

8208
06:01:49,190 --> 06:01:50,550
I would use the put command.

8209
06:01:50,550 --> 06:01:51,900
And then inside of the put command,

8210
06:01:51,900 --> 06:01:53,570
I would provide another key.

8211
06:01:53,570 --> 06:01:56,210
And so I could say TX and then the value,

8212
06:01:56,210 --> 06:01:58,010
what it would be, it would be Texas.

8213
06:01:59,410 --> 06:02:01,510
Now, notice how we have
a little squiggly here.

8214
06:02:01,510 --> 06:02:05,050
What this is telling us
is that the put method

8215
06:02:05,050 --> 06:02:07,040
can be converted into an assignment call.

8216
06:02:07,040 --> 06:02:10,118
So I'll hit Alt + Enter or
you can also just click on

8217
06:02:10,118 --> 06:02:12,960
the little light bulb right here

8218
06:02:12,960 --> 06:02:15,880
when you put my cursor here, there you go.

8219
06:02:18,265 --> 06:02:19,740
And we can just say, it looks like that.

8220
06:02:19,740 --> 06:02:21,060
I'm gonna leave it for put for now,

8221
06:02:21,060 --> 06:02:23,010
just 'cause it reads a little bit better

8222
06:02:23,880 --> 06:02:27,020
and we can print line so we
can see what this looks like.

8223
06:02:28,000 --> 06:02:31,380
And if we run this, we'll
see down in the output window

8224
06:02:31,380 --> 06:02:35,060
that we have one, two, three, four items.

8225
06:02:35,060 --> 06:02:38,700
So we said New York, New
Jersey, California, and Texas.

8226
06:02:38,700 --> 06:02:41,210
Now, if for some reason, I
wanted to, whatever reason,

8227
06:02:41,210 --> 06:02:43,510
to remove an item from
the state of structure,

8228
06:02:44,350 --> 06:02:49,230
I could say items remove
and all I have to do

8229
06:02:49,230 --> 06:02:50,430
is provide the key here.

8230
06:02:51,342 --> 06:02:52,250
And now to provide a key, I'm gonna say,

8231
06:02:52,250 --> 06:02:54,350
all right, I'd like to remove New York.

8232
06:02:54,350 --> 06:02:56,460
And then of course, I
wanna go ahead and validate

8233
06:02:56,460 --> 06:02:58,200
that our items were removed.

8234
06:02:59,720 --> 06:03:00,880
And if we go ahead and run that again,

8235
06:03:00,880 --> 06:03:04,480
we'll see that we now have the first call,

8236
06:03:04,480 --> 06:03:09,480
had all four items and the
next call had removed New York.

8237
06:03:13,420 --> 06:03:16,070
Now something interesting will happen here

8238
06:03:16,070 --> 06:03:16,990
inside of your code.

8239
06:03:16,990 --> 06:03:18,740
If you already have this list,

8240
06:03:18,740 --> 06:03:22,520
let's go ahead and remove
these we'll leave Texas.

8241
06:03:22,520 --> 06:03:24,370
And we decide to put an item in here.

8242
06:03:26,130 --> 06:03:28,340
And we decided to put New Jersey in,

8243
06:03:28,340 --> 06:03:31,720
though we already have New
Jersey up here on line five.

8244
06:03:31,720 --> 06:03:35,260
If we decide to put New
Jersey in, and we say Joisey,

8245
06:03:35,260 --> 06:03:38,030
because sometimes that's
how they say it out here.

8246
06:03:38,030 --> 06:03:39,380
And we print line.

8247
06:03:39,380 --> 06:03:41,740
We're gonna notice an interesting
thing will happen here.

8248
06:03:41,740 --> 06:03:42,930
And what happens is,

8249
06:03:44,291 --> 06:03:48,510
is that New Jersey is actually
replaced inside of the race.

8250
06:03:48,510 --> 06:03:51,770
So instead of New Jersey,
it's replaced with New Joisey.

8251
06:03:51,770 --> 06:03:54,300
So perhaps that was a mistake in our code.

8252
06:03:54,300 --> 06:03:56,440
Now it's perhaps created
a weird side effect

8253
06:03:56,440 --> 06:03:57,440
where there's a bug.

8254
06:03:58,926 --> 06:03:59,759
Now there's something you can do

8255
06:03:59,759 --> 06:04:00,592
to kind of help prevent this.

8256
06:04:00,592 --> 06:04:03,610
So if you thought that
New Jersey was there

8257
06:04:03,610 --> 06:04:05,330
and you didn't mean to overwrite it,

8258
06:04:05,330 --> 06:04:08,950
or you don't wanna override
it, you can say put if absent.

8259
06:04:08,950 --> 06:04:10,550
And what put, so if we run this,

8260
06:04:13,100 --> 06:04:15,370
we'll see is New Jersey
was not overwritten.

8261
06:04:15,370 --> 06:04:20,010
Why, because put if absent
will only put the item there

8262
06:04:20,010 --> 06:04:22,210
if we scroll up, we see
this, if the specified key

8263
06:04:22,210 --> 06:04:24,260
is not already associated with the value,

8264
06:04:25,470 --> 06:04:27,520
otherwise it'll return the current value.

8265
06:04:28,450 --> 06:04:31,420
So if we look back at
the code here, again,

8266
06:04:31,420 --> 06:04:32,950
it returned a value.

8267
06:04:32,950 --> 06:04:34,100
So what does it return?

8268
06:04:36,181 --> 06:04:37,210
Let's go ahead and check it out.

8269
06:04:38,050 --> 06:04:41,570
So say print line and
what this will return

8270
06:04:41,570 --> 06:04:43,910
is gonna be the item that
was currently existing

8271
06:04:43,910 --> 06:04:45,180
already for that key.

8272
06:04:46,320 --> 06:04:47,520
And so we're saying, hey,
put something in there

8273
06:04:47,520 --> 06:04:48,990
if it's absent.

8274
06:04:48,990 --> 06:04:51,180
Hey, I'm trying to put
something into this map

8275
06:04:51,180 --> 06:04:55,010
that has the key NJ,
and I wanna use Joisey.

8276
06:04:55,010 --> 06:04:56,340
And what it comes back is saying,

8277
06:04:56,340 --> 06:04:58,800
Well, just letting you know,
we already have something

8278
06:04:58,800 --> 06:05:01,220
in there, so we're gonna
go ahead and show you

8279
06:05:01,220 --> 06:05:03,150
what that is, and we're
not going to overwrite it.

8280
06:05:03,150 --> 06:05:05,970
So that's very useful, so
you don't overwrite anything.

8281
06:05:07,410 --> 06:05:11,120
Now on the flip side, let's
say for whatever reason,

8282
06:05:12,140 --> 06:05:16,210
we realized there are some,
you're allowing the user

8283
06:05:16,210 --> 06:05:20,740
to edit something on a screen
and they are removing items

8284
06:05:20,740 --> 06:05:22,230
and putting them et cetera.

8285
06:05:22,230 --> 06:05:25,490
And you want them to allow
them to remove something,

8286
06:05:25,490 --> 06:05:27,880
but only if the key and the value match.

8287
06:05:27,880 --> 06:05:31,520
So if I remove this, if I
say remove, what will happen

8288
06:05:31,520 --> 06:05:35,070
is New Jersey will be
removed from the list.

8289
06:05:35,070 --> 06:05:37,640
And we can see that when we run this.

8290
06:05:37,640 --> 06:05:42,080
But what if I wanna keep
New Jersey inside of there,

8291
06:05:42,080 --> 06:05:45,140
but I only wanna remove it
if somebody accidentally

8292
06:05:45,140 --> 06:05:46,940
kind of got wise was a wise guy and said,

8293
06:05:46,940 --> 06:05:49,280
"Hey, the data is Joisey."

8294
06:05:49,280 --> 06:05:53,760
So what this says is,
"Hey, only remove this key

8295
06:05:53,760 --> 06:05:56,030
"if its value is Joisey."

8296
06:05:56,030 --> 06:05:58,370
So let's go ahead and run
this and what we'll see down

8297
06:05:58,370 --> 06:06:02,040
the last print line is that
New Jersey was not removed.

8298
06:06:02,040 --> 06:06:04,630
So this key and the value stayed put,

8299
06:06:04,630 --> 06:06:08,670
because while it did find
a key for New Jersey,

8300
06:06:08,670 --> 06:06:09,930
it didn't match the value.

8301
06:06:09,930 --> 06:06:12,080
So the value Joisey was not removed.

8302
06:06:13,320 --> 06:06:15,240
Also sometimes during development
you'll need to retrieve

8303
06:06:15,240 --> 06:06:18,430
an item, but sometimes it won't be there,

8304
06:06:18,430 --> 06:06:19,790
but you do expect it to be there.

8305
06:06:19,790 --> 06:06:22,850
And if it's not there, you
would like to add it to the map.

8306
06:06:22,850 --> 06:06:24,800
There's actually something you can use

8307
06:06:24,800 --> 06:06:27,600
and that's called get or put,

8308
06:06:27,600 --> 06:06:31,850
and what that means returns
the value for the given key.

8309
06:06:31,850 --> 06:06:33,190
If the key is not found the map,

8310
06:06:33,190 --> 06:06:35,460
it calls a default value
function and puts its result

8311
06:06:35,460 --> 06:06:38,270
into the map under the
given key and returns it.

8312
06:06:38,270 --> 06:06:42,713
So if we go back here, so get or put

8313
06:06:46,100 --> 06:06:48,650
we're gonna take this key,
and we're gonna say, UT,

8314
06:06:51,142 --> 06:06:54,930
we'll say Utah, and notice
how it's giving us an error,

8315
06:06:54,930 --> 06:06:57,310
because it actually needs
to be an expression.

8316
06:06:57,310 --> 06:06:58,950
So it's a lambda
expression because perhaps

8317
06:06:58,950 --> 06:07:01,850
this needs to be a method that
goes out and does something

8318
06:07:02,730 --> 06:07:04,440
or a bunch of different things.

8319
06:07:04,440 --> 06:07:07,131
So it gives us the ability to do that.

8320
06:07:07,131 --> 06:07:08,420
So we're say Utah, and if we print this,

8321
06:07:09,351 --> 06:07:11,640
what we're now going to see
is because we have not ever

8322
06:07:11,640 --> 06:07:16,340
added Utah to this map, we put Texas in,

8323
06:07:16,340 --> 06:07:17,530
and now we're gonna basically say,

8324
06:07:17,530 --> 06:07:22,445
"Hey, map, get me Utah, but
if Utah does not exist for UT

8325
06:07:22,445 --> 06:07:23,900
"for this key UT, go
ahead and insert it for me

8326
06:07:23,900 --> 06:07:24,733
"and return it."

8327
06:07:24,733 --> 06:07:27,420
So, which we could
basically do inside of here.

8328
06:07:27,420 --> 06:07:29,910
So we say, val result equals this.

8329
06:07:29,910 --> 06:07:33,900
And then we would say print
line and what the result

8330
06:07:33,900 --> 06:07:36,400
would be would just be that, that value.

8331
06:07:36,400 --> 06:07:39,280
So when we run this here, we're
gonna see Utah was returned

8332
06:07:39,280 --> 06:07:42,390
because it's basically
saying, "Hey, give me the key.

8333
06:07:42,390 --> 06:07:44,960
"Give me the value for the key UT."

8334
06:07:44,960 --> 06:07:48,680
And behind the scenes,
the mutable map is saying,

8335
06:07:48,680 --> 06:07:51,010
"I don't have this in here,
let me go ahead and insert it.

8336
06:07:51,010 --> 06:07:51,970
"And now I've inserted it.

8337
06:07:51,970 --> 06:07:53,080
"I'm going to return it back to you."

8338
06:07:53,080 --> 06:07:55,490
So there's one little
line of code can save you

8339
06:07:55,490 --> 06:07:58,400
a number of lines of
code if you need to add

8340
06:07:58,400 --> 06:08:00,720
and remove things to a value.

8341
06:08:00,720 --> 06:08:03,750
Now of course, this is
a map, it's mutable map.

8342
06:08:03,750 --> 06:08:06,180
You can do all different
types of things with it.

8343
06:08:06,180 --> 06:08:08,690
If you would like to clear
it at this point in time.

8344
06:08:08,690 --> 06:08:10,490
And then we can say, so
here, we're gonna print

8345
06:08:10,490 --> 06:08:12,600
all the items and we'll print it again.

8346
06:08:12,600 --> 06:08:15,130
The items that clear is
gonna go ahead and clear

8347
06:08:15,130 --> 06:08:16,580
all the items out of the map.

8348
06:08:17,568 --> 06:08:20,420
So it's just a very, very
kind of just typical map,

8349
06:08:20,420 --> 06:08:22,250
hash map, dictionary, object,

8350
06:08:22,250 --> 06:08:24,480
data structure that you
used to working with.

8351
06:08:24,480 --> 06:08:26,450
And that's how you can work very easily

8352
06:08:26,450 --> 06:08:28,280
with a mutable map in Kotlin.

8353
06:08:29,220 --> 06:08:32,120
Retrieving values from a map
is usually pretty simple.

8354
06:08:32,120 --> 06:08:34,800
And you've seen this
probably in other lessons.

8355
06:08:34,800 --> 06:08:37,610
You can retrieve the
value via the get method,

8356
06:08:37,610 --> 06:08:40,710
what you could just say NY
here or this will return you

8357
06:08:40,710 --> 06:08:42,930
your result as we can see here,

8358
06:08:42,930 --> 06:08:47,930
or you can actually go ahead
and use the indexing operator

8359
06:08:48,560 --> 06:08:49,950
to return the value.

8360
06:08:49,950 --> 06:08:52,800
Now, there are a bunch of
other things that you can do

8361
06:08:52,800 --> 06:08:56,830
because a mutable map inside of Kotlin

8362
06:08:57,770 --> 06:09:00,840
is inside of the collections library.

8363
06:09:00,840 --> 06:09:03,230
And so there's a bunch of
different types of collections.

8364
06:09:03,230 --> 06:09:05,417
And the map is one of the most common

8365
06:09:05,417 --> 06:09:06,420
that you're going to end up using.

8366
06:09:06,420 --> 06:09:09,990
Now there's a bunch of different
utilities that you can use

8367
06:09:09,990 --> 06:09:12,350
on a map, just like for a list and arrays

8368
06:09:12,350 --> 06:09:15,780
and other common collection data types.

8369
06:09:15,780 --> 06:09:19,680
So if we say items dot,
the best recommendation

8370
06:09:19,680 --> 06:09:21,930
I can give to you is
to start looking around

8371
06:09:21,930 --> 06:09:24,310
at all the different things it can do.

8372
06:09:24,310 --> 06:09:27,610
Now, one of the things that
I am really happy about

8373
06:09:27,610 --> 06:09:29,300
is actually the, any method.

8374
06:09:29,300 --> 06:09:30,490
And any method basically says,

8375
06:09:30,490 --> 06:09:35,020
"Hey, if there's any items
inside of this list."

8376
06:09:35,020 --> 06:09:39,330
And this is very useful,
especially in common expressions

8377
06:09:39,330 --> 06:09:41,870
where you're checking to see
if there's anything in there.

8378
06:09:41,870 --> 06:09:44,420
And so if you would like
to see if there's any items

8379
06:09:44,420 --> 06:09:46,660
in the map, then do something.

8380
06:09:46,660 --> 06:09:49,400
So you wanna do X, Y, or Z.

8381
06:09:49,400 --> 06:09:51,580
Otherwise, maybe you wanna prompt the user

8382
06:09:51,580 --> 06:09:54,690
to add some values because
they can't continue.

8383
06:09:54,690 --> 06:09:57,630
So any is a quick way to check
if there's anything in there.

8384
06:09:57,630 --> 06:09:59,550
Now there's other things in there as well,

8385
06:09:59,550 --> 06:10:01,130
which kind of is the opposite of that,

8386
06:10:01,130 --> 06:10:04,210
which is none basically says returns true

8387
06:10:04,210 --> 06:10:06,310
if the map has no entries.

8388
06:10:06,310 --> 06:10:08,950
So is there nothing in there, okay, cool.

8389
06:10:08,950 --> 06:10:12,070
Then at that point, it's
kind of the opposite of any.

8390
06:10:12,070 --> 06:10:17,070
So this would then operate
if there are no entries

8391
06:10:17,910 --> 06:10:20,860
and this operates if there are entries.

8392
06:10:20,860 --> 06:10:22,910
So these are very useful little operators

8393
06:10:23,867 --> 06:10:24,930
onsite of the map.

8394
06:10:25,920 --> 06:10:26,753
This is also very common
stuff that you're gonna see

8395
06:10:26,753 --> 06:10:28,360
instead of lists of stuff as well.

8396
06:10:29,750 --> 06:10:31,950
Now, if you also would
like to return values

8397
06:10:32,974 --> 06:10:33,810
outside of a map, again,
the most common way

8398
06:10:33,810 --> 06:10:37,900
is going to be using the
items.get or get or default

8399
06:10:37,900 --> 06:10:41,290
or get or put get, get
or else, get values.

8400
06:10:41,290 --> 06:10:44,110
You can actually iterate
over the values themselves.

8401
06:10:44,110 --> 06:10:46,870
You can also check to see if
it contains a particular key.

8402
06:10:46,870 --> 06:10:50,080
So does it contain the
key and NE for Nebraska,

8403
06:10:50,080 --> 06:10:54,770
this will return true because
we do have the key Nebraska

8404
06:10:54,770 --> 06:10:56,170
inside of here.

8405
06:10:56,170 --> 06:10:58,270
Now, one of the things
you have to be aware of

8406
06:10:58,270 --> 06:11:01,650
is when you're using the
common methods inside of here

8407
06:11:01,650 --> 06:11:04,390
is you may wanna say, "Hey, I wanna filter

8408
06:11:04,390 --> 06:11:05,223
"a particular value."

8409
06:11:05,223 --> 06:11:07,990
So let's say val result equals filter.

8410
06:11:07,990 --> 06:11:12,130
And I wanna say, item.key equals NY.

8411
06:11:12,130 --> 06:11:16,080
Now you may think, well, that's
gonna give me back my value.

8412
06:11:16,080 --> 06:11:19,090
Well, that's incorrect, you
actually gonna get back a map.

8413
06:11:19,090 --> 06:11:24,090
And we can see this simply
through the code help

8414
06:11:24,240 --> 06:11:25,440
inside of IntelliJ.

8415
06:11:25,440 --> 06:11:26,710
But let's just go ahead and print that out

8416
06:11:26,710 --> 06:11:28,830
to see what that looks like.

8417
06:11:28,830 --> 06:11:31,330
And when we look at the
output, we're gonna see

8418
06:11:31,330 --> 06:11:33,970
that we actually get back an actual map

8419
06:11:33,970 --> 06:11:36,050
and we can see it's a little
bit further if we actually

8420
06:11:36,050 --> 06:11:39,300
just filter this just by saying contains.

8421
06:11:40,750 --> 06:11:43,208
Let's go with the letter
N and we'll go ahead

8422
06:11:43,208 --> 06:11:44,270
and get rid of this NY here.

8423
06:11:45,200 --> 06:11:47,370
And what this is gonna do
is actually filter the map

8424
06:11:47,370 --> 06:11:52,370
and give us a new map back
that only has any of the items

8425
06:11:53,160 --> 06:11:55,960
in the map where the
key contains a letter N.

8426
06:11:55,960 --> 06:11:59,130
So we have New York, New
Jersey, New Mexico, Nevada,

8427
06:11:59,130 --> 06:12:00,340
Minnesota, and Nebraska.

8428
06:12:01,940 --> 06:12:03,630
If we were to change this
to the letter F of course,

8429
06:12:03,630 --> 06:12:05,010
we're only gonna get back Florida

8430
06:12:05,010 --> 06:12:06,990
because as we see down here,

8431
06:12:06,990 --> 06:12:11,410
because Florida is the only
one that has any of the keys

8432
06:12:11,410 --> 06:12:13,520
with the letter F inside of it.

8433
06:12:13,520 --> 06:12:18,520
Now that it's kind of a
very common filter method

8434
06:12:18,840 --> 06:12:20,970
you're used to seeing, but
you can also use filter keys.

8435
06:12:20,970 --> 06:12:24,830
And what that will do is
remove the requirement for you

8436
06:12:24,830 --> 06:12:28,260
to type keys, because
it is the key right now.

8437
06:12:28,260 --> 06:12:31,100
So now it is the key, we'll
run the same exact thing

8438
06:12:32,200 --> 06:12:33,200
and it'll filter out the keys.

8439
06:12:33,200 --> 06:12:35,260
And of course, we just get the letter N,

8440
06:12:35,260 --> 06:12:36,990
you can see that here,
so we can say filter key.

8441
06:12:36,990 --> 06:12:39,370
So you can start filtering
based upon the keys.

8442
06:12:39,370 --> 06:12:41,380
If you only wanna filter the values,

8443
06:12:41,380 --> 06:12:43,270
you can say filter values, same thing.

8444
06:12:43,270 --> 06:12:45,870
Does it contain the letter
N and that's only gonna be

8445
06:12:45,870 --> 06:12:47,170
a capital N, by the way.

8446
06:12:47,170 --> 06:12:50,085
And so we're gonna see
back, we do have New Mexico,

8447
06:12:50,085 --> 06:12:50,970
New Jersey, blah, blah, blah.

8448
06:12:50,970 --> 06:12:53,620
If we wanted it to be lowercase,

8449
06:12:54,760 --> 06:12:57,700
then we will kind of get all of our values

8450
06:12:57,700 --> 06:12:59,720
that have a letter N which
might be additional ones

8451
06:12:59,720 --> 06:13:01,950
like Minnesota and
California and so forth.

8452
06:13:01,950 --> 06:13:04,410
They're all gonna be
included inside of there.

8453
06:13:05,260 --> 06:13:07,090
So there are different
ways that you can work

8454
06:13:07,090 --> 06:13:07,923
with these things.

8455
06:13:07,923 --> 06:13:11,880
And of course, these are
basically collection operations.

8456
06:13:11,880 --> 06:13:13,770
So if we wanted to filter those values,

8457
06:13:13,770 --> 06:13:16,060
and then I wanted to
provide a map over it,

8458
06:13:16,060 --> 06:13:17,510
and I wanted to do something to that map,

8459
06:13:17,510 --> 06:13:19,790
and again, this is gonna
be a transform function

8460
06:13:19,790 --> 06:13:21,560
that's applied to this.

8461
06:13:21,560 --> 06:13:23,780
I could say at this point, I wanna take

8462
06:13:23,780 --> 06:13:28,190
the first three letters of the value.

8463
06:13:28,190 --> 06:13:31,070
And I just wanna go
ahead and map that value

8464
06:13:31,070 --> 06:13:32,514
and give me the value.

8465
06:13:32,514 --> 06:13:35,240
So if we did this and then
we did the substring of it,

8466
06:13:35,240 --> 06:13:37,930
and we said, all right, we'll
take the first three letters.

8467
06:13:37,930 --> 06:13:39,230
What would that look like?

8468
06:13:40,597 --> 06:13:41,430
You may think, all right,
I'm gonna get a map back.

8469
06:13:41,430 --> 06:13:42,350
No, you're actually gonna get a string

8470
06:13:42,350 --> 06:13:45,380
because we're just actually
taking the value here.

8471
06:13:46,220 --> 06:13:48,370
So you can take a look at
all of the different things.

8472
06:13:48,370 --> 06:13:53,370
So we can perhaps filter
keys, filter not to,

8473
06:13:53,400 --> 06:13:55,750
we could say map keys.

8474
06:13:55,750 --> 06:13:57,280
So there's different things
you can do inside of here.

8475
06:13:57,280 --> 06:13:59,740
So you can map the keys,
you can map the value.

8476
06:14:00,790 --> 06:14:04,450
So if we take a look at this,
it's going to be it.value.

8477
06:14:05,600 --> 06:14:08,193
And then what we're gonna
do here is we're gonna say

8478
06:14:08,193 --> 06:14:10,470
sub string zero, comma three.

8479
06:14:11,360 --> 06:14:14,390
And if we run this, what
we're gonna see back

8480
06:14:14,390 --> 06:14:18,590
is now we still have our map
intact because we're using

8481
06:14:18,590 --> 06:14:21,150
map of values instead of the map.

8482
06:14:21,150 --> 06:14:23,810
So previously again, let's go
ahead and comment this out,

8483
06:14:23,810 --> 06:14:26,570
just to see the difference
here, we use map,

8484
06:14:26,570 --> 06:14:29,190
and then we say it.value.sub string.

8485
06:14:31,053 --> 06:14:32,430
And we said, all right, we
wanna take zero to three.

8486
06:14:33,586 --> 06:14:35,570
And when we ran this, we just
got back a list of strings

8487
06:14:35,570 --> 06:14:38,370
that contain the first three
letters of all the states.

8488
06:14:38,370 --> 06:14:40,880
And the reason for that is
the map is just a mapping.

8489
06:14:40,880 --> 06:14:42,440
"Hey, this is a transform function

8490
06:14:42,440 --> 06:14:46,430
"applied to the map entry."

8491
06:14:46,430 --> 06:14:49,230
Which is basically each entry
inside of a mutable maps

8492
06:14:49,230 --> 06:14:51,130
is called a map entry.

8493
06:14:51,130 --> 06:14:52,880
And the map entry is a string.

8494
06:14:52,880 --> 06:14:55,260
As we can see here, it's
a string and a string.

8495
06:14:55,260 --> 06:14:57,260
So the key is a string,
the value is a string.

8496
06:14:57,260 --> 06:15:00,190
And I'm just saying, "Hey,
I wanna take the value.

8497
06:15:00,190 --> 06:15:02,630
"And whatever is returned
from this is what's going

8498
06:15:02,630 --> 06:15:04,220
"to be returned from the map."

8499
06:15:04,220 --> 06:15:06,780
So it's gonna be the first
three letters of the value,

8500
06:15:06,780 --> 06:15:08,949
and it'll be shoved back in there.

8501
06:15:08,949 --> 06:15:09,782
And now, if we kind of switch us around

8502
06:15:09,782 --> 06:15:13,030
and come put this out,
there we go and we run this,

8503
06:15:13,030 --> 06:15:15,280
now, of course, what then
that values is gonna do.

8504
06:15:15,280 --> 06:15:17,490
It's gonna say, "Hey, well, let's go ahead

8505
06:15:17,490 --> 06:15:21,090
"and take the values and allow
you to transform something

8506
06:15:21,090 --> 06:15:22,790
"on the value itself."

8507
06:15:22,790 --> 06:15:25,810
So returns a new map as we
see from the documentation

8508
06:15:25,810 --> 06:15:27,590
with entries having the keys of this map

8509
06:15:27,590 --> 06:15:30,530
and the values obtained by
applying the transform function.

8510
06:15:30,530 --> 06:15:33,520
So in short, what that
allows you to do is transform

8511
06:15:33,520 --> 06:15:36,170
the values, but maintain
your map structure.

8512
06:15:36,170 --> 06:15:40,170
You can do the same thing
with things like map.keys.

8513
06:15:40,170 --> 06:15:43,770
You could do some type of
transform function inside of here.

8514
06:15:43,770 --> 06:15:45,620
We don't wanna say map.value.

8515
06:15:48,634 --> 06:15:50,727
We would say map.key. I'm gonna say,

8516
06:15:52,980 --> 06:15:56,680
just make it all lowercase, to lowercase.

8517
06:15:56,680 --> 06:15:58,080
And now if we to run this,

8518
06:15:59,235 --> 06:16:01,050
we'll see that the result that
we get back is now we have

8519
06:16:01,050 --> 06:16:03,480
all of our keys have now
been turned into lowercase,

8520
06:16:03,480 --> 06:16:06,620
but we still maintain our map
structure and our map data.

8521
06:16:06,620 --> 06:16:08,760
So anytime you are working with a map

8522
06:16:08,760 --> 06:16:11,480
and you wanna kind of transform
the data, iterate over it,

8523
06:16:11,480 --> 06:16:13,350
you wanna go ahead and take
a look at some of the various

8524
06:16:13,350 --> 06:16:14,790
different map operators.

8525
06:16:14,790 --> 06:16:18,020
So you can do flat maps and
regular maps and map not nulls

8526
06:16:18,020 --> 06:16:19,400
and so forth like that.

8527
06:16:19,400 --> 06:16:20,520
Which are very useful.

8528
06:16:20,520 --> 06:16:23,140
But this is one way that you
can find and filter values

8529
06:16:23,140 --> 06:16:26,130
other than using the
traditional get and put methods

8530
06:16:26,130 --> 06:16:29,270
inside of the immutable
map and maps themselves.

8531
06:16:30,600 --> 06:16:33,420
One thing that you will eventually
run into in almost every

8532
06:16:33,420 --> 06:16:37,110
programming endeavor is the
point in time in which you have

8533
06:16:37,110 --> 06:16:39,050
to start working with null values.

8534
06:16:39,050 --> 06:16:41,620
Now, by default, you wanna
try to work with as many

8535
06:16:41,620 --> 06:16:44,290
non null values as possible,

8536
06:16:44,290 --> 06:16:46,790
which by default is why Kotlin makes you

8537
06:16:46,790 --> 06:16:48,880
specify nullable types.

8538
06:16:48,880 --> 06:16:51,720
However, there are times when
you perhaps need to perform

8539
06:16:51,720 --> 06:16:53,320
some type of map operation.

8540
06:16:54,740 --> 06:16:57,770
Now, for example, this map
might have you do something

8541
06:16:57,770 --> 06:17:00,435
and you have to call
into a certain function.

8542
06:17:00,435 --> 06:17:02,560
So we have a function down
here below and it's called

8543
06:17:02,560 --> 06:17:04,220
find value in web service.

8544
06:17:04,220 --> 06:17:06,890
Now this doesn't really find
a value in a web service,

8545
06:17:06,890 --> 06:17:10,400
but we are trying to
emulate that environment.

8546
06:17:10,400 --> 06:17:13,150
Let's assume for whatever
reason that all of your items

8547
06:17:13,150 --> 06:17:15,030
in your map, you need to
go up to a web service

8548
06:17:15,030 --> 06:17:17,780
and you need to ask it for some value

8549
06:17:17,780 --> 06:17:20,100
and you don't control the web service,

8550
06:17:20,100 --> 06:17:21,100
but for whatever reason,

8551
06:17:21,100 --> 06:17:23,660
that web service could
either return a null value,

8552
06:17:23,660 --> 06:17:26,360
or it could return back
that particular entry,

8553
06:17:26,360 --> 06:17:27,620
maybe it's been modified.

8554
06:17:27,620 --> 06:17:30,291
You know, it could be something different

8555
06:17:30,291 --> 06:17:32,290
or it's just gonna return
it back as a regular entry.

8556
06:17:32,290 --> 06:17:34,220
So if we were to print this out here,

8557
06:17:35,060 --> 06:17:38,310
what you might see at this
point in time is that we have

8558
06:17:38,310 --> 06:17:41,380
a bunch of weird values in here.

8559
06:17:41,380 --> 06:17:45,390
So it looks now we have
basically a map, which again,

8560
06:17:45,390 --> 06:17:49,360
is just going to return us
back a list of certain values

8561
06:17:49,360 --> 06:17:51,990
or whatever, we're
going over the map here,

8562
06:17:52,890 --> 06:17:55,180
and we're saying, hey, give me
all the values of everything.

8563
06:17:55,180 --> 06:17:57,350
So it's returning us back a list,

8564
06:17:57,350 --> 06:17:59,730
but this list has a bunch
of null values in it.

8565
06:17:59,730 --> 06:18:00,890
And we don't want these nulls

8566
06:18:00,890 --> 06:18:04,030
because now when we have a null value,

8567
06:18:04,030 --> 06:18:06,920
you can see that the entry
that's returned is a list

8568
06:18:06,920 --> 06:18:09,140
of all these different entries,

8569
06:18:09,140 --> 06:18:11,270
which makes it very difficult

8570
06:18:11,270 --> 06:18:12,340
because now we have to worry about

8571
06:18:12,340 --> 06:18:14,030
null checking and so forth.

8572
06:18:14,030 --> 06:18:16,410
And if your method that you're sending in

8573
06:18:16,410 --> 06:18:17,820
this result value into,

8574
06:18:17,820 --> 06:18:20,790
so if you have another method
down the line that says,

8575
06:18:20,790 --> 06:18:24,980
you wanna process results
and process values,

8576
06:18:24,980 --> 06:18:27,610
and that method for whatever
reason takes in a result,

8577
06:18:27,610 --> 06:18:29,360
and it takes in a non nullable type,

8578
06:18:29,360 --> 06:18:31,800
which is what you should try to aim for,

8579
06:18:31,800 --> 06:18:34,350
because nulls can create
a lot of problems for you.

8580
06:18:35,590 --> 06:18:37,810
That's gonna create a problem
here because you're parsing

8581
06:18:37,810 --> 06:18:39,550
in null values now you
have to do the checking,

8582
06:18:39,550 --> 06:18:40,440
now you have to remove them.

8583
06:18:40,440 --> 06:18:42,090
Well, thankfully, there's
a way around that.

8584
06:18:42,090 --> 06:18:46,130
So you could say map not null.

8585
06:18:46,130 --> 06:18:49,910
And what map not null will
do is if it encounters

8586
06:18:49,910 --> 06:18:52,500
any situation where a
null value is returned,

8587
06:18:52,500 --> 06:18:54,220
which is what it will do here,

8588
06:18:54,220 --> 06:18:58,870
and basically what that happens
is any time one of the keys

8589
06:18:58,870 --> 06:19:00,730
inside of our map starts with the letter N

8590
06:19:00,730 --> 06:19:02,300
we're just gonna return a null,

8591
06:19:02,300 --> 06:19:04,370
otherwise just return the entry.

8592
06:19:04,370 --> 06:19:07,690
So if it encounters, you know,
New York, New Jersey, Nevada,

8593
06:19:07,690 --> 06:19:10,620
Nebraska, anything like that,
it's gonna return a null,

8594
06:19:10,620 --> 06:19:11,580
which is what we saw here.

8595
06:19:11,580 --> 06:19:14,630
That's just, these are all
the null values that we see

8596
06:19:14,630 --> 06:19:17,920
down inside that were
returned back and so forth.

8597
06:19:17,920 --> 06:19:19,820
So we got them there, we
got there, we got it there.

8598
06:19:19,820 --> 06:19:23,880
We got them all over the
place and we don't want that.

8599
06:19:23,880 --> 06:19:25,700
We only want the values
that are not gonna be null,

8600
06:19:25,700 --> 06:19:27,520
because perhaps we need
to do some processing.

8601
06:19:27,520 --> 06:19:29,870
We don't have to worry
about nulls, et cetera.

8602
06:19:29,870 --> 06:19:31,270
So you can use map not null.

8603
06:19:32,208 --> 06:19:33,520
And if you run this,
now, what this will do is

8604
06:19:33,520 --> 06:19:36,157
Kotlin will say, all
right, we're gonna iterate

8605
06:19:36,157 --> 06:19:36,990
through the map, if we get a null,

8606
06:19:36,990 --> 06:19:38,420
we're just not gonna include it.

8607
06:19:38,420 --> 06:19:41,020
So here down on our result,
we could see that we do not

8608
06:19:41,020 --> 06:19:44,410
have any null values whatsoever.

8609
06:19:44,410 --> 06:19:47,560
These are just values that are not null.

8610
06:19:47,560 --> 06:19:52,560
So if you ever need to
have a list map, whatever,

8611
06:19:52,590 --> 06:19:54,520
and you don't want the
null values included in it,

8612
06:19:54,520 --> 06:19:56,390
but you do need to perform
some type of processing

8613
06:19:56,390 --> 06:19:59,290
over them, and a lot of
times you may not even have

8614
06:19:59,290 --> 06:20:00,810
the ability to change that code

8615
06:20:00,810 --> 06:20:03,330
because maybe it's inside
of a library somewhere

8616
06:20:03,330 --> 06:20:04,720
and it returns these null values,

8617
06:20:04,720 --> 06:20:07,590
you can use map not null
to ensure that the map

8618
06:20:07,590 --> 06:20:09,670
that you're going to get back is not null.

8619
06:20:09,670 --> 06:20:11,260
Now, of course, items might be missing

8620
06:20:11,260 --> 06:20:12,650
that you were expecting to be there,

8621
06:20:12,650 --> 06:20:15,460
but you'll have to handle
that as a case by case basis.

8622
06:20:15,460 --> 06:20:18,540
And that's how you can work
with a map and make sure

8623
06:20:18,540 --> 06:20:19,850
the items are not null.

8624
06:20:19,850 --> 06:20:21,550
This also works for lists as well.

8625
06:20:22,540 --> 06:20:25,340
Let's assume that you wanted
to generate a very large list

8626
06:20:25,340 --> 06:20:28,230
for whatever reason to do
some testing or perhaps

8627
06:20:28,230 --> 06:20:29,700
just to play around.

8628
06:20:29,700 --> 06:20:32,110
What you can use is the
generate sequence method

8629
06:20:32,110 --> 06:20:34,580
that's inside of the
Kotlin standard library,

8630
06:20:34,580 --> 06:20:36,020
which returns the sequence.

8631
06:20:36,020 --> 06:20:38,540
Now a sequence is a
completely different beast,

8632
06:20:38,540 --> 06:20:40,120
and there's some other videos that talk

8633
06:20:40,120 --> 06:20:42,740
about what sequences are
and why they're important,

8634
06:20:42,740 --> 06:20:45,600
but just know now that you
can generate a sequence

8635
06:20:45,600 --> 06:20:46,740
using this method.

8636
06:20:46,740 --> 06:20:48,500
We wanna seed it with the value of one.

8637
06:20:48,500 --> 06:20:51,320
And then for each iteration,
we want to do something,

8638
06:20:51,320 --> 06:20:53,260
we're gonna perform some
type of function here,

8639
06:20:53,260 --> 06:20:55,790
and that's gonna be the next
function that gets executed.

8640
06:20:55,790 --> 06:20:58,910
And all we're doing is we're
taking that existing value,

8641
06:20:58,910 --> 06:21:00,780
which is the integer value of one

8642
06:21:00,780 --> 06:21:02,800
and incrementing it plus one.

8643
06:21:02,800 --> 06:21:05,560
And then we say dot take,
and what take is going to do

8644
06:21:05,560 --> 06:21:06,750
is re return to sequence

8645
06:21:06,750 --> 06:21:08,900
containing those number of elements.

8646
06:21:08,900 --> 06:21:12,680
And basically we want to
do this 50 million times,

8647
06:21:12,680 --> 06:21:13,513
which is a lot.

8648
06:21:13,513 --> 06:21:15,250
And so again, this is a shorthand version

8649
06:21:15,250 --> 06:21:17,510
for making longer numbers.

8650
06:21:17,510 --> 06:21:20,250
Now, of course, we could
have done this too,

8651
06:21:20,250 --> 06:21:23,410
that would work, but
thankfully Kotlin allows us

8652
06:21:23,410 --> 06:21:25,790
to have some readability
with the underscores.

8653
06:21:25,790 --> 06:21:27,690
So we wanna do this 50 million times,

8654
06:21:27,690 --> 06:21:29,330
and then we wanna turn this into a list.

8655
06:21:29,330 --> 06:21:31,830
So now we have a list of 50 million items

8656
06:21:31,830 --> 06:21:35,540
that are all different, that
have different values in there.

8657
06:21:35,540 --> 06:21:37,160
And then let's say that
for whatever reason,

8658
06:21:37,160 --> 06:21:39,240
we wanted to do some operation.

8659
06:21:39,240 --> 06:21:42,150
Now we could do this operation here,

8660
06:21:42,150 --> 06:21:44,210
and now we have a very
large list to work with

8661
06:21:44,210 --> 06:21:45,560
to see what's gonna happen.

8662
06:21:46,885 --> 06:21:48,341
Now I'm gonna run this here, actually.

8663
06:21:48,341 --> 06:21:49,174
And then what you're going to see

8664
06:21:49,174 --> 06:21:50,580
is it's going to take awhile.

8665
06:21:50,580 --> 06:21:52,390
And so this is currently running.

8666
06:21:53,365 --> 06:21:55,680
We'll know when it's done,
when we see the print line

8667
06:21:55,680 --> 06:21:57,160
is done on here.

8668
06:21:57,160 --> 06:21:59,920
Now, it's very possible that
you could hear my computer fan

8669
06:21:59,920 --> 06:22:02,640
start-up in a second because
this code is still running

8670
06:22:02,640 --> 06:22:05,050
right now, it's still
filtering and averaging

8671
06:22:05,050 --> 06:22:08,460
over 50 million items and
it's running on my laptop.

8672
06:22:08,460 --> 06:22:11,980
And now I can hear my fans
turning on, and there it goes.

8673
06:22:11,980 --> 06:22:16,610
It's now done, so it took
quite a while to generate that.

8674
06:22:16,610 --> 06:22:20,970
And so we get back a double,
so we could say the result,

8675
06:22:21,920 --> 06:22:24,840
and then we say print line
and we could say the result,

8676
06:22:26,014 --> 06:22:27,290
and then we can see the results here.

8677
06:22:27,290 --> 06:22:29,300
And again, if we were running it again,

8678
06:22:29,300 --> 06:22:31,330
it would take quite a while to run this,

8679
06:22:31,330 --> 06:22:35,430
but this is one way that you
can use the generate sequence

8680
06:22:35,430 --> 06:22:39,010
built inside of the
Kotlin standard library

8681
06:22:39,010 --> 06:22:41,390
to generate a very large
list to do some testing with.

8682
06:22:41,390 --> 06:22:45,500
So again, this is generating
a with 50 million items in it,

8683
06:22:45,500 --> 06:22:47,300
and then I'm iterating over it,

8684
06:22:47,300 --> 06:22:50,580
basically filtering out the
items that I have a modulus

8685
06:22:50,580 --> 06:22:53,250
of three, zero.

8686
06:22:53,250 --> 06:22:55,720
So if it's divisible
by three, then go ahead

8687
06:22:55,720 --> 06:22:58,240
and take those out and then I
wanna average those together.

8688
06:22:58,240 --> 06:23:00,130
And then what happens is
I get the result back,

8689
06:23:00,130 --> 06:23:02,080
which is a double, and that's printed out

8690
06:23:02,080 --> 06:23:03,510
down here at the bottom.

8691
06:23:03,510 --> 06:23:05,750
And that's how you can
generate very large sequences

8692
06:23:05,750 --> 06:23:08,200
and very large lists inside of Kotlin

8693
06:23:08,200 --> 06:23:10,650
so you can work and do
some testing, very useful.

8694
06:23:12,952 --> 06:23:14,380
Let's assume you have
this chunk of code here.

8695
06:23:14,380 --> 06:23:17,360
And if you run this code,
you'll notice that it takes

8696
06:23:17,360 --> 06:23:21,180
anywhere from on my
machine, upwards of nine

8697
06:23:21,180 --> 06:23:23,080
to about 20 seconds to run.

8698
06:23:23,080 --> 06:23:25,980
And the reason why is because
we're generating a sequence,

8699
06:23:25,980 --> 06:23:27,250
which is like a collection,

8700
06:23:27,250 --> 06:23:28,450
and we're turning it into a list.

8701
06:23:28,450 --> 06:23:32,410
And this line basically says,
hey, we have 50 million items

8702
06:23:32,410 --> 06:23:33,790
in this list.

8703
06:23:33,790 --> 06:23:36,309
And then what we're gonna do is kind of do

8704
06:23:36,309 --> 06:23:37,400
some operations over it and
then we're gonna calculate

8705
06:23:37,400 --> 06:23:40,322
the average of some of
the values in there,

8706
06:23:40,322 --> 06:23:41,490
and then we're gonna
print and result and done.

8707
06:23:41,490 --> 06:23:43,140
And so we can see that here.

8708
06:23:43,140 --> 06:23:45,570
Now, one of the problems that
we have with a lot of code

8709
06:23:45,570 --> 06:23:48,890
sometimes is we don't know
how long it takes to run.

8710
06:23:48,890 --> 06:23:52,080
All I know here is like, wow,
that was a long time to run.

8711
06:23:52,080 --> 06:23:53,630
So how could we measure this?

8712
06:23:53,630 --> 06:23:55,870
Well, what we can do is
actually create a function

8713
06:23:55,870 --> 06:23:56,703
called measure.

8714
06:23:58,260 --> 06:24:02,580
And this function measure is gonna take in

8715
06:24:02,580 --> 06:24:04,480
what's known as a lambda expression.

8716
06:24:08,500 --> 06:24:12,940
And this lambda expression
kinda confusing.

8717
06:24:12,940 --> 06:24:14,940
So it's called a block and
this is just a function.

8718
06:24:14,940 --> 06:24:16,040
We're just parsing a function.

8719
06:24:16,040 --> 06:24:20,190
And this function right
here has no parameters,

8720
06:24:20,190 --> 06:24:22,650
that's why it's an empty, it's
like an empty parameter list.

8721
06:24:22,650 --> 06:24:24,300
And this function is gonna return units.

8722
06:24:24,300 --> 06:24:27,530
So this block right here,
right here, this block

8723
06:24:27,530 --> 06:24:30,920
is going to have no parameters
and it's gonna return a unit.

8724
06:24:30,920 --> 06:24:33,880
So it's basically a void,
so it's gonna be a void.

8725
06:24:33,880 --> 06:24:35,790
So we can parse some type of function

8726
06:24:35,790 --> 06:24:38,670
inside of this measure block here.

8727
06:24:38,670 --> 06:24:40,180
But now we need to be
able to measure that.

8728
06:24:40,180 --> 06:24:42,230
So we're gonna say, nano time.

8729
06:24:43,540 --> 06:24:47,160
And then what we're gonna
do is say measure nano time.

8730
06:24:47,160 --> 06:24:49,630
And we can actually
parse a block in there.

8731
06:24:49,630 --> 06:24:52,490
Measure nano time, if
we take a look at it,

8732
06:24:52,490 --> 06:24:55,030
it executes the given block
and return to the elapsed time

8733
06:24:55,030 --> 06:24:55,863
in nanoseconds.

8734
06:24:55,863 --> 06:24:57,820
This is built into the
Kotlin standard library

8735
06:24:57,820 --> 06:24:59,310
and the timing file.

8736
06:24:59,310 --> 06:25:02,580
And all it does is it looks
at the system nano time,

8737
06:25:02,580 --> 06:25:03,950
and then it executes the block.

8738
06:25:03,950 --> 06:25:06,190
And remember the block,
which is what we parsing,

8739
06:25:06,190 --> 06:25:07,500
it's just a function.

8740
06:25:07,500 --> 06:25:09,860
So I'll show you how to
parse a function in a second,

8741
06:25:09,860 --> 06:25:13,260
we're gonna parse a function
in the measure nano time

8742
06:25:13,260 --> 06:25:16,490
basically just grabs the nano
time, then tells the function,

8743
06:25:16,490 --> 06:25:18,410
hey, execute, do whatever you need to do.

8744
06:25:18,410 --> 06:25:20,810
Remember the function is returned to unit,

8745
06:25:20,810 --> 06:25:24,420
which is basically the same
as void in most JVM languages.

8746
06:25:24,420 --> 06:25:26,940
It's gonna return a void, and
then at that point in time,

8747
06:25:26,940 --> 06:25:29,430
it just calculates how
long it took a nanoseconds

8748
06:25:29,430 --> 06:25:30,950
for this function to execute,

8749
06:25:30,950 --> 06:25:33,560
because again, that's
a blocking operation.

8750
06:25:33,560 --> 06:25:35,800
We get the start time and
we calculate the end time

8751
06:25:35,800 --> 06:25:37,550
and that's how long it
took and nanoseconds.

8752
06:25:37,550 --> 06:25:38,720
So now we have nanoseconds,

8753
06:25:38,720 --> 06:25:41,120
but we're not too familiar
with how it would work

8754
06:25:41,120 --> 06:25:44,220
with nanosecond, so let's
go and get the milliseconds.

8755
06:25:44,220 --> 06:25:48,930
And so we're gonna do time
unit.nanosecond.two millies

8756
06:25:49,860 --> 06:25:52,050
and now we're gonna
parse in the nano time.

8757
06:25:52,050 --> 06:25:53,200
That's how long it took.

8758
06:25:53,200 --> 06:25:54,390
And then now that we
have the milliseconds,

8759
06:25:54,390 --> 06:25:55,650
we can just do print line.

8760
06:25:56,882 --> 06:25:59,460
And then what we can do is a print ln.

8761
06:25:59,460 --> 06:26:02,473
We actually take the millies,
print ln and parse it

8762
06:26:08,540 --> 06:26:11,750
in the millies and then
type in miliseconds.

8763
06:26:12,600 --> 06:26:13,890
And what this will do is show us how long

8764
06:26:13,890 --> 06:26:14,820
something took to execute.

8765
06:26:14,820 --> 06:26:17,110
So how do we use this function right here?

8766
06:26:17,110 --> 06:26:18,980
So what are we gonna do,
because this is a block

8767
06:26:18,980 --> 06:26:20,280
we'll just scroll up here.

8768
06:26:21,140 --> 06:26:22,940
And this is called a
block because it looks

8769
06:26:22,940 --> 06:26:25,540
like a block of code and I'll
show you what I mean by that.

8770
06:26:25,540 --> 06:26:27,880
Let's type in measure and see how we hit

8771
06:26:27,880 --> 06:26:30,400
the code completion here.

8772
06:26:30,400 --> 06:26:32,917
And it looks like these
little brackets are,

8773
06:26:32,917 --> 06:26:34,260
we'd like to call that a little block.

8774
06:26:34,260 --> 06:26:36,310
And so right now we're in the block.

8775
06:26:36,310 --> 06:26:39,940
This is the piece of code
that's gonna get executed.

8776
06:26:39,940 --> 06:26:42,370
So we can just provide these brackets here

8777
06:26:42,370 --> 06:26:44,580
because is a lambda expression.

8778
06:26:44,580 --> 06:26:46,460
And anything that's in
between these brackets

8779
06:26:46,460 --> 06:26:47,850
is considered the block of codes.

8780
06:26:47,850 --> 06:26:50,190
I'm just gonna go ahead and take all this

8781
06:26:51,300 --> 06:26:53,510
and I'm gonna go ahead and
clean this up a little bit,

8782
06:26:53,510 --> 06:26:55,750
and I'm just gonna drop it right in here.

8783
06:26:55,750 --> 06:26:58,350
So now all this code
that's inside of here,

8784
06:26:59,320 --> 06:27:02,850
this area right here,
this is the block of code.

8785
06:27:03,770 --> 06:27:04,603
So remember it.

8786
06:27:04,603 --> 06:27:08,880
So this right here is what
turns into this block.

8787
06:27:10,570 --> 06:27:13,390
And then when we get onto the nano time,

8788
06:27:13,390 --> 06:27:15,400
that's, what's executes right there.

8789
06:27:15,400 --> 06:27:17,820
So anything between
these two brackets here.

8790
06:27:17,820 --> 06:27:22,820
So top bracket, bottom
bracket is the block.

8791
06:27:22,950 --> 06:27:24,900
And all this code that's inside of here

8792
06:27:26,670 --> 06:27:28,810
is what's gonna get executed and measured.

8793
06:27:28,810 --> 06:27:30,670
So let's go ahead and do that.

8794
06:27:30,670 --> 06:27:33,070
So now what's gonna happen
is we'll still run this code

8795
06:27:33,070 --> 06:27:34,030
as we normally would have,

8796
06:27:34,030 --> 06:27:36,707
but what's gonna happen
is it's going to run

8797
06:27:36,707 --> 06:27:37,580
and then it's gonna show us
how long it took the run.

8798
06:27:37,580 --> 06:27:42,580
So if we run this now, okay, execute this.

8799
06:27:42,900 --> 06:27:45,390
Again, this is gonna take
anywhere from five to eight

8800
06:27:45,390 --> 06:27:46,223
to 10 seconds.

8801
06:27:46,223 --> 06:27:48,560
And as it runs, it's
basically calculating it.

8802
06:27:48,560 --> 06:27:50,680
Again, take a look here right now

8803
06:27:50,680 --> 06:27:52,500
it's executing this code right here.

8804
06:27:52,500 --> 06:27:55,114
It's already calculated the start time

8805
06:27:55,114 --> 06:27:56,970
and it's calculating the end
time as soon as it's complete.

8806
06:27:56,970 --> 06:27:57,900
And as soon as it's complete,

8807
06:27:57,900 --> 06:28:01,950
we'll then see the millies
ms, there we go done.

8808
06:28:01,950 --> 06:28:03,750
So we know that we are
done, we got the result,

8809
06:28:03,750 --> 06:28:05,990
which is the average that was calculated

8810
06:28:05,990 --> 06:28:08,460
and it took 18,244 seconds.

8811
06:28:08,460 --> 06:28:11,680
So on my machine, this operation takes

8812
06:28:11,680 --> 06:28:15,000
a little over 18 seconds.

8813
06:28:15,000 --> 06:28:20,000
Now it's important to
note that measuring time

8814
06:28:21,670 --> 06:28:26,670
and diagnostics for how valid
timing is a difficult task

8815
06:28:27,560 --> 06:28:29,600
inside of JVM.

8816
06:28:29,600 --> 06:28:31,050
So this is a very important note

8817
06:28:31,050 --> 06:28:34,050
that this can not be treated
as the end all be all

8818
06:28:34,050 --> 06:28:36,470
performance checking solution.

8819
06:28:36,470 --> 06:28:41,470
The reason being is the
JVM has in deterministic

8820
06:28:42,270 --> 06:28:43,570
garbage collection.

8821
06:28:43,570 --> 06:28:46,170
So we could be in the
middle of running this

8822
06:28:46,170 --> 06:28:49,410
and for whatever reason, the JVM decides,

8823
06:28:49,410 --> 06:28:51,971
you know what, we needed higher time.

8824
06:28:51,971 --> 06:28:52,804
It's to garbage collect.

8825
06:28:52,804 --> 06:28:55,450
And that could happen right in
the middle of your execution

8826
06:28:55,450 --> 06:28:56,530
and might throw this off.

8827
06:28:56,530 --> 06:28:59,520
So I don't want you to
take the measure nano time

8828
06:28:59,520 --> 06:29:01,060
as the end all be all solution.

8829
06:29:01,060 --> 06:29:04,290
However, it is a very, very
useful tool to kind of get

8830
06:29:04,290 --> 06:29:07,198
a good diagnostic feel of all right,

8831
06:29:07,198 --> 06:29:09,240
how long is this taking,
why is this taking so long?

8832
06:29:09,240 --> 06:29:10,440
And you can use this.

8833
06:29:10,440 --> 06:29:13,410
So what I recommend is taking
this little measure thing,

8834
06:29:13,410 --> 06:29:16,350
you can kind of copy and paste
it into maybe a scratch file

8835
06:29:16,350 --> 06:29:19,370
somewhere or some type
of a tool where you say

8836
06:29:19,370 --> 06:29:22,180
some code snippets and
use it any time you want

8837
06:29:22,180 --> 06:29:24,512
to start measuring things,

8838
06:29:24,512 --> 06:29:26,160
or you can put it in your
project under a utils

8839
06:29:26,160 --> 06:29:28,080
and then decide if you
wanna use it or not.

8840
06:29:28,080 --> 06:29:30,562
Now, of course, you
probably don't want this

8841
06:29:30,562 --> 06:29:31,860
in your production code,
but it's very useful

8842
06:29:31,860 --> 06:29:32,693
if for some reason you're like,

8843
06:29:32,693 --> 06:29:34,830
wow, how long is this really taking?

8844
06:29:34,830 --> 06:29:36,120
And then you can start determining,

8845
06:29:36,120 --> 06:29:38,540
oh wow, this is the chart, you know?

8846
06:29:38,540 --> 06:29:39,700
And then if you wanted to, you could say,

8847
06:29:39,700 --> 06:29:44,140
all right, well, is it really,
is the measure actually,

8848
06:29:44,140 --> 06:29:45,930
is it this piece right here?

8849
06:29:45,930 --> 06:29:47,260
So then, what is that?

8850
06:29:47,260 --> 06:29:49,100
So we actually, we'd probably
want to take this out here

8851
06:29:49,100 --> 06:29:54,100
and say, wanna take this list
out and say list var list.

8852
06:29:58,485 --> 06:30:01,660
So we do a late init var list,

8853
06:30:01,660 --> 06:30:04,810
and that's gonna be a list of integers

8854
06:30:06,960 --> 06:30:08,360
and now we can just do this.

8855
06:30:09,350 --> 06:30:10,720
So then we can see how long that took.

8856
06:30:10,720 --> 06:30:12,220
So if we were to run this now,

8857
06:30:14,270 --> 06:30:17,230
we would see as it's generating
how long it's gonna to take.

8858
06:30:17,230 --> 06:30:20,330
So to generate the 50,000
and then turn it to a list,

8859
06:30:22,520 --> 06:30:23,460
as it's executing.

8860
06:30:27,140 --> 06:30:28,410
Okay, so I'm gonna stop it here.

8861
06:30:28,410 --> 06:30:31,310
Now what we see here is that
it took about nine seconds

8862
06:30:31,310 --> 06:30:33,000
to generate that sequence.

8863
06:30:33,000 --> 06:30:34,870
So then we could start measuring

8864
06:30:34,870 --> 06:30:36,280
various different components here.

8865
06:30:36,280 --> 06:30:39,000
All right, how long did it
take for this other stuff?

8866
06:30:39,000 --> 06:30:41,110
So if I wanted to, I
can move this down here.

8867
06:30:41,110 --> 06:30:43,430
Okay, that took nine seconds.

8868
06:30:43,430 --> 06:30:45,550
How long does it take for this stuff here?

8869
06:30:45,550 --> 06:30:46,950
Let's go ahead and run that.

8870
06:30:48,910 --> 06:30:50,187
And then you can run this, et cetera.

8871
06:30:50,187 --> 06:30:51,600
And then you're gonna be
able to see how long it takes

8872
06:30:51,600 --> 06:30:53,380
for each one of these
things to be generated.

8873
06:30:53,380 --> 06:30:55,950
Now, of course, there's a
bunch of variables in here.

8874
06:30:55,950 --> 06:30:58,720
Okay, we're not late,
we're late in initializing.

8875
06:30:58,720 --> 06:30:59,740
Is that impacting it?

8876
06:30:59,740 --> 06:31:04,110
If you're looking for very,
very fine tuned ways to tune it,

8877
06:31:04,110 --> 06:31:05,550
this is not gonna be a solution,

8878
06:31:05,550 --> 06:31:08,330
this'll be just something
to help you kind of gauge

8879
06:31:08,330 --> 06:31:09,950
whether or not something is slow

8880
06:31:09,950 --> 06:31:11,110
and how to do it very easily.

8881
06:31:11,110 --> 06:31:14,330
So here we can see that
the averaging itself

8882
06:31:14,330 --> 06:31:16,379
takes about eight seconds.

8883
06:31:16,379 --> 06:31:17,970
So generating the list
took a little over nine,

8884
06:31:17,970 --> 06:31:20,520
almost 10 seconds, and this
takes almost nine seconds itself

8885
06:31:20,520 --> 06:31:23,210
to calculate the average and print it.

8886
06:31:23,210 --> 06:31:25,850
And that's how you can
use the measure nano time

8887
06:31:25,850 --> 06:31:27,630
to create a measure block,

8888
06:31:27,630 --> 06:31:29,440
which then you can use
inside of your application

8889
06:31:29,440 --> 06:31:31,530
to measure chunks of code to see how long

8890
06:31:31,530 --> 06:31:32,580
they take to execute.

8891
06:31:33,530 --> 06:31:35,150
To understand sequences in Kotlin,

8892
06:31:35,150 --> 06:31:37,540
it's important to
understand how list operate

8893
06:31:37,540 --> 06:31:40,230
over list of data and how
the mapping operations

8894
06:31:40,230 --> 06:31:42,970
occur to each of the list items.

8895
06:31:42,970 --> 06:31:44,760
So we're gonna do is
create a list of strings,

8896
06:31:44,760 --> 06:31:46,050
and then we're gonna filter that list.

8897
06:31:46,050 --> 06:31:47,320
And it's not really gonna filter anything,

8898
06:31:47,320 --> 06:31:49,820
it's just gonna go ahead and
process it and print line,

8899
06:31:49,820 --> 06:31:52,640
and then return back true
basically saying all the items

8900
06:31:52,640 --> 06:31:53,830
will be included.

8901
06:31:53,830 --> 06:31:56,080
And then finally, we'll go
ahead and then print line it

8902
06:31:56,080 --> 06:31:58,150
at the end of each one of those.

8903
06:31:58,150 --> 06:32:01,780
Now for each is one of the
things we're doing here

8904
06:32:01,780 --> 06:32:06,410
is actually showing that a
list is eagerly evaluated.

8905
06:32:06,410 --> 06:32:09,990
So each time there's an
operation, a new list is created.

8906
06:32:09,990 --> 06:32:13,640
So what that means is if I were
to perform this same filter

8907
06:32:13,640 --> 06:32:18,540
operation twice, and I
were to say, hello here,

8908
06:32:18,540 --> 06:32:22,110
what would happen is Kotlin
is then going to create a,

8909
06:32:23,829 --> 06:32:24,970
it's gonna take the
list from the beginning.

8910
06:32:24,970 --> 06:32:26,220
And then in the filter function,

8911
06:32:26,220 --> 06:32:28,350
it's going to create another list.

8912
06:32:28,350 --> 06:32:31,440
And then from that list, that
list will then be turned in

8913
06:32:31,440 --> 06:32:34,130
and sent into this list right here.

8914
06:32:34,130 --> 06:32:37,130
And when this one is done,
a new list to be created

8915
06:32:37,130 --> 06:32:38,370
and sent into here.

8916
06:32:38,370 --> 06:32:41,120
So basically we're having this
type of thing happen here,

8917
06:32:41,120 --> 06:32:44,870
where these lists are being
created over and over and over,

8918
06:32:44,870 --> 06:32:45,730
but there are new lists.

8919
06:32:45,730 --> 06:32:47,910
So this is a list off of this one,

8920
06:32:47,910 --> 06:32:50,670
this is a list off of this one.

8921
06:32:50,670 --> 06:32:53,400
And then a new list is finally
created that we have a list

8922
06:32:53,400 --> 06:32:54,810
down here.

8923
06:32:54,810 --> 06:32:58,110
So Kotlin is lazily evaluating those.

8924
06:32:58,110 --> 06:33:01,220
And the easy way to see that
is with this function here.

8925
06:33:01,220 --> 06:33:03,320
So let's go ahead and run this
and what we're going to see

8926
06:33:03,320 --> 06:33:06,050
here on the screen down here on the bottom

8927
06:33:06,990 --> 06:33:11,180
is that we have the filter
was run for every single item

8928
06:33:11,180 --> 06:33:13,900
in the list and it didn't
progress until the next function

8929
06:33:13,900 --> 06:33:16,370
until all of the items
are processed in the list.

8930
06:33:16,370 --> 06:33:18,780
The same thing here, and
then the same thing here.

8931
06:33:18,780 --> 06:33:21,960
So as each item walked down,

8932
06:33:21,960 --> 06:33:24,330
so this function did these ones,

8933
06:33:24,330 --> 06:33:26,530
this function did these ones,

8934
06:33:26,530 --> 06:33:28,570
and this function did these ones.

8935
06:33:28,570 --> 06:33:30,910
So it operated one at a time.

8936
06:33:30,910 --> 06:33:34,290
This one, then this one, then this one,

8937
06:33:35,590 --> 06:33:38,130
and that's what's happening
behind the scenes.

8938
06:33:38,130 --> 06:33:40,410
Now this can be home problematic
when you have a very large

8939
06:33:40,410 --> 06:33:43,590
list or many processing
steps inside of your list,

8940
06:33:43,590 --> 06:33:46,600
because if they are processing intensive,

8941
06:33:46,600 --> 06:33:48,550
then if we're creating a new collection,

8942
06:33:48,550 --> 06:33:50,230
each time eagerly evaluating it,

8943
06:33:50,230 --> 06:33:52,710
we can just start
slowing down the process.

8944
06:33:52,710 --> 06:33:55,130
So let's see what that kind of looks like

8945
06:33:55,130 --> 06:33:56,590
if we were to use a sequence.

8946
06:33:57,470 --> 06:33:59,320
Okay, so I've copied and pasted some code

8947
06:33:59,320 --> 06:34:01,640
and I've removed the
additional filter up here.

8948
06:34:01,640 --> 06:34:04,200
Now we now have down here
almost the same exact code.

8949
06:34:04,200 --> 06:34:06,660
The only thing is difference
is we have the sequence of,

8950
06:34:06,660 --> 06:34:10,100
and what the sequence of
is it returns a sequence,

8951
06:34:10,100 --> 06:34:12,520
which is basically something
that can be iterated over.

8952
06:34:12,520 --> 06:34:15,360
And a sequence is returned to
value through its iterator,

8953
06:34:15,360 --> 06:34:17,480
the values are evaluated lazily.

8954
06:34:17,480 --> 06:34:20,910
That's the key, values
are evaluated lazily

8955
06:34:20,910 --> 06:34:23,320
while lists are evaluated eagerly.

8956
06:34:24,210 --> 06:34:26,530
So we've created a sequence of this,

8957
06:34:26,530 --> 06:34:28,960
basically everything
else is the exact same

8958
06:34:28,960 --> 06:34:29,793
for both of these.

8959
06:34:29,793 --> 06:34:31,950
Now, if we run this, we're
gonna see the difference here

8960
06:34:31,950 --> 06:34:33,490
in the output.

8961
06:34:33,490 --> 06:34:36,140
And so we have the line
that's separating down here,

8962
06:34:36,140 --> 06:34:37,430
the top from the bottom.

8963
06:34:37,430 --> 06:34:41,600
So up top we have new list was
created, new list is created.

8964
06:34:41,600 --> 06:34:44,150
We can tell that because all
of the items were processed

8965
06:34:44,150 --> 06:34:45,950
in sequential order before it moved on

8966
06:34:45,950 --> 06:34:48,340
to the next map operation
or the next operation

8967
06:34:48,340 --> 06:34:49,340
inside of the chain.

8968
06:34:50,635 --> 06:34:51,680
However, instead of a sequence we can see

8969
06:34:51,680 --> 06:34:54,570
that the filter executed
for the first value X

8970
06:34:54,570 --> 06:34:57,730
and then X moved on to the next operation,

8971
06:34:57,730 --> 06:35:00,690
which was for each, the same thing for Y.

8972
06:35:00,690 --> 06:35:04,060
So as each item is coming
out of the sequence,

8973
06:35:04,060 --> 06:35:06,457
it's processing through the entire chain

8974
06:35:06,457 --> 06:35:08,220
until it hits down here,
hits the termination.

8975
06:35:08,220 --> 06:35:10,450
And so each item is
processed sequentially,

8976
06:35:10,450 --> 06:35:12,530
so as a sequence.

8977
06:35:12,530 --> 06:35:14,760
So if you have a very
large list or you have

8978
06:35:14,760 --> 06:35:17,470
a very high intensive chain of events

8979
06:35:17,470 --> 06:35:21,220
that are being processed,
it's recommending that you use

8980
06:35:21,220 --> 06:35:23,250
a sequence because it's
much more performing.

8981
06:35:23,250 --> 06:35:25,330
Now, if you have 10 items
and you're only performing

8982
06:35:25,330 --> 06:35:28,180
a couple of operations on
the list, should you use it,

8983
06:35:28,180 --> 06:35:31,330
we don't know, what if
it's 100, we don't know.

8984
06:35:31,330 --> 06:35:34,260
As the saying goes, what
gets measured gets managed.

8985
06:35:34,260 --> 06:35:37,630
So how do we measure if
something is slow or not?

8986
06:35:37,630 --> 06:35:39,680
Well, let's go ahead and delete this code

8987
06:35:41,313 --> 06:35:42,870
and let's go ahead and generate some code

8988
06:35:42,870 --> 06:35:45,770
that has a very high number of values.

8989
06:35:45,770 --> 06:35:48,460
Now the code that I'm
showing you is actually

8990
06:35:48,460 --> 06:35:51,070
from a gentleman named Benjamin.

8991
06:35:51,070 --> 06:35:54,720
And if we go over to,
I found this blog post

8992
06:35:54,720 --> 06:35:56,980
quite a while ago and it's
been the one I've relied on

8993
06:35:56,980 --> 06:35:59,350
for years on the sequences.

8994
06:35:59,350 --> 06:36:00,900
And he talks about all this stuff in here,

8995
06:36:00,900 --> 06:36:02,100
and I'll provide a link to it.

8996
06:36:02,100 --> 06:36:05,610
So I'm actually using the
same exact example he's using

8997
06:36:05,610 --> 06:36:09,160
to show how performant
some of this stuff is,

8998
06:36:09,160 --> 06:36:10,190
very, very useful.

8999
06:36:10,190 --> 06:36:12,200
Thank you, Benjamin, just
want them to give you credit

9000
06:36:12,200 --> 06:36:14,650
for writing this phenomenal blog article.

9001
06:36:14,650 --> 06:36:16,580
And I'm basically explaining
a lot of what's covered

9002
06:36:16,580 --> 06:36:19,200
in here, though he does
go into some more detail

9003
06:36:19,200 --> 06:36:20,720
with some other information.

9004
06:36:20,720 --> 06:36:22,730
Okay, so let's go ahead and get some code

9005
06:36:22,730 --> 06:36:24,680
to actually show how to measure things.

9006
06:36:25,760 --> 06:36:27,630
So I have some code in here and this code

9007
06:36:27,630 --> 06:36:29,120
does a couple of things.

9008
06:36:29,120 --> 06:36:33,160
We're generating a sequence as we can do,

9009
06:36:33,160 --> 06:36:35,800
which is built into the
Kotlin standard library.

9010
06:36:35,800 --> 06:36:37,530
So I'm generating a sequence,

9011
06:36:37,530 --> 06:36:38,860
I'm gonna seed it with a value of one.

9012
06:36:38,860 --> 06:36:41,710
And then for each iteration
again, generate sequence

9013
06:36:41,710 --> 06:36:44,410
is in the Kotlin center
library and it basically says,

9014
06:36:45,507 --> 06:36:47,320
you can give it a seed
value, and then we'll invoke

9015
06:36:47,320 --> 06:36:49,400
the next function for every single time

9016
06:36:49,400 --> 06:36:52,150
you want something from the sequence.

9017
06:36:52,150 --> 06:36:54,190
And so I'm gonna tell it to
just increment that value

9018
06:36:54,190 --> 06:36:56,906
and I want it to do it 15 million times.

9019
06:36:56,906 --> 06:36:58,710
So I have a sequence of 50
million items and then I say,

9020
06:36:58,710 --> 06:37:00,200
hey, turn that into a list.

9021
06:37:01,416 --> 06:37:04,730
And so now I have this
list of 50 million items,

9022
06:37:04,730 --> 06:37:07,420
which is a very large list
and it's gonna be processed

9023
06:37:07,420 --> 06:37:08,500
on the laptop.

9024
06:37:08,500 --> 06:37:10,460
So 50 million integers in the list.

9025
06:37:10,460 --> 06:37:11,840
And then what I wanna do is filter it.

9026
06:37:11,840 --> 06:37:14,230
So find anything that's
dividable by three,

9027
06:37:14,230 --> 06:37:15,180
and then average that out.

9028
06:37:15,180 --> 06:37:16,700
And of course, we're
gonna get a value back.

9029
06:37:16,700 --> 06:37:18,760
So let's go ahead and grab that value.

9030
06:37:18,760 --> 06:37:19,660
That's the result.

9031
06:37:21,000 --> 06:37:22,670
And we can go ahead and
put everything back up

9032
06:37:22,670 --> 06:37:25,480
on a single line here, 'cause
it kind of makes sense.

9033
06:37:25,480 --> 06:37:27,860
And then we'll do is print the result,

9034
06:37:28,910 --> 06:37:30,810
print line and we'll do it the result.

9035
06:37:33,170 --> 06:37:35,520
And then what this measure
method will do here,

9036
06:37:35,520 --> 06:37:37,440
which is what you've probably
been wondering about.

9037
06:37:37,440 --> 06:37:40,390
It takes in a block and a
block is just a unit of code.

9038
06:37:40,390 --> 06:37:43,180
And this measure function is
explained in another video,

9039
06:37:43,180 --> 06:37:45,840
but basically shows how long
it takes this chunk of code

9040
06:37:45,840 --> 06:37:47,390
to execute.

9041
06:37:47,390 --> 06:37:48,870
And so this is what's parsed in.

9042
06:37:48,870 --> 06:37:50,240
And so let's go ahead and execute this.

9043
06:37:50,240 --> 06:37:51,830
And then what we're gonna see at the end

9044
06:37:51,830 --> 06:37:55,230
is how long it took and
milliseconds to process this.

9045
06:37:55,230 --> 06:37:57,580
This could take anywhere
from eight to 20 seconds,

9046
06:37:57,580 --> 06:37:59,980
depends on my machine today.

9047
06:37:59,980 --> 06:38:02,498
I've seen it kind of
range all over the place,

9048
06:38:02,498 --> 06:38:04,390
depends on what's happening on my machine.

9049
06:38:04,390 --> 06:38:05,223
And it's still running.

9050
06:38:05,223 --> 06:38:08,640
We can tell this by the
stop icon is active,

9051
06:38:08,640 --> 06:38:11,066
which means there's something running.

9052
06:38:11,066 --> 06:38:12,350
The green little dot there
also helps us indicate

9053
06:38:12,350 --> 06:38:13,183
that something's running.

9054
06:38:13,183 --> 06:38:15,180
There we go, something came back.

9055
06:38:15,180 --> 06:38:19,600
So we have the result, which
is 2.5 to whatever power,

9056
06:38:19,600 --> 06:38:21,240
et cetera, very large number.

9057
06:38:21,240 --> 06:38:23,720
And it took us 18,000 milliseconds,

9058
06:38:23,720 --> 06:38:27,400
so basically about 18
seconds to run this process.

9059
06:38:27,400 --> 06:38:30,420
So, okay, so we have a
list we're processing

9060
06:38:30,420 --> 06:38:32,350
over the list and remember how we executed

9061
06:38:32,350 --> 06:38:33,610
those things before.

9062
06:38:33,610 --> 06:38:36,070
So let's go ahead and change this.

9063
06:38:36,070 --> 06:38:38,540
And instead of making this a list,

9064
06:38:38,540 --> 06:38:40,800
let's go ahead and make
this just a sequence.

9065
06:38:40,800 --> 06:38:43,240
And so to do that, I'm just
gonna remove this list here.

9066
06:38:43,240 --> 06:38:44,480
And instead of calling this a list,

9067
06:38:44,480 --> 06:38:47,720
I'm gonna call this to change
the name to a sequence.

9068
06:38:47,720 --> 06:38:48,670
So now this is a sequence.

9069
06:38:48,670 --> 06:38:49,960
So it's almost the same exact code,

9070
06:38:49,960 --> 06:38:52,460
I've just changed the
variable name and removed it

9071
06:38:52,460 --> 06:38:53,880
from being a list.

9072
06:38:53,880 --> 06:38:56,920
So let's rerun this to see
how fast it is to process

9073
06:38:56,920 --> 06:38:59,980
a very large list and do
a couple of operations.

9074
06:38:59,980 --> 06:39:01,460
Boom, we're already done.

9075
06:39:01,460 --> 06:39:05,990
So 50 million items with a
sequence took 628 milliseconds.

9076
06:39:05,990 --> 06:39:07,460
And if we did it with a list,

9077
06:39:08,316 --> 06:39:10,473
it took us almost 20 seconds to do.

9078
06:39:10,473 --> 06:39:11,530
So it's orders of operations,

9079
06:39:11,530 --> 06:39:15,220
much more efficient to use
a sequence in this manner.

9080
06:39:15,220 --> 06:39:17,460
At what point should you use a sequence,

9081
06:39:17,460 --> 06:39:20,930
that's up to you to decide,
should you be using a sequence?

9082
06:39:20,930 --> 06:39:23,380
If it's 10 items, depends
on how much processing

9083
06:39:23,380 --> 06:39:24,580
you're doing on those 10 items.

9084
06:39:24,580 --> 06:39:26,360
Are you doing 100 operations on it?

9085
06:39:27,515 --> 06:39:29,300
Maybe it's important to
you the sequence then.

9086
06:39:29,300 --> 06:39:31,450
What if you have 100 million
items and you're only doing

9087
06:39:31,450 --> 06:39:33,680
two operations on it,
like we're doing here

9088
06:39:33,680 --> 06:39:36,000
and only doing a filter and an average.

9089
06:39:36,000 --> 06:39:38,160
Should you use a sequencer, probably so.

9090
06:39:38,160 --> 06:39:41,290
But what if you have 10 operations,

9091
06:39:41,290 --> 06:39:43,710
it's not really doing much calculation

9092
06:39:43,710 --> 06:39:47,340
and it's only maybe 10
items in the collection.

9093
06:39:47,340 --> 06:39:50,810
Should you use a list maybe, maybe not,

9094
06:39:50,810 --> 06:39:52,180
it's up to you to decide.

9095
06:39:52,180 --> 06:39:55,600
I wouldn't focus on making
sure that everything

9096
06:39:55,600 --> 06:39:58,540
is performant, that's
premature optimization.

9097
06:39:58,540 --> 06:40:02,530
However, you can use this nice
little handy measure block

9098
06:40:02,530 --> 06:40:05,155
as we have here inside of your code,

9099
06:40:05,155 --> 06:40:07,316
throw it inside of a
utils folder or whatever

9100
06:40:07,316 --> 06:40:08,149
and then measure something.

9101
06:40:08,149 --> 06:40:10,440
If you find piece of your code,
kind of being really slow,

9102
06:40:10,440 --> 06:40:12,670
I highly recommend slapping
the measure block around it.

9103
06:40:12,670 --> 06:40:14,720
It'll give you a good
rule of thumb of like,

9104
06:40:14,720 --> 06:40:17,870
alright, is this taking a long
time or where is this slow?

9105
06:40:17,870 --> 06:40:20,360
If you find you're processing
around a large list

9106
06:40:20,360 --> 06:40:23,090
or list operations to
be slow, at that point,

9107
06:40:23,090 --> 06:40:26,510
it might be time to take
something and make it a sequence,

9108
06:40:26,510 --> 06:40:28,390
which it could be also very interesting.

9109
06:40:28,390 --> 06:40:32,600
So let's assume that for whatever
reason, we have a method.

9110
06:40:32,600 --> 06:40:37,280
And this method is called
get list of customers.

9111
06:40:37,280 --> 06:40:40,920
And this list of customers
comes from a database.

9112
06:40:40,920 --> 06:40:44,320
And it's gonna return a list
of data and this returns,

9113
06:40:44,320 --> 06:40:45,950
let's call this integers for now.

9114
06:40:46,917 --> 06:40:48,620
And then what we'll do
is I'm just gonna do this

9115
06:40:48,620 --> 06:40:53,110
right here, it's gonna return
a list to that to list.

9116
06:40:54,250 --> 06:40:56,280
We're just gonna pretend
that this is actually

9117
06:40:56,280 --> 06:40:57,320
is from a database.

9118
06:40:57,320 --> 06:40:58,930
So I'm gonna pretend it's in the library

9119
06:40:58,930 --> 06:40:59,870
and I get this out of here.

9120
06:40:59,870 --> 06:41:01,120
Okay, whatever.

9121
06:41:01,120 --> 06:41:04,690
So now I'm gonna have my changes to list.

9122
06:41:06,510 --> 06:41:08,900
Actually it will leave a sequence.

9123
06:41:08,900 --> 06:41:10,730
Actually, I'm gonna change it back to list

9124
06:41:10,730 --> 06:41:12,020
and I'll show you why in a second.

9125
06:41:12,020 --> 06:41:13,650
So we're gonna say this is list and say,

9126
06:41:13,650 --> 06:41:18,650
we'll say val list equals
get list of customers.

9127
06:41:19,200 --> 06:41:20,532
So there we go.

9128
06:41:20,532 --> 06:41:21,365
Now we have our list of customers.

9129
06:41:21,365 --> 06:41:23,900
we're gonna perform some filtering
on it and it's gonna run.

9130
06:41:23,900 --> 06:41:25,880
Now, as we know, this is
gonna take a long time

9131
06:41:25,880 --> 06:41:28,390
because this list of customers here

9132
06:41:28,390 --> 06:41:30,610
is a very, very large list.

9133
06:41:30,610 --> 06:41:33,410
Now, again, we're
generating this on the fly,

9134
06:41:33,410 --> 06:41:36,290
so let's go ahead and
pretend you don't see that.

9135
06:41:36,290 --> 06:41:39,460
Let's assume that it just returns a list

9136
06:41:39,460 --> 06:41:41,330
and we don't have control over that.

9137
06:41:41,330 --> 06:41:43,780
But however, now that
we have this large list,

9138
06:41:43,780 --> 06:41:45,960
however it's been processed
maybe on a background thread,

9139
06:41:45,960 --> 06:41:48,480
but now we have it and
we need to process it.

9140
06:41:48,480 --> 06:41:49,880
We now have control of them.

9141
06:41:49,880 --> 06:41:51,560
So this is a very large list.

9142
06:41:51,560 --> 06:41:53,260
Let's go ahead and run this again.

9143
06:41:55,450 --> 06:41:57,780
So we have that list of customers,

9144
06:41:57,780 --> 06:41:59,370
actually, we can go ahead and take,

9145
06:41:59,370 --> 06:42:00,340
let's assume that this is out here

9146
06:42:00,340 --> 06:42:02,580
'cause we don't wanna
measure that component there.

9147
06:42:02,580 --> 06:42:04,420
So we have our list of customers.

9148
06:42:04,420 --> 06:42:06,710
That list of customers is
gonna take probably eight

9149
06:42:06,710 --> 06:42:08,950
or 10 seconds to generate
because it has to turn it

9150
06:42:08,950 --> 06:42:10,310
into a list.

9151
06:42:10,310 --> 06:42:12,560
And most likely this block
of code will probably take

9152
06:42:12,560 --> 06:42:15,620
another eight or 10
seconds to execute as well.

9153
06:42:15,620 --> 06:42:17,570
So perhaps this is on a background thread.

9154
06:42:17,570 --> 06:42:20,250
We can't control that,
that just is what it is.

9155
06:42:20,250 --> 06:42:22,710
And we're maybe we're
gonna get that data back.

9156
06:42:22,710 --> 06:42:24,710
But now once it's off
that background thread,

9157
06:42:24,710 --> 06:42:28,070
we can control it, so for
example, it takes eight seconds.

9158
06:42:28,070 --> 06:42:31,380
So at that point, how
could we speed this up?

9159
06:42:32,610 --> 06:42:34,820
Well, because this is a
list at this point in time,

9160
06:42:34,820 --> 06:42:35,810
everything's running slow.

9161
06:42:35,810 --> 06:42:38,890
Now, thankfully there's
actually a nice method

9162
06:42:38,890 --> 06:42:42,060
on the collection here called as sequence.

9163
06:42:42,060 --> 06:42:44,510
And what this will do is will turn this,

9164
06:42:44,510 --> 06:42:46,780
I'm gonna go ahead and break
these into new lines here.

9165
06:42:46,780 --> 06:42:51,150
This will turn this list into a sequence.

9166
06:42:53,830 --> 06:42:56,335
And so what this will
allow us to do is get

9167
06:42:56,335 --> 06:42:57,840
some performance benefit
as treating this list

9168
06:42:57,840 --> 06:42:58,673
as a sequence.

9169
06:42:58,673 --> 06:43:01,780
And then from this point
on after this line,

9170
06:43:01,780 --> 06:43:04,160
everything will be operated sequentially

9171
06:43:04,160 --> 06:43:04,993
as a sequence would.

9172
06:43:04,993 --> 06:43:06,850
So let's go ahead and rerun this.

9173
06:43:10,230 --> 06:43:11,630
And as we're running
it here, we're waiting.

9174
06:43:11,630 --> 06:43:12,970
And of course, it's gonna take a while

9175
06:43:12,970 --> 06:43:14,850
because we're assuming this
is on a background thread.

9176
06:43:14,850 --> 06:43:17,260
It's gonna take awhile
eight or 10 seconds.

9177
06:43:17,260 --> 06:43:19,800
And then once we get a result back, boom.

9178
06:43:19,800 --> 06:43:21,490
Now this code has been measured.

9179
06:43:21,490 --> 06:43:23,780
Previously, it took them
as nine seconds to run.

9180
06:43:23,780 --> 06:43:27,670
Now we turned it into a
sequence via the as sequence

9181
06:43:27,670 --> 06:43:28,740
helper method.

9182
06:43:28,740 --> 06:43:31,740
And we have transformed this
from a nine second operation

9183
06:43:31,740 --> 06:43:34,860
into a 244 millisecond.

9184
06:43:34,860 --> 06:43:37,750
244 millisecond operation
orders of magnitude

9185
06:43:37,750 --> 06:43:40,820
faster just by slapping on as sequence.

9186
06:43:40,820 --> 06:43:42,710
Now, of course, you're not
going to get this benefit

9187
06:43:42,710 --> 06:43:44,600
if your list is 10 items,

9188
06:43:44,600 --> 06:43:47,380
you're not gonna see
that drastic improvement.

9189
06:43:47,380 --> 06:43:49,050
It's gonna be very
negligible at that point.

9190
06:43:49,050 --> 06:43:54,000
So follow the mantra of whatever
gets measured gets managed.

9191
06:43:54,000 --> 06:43:55,380
If you find slow piece in your code,

9192
06:43:55,380 --> 06:43:56,790
see what's taking a long time.

9193
06:43:56,790 --> 06:43:59,040
If it's a (indistinct) list or
a map or something like that,

9194
06:43:59,040 --> 06:44:00,790
perhaps you need to figure
out a way to turn it into

9195
06:44:00,790 --> 06:44:02,970
a sequence so you can get
some performance benefit

9196
06:44:02,970 --> 06:44:03,803
out of it.

9197
06:44:03,803 --> 06:44:05,380
And of course, be sure to
check out the blog link

9198
06:44:05,380 --> 06:44:07,370
in the show notes.

9199
06:44:07,370 --> 06:44:10,350
So big hat tip to
Benjamin for demonstrating

9200
06:44:10,350 --> 06:44:11,330
a perfect example.

9201
06:44:11,330 --> 06:44:12,270
I tried to create my own,

9202
06:44:12,270 --> 06:44:14,400
but his example was just
so succinct and great.

9203
06:44:14,400 --> 06:44:16,100
Thank you Benjamin for doing that.

9204
06:44:21,080 --> 06:44:24,470
What's the difference
between a list, a set, a map,

9205
06:44:24,470 --> 06:44:25,303
and a sequence?

9206
06:44:26,170 --> 06:44:28,270
Well, a list of data inside of Kotlin

9207
06:44:28,270 --> 06:44:29,380
can be a list of anything.

9208
06:44:29,380 --> 06:44:31,060
It can be a list of primitive values

9209
06:44:31,060 --> 06:44:32,660
such as strings as we have here.

9210
06:44:33,721 --> 06:44:34,554
So we have lists.

9211
06:44:34,554 --> 06:44:38,230
We have some names, Donn
Tushar, Cavita Evelyn, Felicia.

9212
06:44:38,230 --> 06:44:40,531
This could also be a list of integers.

9213
06:44:40,531 --> 06:44:45,531
So we could have a list of
integers of one, two, 12, 23, 44,

9214
06:44:45,540 --> 06:44:46,680
66, et cetera.

9215
06:44:47,630 --> 06:44:49,890
And they can be a list of integers.

9216
06:44:49,890 --> 06:44:50,723
It could be a list of objects.

9217
06:44:50,723 --> 06:44:55,470
So any time you need a
list of data to work with,

9218
06:44:55,470 --> 06:44:56,910
you're gonna wanna use a list.

9219
06:44:56,910 --> 06:44:58,140
Now, as you can see here,

9220
06:44:58,140 --> 06:45:01,490
the list right now is strongly
typed to be a list of string.

9221
06:45:01,490 --> 06:45:03,680
And again, if you need
it to be a mutable list,

9222
06:45:03,680 --> 06:45:07,499
you would type mutable list
of which means this is a list

9223
06:45:07,499 --> 06:45:08,332
that you could change.

9224
06:45:08,332 --> 06:45:10,500
So the same thing goes for
almost any of the collections

9225
06:45:10,500 --> 06:45:13,480
inside of Kotlin.

9226
06:45:13,480 --> 06:45:14,650
If you want it to be mutable,

9227
06:45:14,650 --> 06:45:17,680
you'll actually slot the word
mutable at the beginning.

9228
06:45:17,680 --> 06:45:18,940
So when do you wanna use a set?

9229
06:45:18,940 --> 06:45:22,840
Well, a set remember only
include unique items.

9230
06:45:22,840 --> 06:45:23,990
So in this case,

9231
06:45:23,990 --> 06:45:27,130
I've set a creative set
of these four items,

9232
06:45:27,130 --> 06:45:29,550
Don, Tusha, Donn and Tusha.

9233
06:45:29,550 --> 06:45:31,200
Now, when we actually print these out,

9234
06:45:31,200 --> 06:45:32,033
if we were to print it,

9235
06:45:32,033 --> 06:45:34,940
we would see that this set
actually only includes two items

9236
06:45:34,940 --> 06:45:37,710
because a set does not
allow multiple duplicates

9237
06:45:37,710 --> 06:45:39,410
of an item inside of there.

9238
06:45:39,410 --> 06:45:42,430
So here, it's going to see that
Donn is then presented twice

9239
06:45:42,430 --> 06:45:43,990
so it will not add the second one.

9240
06:45:43,990 --> 06:45:46,120
And the same thing for Tusha
has been added another time.

9241
06:45:46,120 --> 06:45:48,010
So it will not add a second one.

9242
06:45:48,010 --> 06:45:51,740
And this result will only be
in the set be Donn and Tusha.

9243
06:45:51,740 --> 06:45:54,870
So if you need your items to
be unique inside of basically

9244
06:45:54,870 --> 06:45:57,520
you need a unique list,
you're gonna wanna use a set.

9245
06:45:58,562 --> 06:45:59,395
So what about a map?

9246
06:45:59,395 --> 06:46:00,520
So when would you use a map?

9247
06:46:00,520 --> 06:46:04,460
Well, a map is basically a
mapping of one value to another,

9248
06:46:04,460 --> 06:46:06,310
and I like to think of
it as a key-value pair.

9249
06:46:06,310 --> 06:46:09,050
And that's what this is, is a
map right here with the helper

9250
06:46:09,050 --> 06:46:12,350
is we have the key, which
is a string and the value,

9251
06:46:12,350 --> 06:46:13,390
which is a string.

9252
06:46:13,390 --> 06:46:16,440
Now this does not mean that
you have to always use string

9253
06:46:16,440 --> 06:46:17,708
and string.

9254
06:46:17,708 --> 06:46:20,330
So we can say map to, we
could actually say map of,

9255
06:46:20,330 --> 06:46:24,060
and I'm going to say one to Don

9256
06:46:24,060 --> 06:46:28,400
and then we say two to Tusha.

9257
06:46:28,400 --> 06:46:32,220
And what this does, it creates
a map with the key being

9258
06:46:32,220 --> 06:46:35,060
an integer and then the
value being a string.

9259
06:46:35,060 --> 06:46:37,850
So you can create a map of
all different types of things.

9260
06:46:37,850 --> 06:46:40,313
If you wanted to create it as an object,

9261
06:46:40,313 --> 06:46:41,200
you could create it as
its own custom object.

9262
06:46:41,200 --> 06:46:44,150
If you had say a data class,

9263
06:46:44,150 --> 06:46:48,180
it'd be person and we maybe
had val name, it's a string.

9264
06:46:48,180 --> 06:46:52,960
What you could do is you can
make this map, turn to person,

9265
06:46:52,960 --> 06:46:57,960
Donn to, maybe he does Android.

9266
06:46:58,980 --> 06:47:01,880
And we wanna have a map of person Tushar,

9267
06:47:04,450 --> 06:47:08,410
which then maps to let's say he does J2EE.

9268
06:47:09,940 --> 06:47:13,530
And at that point, we now
have a map where the key

9269
06:47:13,530 --> 06:47:15,750
is a person object and
the value of the string.

9270
06:47:15,750 --> 06:47:17,060
And of course it could be flipped around.

9271
06:47:17,060 --> 06:47:19,860
There's no rhyme or reason
to what you would want.

9272
06:47:19,860 --> 06:47:21,370
It's just a data structure that allows you

9273
06:47:21,370 --> 06:47:22,540
to have a map and a key.

9274
06:47:22,540 --> 06:47:24,660
So if you ever need to
have a map and a key,

9275
06:47:24,660 --> 06:47:27,600
you're gonna wanna use a
map type data structure.

9276
06:47:28,790 --> 06:47:31,500
All right, so when would
you wanna use a sequence?

9277
06:47:31,500 --> 06:47:33,450
Now sequence is basically
going to be anytime

9278
06:47:33,450 --> 06:47:36,360
you want something that's gonna
be more highly performant.

9279
06:47:36,360 --> 06:47:38,790
And this could be, if you
have a very large list.

9280
06:47:38,790 --> 06:47:41,000
So maybe 50 million items in a list

9281
06:47:41,000 --> 06:47:43,200
or you have a bunch of
items you need to process.

9282
06:47:43,200 --> 06:47:45,500
So you have 100 items in a
list and you need to process it

9283
06:47:45,500 --> 06:47:48,269
through a bunch of different maps.

9284
06:47:48,269 --> 06:47:49,102
You're gonna do list.map,

9285
06:47:50,331 --> 06:47:52,950
and then you need to do another
map for whatever reason,

9286
06:47:53,847 --> 06:47:54,780
a map, and then you're
gonna do it for a reason,

9287
06:47:54,780 --> 06:47:57,080
you can do a flat map and then
you're gonna go from there

9288
06:47:57,080 --> 06:47:59,830
and you're gonna do a filter,
or you can do an average,

9289
06:48:00,710 --> 06:48:01,870
actually I'm not gonna work that way.

9290
06:48:01,870 --> 06:48:04,792
But the new map won't work on a flat map

9291
06:48:04,792 --> 06:48:05,625
because you have a list.

9292
06:48:06,841 --> 06:48:08,750
And then so you have, you
know, some averages that are,

9293
06:48:08,750 --> 06:48:11,350
or whatever you get inside
of here and you can filter

9294
06:48:11,350 --> 06:48:13,190
and all different kinds of things.

9295
06:48:13,190 --> 06:48:15,150
And let's say, assume all
of these different things

9296
06:48:15,150 --> 06:48:20,150
had very complex calculations
that took a lot of time

9297
06:48:20,230 --> 06:48:23,630
because lists and so forth
are evaluated eagerly.

9298
06:48:24,610 --> 06:48:26,180
A new list is created each time.

9299
06:48:26,180 --> 06:48:28,780
Then there's actually a
lesson that you can view

9300
06:48:28,780 --> 06:48:31,010
that will show the performance
metrics of actually using

9301
06:48:31,010 --> 06:48:33,580
a sequence overlords lists.

9302
06:48:33,580 --> 06:48:35,670
And so if you need performance,
you'll wanna use a sequence.

9303
06:48:35,670 --> 06:48:37,530
Now, you can also take a large list

9304
06:48:37,530 --> 06:48:39,970
and turn it into a sequence here.

9305
06:48:39,970 --> 06:48:43,220
You can also turn a map and
turn it into a sequence as well.

9306
06:48:43,220 --> 06:48:45,470
So if you have a large map or a large list

9307
06:48:45,470 --> 06:48:47,450
and you need to process it, sequentially,

9308
06:48:47,450 --> 06:48:49,120
you can just slap as sequence on there

9309
06:48:49,120 --> 06:48:51,230
and it will process accordingly.

9310
06:48:51,230 --> 06:48:52,570
And then you can make things very quickly.

9311
06:48:52,570 --> 06:48:53,790
And then if for whatever reason,

9312
06:48:53,790 --> 06:48:55,970
after you're done processing the sequence,

9313
06:48:55,970 --> 06:48:58,260
you would like to turn that
sequence into a list again,

9314
06:48:58,260 --> 06:49:00,502
you can turn it into a list as well.

9315
06:49:00,502 --> 06:49:01,335
Of course, you're gonna wanna measure

9316
06:49:01,335 --> 06:49:02,168
the performance benefit.

9317
06:49:02,168 --> 06:49:05,610
So sequence usually use for performants.

9318
06:49:05,610 --> 06:49:07,480
So if you have large lists, large maps,

9319
06:49:07,480 --> 06:49:10,140
or you're doing a lot
of mapping operations,

9320
06:49:10,140 --> 06:49:12,160
you're doing a lot of
operations, you know,

9321
06:49:12,160 --> 06:49:15,390
on the data structure itself,
then you wanna go ahead

9322
06:49:15,390 --> 06:49:18,890
and turn it into a sequence
or use a sequence if possible.

9323
06:49:20,398 --> 06:49:21,750
And of course you can always
use generate sequence.

9324
06:49:21,750 --> 06:49:24,380
So that's the difference
between the list, set, map

9325
06:49:24,380 --> 06:49:25,213
and sequence.

9326
06:49:26,650 --> 06:49:29,150
Kotlin does not have a ternary operator.

9327
06:49:29,150 --> 06:49:31,672
So if you're looking to
do something like this,

9328
06:49:31,672 --> 06:49:34,440
let's assume we want to get
the length of the string,

9329
06:49:34,440 --> 06:49:36,500
but we only wanna do it, if it's not null,

9330
06:49:36,500 --> 06:49:39,220
perhaps we could say something like this.

9331
06:49:39,220 --> 06:49:40,770
You might be used to doing like this.

9332
06:49:40,770 --> 06:49:43,986
If name does not equal
null then we're gonna do

9333
06:49:43,986 --> 06:49:47,280
name.length, otherwise wanna do zero.

9334
06:49:48,315 --> 06:49:50,480
So you may wanna do something like that.

9335
06:49:50,480 --> 06:49:53,110
You'll see here, we have
to use some wiggly things.

9336
06:49:53,110 --> 06:49:54,490
It's not letting us do this.

9337
06:49:54,490 --> 06:49:56,790
This is because the ternary
operator does not exist

9338
06:49:56,790 --> 06:49:57,760
in Kotlin.

9339
06:49:57,760 --> 06:50:00,600
So to do this, you need to use
a single line if statement.

9340
06:50:00,600 --> 06:50:05,460
So if name's not equal to
null you can do name.length,

9341
06:50:07,650 --> 06:50:10,530
else zero.

9342
06:50:11,790 --> 06:50:14,770
Now this will give you the
length here so we can say

9343
06:50:15,780 --> 06:50:20,780
print line length, and then
you can run the code here

9344
06:50:23,120 --> 06:50:25,470
and you'll see that the
length is then returned.

9345
06:50:25,470 --> 06:50:27,520
And for whatever reason, if this is null,

9346
06:50:29,160 --> 06:50:30,140
we can return that.

9347
06:50:31,560 --> 06:50:34,190
And then we'll get zero because
it's handled accordingly.

9348
06:50:34,190 --> 06:50:39,160
Now we get this nice little use
here where we can replace it

9349
06:50:39,160 --> 06:50:40,980
with the Elvis expression.

9350
06:50:40,980 --> 06:50:43,110
If you know what that
is, you can use that.

9351
06:50:43,110 --> 06:50:46,470
But if you are looking for a
ternary operator in Kotlin,

9352
06:50:46,470 --> 06:50:47,303
it does not exist.

9353
06:50:47,303 --> 06:50:49,820
So you wanna use a single
line If Statement instead.

9354
06:50:52,034 --> 06:50:52,867
It's very often that you could be working

9355
06:50:52,867 --> 06:50:55,550
inside of some code and you
may need to do something.

9356
06:50:55,550 --> 06:50:58,900
For example, you may need to
get the length of the name

9357
06:50:58,900 --> 06:51:02,000
of a particular value, maybe of a string

9358
06:51:02,000 --> 06:51:03,700
and you wanna say name.length.

9359
06:51:04,620 --> 06:51:05,500
Now what you'll notice here,

9360
06:51:05,500 --> 06:51:08,070
because we're working
with a nullable string,

9361
06:51:08,070 --> 06:51:09,180
that we cannot do this.

9362
06:51:09,180 --> 06:51:11,610
Only safe calls can, this can happen.

9363
06:51:11,610 --> 06:51:12,660
So we're gonna get back.

9364
06:51:12,660 --> 06:51:14,860
We could change this to a safe call.

9365
06:51:14,860 --> 06:51:16,400
This would give us a nullable integer.

9366
06:51:16,400 --> 06:51:18,840
However, if we're
working in an environment

9367
06:51:18,840 --> 06:51:21,200
where we do not wanna work with nulls,

9368
06:51:21,200 --> 06:51:22,900
this is not going to work for us.

9369
06:51:22,900 --> 06:51:24,770
So there's a couple of things we could do.

9370
06:51:24,770 --> 06:51:27,440
If we can change the data type
to actually be non-nullable,

9371
06:51:27,440 --> 06:51:28,950
that would be fantastic.

9372
06:51:28,950 --> 06:51:32,130
However, sometimes data comes
back from other libraries,

9373
06:51:32,130 --> 06:51:35,030
such as Java libraries,
where the nullable type

9374
06:51:35,030 --> 06:51:37,750
is just going to be there and
we can't do anything about it.

9375
06:51:37,750 --> 06:51:41,070
However, we may understand
at some point in time

9376
06:51:41,070 --> 06:51:44,080
that we know for certain that this value

9377
06:51:44,080 --> 06:51:44,913
is not going to be known.

9378
06:51:44,913 --> 06:51:47,080
Now, this is something I
usually don't recommend,

9379
06:51:47,080 --> 06:51:48,390
but there's a way to do that.

9380
06:51:48,390 --> 06:51:52,290
And we can use the double
bang operator to tell Kotlin,

9381
06:51:52,290 --> 06:51:53,810
look, I know what I'm doing.

9382
06:51:53,810 --> 06:51:56,300
I know that a named value
is not gonna be null,

9383
06:51:56,300 --> 06:51:58,490
which we can see directly from here.

9384
06:51:58,490 --> 06:52:00,810
There's no way on nothing in line five.

9385
06:52:00,810 --> 06:52:03,350
That's making this not null.

9386
06:52:03,350 --> 06:52:04,280
We're making this null.

9387
06:52:04,280 --> 06:52:06,320
So we're basically telling Kotlin,

9388
06:52:06,320 --> 06:52:07,390
don't worry, I know what I'm doing.

9389
06:52:07,390 --> 06:52:09,680
Trust me, just go ahead and treat this

9390
06:52:09,680 --> 06:52:11,590
as something that's not null.

9391
06:52:11,590 --> 06:52:14,280
And then what we'll have
happen is we'll go ahead

9392
06:52:14,280 --> 06:52:19,280
and we can say print line
length, and then we can run it.

9393
06:52:19,550 --> 06:52:23,220
And then what will happen is
we'll then have a int value,

9394
06:52:23,220 --> 06:52:27,050
which is again, it's only
going to be a regular integer,

9395
06:52:27,050 --> 06:52:28,570
so it's not gonna be nullable

9396
06:52:28,570 --> 06:52:30,910
and then we'll get the length of four.

9397
06:52:30,910 --> 06:52:33,100
Now, the real challenge comes in here

9398
06:52:35,420 --> 06:52:37,540
when you're telling Kotlin, hey, trust me,

9399
06:52:37,540 --> 06:52:39,510
I know this is not gonna be null,

9400
06:52:39,510 --> 06:52:41,490
but for some reason it ends up null.

9401
06:52:41,490 --> 06:52:43,510
And this can end up showing
up inside of your code

9402
06:52:43,510 --> 06:52:44,690
multiple times.

9403
06:52:44,690 --> 06:52:47,430
So if you find yourself
doing something like this

9404
06:52:47,430 --> 06:52:49,620
all over the place, you
might wanna inspect your code

9405
06:52:49,620 --> 06:52:51,640
to see if it's something is correct.

9406
06:52:51,640 --> 06:52:54,241
Now on tests, you may have it a lot,

9407
06:52:54,241 --> 06:52:56,220
but in this instance, perhaps I've said,

9408
06:52:56,220 --> 06:52:57,360
hey, this should not be null.

9409
06:52:57,360 --> 06:52:59,870
Maybe this code on line
six is buried somewhere

9410
06:52:59,870 --> 06:53:01,330
in a method somewhere.

9411
06:53:01,330 --> 06:53:03,120
But what happen is when Kotlin says,

9412
06:53:03,120 --> 06:53:07,320
hey, go ahead and just treat
this as a nominal value

9413
06:53:07,320 --> 06:53:09,610
and give me the length
on it, and it's null,

9414
06:53:09,610 --> 06:53:11,900
it'll throw a Kotlin and
null pointer exception.

9415
06:53:11,900 --> 06:53:13,940
So this will blow up your application.

9416
06:53:13,940 --> 06:53:16,750
So you do have to be
careful in this regard

9417
06:53:16,750 --> 06:53:18,750
to see if you want to
actually work with this.

9418
06:53:18,750 --> 06:53:20,630
So again, if you know what you're doing

9419
06:53:20,630 --> 06:53:22,190
and you wanna tell Kotlin about it,

9420
06:53:22,190 --> 06:53:23,300
you can go ahead and say,

9421
06:53:23,300 --> 06:53:24,600
hey, Kotlin, I know what I'm doing.

9422
06:53:24,600 --> 06:53:26,200
Use the double bang operator.

9423
06:53:26,200 --> 06:53:28,859
The same thing could go for a class.

9424
06:53:28,859 --> 06:53:31,790
So if we have a person and
then we have a vowel name

9425
06:53:32,655 --> 06:53:33,890
and that's gonna be a string,

9426
06:53:33,890 --> 06:53:35,560
we could actually say something like this.

9427
06:53:35,560 --> 06:53:37,260
And we can have a nullable person.

9428
06:53:38,395 --> 06:53:39,950
Let's say person,

9429
06:53:39,950 --> 06:53:42,641
and that's gonna be a
person that's nullable,

9430
06:53:42,641 --> 06:53:44,290
again, maybe this comes back from an API

9431
06:53:44,290 --> 06:53:46,150
and it could be empty or whatever.

9432
06:53:46,150 --> 06:53:48,340
And so the person could be Don.

9433
06:53:49,470 --> 06:53:52,000
At this point in time
I could say, if I wanna

9434
06:53:52,000 --> 06:53:54,130
kind of get the values of print ln,

9435
06:53:55,090 --> 06:53:56,690
I wanna print the person's name.

9436
06:53:57,790 --> 06:54:00,600
Well, this is not gonna
work because again,

9437
06:54:00,600 --> 06:54:02,690
person is nullable and Kotlin will say,

9438
06:54:02,690 --> 06:54:04,700
hey, we're not sure if this is a safe call

9439
06:54:04,700 --> 06:54:07,260
because well, person's nullable,

9440
06:54:07,260 --> 06:54:09,120
and this could end up being
a null pointer exception.

9441
06:54:09,120 --> 06:54:10,260
So I could handle it this way.

9442
06:54:10,260 --> 06:54:12,780
And if I did handle it
this way, if we ran it,

9443
06:54:12,780 --> 06:54:15,190
it would still work, we
would get the person's name.

9444
06:54:15,190 --> 06:54:16,023
It would be Don.

9445
06:54:16,023 --> 06:54:19,540
However, if for some reason
this was comment that out,

9446
06:54:19,540 --> 06:54:21,940
and this was no we're now gonna go ahead

9447
06:54:21,940 --> 06:54:25,920
and we run this again,
it's gonna show up as null.

9448
06:54:25,920 --> 06:54:27,430
But again, maybe we don't want that,

9449
06:54:27,430 --> 06:54:30,670
we want it to say, hey, trust
us, we know what we're doing.

9450
06:54:30,670 --> 06:54:33,440
So you can use also the double
bang operator inside of here.

9451
06:54:33,440 --> 06:54:35,770
Again, if the value is null
as it's happening here,

9452
06:54:35,770 --> 06:54:38,960
you're going to get this
Kotlin null pointer exception.

9453
06:54:38,960 --> 06:54:40,740
So if we were to just remove this,

9454
06:54:40,740 --> 06:54:43,341
again, it's going to work as we expect.

9455
06:54:43,341 --> 06:54:46,000
But usually my recommendation
is if you see yourself

9456
06:54:46,000 --> 06:54:48,470
or wanting yourself to add
these values all over the place,

9457
06:54:48,470 --> 06:54:50,070
you might wanna figure
out if there's a way

9458
06:54:50,070 --> 06:54:53,030
where you can not use that or
use something like required,

9459
06:54:53,030 --> 06:54:55,190
not null which is in another video

9460
06:54:55,190 --> 06:54:57,260
and link in the show notes below.

9461
06:54:58,820 --> 06:55:01,940
In some Kotlin code bases,
you may find yourself

9462
06:55:01,940 --> 06:55:03,970
wanting to type the double
bang operator to force

9463
06:55:03,970 --> 06:55:06,780
a nullable value to not
be nullable anymore.

9464
06:55:06,780 --> 06:55:07,710
You're basically telling Kotlin,

9465
06:55:07,710 --> 06:55:10,215
hey, trust me, I know what I'm doing.

9466
06:55:10,215 --> 06:55:12,340
This can happen for regular
primitive nullable types,

9467
06:55:12,340 --> 06:55:15,840
such as the strings integers,
et cetera, Boolean values,

9468
06:55:15,840 --> 06:55:18,940
or it can also happen
for the nullable objects

9469
06:55:18,940 --> 06:55:21,800
such as a person object that we have here.

9470
06:55:21,800 --> 06:55:23,000
Now, there's a way around this.

9471
06:55:23,000 --> 06:55:24,790
If you don't wanna type
the double bang operator,

9472
06:55:24,790 --> 06:55:26,720
you can also use what is built in

9473
06:55:26,720 --> 06:55:27,990
to the Kotlin standard library,

9474
06:55:27,990 --> 06:55:30,520
which is called require not null,

9475
06:55:30,520 --> 06:55:35,520
and require not null basically
will turn this value,

9476
06:55:35,620 --> 06:55:38,690
which if you look at it
into a non nullable type,

9477
06:55:38,690 --> 06:55:39,930
if it's null, though,

9478
06:55:39,930 --> 06:55:41,950
it will throw in a legal argument section,

9479
06:55:41,950 --> 06:55:44,350
otherwise returns the not null value.

9480
06:55:44,350 --> 06:55:48,060
So if we run this here, what
we'll see is it'll continue

9481
06:55:48,060 --> 06:55:51,750
to run this fine because we
have the length of the name.

9482
06:55:51,750 --> 06:55:55,370
This has now been turned
into a regular string,

9483
06:55:55,370 --> 06:55:56,690
not a nullable string.

9484
06:55:56,690 --> 06:56:00,640
However, if for whatever reason,
this comes back from an API

9485
06:56:00,640 --> 06:56:04,060
or database or something,
and that value is null

9486
06:56:04,060 --> 06:56:05,320
and we process it.

9487
06:56:05,320 --> 06:56:07,230
What will then happen is Kotlin will throw

9488
06:56:07,230 --> 06:56:08,760
an illegal argument exception saying,

9489
06:56:08,760 --> 06:56:10,850
hey, the required value is null.

9490
06:56:10,850 --> 06:56:14,040
Now, to be honest, this
error message while helpful,

9491
06:56:14,040 --> 06:56:16,900
this required value is
null, in a large code base,

9492
06:56:16,900 --> 06:56:18,150
this is not very helpful.

9493
06:56:19,188 --> 06:56:21,210
This can be kind of like,
okay, there was a null value

9494
06:56:21,210 --> 06:56:23,280
somewhere that we shouldn't
have got, where's it at?

9495
06:56:23,280 --> 06:56:26,250
Okay, let's look at the stack
trace, there's a stack trace.

9496
06:56:26,250 --> 06:56:27,300
Let's go investigate it.

9497
06:56:27,300 --> 06:56:29,740
Sometimes it helps to have
some additional information

9498
06:56:29,740 --> 06:56:30,573
inside of there.

9499
06:56:30,573 --> 06:56:32,970
And so you can do that,
there's actually an overload

9500
06:56:32,970 --> 06:56:36,740
of this, which will allow you
to provide a lazy message,

9501
06:56:36,740 --> 06:56:38,910
which will be the result
of that being called.

9502
06:56:38,910 --> 06:56:40,730
And so it can be a function.

9503
06:56:40,730 --> 06:56:42,860
And we're just gonna go
ahead and use the lambda.

9504
06:56:42,860 --> 06:56:45,992
And I'm gonna say something like the name

9505
06:56:45,992 --> 06:56:50,380
should not be null, but
it was, exclamation point.

9506
06:56:50,380 --> 06:56:52,580
Now, if I run this, we'll
still get an illegal

9507
06:56:52,580 --> 06:56:54,810
argument exception, but
we'll get the message

9508
06:56:54,810 --> 06:56:56,900
the name should not be null but it was.

9509
06:56:56,900 --> 06:56:59,458
And you could provide some
additional information

9510
06:56:59,458 --> 06:57:02,430
inside of here, perhaps that
might help you debugging,

9511
06:57:02,430 --> 06:57:05,243
if you were throwing in
legal argument exception,

9512
06:57:05,243 --> 06:57:07,540
and you have a crash
handler on your application,

9513
06:57:07,540 --> 06:57:09,440
if you're having an Android application,

9514
06:57:09,440 --> 06:57:11,330
this information is gonna show up inside

9515
06:57:11,330 --> 06:57:13,660
of your crash tracking utility.

9516
06:57:13,660 --> 06:57:14,670
So you might be able to say,

9517
06:57:14,670 --> 06:57:16,900
hey, here's the value that came in.

9518
06:57:16,900 --> 06:57:19,800
You could throw additional
information inside of here

9519
06:57:19,800 --> 06:57:22,970
that might help you diagnose what it is.

9520
06:57:22,970 --> 06:57:26,450
Sometimes, maybe a backend
changed and they are sending

9521
06:57:26,450 --> 06:57:29,360
a nullable value that was
not supposed to be nullable,

9522
06:57:29,360 --> 06:57:32,890
and you're not expecting it
to be null and things blow up.

9523
06:57:32,890 --> 06:57:35,580
And so you can just say require not null

9524
06:57:35,580 --> 06:57:37,240
and that'll get you around it there.

9525
06:57:37,240 --> 06:57:39,680
Now there's also, you
can do the same thing

9526
06:57:39,680 --> 06:57:42,950
for objects as well, not
just primitive types.

9527
06:57:42,950 --> 06:57:46,180
So we have this person here,
perhaps we don't wanna use

9528
06:57:46,180 --> 06:57:47,510
a double bang operator here.

9529
06:57:47,510 --> 06:57:51,380
We can go ahead and say require not null.

9530
06:57:51,380 --> 06:57:53,010
And again, it's just
gonna take this object

9531
06:57:53,010 --> 06:57:54,950
and make it to this not null type.

9532
06:57:55,910 --> 06:57:56,810
And there we go.

9533
06:57:56,810 --> 06:57:59,320
And if we run that everything
should run accordingly,

9534
06:57:59,320 --> 06:58:02,680
except we're gonna get that
exception, so let's fix that.

9535
06:58:02,680 --> 06:58:04,310
That's the exception from up here.

9536
06:58:04,310 --> 06:58:05,660
So I would just say Don.

9537
06:58:07,136 --> 06:58:10,060
And if we run this now, we'll
see that we get the Don,

9538
06:58:10,060 --> 06:58:11,000
which is down here in the bottom,

9539
06:58:11,000 --> 06:58:13,140
which is from this print line down here.

9540
06:58:13,140 --> 06:58:15,500
So we can actually just go
ahead and get rid of that

9541
06:58:15,500 --> 06:58:17,130
to make it easier.

9542
06:58:17,130 --> 06:58:21,180
And then if for whatever
reason this person was null,

9543
06:58:22,980 --> 06:58:24,180
same thing happens here.

9544
06:58:25,469 --> 06:58:26,870
So you can say require not
null on an actual class,

9545
06:58:26,870 --> 06:58:28,900
you'll get the same thing,
the required value was null.

9546
06:58:28,900 --> 06:58:30,420
Again, just like the other version,

9547
06:58:30,420 --> 06:58:32,260
it's the same exact thing.

9548
06:58:32,260 --> 06:58:34,370
You can put some other our message here.

9549
06:58:34,370 --> 06:58:36,570
So hi friends.

9550
06:58:36,570 --> 06:58:38,040
Not that you would wanna
do this in production,

9551
06:58:38,040 --> 06:58:39,980
but this basically oops,

9552
06:58:39,980 --> 06:58:41,980
and that needs to be inside of a lambda.

9553
06:58:43,550 --> 06:58:45,570
So that just needs to be there.

9554
06:58:45,570 --> 06:58:48,830
And then it'll actually show
up in there, so hi friends.

9555
06:58:48,830 --> 06:58:50,300
You can put any message
you want inside there.

9556
06:58:50,300 --> 06:58:53,580
So person should not be null, here we go.

9557
06:58:57,060 --> 06:58:59,637
And then once you run it and
you'll see that the person

9558
06:58:59,637 --> 06:59:00,470
should not be null.

9559
06:59:00,470 --> 06:59:03,220
And that's how you can
use a require not null

9560
06:59:03,220 --> 06:59:04,570
inside of your application.

9561
06:59:05,494 --> 06:59:06,330
So you may have some
code in your application

9562
06:59:06,330 --> 06:59:09,300
that looks like this, you have
an object, that's a person.

9563
06:59:09,300 --> 06:59:11,760
And for whatever reason, it
comes back from the API as null

9564
06:59:11,760 --> 06:59:13,366
or it doesn't.

9565
06:59:13,366 --> 06:59:15,323
And then inside of your code,
you're using the double bang

9566
06:59:15,323 --> 06:59:20,323
operator to force the person
object to not be null.

9567
06:59:20,510 --> 06:59:21,530
So of course this wouldn't work.

9568
06:59:21,530 --> 06:59:23,630
You could do something like
this, this would also work.

9569
06:59:23,630 --> 06:59:25,010
It's actually much cleaner in my opinion,

9570
06:59:25,010 --> 06:59:28,040
this way than forcing it to be not null,

9571
06:59:28,040 --> 06:59:31,290
because we could not run into situations.

9572
06:59:31,290 --> 06:59:33,380
But as for whatever reason,
let's say you do have that

9573
06:59:33,380 --> 06:59:35,860
or you're using require not null.

9574
06:59:35,860 --> 06:59:37,880
And require not null will basically turn

9575
06:59:39,632 --> 06:59:40,530
that nullable person
into a regular person.

9576
06:59:40,530 --> 06:59:42,900
However, there's also check not null.

9577
06:59:44,420 --> 06:59:47,930
And check not null basically
does the exact same thing

9578
06:59:47,930 --> 06:59:49,700
as required not null.

9579
06:59:49,700 --> 06:59:51,870
And if we go to the implementation here,

9580
06:59:51,870 --> 06:59:54,130
we'll actually see that check not null,

9581
06:59:54,130 --> 06:59:58,300
which is down here at the bottom
is basically the exact same

9582
06:59:58,300 --> 06:59:59,740
as require not null.

9583
06:59:59,740 --> 07:00:01,690
So let's go ahead and shrink this down.

9584
07:00:02,896 --> 07:00:04,790
Let's see if we can get it
all into the same screen.

9585
07:00:04,790 --> 07:00:05,900
Very close.

9586
07:00:05,900 --> 07:00:07,510
So require not null is up here.

9587
07:00:10,036 --> 07:00:12,770
And then we have check not
null, which is down here.

9588
07:00:12,770 --> 07:00:15,000
And we could see it as a
contract for require not null

9589
07:00:15,000 --> 07:00:17,090
checks the value, we get the lazy message.

9590
07:00:17,090 --> 07:00:21,280
And if we look down here,
the code is exactly the same.

9591
07:00:21,280 --> 07:00:22,560
So it's doing the same exact thing.

9592
07:00:22,560 --> 07:00:25,470
It's basically checking
to see if it's not null

9593
07:00:26,356 --> 07:00:27,189
and requiring it if it's not null.

9594
07:00:27,189 --> 07:00:29,260
And if it does, if it's
there, it returns the value,

9595
07:00:29,260 --> 07:00:30,270
otherwise it doesn't.

9596
07:00:30,270 --> 07:00:32,650
So you can use either one
of these check not null

9597
07:00:32,650 --> 07:00:34,810
or require not null, depends
on what you'd like to do.

9598
07:00:34,810 --> 07:00:37,590
I have seen in multiple code
bases where a check not null

9599
07:00:37,590 --> 07:00:40,260
will be somewhere
randomly in the code base,

9600
07:00:40,260 --> 07:00:43,650
perhaps after an API call,

9601
07:00:43,650 --> 07:00:46,192
just make sure that the users not null.

9602
07:00:46,192 --> 07:00:47,110
And then at that point in time,

9603
07:00:47,110 --> 07:00:50,810
the person might be a
var if that's the case.

9604
07:00:51,910 --> 07:00:54,810
So if that's the case, it
might be var person equals

9605
07:00:54,810 --> 07:00:57,070
check not null or person two.

9606
07:00:59,211 --> 07:01:00,050
At that point in time, check not null.

9607
07:01:00,050 --> 07:01:01,800
So you hadn't have a nullable version.

9608
07:01:01,800 --> 07:01:04,980
So you can either use require
not null or check not null.

9609
07:01:04,980 --> 07:01:06,910
Let's go ahead and assume
you have a list of names

9610
07:01:06,910 --> 07:01:09,380
or some list of data that
has come back from a database

9611
07:01:09,380 --> 07:01:11,480
API call or anything like that.

9612
07:01:12,460 --> 07:01:13,750
Here we're just creating a list of names

9613
07:01:13,750 --> 07:01:16,647
and we have a couple
of null values in here.

9614
07:01:16,647 --> 07:01:17,660
Now it's very often that, for example,

9615
07:01:17,660 --> 07:01:21,040
we now have a list front
that is a nullable string.

9616
07:01:21,040 --> 07:01:24,470
So a list of nullable strings
and in our application,

9617
07:01:24,470 --> 07:01:26,640
or maybe even a library
that does not allow

9618
07:01:26,640 --> 07:01:28,720
a list of nullable strings, all the values

9619
07:01:28,720 --> 07:01:30,220
have to be present.

9620
07:01:30,220 --> 07:01:32,420
So what can you do here?

9621
07:01:32,420 --> 07:01:34,270
Well, there's a couple
of things you could do.

9622
07:01:34,270 --> 07:01:36,610
You could go through
each one of these things.

9623
07:01:36,610 --> 07:01:39,670
And so we could say you
could filter them out.

9624
07:01:39,670 --> 07:01:41,680
You can map them to a correct value.

9625
07:01:41,680 --> 07:01:44,060
Or if you just want all of
the items that are not null,

9626
07:01:44,060 --> 07:01:48,360
you could say val names that are not null.

9627
07:01:48,360 --> 07:01:53,360
And you could say names
dot filter not null.

9628
07:01:53,380 --> 07:01:54,640
It's a nice little help our method there.

9629
07:01:54,640 --> 07:01:57,325
And then you can just go
ahead and print line that

9630
07:01:57,325 --> 07:01:59,630
to the screen, name that are not null.

9631
07:01:59,630 --> 07:02:01,750
Let's going and fix that
because it should say names.

9632
07:02:03,090 --> 07:02:04,020
And if we go ahead and run this,

9633
07:02:04,020 --> 07:02:06,260
what we'll see is we're
gonna have all of the names

9634
07:02:06,260 --> 07:02:07,980
and we are not going
to have the null value.

9635
07:02:07,980 --> 07:02:10,730
So very easy to filter out a list

9636
07:02:10,730 --> 07:02:12,540
of all the non nullable types.

9637
07:02:12,540 --> 07:02:14,720
So if you don't want nulls in your list

9638
07:02:14,720 --> 07:02:16,670
and they are already there,
you can filter it out

9639
07:02:16,670 --> 07:02:19,180
with the easy filter not null method.

9640
07:02:20,540 --> 07:02:22,040
One of the keys to understanding Kotlin

9641
07:02:22,040 --> 07:02:24,190
is understanding the
type hierarchy system.

9642
07:02:25,100 --> 07:02:29,230
So this is a great diagram,
which is actually used over here

9643
07:02:29,230 --> 07:02:30,890
from this gentleman who created it,

9644
07:02:30,890 --> 07:02:32,080
which is Marcos Sandoval.

9645
07:02:32,080 --> 07:02:33,250
So, thank you, Marcos.

9646
07:02:33,250 --> 07:02:37,000
This is a great diagram that
illustrates the Kotlin type

9647
07:02:37,000 --> 07:02:39,330
hierarchy system, which basically states

9648
07:02:39,330 --> 07:02:42,060
that any non-billable type
is always going to extend

9649
07:02:42,060 --> 07:02:44,810
to any type and any nullable type

9650
07:02:44,810 --> 07:02:48,050
will extend the nullable any
type which we can see here.

9651
07:02:49,063 --> 07:02:51,487
And then we have also
nothing in there, et cetera.

9652
07:02:51,487 --> 07:02:52,320
We get into that later.

9653
07:02:52,320 --> 07:02:54,860
So Boolean, string, a class,
you create unit number,

9654
07:02:54,860 --> 07:02:56,300
everything extends any.

9655
07:02:56,300 --> 07:02:59,240
So you can use any or
the nullable any type

9656
07:02:59,240 --> 07:03:02,090
instead of your functions
as a parameter type.

9657
07:03:02,090 --> 07:03:05,050
So this is very similar
to in the Java world

9658
07:03:05,050 --> 07:03:05,980
of using object.

9659
07:03:07,240 --> 07:03:09,260
Now you can actually test this by writing

9660
07:03:09,260 --> 07:03:12,990
a simple little program And
we'll say Val age equals 32.

9661
07:03:12,990 --> 07:03:14,360
And we could say something like this.

9662
07:03:14,360 --> 07:03:18,100
If age is any, then we can actually say

9663
07:03:18,100 --> 07:03:20,680
print is any.

9664
07:03:22,061 --> 07:03:23,220
And that would tell us if this is any.

9665
07:03:23,220 --> 07:03:26,700
Now this is how we can check
for types inside of Kotlin.

9666
07:03:26,700 --> 07:03:27,990
This is type checking.

9667
07:03:27,990 --> 07:03:30,310
We're checking to see if age
is of this particular type.

9668
07:03:30,310 --> 07:03:33,870
Now I can change this to
say, hey if age is a string

9669
07:03:33,870 --> 07:03:36,630
and we're gonna see here,
the incompatible types

9670
07:03:36,630 --> 07:03:39,280
type string and into it already
knows the compiler knows

9671
07:03:39,280 --> 07:03:41,140
at this point in time that
this is not going to work.

9672
07:03:41,140 --> 07:03:45,120
So what we could say is I can
change this to the type any.

9673
07:03:46,568 --> 07:03:47,401
I could say if age is a string,

9674
07:03:47,401 --> 07:03:48,810
then it would print that off.

9675
07:03:48,810 --> 07:03:51,020
And if we run this, we'll
see we get nothing back.

9676
07:03:51,020 --> 07:03:52,970
So let's go ahead and add
an else statement here.

9677
07:03:53,970 --> 07:03:54,803
Print ln.any.

9678
07:03:58,640 --> 07:04:02,310
Now, if we say not any,
well, this is a string,

9679
07:04:02,310 --> 07:04:07,030
so we're just gonna change
this to it is, it is not.

9680
07:04:08,720 --> 07:04:12,390
And so is it page, which has
any, does it equal string?

9681
07:04:12,390 --> 07:04:13,223
No, it's not.

9682
07:04:13,223 --> 07:04:16,980
Okay, well, is it a int, let's
run that, see is it an int?

9683
07:04:18,240 --> 07:04:20,970
We see it is, we can change
these to different values.

9684
07:04:20,970 --> 07:04:22,420
So we'll say, is it a double?

9685
07:04:23,730 --> 07:04:24,730
And we can run is it a double?

9686
07:04:25,709 --> 07:04:26,542
It is not.

9687
07:04:26,542 --> 07:04:28,170
So this allows us to start doing various

9688
07:04:28,170 --> 07:04:29,080
different types of things.

9689
07:04:29,080 --> 07:04:32,610
We could change this to
because again, string.

9690
07:04:32,610 --> 07:04:36,380
We'll use Donn actually
is a string and we'll see

9691
07:04:36,380 --> 07:04:39,700
that is not a double,
again it still compiles.

9692
07:04:39,700 --> 07:04:41,130
Is it a int?

9693
07:04:41,130 --> 07:04:43,320
No, it's not because it's an int.

9694
07:04:43,320 --> 07:04:45,340
But if we were to change this to string,

9695
07:04:47,430 --> 07:04:49,760
then we would see that we can
actually easily type check it.

9696
07:04:49,760 --> 07:04:53,830
Now this also works for other,
your own custom classes too.

9697
07:04:53,830 --> 07:04:56,820
So we could say a data
class say create an order.

9698
07:04:57,920 --> 07:05:00,140
And maybe it has an
amount which is an int.

9699
07:05:01,125 --> 07:05:02,870
And then maybe we have
just a regular class

9700
07:05:02,870 --> 07:05:03,910
that is a person.

9701
07:05:05,324 --> 07:05:08,520
And this person has a
name, which is a string.

9702
07:05:08,520 --> 07:05:10,920
So we can create an object here, say,

9703
07:05:10,920 --> 07:05:14,900
val, I'll be J and we would call this.

9704
07:05:15,775 --> 07:05:17,570
We're gonna say, hey, this is
any, so we're kind of just,

9705
07:05:17,570 --> 07:05:19,870
we're using the root object here.

9706
07:05:19,870 --> 07:05:21,680
And we're saying that this is any.

9707
07:05:21,680 --> 07:05:25,220
And we're gonna create this
person and his name's gonna be,

9708
07:05:25,220 --> 07:05:29,960
let's call it Bob, Bob.

9709
07:05:29,960 --> 07:05:32,430
And then what we can say, let
me get rid of this age thing.

9710
07:05:32,430 --> 07:05:33,890
We'll say this object string.

9711
07:05:36,700 --> 07:05:38,650
No, it's not, so it's not a string.

9712
07:05:39,540 --> 07:05:40,600
And we see that it is not.

9713
07:05:40,600 --> 07:05:43,990
However, it would be nice to
see what kind of object it is.

9714
07:05:43,990 --> 07:05:47,070
And we can do that pretty
easily say print line,

9715
07:05:47,070 --> 07:05:49,970
and we can just inspect the
object, object.javaClass.name.

9716
07:05:51,077 --> 07:05:54,000
And this will give us the name
of the Java class that it is.

9717
07:05:54,000 --> 07:05:56,480
So is this person a string?

9718
07:05:56,480 --> 07:05:58,080
No, it's not, it's a person class.

9719
07:05:58,080 --> 07:06:02,310
So let's change this back
to a, let's go do a 16.0

9720
07:06:03,700 --> 07:06:04,533
let's see what that is.

9721
07:06:04,533 --> 07:06:06,390
So is it a string, it's
not, and we'll see,

9722
07:06:06,390 --> 07:06:07,840
it looks like it is a double.

9723
07:06:08,820 --> 07:06:13,170
And then we can also print
a, we could change this to,

9724
07:06:15,439 --> 07:06:16,272
you can change this back to Bob.

9725
07:06:16,272 --> 07:06:18,364
And of course, this is gonna say it is,

9726
07:06:18,364 --> 07:06:20,360
but let's go ahead and
change this to int now.

9727
07:06:20,360 --> 07:06:22,150
And if we run this, what
we're gonna see now,

9728
07:06:22,150 --> 07:06:26,010
is it gonna say it is not and
the type is Java.line.string.

9729
07:06:26,010 --> 07:06:28,280
Now we can change this around too.

9730
07:06:28,280 --> 07:06:29,790
We can say, is this any.

9731
07:06:29,790 --> 07:06:32,363
Now this is just gonna
execute for everything,

9732
07:06:32,363 --> 07:06:33,730
it's just gonna say it is.

9733
07:06:33,730 --> 07:06:37,150
So it is, we could say 12.

9734
07:06:37,150 --> 07:06:39,690
We're just gonna say that it is.

9735
07:06:39,690 --> 07:06:43,210
And we could say for the data class order,

9736
07:06:43,210 --> 07:06:48,210
which is gonna have an
amount of 120 is object any,

9737
07:06:49,170 --> 07:06:52,930
it is so any is the
root object of anything.

9738
07:06:52,930 --> 07:06:56,420
So this allows you to do
some cool type checking

9739
07:06:56,420 --> 07:06:58,850
inside of your application,

9740
07:06:58,850 --> 07:07:01,340
because you may have an
application that returns,

9741
07:07:01,340 --> 07:07:02,480
you working with some different types

9742
07:07:02,480 --> 07:07:06,940
and for whatever reason,
it returns back in any

9743
07:07:06,940 --> 07:07:09,490
which can happen for some various reasons.

9744
07:07:09,490 --> 07:07:14,170
And so if, for example, let's
go ahead and in a string.

9745
07:07:15,477 --> 07:07:17,427
So val value and it's gonna be a string

9746
07:07:18,772 --> 07:07:21,560
and we'll use a one expression, one value.

9747
07:07:21,560 --> 07:07:26,560
And when we say the value is
one, then we want it to return.

9748
07:07:28,904 --> 07:07:30,204
Let's say return here two.

9749
07:07:36,890 --> 07:07:41,370
And if we return two,
we're gonna return a hello.

9750
07:07:44,360 --> 07:07:47,700
If we say three, then we're
gonna return something else,

9751
07:07:47,700 --> 07:07:50,690
such as a true Boolean value.

9752
07:07:50,690 --> 07:07:53,920
If we ask for four, then
we're gonna return a double.

9753
07:07:53,920 --> 07:07:55,900
And so we'll say 16.01.

9754
07:07:56,940 --> 07:07:59,100
And then of course we have
to provide an exhaustive else

9755
07:07:59,100 --> 07:08:02,590
because this could end
up being a certain value.

9756
07:08:02,590 --> 07:08:05,900
So we can get rid of that, there we go.

9757
07:08:05,900 --> 07:08:07,930
And now at this point,
what we can do up here

9758
07:08:07,930 --> 07:08:12,930
is we can just say, what we
can do is if we were to say,

9759
07:08:15,710 --> 07:08:20,710
get stuff in order to parsing
them to number one there,

9760
07:08:20,950 --> 07:08:23,500
what that's gonna do is any
is gonna report to it is.

9761
07:08:23,500 --> 07:08:25,730
But let's go ahead and
change this to string.

9762
07:08:26,990 --> 07:08:29,930
So if my method, maybe a
library I'm working with

9763
07:08:29,930 --> 07:08:31,990
returns, an object or any,
or something like that,

9764
07:08:31,990 --> 07:08:34,980
I can do the type checking
with the is key word.

9765
07:08:34,980 --> 07:08:37,050
And so it's not, so it's an integer.

9766
07:08:37,050 --> 07:08:38,020
What about number two?

9767
07:08:38,020 --> 07:08:41,630
So whatever this method
returns is in any, it is.

9768
07:08:41,630 --> 07:08:45,590
So now I can actually do this
and do different type checking

9769
07:08:45,590 --> 07:08:48,160
and perform various different operations

9770
07:08:48,160 --> 07:08:51,770
based upon the type checking
if I'm working with any type.

9771
07:08:52,900 --> 07:08:54,850
Sometimes you have a
method that returns any,

9772
07:08:54,850 --> 07:08:57,010
and you need to cast that
into a particular value.

9773
07:08:57,010 --> 07:09:00,310
So maybe we know that we
need this to be the age

9774
07:09:00,310 --> 07:09:01,270
and it's gonna be int.

9775
07:09:01,270 --> 07:09:03,500
And so we need to cast
this into an integer.

9776
07:09:03,500 --> 07:09:07,420
So we could say obj.as
int, and when we run this,

9777
07:09:07,420 --> 07:09:09,740
because the OBJ is in any value.

9778
07:09:11,130 --> 07:09:13,460
If we run it, we'll go ahead and see

9779
07:09:13,460 --> 07:09:16,910
that it did execute correctly
and we forgot to print it.

9780
07:09:16,910 --> 07:09:19,255
So we print this to the screen,

9781
07:09:19,255 --> 07:09:22,460
we'll see that it was run as OBJ to 99.

9782
07:09:22,460 --> 07:09:23,760
Now, for whatever reason,

9783
07:09:23,760 --> 07:09:27,730
we were working with the string
and we wanted to use a name.

9784
07:09:27,730 --> 07:09:30,020
So let's just call this
cast so it's easier.

9785
07:09:30,890 --> 07:09:34,110
And this was a name and we'll
call this, this was a string.

9786
07:09:34,110 --> 07:09:35,950
We're expecting it to be a string.

9787
07:09:35,950 --> 07:09:38,584
And we want this to be cast to a string.

9788
07:09:38,584 --> 07:09:40,740
And of course we want maybe
our method of assuming

9789
07:09:40,740 --> 07:09:42,790
this is from like an API
or something like that

9790
07:09:42,790 --> 07:09:45,510
or some library that
gives us back an any type,

9791
07:09:45,510 --> 07:09:46,780
somewhat for some reason.

9792
07:09:47,710 --> 07:09:50,178
We know that number two returns, hello,

9793
07:09:50,178 --> 07:09:51,011
we can then cast that to a string.

9794
07:09:51,011 --> 07:09:53,877
And then at this point
in time going forward,

9795
07:09:53,877 --> 07:09:54,710
we now have a string.

9796
07:09:54,710 --> 07:09:57,960
And what that gives us is
the ability to actually use

9797
07:09:57,960 --> 07:10:00,550
different, for example, I have the length,

9798
07:10:00,550 --> 07:10:03,320
I can do all different kinds
of stuff with this as well.

9799
07:10:03,320 --> 07:10:05,920
If for let's even take this a step further

9800
07:10:05,920 --> 07:10:09,730
and say that I had a data class, a person,

9801
07:10:09,730 --> 07:10:14,290
and that person has a
name and that's a string.

9802
07:10:14,290 --> 07:10:17,720
Then what I could do inside
of here if we say five,

9803
07:10:17,720 --> 07:10:22,720
I would then return back
person with the name of Don.

9804
07:10:23,050 --> 07:10:24,980
So this is gonna work because I have two,

9805
07:10:24,980 --> 07:10:27,310
and I'm gonna return back to value of two,

9806
07:10:27,310 --> 07:10:29,810
but I could also do something like this.

9807
07:10:29,810 --> 07:10:31,770
I could say five.

9808
07:10:31,770 --> 07:10:36,350
Now this of course is, if
we look at object, OBJ,

9809
07:10:36,350 --> 07:10:39,232
what do we have on it, what is it?

9810
07:10:39,232 --> 07:10:42,840
It's any type as you
can see here, it's any.

9811
07:10:42,840 --> 07:10:44,920
So the things that we can do with it.

9812
07:10:45,790 --> 07:10:48,380
If I know that when I parse a five in,

9813
07:10:48,380 --> 07:10:51,000
I'm gonna get a person,
I can't say any.name.

9814
07:10:51,000 --> 07:10:53,760
Name doesn't exist because
I'm working with an any type.

9815
07:10:53,760 --> 07:10:55,490
So I need to cast that
to have the type them,

9816
07:10:55,490 --> 07:10:56,420
which I can work with it.

9817
07:10:56,420 --> 07:11:00,100
So five let's go and
cast that to a person.

9818
07:11:00,100 --> 07:11:02,080
I need to make this person.

9819
07:11:02,080 --> 07:11:03,730
And now I have a person object.

9820
07:11:04,658 --> 07:11:06,070
And what that means is
now I can say cast it.

9821
07:11:07,528 --> 07:11:09,320
And now I have the name and
I also have the copy method,

9822
07:11:09,320 --> 07:11:11,170
which is built into data classes.

9823
07:11:11,170 --> 07:11:13,942
And everything else that
data class is also have

9824
07:11:13,942 --> 07:11:15,570
along with it or any other
class that you're working with.

9825
07:11:15,570 --> 07:11:16,840
So now I can access the name.

9826
07:11:16,840 --> 07:11:20,020
So I've basically turned this
any type right here, any,

9827
07:11:20,020 --> 07:11:21,520
I've turned it into a person.

9828
07:11:21,520 --> 07:11:23,700
So now when I work with
this person object,

9829
07:11:23,700 --> 07:11:25,740
which is right here, I
can see that it's a person

9830
07:11:25,740 --> 07:11:28,110
and I can use the type system accordingly.

9831
07:11:28,110 --> 07:11:30,760
So if I run this here,
we'll see that we can run

9832
07:11:30,760 --> 07:11:33,767
and we can get the object
turned into a person.

9833
07:11:33,767 --> 07:11:36,500
And that's how you can
perform casting in Kotlin.

9834
07:11:36,500 --> 07:11:38,850
Let's assume you have a
method called get stuff,

9835
07:11:38,850 --> 07:11:40,690
and it can return in any type,

9836
07:11:40,690 --> 07:11:43,480
which is the root of all types in Kotlin

9837
07:11:43,480 --> 07:11:44,850
for non nullable types.

9838
07:11:44,850 --> 07:11:46,910
So if you parse into
one, you get an integer,

9839
07:11:46,910 --> 07:11:49,040
if you parse in two, you get a string,

9840
07:11:49,040 --> 07:11:50,640
three, you get a Boolean value,

9841
07:11:50,640 --> 07:11:54,000
four, you get a double and
anything else, you get a false.

9842
07:11:54,000 --> 07:11:57,530
So sometimes we need to perform
various different casting.

9843
07:11:57,530 --> 07:11:59,200
We need to cast it to a particular value.

9844
07:11:59,200 --> 07:12:01,620
So I'm gonna create a new
variable called cast it.

9845
07:12:01,620 --> 07:12:06,310
And what I'm going to
do is say OBJ as int.

9846
07:12:06,310 --> 07:12:08,450
And so what I wanna do
is I wanna get this.

9847
07:12:08,450 --> 07:12:12,700
I wanna cast this value that
I get back to an integer.

9848
07:12:12,700 --> 07:12:15,370
And so when I try to do
this, I'm gonna run this.

9849
07:12:15,370 --> 07:12:17,880
And what we're going to see is
we're gonna get an exception.

9850
07:12:17,880 --> 07:12:19,960
And the exception is a
class cast exception,

9851
07:12:19,960 --> 07:12:22,520
basically stating you can't cast...

9852
07:12:24,085 --> 07:12:26,530
Basically a string can
not be cast to an integer.

9853
07:12:26,530 --> 07:12:29,150
And that's because the value
we got back from get stuff,

9854
07:12:29,150 --> 07:12:32,090
we parsed it two in two came
in executed this line of code.

9855
07:12:32,090 --> 07:12:35,620
We returned the value of OBJ was hello.

9856
07:12:35,620 --> 07:12:37,670
And we're trying to cast
the string as an integer

9857
07:12:37,670 --> 07:12:40,680
and Java says, nope, no
dice, that can't happen.

9858
07:12:40,680 --> 07:12:42,630
So we got a class cast exception to,

9859
07:12:42,630 --> 07:12:46,710
how can we solve this? So
we can't cast it this way.

9860
07:12:46,710 --> 07:12:48,930
So what we could do is we
could do some type checking.

9861
07:12:48,930 --> 07:12:52,930
We could do if object and we
change this to as is into,

9862
07:12:52,930 --> 07:12:55,280
we could get back the OBJ else,

9863
07:12:55,280 --> 07:12:59,860
maybe willing to return to
zero, that that would work.

9864
07:12:59,860 --> 07:13:02,710
We could run this, and this
would work accordingly.

9865
07:13:02,710 --> 07:13:05,780
We'd get back zero because
object is not an integer.

9866
07:13:07,058 --> 07:13:11,000
If it was, so if we came back
here and we changed to a one,

9867
07:13:11,000 --> 07:13:13,850
which again, would return
us back in any value of one,

9868
07:13:13,850 --> 07:13:15,650
we'd get back the one there.

9869
07:13:15,650 --> 07:13:17,523
And actually who's go and change this

9870
07:13:17,523 --> 07:13:20,504
to just what makes more
sense to change it the 99.

9871
07:13:20,504 --> 07:13:22,620
And so when we parse in one
for the value of the get stuff

9872
07:13:22,620 --> 07:13:23,940
method, we'll get back 99,

9873
07:13:23,940 --> 07:13:26,830
which has hap executes
this line right here.

9874
07:13:26,830 --> 07:13:29,130
And since it is because an
integer, we got this back,

9875
07:13:29,130 --> 07:13:30,290
that makes sense.

9876
07:13:30,290 --> 07:13:31,440
However, there's also another way

9877
07:13:31,440 --> 07:13:32,840
that we can do this as well.

9878
07:13:33,910 --> 07:13:35,890
Perhaps we're okay with working
with some nullable types.

9879
07:13:35,890 --> 07:13:40,600
One thing we can do is we can
cast it and do a safe cast.

9880
07:13:40,600 --> 07:13:45,080
And what the safecast
is saved as an integer.

9881
07:13:45,080 --> 07:13:48,050
And what this basically says,
hey, I would like you to,

9882
07:13:48,050 --> 07:13:49,570
as I'm gonna change this to two,

9883
07:13:51,245 --> 07:13:52,270
done a second, we'll do that.

9884
07:13:52,270 --> 07:13:55,300
I would like you to try to
cast this object right here,

9885
07:13:55,300 --> 07:13:58,690
this object as an integer.

9886
07:13:58,690 --> 07:14:01,070
And so when this piece of code executes,

9887
07:14:01,070 --> 07:14:03,250
if it can execute it as an a can do it,

9888
07:14:03,250 --> 07:14:04,170
it'll return the integer,

9889
07:14:04,170 --> 07:14:06,738
otherwise it'll return a nullable type.

9890
07:14:06,738 --> 07:14:09,130
So if we re run this right
now, we're gonna get back 99.

9891
07:14:09,130 --> 07:14:11,570
That makes sense, because
if we parse in one,

9892
07:14:11,570 --> 07:14:12,403
we get back 99.

9893
07:14:12,403 --> 07:14:13,860
So let me change this to two,

9894
07:14:13,860 --> 07:14:15,190
which is gonna give me back a string.

9895
07:14:15,190 --> 07:14:18,030
Now, if I run this, what
we're gonna get back is null.

9896
07:14:18,030 --> 07:14:21,320
And the reason for that is
because this line of code

9897
07:14:21,320 --> 07:14:23,630
right here that executed said,

9898
07:14:23,630 --> 07:14:27,260
hey, this object is actually null.

9899
07:14:27,260 --> 07:14:30,330
And so the smart cast said,
hey, I recognize that was null.

9900
07:14:30,330 --> 07:14:32,970
So I'm just gonna go ahead
and give you back a null value

9901
07:14:32,970 --> 07:14:34,790
at that point in time, we can continue on

9902
07:14:34,790 --> 07:14:36,530
and our application didn't crash.

9903
07:14:36,530 --> 07:14:38,090
And that's how you can use a smart cast.

9904
07:14:38,090 --> 07:14:42,326
So this could be anything for Boolean,

9905
07:14:42,326 --> 07:14:43,420
can I parse that to a Boolean?

9906
07:14:43,420 --> 07:14:45,180
And if we run that, is that going to work?

9907
07:14:45,180 --> 07:14:48,935
Let's see, no that's null as
well, it's not true or false.

9908
07:14:48,935 --> 07:14:49,768
So we can't do that.

9909
07:14:49,768 --> 07:14:52,664
So anytime you need to cast
something and be safe about it

9910
07:14:52,664 --> 07:14:54,070
with a nullable type,
you can use a smart cast,

9911
07:14:54,070 --> 07:14:57,400
which is the word as with
a question mark after it.

9912
07:14:59,218 --> 07:15:01,370
You've probably heard the
word generic tossed around

9913
07:15:01,370 --> 07:15:03,040
inside of Kotlin various times.

9914
07:15:04,566 --> 07:15:06,080
And the word generic just
means that we're using a class

9915
07:15:06,080 --> 07:15:09,100
or an implementation in
a very generic manner.

9916
07:15:09,100 --> 07:15:11,600
And so here we have an
interface which has a list,

9917
07:15:12,438 --> 07:15:13,330
and then it has this
weird little parameter.

9918
07:15:13,330 --> 07:15:14,480
Ignore the out for now.

9919
07:15:15,350 --> 07:15:18,220
And it has this little E and
that E is the type of elements

9920
07:15:18,220 --> 07:15:19,990
that are contained within the list.

9921
07:15:19,990 --> 07:15:22,960
And so this is a collection
which extends collection,

9922
07:15:22,960 --> 07:15:24,230
and it takes a type E.

9923
07:15:24,230 --> 07:15:26,930
So what this allows us to do is have

9924
07:15:26,930 --> 07:15:30,310
all the same operations,
like we can some contains,

9925
07:15:30,310 --> 07:15:33,280
is it empty, we can use get index.

9926
07:15:33,280 --> 07:15:36,330
It allows us for high levels of code reuse

9927
07:15:36,330 --> 07:15:38,340
and allows us to specify different types.

9928
07:15:38,340 --> 07:15:39,960
So we still have type safety.

9929
07:15:39,960 --> 07:15:42,210
So I can do that a list of strings,

9930
07:15:42,210 --> 07:15:45,760
or I could do, let's call
this list of strings,

9931
07:15:47,840 --> 07:15:51,360
or I could say, val list of ints.

9932
07:15:51,360 --> 07:15:55,180
And then I could basically
either say a list int

9933
07:15:55,180 --> 07:16:00,180
and as a list of, and I can
say one, two, three, whatever.

9934
07:16:03,870 --> 07:16:05,170
And I can have my list of integers.

9935
07:16:05,170 --> 07:16:08,270
And now they're all both
going to have same operations.

9936
07:16:09,472 --> 07:16:11,600
List of strings, I'm gonna
have the get operation,

9937
07:16:12,905 --> 07:16:14,070
I'm gonna have a list of ints.

9938
07:16:14,070 --> 07:16:15,150
I'm gonna have the same get operation.

9939
07:16:15,150 --> 07:16:17,800
Now, a lot of these things
are already built for you.

9940
07:16:18,867 --> 07:16:20,700
So a lot of these generic
operations and generic classes,

9941
07:16:20,700 --> 07:16:24,000
such as a list and a map and a set,

9942
07:16:24,000 --> 07:16:26,670
anything like that have
already been built for you.

9943
07:16:26,670 --> 07:16:28,310
And so it's very easy to use them.

9944
07:16:28,310 --> 07:16:32,930
So if you want to use a
map, you can specify a map

9945
07:16:32,930 --> 07:16:34,920
and say map, and you can specify the types

9946
07:16:34,920 --> 07:16:35,753
that you would like as well.

9947
07:16:35,753 --> 07:16:38,430
So the key is gonna be
a string and the value

9948
07:16:38,430 --> 07:16:39,900
will be an int.

9949
07:16:39,900 --> 07:16:42,710
And then perhaps you wanna
create a map of that.

9950
07:16:42,710 --> 07:16:46,054
And now you don't have to
provide these type parameters,

9951
07:16:46,054 --> 07:16:48,890
because it will be inferred
if from the map creation,

9952
07:16:48,890 --> 07:16:50,740
but here I'm just being
very explicit about it.

9953
07:16:50,740 --> 07:16:55,663
So I might map Donn to 32
and I might map Tushar to 42

9954
07:16:58,530 --> 07:16:59,998
and so forth.

9955
07:16:59,998 --> 07:17:03,290
But now I have a map and
that string is it's key

9956
07:17:03,290 --> 07:17:04,500
and the value is its int.

9957
07:17:04,500 --> 07:17:06,970
And this is all already built for us.

9958
07:17:07,955 --> 07:17:09,651
So here's just using a map interface.

9959
07:17:09,651 --> 07:17:10,484
And so there's a bunch of different maps

9960
07:17:10,484 --> 07:17:12,260
that are implemented inside of the Kotlin

9961
07:17:12,260 --> 07:17:15,810
collections library and all
different kinds of things.

9962
07:17:15,810 --> 07:17:18,980
So you can see, so we'll go map.entries

9963
07:17:18,980 --> 07:17:21,190
and we can look inside of there and see

9964
07:17:21,190 --> 07:17:22,970
all the various different entries.

9965
07:17:22,970 --> 07:17:25,650
We can do different, you
know, for different things,

9966
07:17:25,650 --> 07:17:29,860
such as map.map, which is
kind of weird sounding,

9967
07:17:29,860 --> 07:17:32,860
but it's part of the maps
function and allows us

9968
07:17:32,860 --> 07:17:35,100
to transform items inside of there.

9969
07:17:35,100 --> 07:17:38,800
But the key thing here is
that all of that common

9970
07:17:38,800 --> 07:17:42,050
functionality is buried
inside of these generics.

9971
07:17:42,050 --> 07:17:44,620
So you don't have to worry
about building a list,

9972
07:17:44,620 --> 07:17:49,320
just custom for strings or
a custom list for integers.

9973
07:17:49,320 --> 07:17:51,600
All that's buried behind
the generics themselves.

9974
07:17:51,600 --> 07:17:53,090
And the good thing is
you can actually build

9975
07:17:53,090 --> 07:17:54,680
your own generic classes,
which I'll show you

9976
07:17:54,680 --> 07:17:55,770
in another video.

9977
07:17:55,770 --> 07:17:59,150
However, these are the bald basic built-in

9978
07:17:59,150 --> 07:18:00,440
different types of generics.

9979
07:18:00,440 --> 07:18:03,200
And very often when you're
looking at the documentation,

9980
07:18:03,200 --> 07:18:05,020
you're gonna notice these single letters.

9981
07:18:05,020 --> 07:18:07,780
So E in this case is gonna be the type.

9982
07:18:07,780 --> 07:18:09,590
Sometimes you'll see
multiple different types.

9983
07:18:09,590 --> 07:18:11,300
So if we go look at a map,

9984
07:18:11,300 --> 07:18:13,318
you're gonna see different types in here,

9985
07:18:13,318 --> 07:18:14,820
you're gonna see K and V.

9986
07:18:14,820 --> 07:18:17,950
Now the letters, they don't
have to be letters themselves,

9987
07:18:17,950 --> 07:18:21,633
but they're using very
good terminology here.

9988
07:18:21,633 --> 07:18:24,740
K for key and V for value in this case.

9989
07:18:24,740 --> 07:18:29,740
And so up here, the E I think
is for element of the list.

9990
07:18:32,609 --> 07:18:33,442
And so it was a very element.

9991
07:18:33,442 --> 07:18:35,587
Now you could actually, if you're building

9992
07:18:35,587 --> 07:18:38,500
your own generics, you can
actually provide a full on word

9993
07:18:38,500 --> 07:18:41,290
for the different type,
if you would like to.

9994
07:18:41,290 --> 07:18:43,590
But a lot of these
things are just that way.

9995
07:18:44,552 --> 07:18:45,385
So that's what generics are.

9996
07:18:45,385 --> 07:18:47,530
They allow you to encapsulate
common functionality

9997
07:18:47,530 --> 07:18:51,800
across a large swath of
code and folks can end up

9998
07:18:51,800 --> 07:18:53,870
using them for various different things.

9999
07:18:53,870 --> 07:18:56,250
So for example, here's a mutable list

10000
07:18:56,250 --> 07:18:57,420
that extends another one.

10001
07:18:57,420 --> 07:18:59,550
And all that's doing is
saying, hey, we're gonna use

10002
07:18:59,550 --> 07:19:02,350
all of the exact stuff
from within the list

10003
07:19:02,350 --> 07:19:05,089
and everything from within
a mutable collection

10004
07:19:05,089 --> 07:19:05,922
and we're gonna create mutable list.

10005
07:19:05,922 --> 07:19:09,210
And by the way, here's how
we're going to override

10006
07:19:09,210 --> 07:19:11,800
this remove function and
here's how we're gonna do

10007
07:19:11,800 --> 07:19:13,720
all these other different types of things

10008
07:19:13,720 --> 07:19:16,110
based upon this type of collection.

10009
07:19:16,110 --> 07:19:18,720
So these are the generic
kind of collections classes.

10010
07:19:18,720 --> 07:19:21,080
There's a whole swath of
things that are all generic

10011
07:19:21,080 --> 07:19:23,870
inside of various different
apps that you're gonna use

10012
07:19:23,870 --> 07:19:25,400
instead of different libraries.

10013
07:19:25,400 --> 07:19:28,000
HTTP libraries will have you returning

10014
07:19:28,000 --> 07:19:29,496
a different component.

10015
07:19:29,496 --> 07:19:31,480
If you're using reactive
libraries, we'll be working

10016
07:19:31,480 --> 07:19:34,390
with reactive streams of
different types of data

10017
07:19:34,390 --> 07:19:35,270
and so forth.

10018
07:19:35,270 --> 07:19:38,720
And those keys and values and
et cetera, are all performed

10019
07:19:38,720 --> 07:19:41,050
and mapped inside of the various different

10020
07:19:41,050 --> 07:19:44,200
generic classes themselves
built by the developers.

10021
07:19:44,200 --> 07:19:46,746
And so these are all the built-in ones,

10022
07:19:46,746 --> 07:19:48,350
and here's how you can kind of
understand what generics are

10023
07:19:48,350 --> 07:19:49,400
at a very high level.

10024
07:19:51,798 --> 07:19:55,491
Let's assume that you wanna
create your own generic class.

10025
07:19:55,491 --> 07:19:57,060
So the first thing you need
to do is define a class

10026
07:19:58,247 --> 07:19:59,750
and what we're gonna do is
create a class called even list.

10027
07:20:00,936 --> 07:20:02,210
And even list is going to give us,

10028
07:20:02,210 --> 07:20:05,040
we're gonna take in a list,
so here we'll say val.

10029
07:20:05,988 --> 07:20:09,130
We'll say list, and
this'll be a list of type T

10030
07:20:09,130 --> 07:20:11,630
and then inside of here,
we're gonna do something

10031
07:20:12,521 --> 07:20:14,030
or we're gonna return so function.

10032
07:20:14,030 --> 07:20:16,210
And I we'll say items.

10033
07:20:16,210 --> 07:20:18,928
And then what we're gonna
do is we're gonna return

10034
07:20:18,928 --> 07:20:20,570
a list out of this, and it's
gonna be the same type too.

10035
07:20:20,570 --> 07:20:24,380
So notice how I'm not providing
anything inside of here.

10036
07:20:24,380 --> 07:20:26,480
So what this class is going to do for us,

10037
07:20:26,480 --> 07:20:28,120
this is generic class.

10038
07:20:28,120 --> 07:20:31,529
And I'm basically saying,
look, this class is gonna hold

10039
07:20:31,529 --> 07:20:34,393
a bunch of things and
they're gonna be of type T.

10040
07:20:34,393 --> 07:20:36,950
Even lists, it can be of type
T, you don't know what it is.

10041
07:20:38,285 --> 07:20:40,860
The constructor is going
to take a list into it,

10042
07:20:40,860 --> 07:20:42,010
and it's gonna be of type T.

10043
07:20:42,010 --> 07:20:44,430
So basically if it's a list of strings,

10044
07:20:44,430 --> 07:20:46,750
then it'll be even list of strings.

10045
07:20:46,750 --> 07:20:50,100
And then what will
happen is I wanna return

10046
07:20:50,100 --> 07:20:51,106
the even items.

10047
07:20:51,106 --> 07:20:52,557
And so I'm just gonna go ahead and return

10048
07:20:52,557 --> 07:20:53,500
those even items.

10049
07:20:53,500 --> 07:20:56,050
And to do that, I'm gonna
say return list.filtered.

10050
07:20:58,620 --> 07:21:02,030
Now, I need to put val on here
so I can get access to it.

10051
07:21:02,030 --> 07:21:03,390
Val.filtered index.

10052
07:21:05,248 --> 07:21:09,320
And then what I'm going
to do is parse into lambda

10053
07:21:10,165 --> 07:21:12,820
and it's gonna give me
an index and a value.

10054
07:21:15,040 --> 07:21:16,320
And then from here, what I can do is say,

10055
07:21:16,320 --> 07:21:21,320
index modulates two equal
equals zero, which means,

10056
07:21:21,700 --> 07:21:22,820
hey, if it's divisible by two,

10057
07:21:22,820 --> 07:21:25,370
if it's a second item inside of there,

10058
07:21:25,370 --> 07:21:28,700
then if it's divisible by two,
so two zero, two, four, six,

10059
07:21:28,700 --> 07:21:31,335
eight, 10, and then go
ahead and return the items.

10060
07:21:31,335 --> 07:21:33,340
So only return the even
items in this list.

10061
07:21:33,340 --> 07:21:36,180
So I have not actually
specified that I'm working

10062
07:21:36,180 --> 07:21:38,490
with strings or integers or anything.

10063
07:21:38,490 --> 07:21:40,410
And here I'm using this type T.

10064
07:21:40,410 --> 07:21:43,670
So how would I use this
class, this is a generic class

10065
07:21:43,670 --> 07:21:46,640
that only works with even items.

10066
07:21:46,640 --> 07:21:49,010
And perhaps for whatever reason,
I want this to be something

10067
07:21:49,010 --> 07:21:50,630
I can use all over my application,

10068
07:21:50,630 --> 07:21:53,350
because I am maybe
building some type of game

10069
07:21:53,350 --> 07:21:55,130
where I only work with even ones.

10070
07:21:55,130 --> 07:21:57,430
And you know, of course
I could build another one

10071
07:21:58,340 --> 07:21:59,178
called odd.

10072
07:21:59,178 --> 07:22:02,120
So to do this, I could say
val result equals even list,

10073
07:22:03,580 --> 07:22:04,990
not event list, even list.

10074
07:22:05,883 --> 07:22:08,980
And I could specify a string
here, I want it to be string.

10075
07:22:08,980 --> 07:22:11,250
I need to parse in, I'm gonna
parse in my list of strings.

10076
07:22:11,250 --> 07:22:14,540
Now look, the IDE says, hey,
we can remove the explicit type

10077
07:22:14,540 --> 07:22:16,460
arguments because it's
going to be inferred

10078
07:22:16,460 --> 07:22:19,250
because you're parsing
in the list of strings.

10079
07:22:19,250 --> 07:22:21,950
And we already know that
this list of strings

10080
07:22:21,950 --> 07:22:23,970
is this type right here is a string.

10081
07:22:24,898 --> 07:22:26,349
So we already know that
you're a string over here.

10082
07:22:26,349 --> 07:22:27,610
So you don't really need to
tell us that it's a string.

10083
07:22:27,610 --> 07:22:30,080
We kind of already
figured that out for you,

10084
07:22:30,080 --> 07:22:32,650
so you don't need to
provide that information.

10085
07:22:32,650 --> 07:22:34,930
So then what I can do is
I have my list of strings.

10086
07:22:34,930 --> 07:22:37,370
So now I have an event list of strings.

10087
07:22:38,304 --> 07:22:41,473
And if I wanted to print
out the actual even ones,

10088
07:22:41,473 --> 07:22:43,900
I could say, result.items,

10089
07:22:43,900 --> 07:22:45,950
which is gonna call this function here.

10090
07:22:45,950 --> 07:22:47,810
It's gonna call the items, function.

10091
07:22:47,810 --> 07:22:49,780
And wait, maybe we even
wanna call this even,

10092
07:22:49,780 --> 07:22:53,160
be a little more explicit
here, we'll call it even items,

10093
07:22:54,116 --> 07:22:55,620
which makes more sense, result.even items.

10094
07:22:55,620 --> 07:22:58,020
And if we print this out,
what we're gonna see here,

10095
07:22:59,101 --> 07:23:00,525
and we're only using
the strings right now,

10096
07:23:00,525 --> 07:23:01,358
let's see Donn and Mary.

10097
07:23:01,358 --> 07:23:04,180
Now the power of generics really comes in

10098
07:23:04,180 --> 07:23:05,740
that you can reuse it
with different types.

10099
07:23:05,740 --> 07:23:09,900
So let's reuse this again,
the same val results,

10100
07:23:09,900 --> 07:23:12,670
let's say other result 'cause
we need another variable

10101
07:23:14,510 --> 07:23:16,630
and this one's gonna be event list.

10102
07:23:16,630 --> 07:23:19,260
And this time we're gonna
take in a list of ints

10103
07:23:20,920 --> 07:23:22,790
not event, even list.

10104
07:23:23,771 --> 07:23:25,538
So we're gonna take a list of integers in,

10105
07:23:25,538 --> 07:23:27,181
and we're gonna print this out,

10106
07:23:27,181 --> 07:23:29,630
I'm gonna say result.even items.

10107
07:23:31,132 --> 07:23:32,205
And when we print this one out,

10108
07:23:32,205 --> 07:23:33,110
we're now working with integers.

10109
07:23:36,240 --> 07:23:37,640
And I used the wrong result.

10110
07:23:38,480 --> 07:23:39,313
There we go.

10111
07:23:40,860 --> 07:23:43,308
And if we use the other result,
which is the proper one,

10112
07:23:43,308 --> 07:23:45,790
we'll now see, we were able to reuse

10113
07:23:45,790 --> 07:23:48,250
this class's exact functionality.

10114
07:23:48,250 --> 07:23:51,290
I didn't have to write it twice,
I'm now relying on a type,

10115
07:23:51,290 --> 07:23:53,390
this called a type parameter, the type key

10116
07:23:54,723 --> 07:23:55,556
to do some work for us.

10117
07:23:55,556 --> 07:23:59,541
And if we can look at this
value, look, if we go over here

10118
07:23:59,541 --> 07:24:01,552
and actually do something
with a value actually,

10119
07:24:01,552 --> 07:24:04,837
we can see the value over
here is actually type T.

10120
07:24:04,837 --> 07:24:06,440
So I don't know what that type is.

10121
07:24:07,854 --> 07:24:09,230
I could say the value is of type blah.

10122
07:24:09,230 --> 07:24:12,830
Now I could do some, I could
do as value as a string.

10123
07:24:12,830 --> 07:24:14,840
So if I parse in an any into this,

10124
07:24:14,840 --> 07:24:17,150
then we could do some type
of stuff inside of here.

10125
07:24:17,150 --> 07:24:19,050
Now that's gonna limit
me on what I can do,

10126
07:24:19,050 --> 07:24:23,060
but depends on my implementation
of my generic class

10127
07:24:23,060 --> 07:24:23,893
if that's what I wanna do.

10128
07:24:23,893 --> 07:24:26,070
So here now I have an
even class that will work

10129
07:24:27,150 --> 07:24:29,100
exactly with what these and I could be.

10130
07:24:30,254 --> 07:24:31,087
Again, we could even go a step further

10131
07:24:31,087 --> 07:24:35,410
and we can go class person
and we could easily do

10132
07:24:35,410 --> 07:24:38,200
name string, and then we
can create a list of people.

10133
07:24:38,200 --> 07:24:42,770
So let's just do that,
val people equals list of,

10134
07:24:43,682 --> 07:24:44,515
and then let's do person.

10135
07:24:51,191 --> 07:24:53,600
And now if I have these people
and I wanna print it out,

10136
07:24:53,600 --> 07:24:55,234
we're just gonna do this.

10137
07:24:55,234 --> 07:24:56,378
We're gonna single line this right now.

10138
07:24:56,378 --> 07:24:58,330
So I'm just gonna do even list

10139
07:24:58,330 --> 07:25:00,580
and then I'm gonna parse in my people.

10140
07:25:00,580 --> 07:25:02,130
And then I'm gonna say, I
wanna get my even items.

10141
07:25:02,130 --> 07:25:03,890
I'm just gonna print that out.

10142
07:25:03,890 --> 07:25:04,980
And then what we're gonna see here

10143
07:25:04,980 --> 07:25:08,140
is even with my own custom
class, I'm getting that.

10144
07:25:08,140 --> 07:25:10,750
And I can make a little bit
nicer and just say data class,

10145
07:25:10,750 --> 07:25:12,940
'cause data classes will
give you a nice little

10146
07:25:12,940 --> 07:25:15,030
two string representation
of your class already

10147
07:25:15,030 --> 07:25:16,210
as we can see here.

10148
07:25:16,210 --> 07:25:18,150
Now the two string is
represented that two strings

10149
07:25:18,150 --> 07:25:21,090
is built for you by
default and data classes.

10150
07:25:21,090 --> 07:25:22,340
So I can print out and everything here.

10151
07:25:22,340 --> 07:25:24,220
So now I'm only receiving the even number.

10152
07:25:24,220 --> 07:25:27,710
So I'm receiving Donn and Mary,
but Bob has index number one

10153
07:25:27,710 --> 07:25:29,150
and Felicia's index number three.

10154
07:25:29,150 --> 07:25:31,360
So we're just gonna
completely skip over that.

10155
07:25:31,360 --> 07:25:33,940
Remember 'cause these
are zero-based index.

10156
07:25:33,940 --> 07:25:38,230
So remember that this is
zero, this is one, this is two

10157
07:25:39,730 --> 07:25:41,940
and this is three inside of array index

10158
07:25:41,940 --> 07:25:43,680
'cause we're zero-based.

10159
07:25:43,680 --> 07:25:45,680
So this is why we're
getting it even index.

10160
07:25:45,680 --> 07:25:47,120
So the other cool thing about this too,

10161
07:25:47,120 --> 07:25:48,980
is like, let's say that
you don't really like

10162
07:25:48,980 --> 07:25:50,630
the type T.

10163
07:25:50,630 --> 07:25:53,660
I prefer to use the word T
because it means type to me

10164
07:25:53,660 --> 07:25:55,050
and it's a type system.

10165
07:25:55,050 --> 07:25:56,980
I could also just say this right here.

10166
07:25:56,980 --> 07:26:00,750
I could rename this type
and say type like that.

10167
07:26:00,750 --> 07:26:02,500
And now it could use the same thing.

10168
07:26:02,500 --> 07:26:04,400
I could even call this something else.

10169
07:26:04,400 --> 07:26:08,183
If I wanted to call this, we
wanted to call this tiger.

10170
07:26:10,960 --> 07:26:12,505
I call it tiger.

10171
07:26:12,505 --> 07:26:13,338
It doesn't matter what I call it.

10172
07:26:13,338 --> 07:26:15,510
This is just a tight parameter
that I'm gonna be using.

10173
07:26:15,510 --> 07:26:18,740
And if I look over here,
now this might get confusing

10174
07:26:19,670 --> 07:26:20,503
because I would never use the word tiger

10175
07:26:20,503 --> 07:26:23,220
because tiger has an implicit
meaning of an animal.

10176
07:26:23,220 --> 07:26:25,390
So I see that this value is of type tiger,

10177
07:26:25,390 --> 07:26:26,720
but that doesn't make any sense.

10178
07:26:26,720 --> 07:26:29,590
So it's usually good to
keep these tight parameters

10179
07:26:29,590 --> 07:26:32,580
to be a very simple name
that represents something.

10180
07:26:32,580 --> 07:26:34,110
So it could be type.

10181
07:26:34,110 --> 07:26:36,750
It could be sometimes people use action.

10182
07:26:36,750 --> 07:26:40,020
If they're building something
with actions and so forth.

10183
07:26:40,020 --> 07:26:44,090
However, it's really easy just
to use simple single letter

10184
07:26:44,090 --> 07:26:46,280
types, because then when
you're looking inside

10185
07:26:46,280 --> 07:26:50,180
of perhaps your code and
you're looking at the value

10186
07:26:50,180 --> 07:26:51,610
of something, you can look over and say,

10187
07:26:51,610 --> 07:26:54,050
Oh, that's gonna be of type T.

10188
07:26:54,050 --> 07:26:56,357
Oh, okay, I don't know if that is,

10189
07:26:56,357 --> 07:26:58,120
that's a type or I need
to think about this more.

10190
07:26:58,120 --> 07:27:02,410
So that's how you can build
a very simple generic class

10191
07:27:02,410 --> 07:27:05,470
in your very first generic
class inside of Kotlin.

10192
07:27:07,763 --> 07:27:08,790
Let's assume that you have a person

10193
07:27:08,790 --> 07:27:11,010
and inside of your application,
for whatever reason,

10194
07:27:11,010 --> 07:27:14,120
you can't allow anyone to
be under the age of 18.

10195
07:27:15,295 --> 07:27:17,080
Perhaps it's an application
for allowing people

10196
07:27:17,080 --> 07:27:20,190
into particular restaurants
or music events.

10197
07:27:20,190 --> 07:27:22,090
So you wanna make sure
that no one gets in,

10198
07:27:22,090 --> 07:27:23,600
unless they're over 18.

10199
07:27:23,600 --> 07:27:27,050
However, this is an exceptional case.

10200
07:27:27,050 --> 07:27:30,590
So you wanna check to see if
the person is over age 18.

10201
07:27:30,590 --> 07:27:33,230
If they're basically
under the age of 18 now,

10202
07:27:33,230 --> 07:27:34,110
that should never happen.

10203
07:27:34,110 --> 07:27:36,910
Perhaps these values are
coming back from an API

10204
07:27:36,910 --> 07:27:38,120
or somewhere else.

10205
07:27:38,120 --> 07:27:40,080
And at this point you're
like, you know what,

10206
07:27:40,080 --> 07:27:42,380
if I get someone back
less than the age of 18,

10207
07:27:43,228 --> 07:27:44,150
this application just
needs to basically blow up.

10208
07:27:44,150 --> 07:27:45,430
There's something that should happen.

10209
07:27:45,430 --> 07:27:48,010
And to do that, you can throw
what's known as an exception

10210
07:27:48,010 --> 07:27:50,660
and you use the throw keyword for that.

10211
07:27:50,660 --> 07:27:52,200
And so we can throw an exception.

10212
07:27:52,200 --> 07:27:53,900
And so we have an
exception here in Kotlin.

10213
07:27:53,900 --> 07:27:55,780
We provide an error message.

10214
07:27:55,780 --> 07:27:57,310
User is not old enough.

10215
07:28:00,381 --> 07:28:02,320
All right, now, at this point,
if we run this application,

10216
07:28:02,320 --> 07:28:06,460
what we're going to see is that
this person Donnie who's 13.

10217
07:28:06,460 --> 07:28:08,440
Little Donnie can't
come in because the user

10218
07:28:08,440 --> 07:28:09,670
is not old enough.

10219
07:28:09,670 --> 07:28:12,860
Now the exception is built into
the Kotlin standard library

10220
07:28:12,860 --> 07:28:16,750
and all it really is the type
alias for Java Lang exception.

10221
07:28:16,750 --> 07:28:18,960
And what that means is
this kind of just created

10222
07:28:18,960 --> 07:28:21,500
a little shortcut for you,
like a little link and said,

10223
07:28:21,500 --> 07:28:23,240
hey, if you type exception,

10224
07:28:23,240 --> 07:28:26,570
and this is a type in Kotlin
what you're actually meaning

10225
07:28:26,570 --> 07:28:29,210
is this actual Java language exception.

10226
07:28:29,210 --> 07:28:30,970
There's a bunch of
different exception types

10227
07:28:30,970 --> 07:28:33,610
inside of Kotlin and
a million more of them

10228
07:28:33,610 --> 07:28:35,180
in various libraries.

10229
07:28:35,180 --> 07:28:36,200
But the common ones are gonna see

10230
07:28:36,200 --> 07:28:38,330
you as just regular exception,
where you provide a message,

10231
07:28:38,330 --> 07:28:40,580
a runtime exception and a legal argument,

10232
07:28:40,580 --> 07:28:42,937
maybe provide an illegal argument.

10233
07:28:42,937 --> 07:28:44,360
and a legal argument, maybe
provide an illegal argument.

10234
07:28:44,360 --> 07:28:46,760
So it got into a weird
state that it doesn't know

10235
07:28:46,760 --> 07:28:48,900
how to handle and it needs to get out.

10236
07:28:48,900 --> 07:28:51,490
So that's an illegal state
exception index out of bounds.

10237
07:28:51,490 --> 07:28:54,898
You know, if you're working
with an array or a list,

10238
07:28:54,898 --> 07:28:56,790
an index out of bounds
unsupported operation,

10239
07:28:56,790 --> 07:28:58,990
you're doing something
that's not built yet.

10240
07:29:00,118 --> 07:29:00,951
Perhaps this could be
very useful for a feature

10241
07:29:00,951 --> 07:29:02,700
you're building out, but
the function isn't done,

10242
07:29:02,700 --> 07:29:05,440
but you need to make sure
that you do something

10243
07:29:05,440 --> 07:29:07,100
in the function so it compiles.

10244
07:29:08,290 --> 07:29:10,630
You could just throw it on
supported operation exception.

10245
07:29:10,630 --> 07:29:13,110
And then if you accidentally
hit that in testing or in code,

10246
07:29:13,110 --> 07:29:13,943
it'll blow up.

10247
07:29:14,799 --> 07:29:15,730
And of course there's
various other exceptions

10248
07:29:15,730 --> 07:29:16,670
inside of here,

10249
07:29:16,670 --> 07:29:19,940
but this is how you can throw
an exception inside of Kotlin.

10250
07:29:19,940 --> 07:29:21,200
And it can be any other exception here.

10251
07:29:21,200 --> 07:29:24,740
So if we wanted it to be a
illegal argument exception,

10252
07:29:24,740 --> 07:29:28,990
we could say the user is not
old enough, user is too young,

10253
07:29:29,900 --> 07:29:31,200
and then we could run that.

10254
07:29:31,200 --> 07:29:33,310
And then of course the
output would then show

10255
07:29:33,310 --> 07:29:35,830
that we then got an
illegal argument exception.

10256
07:29:37,277 --> 07:29:38,110
You wanna use the correct exception

10257
07:29:38,110 --> 07:29:40,940
for whatever you would like,
for whatever you're wanting

10258
07:29:40,940 --> 07:29:44,720
to do and you can throw that
correct exception to that time.

10259
07:29:45,571 --> 07:29:47,190
And if you're using any
type of code and production,

10260
07:29:47,190 --> 07:29:48,850
that's looking for these exceptions,

10261
07:29:48,850 --> 07:29:50,810
you can start filtering
on the types of exceptions

10262
07:29:50,810 --> 07:29:51,890
that were thrown,

10263
07:29:51,890 --> 07:29:54,340
and that's how you throw
an exception and Kotlin.

10264
07:29:56,355 --> 07:29:57,620
In Kotlin, and in many other JVM languages

10265
07:29:57,620 --> 07:29:59,130
and most programming languages,

10266
07:29:59,130 --> 07:30:01,740
you're not limited to the
default set of exceptions.

10267
07:30:01,740 --> 07:30:03,660
You can actually create your own set

10268
07:30:03,660 --> 07:30:05,140
that you would need as well.

10269
07:30:05,140 --> 07:30:07,824
So let's assume that
you didn't want to use

10270
07:30:07,824 --> 07:30:08,657
the illegal argument exception,

10271
07:30:08,657 --> 07:30:09,490
but you wanted to create your own.

10272
07:30:09,490 --> 07:30:12,990
So you can create a class and
we'll call it illegal age,

10273
07:30:12,990 --> 07:30:16,240
or it's called invalidate age exception.

10274
07:30:18,260 --> 07:30:21,700
And usually you'll add
the suffix exception

10275
07:30:21,700 --> 07:30:22,980
to the end of an exception.

10276
07:30:22,980 --> 07:30:24,390
So, you know what that type means.

10277
07:30:24,390 --> 07:30:26,490
If I just typed in valid age,

10278
07:30:26,490 --> 07:30:27,680
I don't know if this is an exception,

10279
07:30:27,680 --> 07:30:29,200
if it's an object or what is it for,

10280
07:30:29,200 --> 07:30:31,680
but if I say exception at the end,

10281
07:30:31,680 --> 07:30:33,900
it's very easy to read for what it is.

10282
07:30:33,900 --> 07:30:36,260
Now, this is a class I can
provide anything I like.

10283
07:30:36,260 --> 07:30:38,850
So maybe I wanna provide
the age, which is an int.

10284
07:30:38,850 --> 07:30:40,220
And then I'll also wanna
provide the message,

10285
07:30:40,220 --> 07:30:41,780
which is a string.

10286
07:30:41,780 --> 07:30:45,000
And then I'm gonna go
ahead and pars, make this.

10287
07:30:45,000 --> 07:30:45,910
I can either make this just an exception,

10288
07:30:45,910 --> 07:30:48,941
or you know what, since
this has has something

10289
07:30:48,941 --> 07:30:50,920
to do with an argument, I'm
gonna extend illegal argument

10290
07:30:50,920 --> 07:30:54,390
exception and then I need to
parse in either no parameters

10291
07:30:54,390 --> 07:30:55,920
or the message.

10292
07:30:55,920 --> 07:30:58,050
And I'm gonna go ahead
and create a message

10293
07:30:58,050 --> 07:31:00,270
that's going to be based
upon the other stuff.

10294
07:31:01,187 --> 07:31:03,779
And I'll say in a valid
age and then I'll go ahead

10295
07:31:03,779 --> 07:31:04,910
and render the age variable.

10296
07:31:04,910 --> 07:31:06,580
And then I'm gonna go ahead and then also

10297
07:31:06,580 --> 07:31:07,780
append the message here.

10298
07:31:08,640 --> 07:31:12,010
So now instead of using an
illegal argument exception,

10299
07:31:12,010 --> 07:31:14,436
I can say invalid age exception,

10300
07:31:14,436 --> 07:31:16,601
throw new invalid age exception.

10301
07:31:16,601 --> 07:31:17,460
And of course it can give me an error here

10302
07:31:17,460 --> 07:31:19,900
because I don't have the age parsed in.

10303
07:31:19,900 --> 07:31:24,450
So I'm gonna say P.age,
which is the person's age.

10304
07:31:24,450 --> 07:31:26,480
And now if I run this
and what we're gonna see

10305
07:31:26,480 --> 07:31:29,470
in the output is that an
illegal age exception is thrown.

10306
07:31:29,470 --> 07:31:31,920
So illegal age exception
and valid age, 13.

10307
07:31:31,920 --> 07:31:34,020
User is not old enough, user is too young.

10308
07:31:35,040 --> 07:31:37,240
And so I'm parsing this message in,

10309
07:31:38,227 --> 07:31:40,230
and this is which means
invalid age exception

10310
07:31:40,230 --> 07:31:44,970
is basically a child of
illegal argument exception.

10311
07:31:44,970 --> 07:31:47,010
And so now I've created my own exception.

10312
07:31:47,010 --> 07:31:50,135
You can create as many
exceptions as you would like.

10313
07:31:50,135 --> 07:31:52,385
These can help you inside
of your application

10314
07:31:53,830 --> 07:31:54,663
when things are perhaps not working

10315
07:31:54,663 --> 07:31:55,860
and your applications is crashing,

10316
07:31:55,860 --> 07:31:58,960
you can see exactly what
type of exceptions they are.

10317
07:31:58,960 --> 07:32:01,800
Perhaps a particular
part of your application

10318
07:32:01,800 --> 07:32:02,840
is really difficult.

10319
07:32:02,840 --> 07:32:05,570
So you may wanna create a
couple of different exceptions

10320
07:32:05,570 --> 07:32:08,270
and you track those
inside of your application

10321
07:32:08,270 --> 07:32:09,730
or inside of your crash tool,

10322
07:32:09,730 --> 07:32:12,130
or maybe you're building
a library and that library

10323
07:32:12,130 --> 07:32:13,370
has very particular needs.

10324
07:32:13,370 --> 07:32:14,920
And so you need to make
sure that you returning

10325
07:32:14,920 --> 07:32:17,480
certain exceptions from your application

10326
07:32:17,480 --> 07:32:20,990
and giving exceptional situations.

10327
07:32:20,990 --> 07:32:21,900
So that's how you can do it.

10328
07:32:21,900 --> 07:32:23,410
You just have to go ahead and take class

10329
07:32:23,410 --> 07:32:26,290
and extend exception or
you can just even extend

10330
07:32:26,290 --> 07:32:29,663
just regular exception and so forth,

10331
07:32:29,663 --> 07:32:30,725
and then you can start building your own.

10332
07:32:30,725 --> 07:32:31,558
So it depends on which
one you want to extend.

10333
07:32:31,558 --> 07:32:33,110
You need to make sure
that you can extend it.

10334
07:32:33,110 --> 07:32:36,080
So there is an exception,
you can also extend

10335
07:32:36,080 --> 07:32:37,360
runtime exception as well.

10336
07:32:37,360 --> 07:32:39,310
So if you wanna make your
own runtime exceptions,

10337
07:32:39,310 --> 07:32:40,870
you can do that as well.

10338
07:32:40,870 --> 07:32:43,180
So that's how you can
create your own exceptions

10339
07:32:43,180 --> 07:32:44,580
in Kotlin.

10340
07:32:44,580 --> 07:32:46,090
Okay, let's assume we have some code here.

10341
07:32:46,090 --> 07:32:49,720
We have a person object, and
this side, this person object

10342
07:32:49,720 --> 07:32:53,830
has a user with the name
Donnie and age of 13

10343
07:32:53,830 --> 07:32:55,360
and a method called check age.

10344
07:32:55,360 --> 07:32:58,590
And if the age is less than
18, it throws an exception.

10345
07:32:58,590 --> 07:33:01,510
And maybe this, let's assume
that this is in a different

10346
07:33:01,510 --> 07:33:04,631
library somewhere, so we
can't even control it.

10347
07:33:04,631 --> 07:33:05,620
So this is beyond the scope of our things.

10348
07:33:05,620 --> 07:33:08,500
We have to call into this
library to do something.

10349
07:33:08,500 --> 07:33:11,810
And for whatever reason, this
library throws an exception,

10350
07:33:11,810 --> 07:33:14,090
even though we may or
may not agree with that

10351
07:33:14,090 --> 07:33:16,990
on the way that the code is working level,

10352
07:33:16,990 --> 07:33:19,540
sometimes that's just the
reality of the situation.

10353
07:33:20,645 --> 07:33:21,900
I've worked with many libraries
in which I can't control

10354
07:33:21,900 --> 07:33:23,450
or don't agree with how
they handle something

10355
07:33:23,450 --> 07:33:24,480
and they throw an exception.

10356
07:33:24,480 --> 07:33:27,550
I don't want the application to blow up.

10357
07:33:27,550 --> 07:33:29,510
So what I can do is I can wrap this

10358
07:33:29,510 --> 07:33:31,820
in what's known as a try-catch.

10359
07:33:31,820 --> 07:33:35,710
And try-catch is going
to give us a ability

10360
07:33:35,710 --> 07:33:36,970
to catch the exception.

10361
07:33:36,970 --> 07:33:40,350
So basically what's gonna happen
I wanna show you something.

10362
07:33:43,980 --> 07:33:47,172
what's gonna happen is
check age is gonna happen.

10363
07:33:47,172 --> 07:33:48,005
And then that's gonna throw an exception

10364
07:33:48,005 --> 07:33:49,000
so we can see the exception again.

10365
07:33:49,000 --> 07:33:50,870
It's gonna throw this exception,

10366
07:33:50,870 --> 07:33:53,803
then what's gonna happen is
basically gonna short circuit

10367
07:33:53,803 --> 07:33:54,636
right here.

10368
07:33:54,636 --> 07:33:55,520
I could have a whole bunch code.

10369
07:33:55,520 --> 07:33:58,649
Most like I probably will
have a whole bunch of code

10370
07:33:58,649 --> 07:34:02,060
down here and none of this
code is gonna execute.

10371
07:34:02,060 --> 07:34:05,260
Why, because this thing right
here is doing an exception

10372
07:34:05,260 --> 07:34:07,440
and I need to do something
with that exception.

10373
07:34:07,440 --> 07:34:09,940
And so here I can actually
catch that exception

10374
07:34:10,836 --> 07:34:13,236
and I can actually get
rid of that if I want to.

10375
07:34:14,490 --> 07:34:17,501
Catch the exception and then
I can do something with it.

10376
07:34:17,501 --> 07:34:19,240
Now I can decide to do print ln,

10377
07:34:20,850 --> 07:34:25,430
caught the exception, et cetera.

10378
07:34:25,430 --> 07:34:27,860
Now, when I run this, now the application

10379
07:34:27,860 --> 07:34:30,090
is not going to crash, I got a typo there.

10380
07:34:32,130 --> 07:34:34,120
And what we see is caught the exception.

10381
07:34:34,120 --> 07:34:35,570
Again, we'll fix the
type, we'll run it again.

10382
07:34:35,570 --> 07:34:36,970
We see caught the exception,

10383
07:34:38,702 --> 07:34:40,290
but we still didn't get
all these values run.

10384
07:34:40,290 --> 07:34:43,280
Now this is beneficial
because if we don't have this,

10385
07:34:43,280 --> 07:34:45,320
let's go ahead and comment this out.

10386
07:34:45,320 --> 07:34:48,550
What can end up happening is
our application could run.

10387
07:34:48,550 --> 07:34:50,760
And then for whatever
reason, it just blows up.

10388
07:34:50,760 --> 07:34:53,160
And maybe we don't want it to blow up.

10389
07:34:53,160 --> 07:34:54,740
Again, as a library or something,

10390
07:34:54,740 --> 07:34:57,240
we get an exception and we
wanna do something different.

10391
07:34:57,240 --> 07:35:00,640
So we were like, oh wow, okay,
this person's age is not 13.

10392
07:35:00,640 --> 07:35:03,280
Okay, maybe then we kind
of do some other type

10393
07:35:03,280 --> 07:35:05,680
of code handling, set some variables

10394
07:35:05,680 --> 07:35:06,980
and do anything like that.

10395
07:35:07,830 --> 07:35:11,490
So that's how we can catch an
exception inside of Kotlin.

10396
07:35:11,490 --> 07:35:16,490
Now inside of here, if this were,

10397
07:35:16,590 --> 07:35:18,040
if we're gonna do print line,

10398
07:35:19,290 --> 07:35:22,430
exception was caught
or say caught for now.

10399
07:35:22,430 --> 07:35:24,880
If for some reason this person was 23.

10400
07:35:24,880 --> 07:35:28,430
What we're gonna see now
is the code is going to run

10401
07:35:28,430 --> 07:35:30,430
and check age is gonna run, that's fine.

10402
07:35:31,532 --> 07:35:32,530
And then all of these
statements are gonna run.

10403
07:35:32,530 --> 07:35:35,820
And this block of code right
here is gonna be skipped.

10404
07:35:35,820 --> 07:35:36,653
It's completely skipped.

10405
07:35:36,653 --> 07:35:38,700
So what ends up happening is Kotlin says,

10406
07:35:39,700 --> 07:35:41,180
all right, I'm gonna try to
do all the stuff in here.

10407
07:35:41,180 --> 07:35:42,670
And then if anything bad happens,

10408
07:35:42,670 --> 07:35:45,000
I'm gonna go ahead and
basically short circuit

10409
07:35:45,000 --> 07:35:47,330
down into this little branch down here.

10410
07:35:47,330 --> 07:35:49,330
Now that's great.

10411
07:35:49,330 --> 07:35:52,309
If no errors happen,
then all the code in here

10412
07:35:52,309 --> 07:35:54,350
will successfully execute and
then it'll continue down here.

10413
07:35:54,350 --> 07:35:58,666
So we'll say for an ln after try catch,

10414
07:35:58,666 --> 07:35:59,890
and this is known as a try-catch block.

10415
07:36:00,780 --> 07:36:02,420
Up here, so we have a try catch.

10416
07:36:02,420 --> 07:36:04,880
And so we'll say you done,
done, done, done, done, done

10417
07:36:04,880 --> 07:36:06,190
after try catch.

10418
07:36:06,190 --> 07:36:09,270
And so that's how you can
work and catch exceptions.

10419
07:36:09,270 --> 07:36:11,540
You can also catch very
particular exceptions.

10420
07:36:11,540 --> 07:36:14,180
So maybe if we can see if
this is an illegal argument

10421
07:36:14,180 --> 07:36:16,950
exception, and what we
need to do is change this

10422
07:36:16,950 --> 07:36:18,340
again to something that will fail.

10423
07:36:18,340 --> 07:36:21,497
So we'll set the age to
13, so it throws throw.

10424
07:36:21,497 --> 07:36:25,700
And then we'll notice
here is it all of a sudden

10425
07:36:25,700 --> 07:36:26,720
our application is bombing,

10426
07:36:26,720 --> 07:36:28,450
but we still have a try-catch here.

10427
07:36:29,410 --> 07:36:30,886
What happened?

10428
07:36:30,886 --> 07:36:32,870
Well, the reason is because
what we're at throwing down here

10429
07:36:32,870 --> 07:36:35,680
is an exception, but
what we're checking for

10430
07:36:35,680 --> 07:36:39,490
is a much more granular
level of acception.

10431
07:36:39,490 --> 07:36:41,550
Here, we're checking for
illegal argument exception.

10432
07:36:41,550 --> 07:36:43,190
We're checking, hey, the exception,

10433
07:36:43,190 --> 07:36:45,340
we only wanna catch
this if it's an illegal

10434
07:36:46,522 --> 07:36:47,660
argument exception, otherwise
just let it blow up.

10435
07:36:47,660 --> 07:36:49,750
So this is very useful if
we're trying to make sure

10436
07:36:49,750 --> 07:36:52,790
that inside, maybe we have
that custom exception.

10437
07:36:52,790 --> 07:36:57,790
Again, we have class invalid
name or valid age exception.

10438
07:37:04,140 --> 07:37:05,470
And it's gonna parse in a message.

10439
07:37:05,470 --> 07:37:09,090
And what it is, is it's an
illegal argument exception,

10440
07:37:10,010 --> 07:37:11,810
and we parse in the message there.

10441
07:37:11,810 --> 07:37:15,060
So instead of throwing
this regular exception,

10442
07:37:15,060 --> 07:37:16,810
we're gonna throw it this one here,

10443
07:37:18,870 --> 07:37:20,700
and we can see what happens here.

10444
07:37:20,700 --> 07:37:23,270
And so, oh, looks like
it caught the illegal

10445
07:37:23,270 --> 07:37:24,103
argument exception.

10446
07:37:24,103 --> 07:37:25,820
Well, why did it catch your
legal argument exception

10447
07:37:25,820 --> 07:37:27,950
if it's an invalid age exception,

10448
07:37:27,950 --> 07:37:30,040
because invalid age exception

10449
07:37:30,040 --> 07:37:31,880
is an illegal argument exception.

10450
07:37:31,880 --> 07:37:34,480
Now, if we were to change this to invalid,

10451
07:37:37,290 --> 07:37:39,590
let's say invalid class exceptions,

10452
07:37:39,590 --> 07:37:44,350
which is just a different
exception from the Java.io.

10453
07:37:44,350 --> 07:37:46,080
It's not gonna work because
it's not gonna catch it.

10454
07:37:46,080 --> 07:37:47,930
It's saying invalid age exception.

10455
07:37:47,930 --> 07:37:51,520
So a lot of times you may want
to catch multiple exceptions

10456
07:37:51,520 --> 07:37:53,040
at once, so you need to climb up

10457
07:37:53,040 --> 07:37:55,620
the hierarchy of classes here.

10458
07:37:55,620 --> 07:37:59,780
So the exception is some
classes or form of code,

10459
07:37:59,780 --> 07:38:02,760
throwable, excuse me,
that indicates, et cetera,

10460
07:38:02,760 --> 07:38:04,200
the things are throwable.

10461
07:38:04,200 --> 07:38:06,450
So what you can do is just rely

10462
07:38:06,450 --> 07:38:08,320
on just the default exception.

10463
07:38:08,320 --> 07:38:11,040
So we can just delete this cause it'll use

10464
07:38:11,040 --> 07:38:12,240
Kotlin's type alias.

10465
07:38:14,010 --> 07:38:18,180
And we can see here that the
exceptions kind of all root up

10466
07:38:18,180 --> 07:38:19,013
towards the top.

10467
07:38:19,013 --> 07:38:20,820
And if we use just a high
level exception like this,

10468
07:38:20,820 --> 07:38:24,020
then what we can do is actually
provide a when statement.

10469
07:38:24,020 --> 07:38:29,020
When EX, I can say is
illegal argument exception,

10470
07:38:30,200 --> 07:38:34,550
we can say print ln legal argument.

10471
07:38:36,100 --> 07:38:41,033
When is, we might wanna say
something like invalid age,

10472
07:38:43,550 --> 07:38:47,730
then we wanna print something,
print ln, invalid age,

10473
07:38:49,490 --> 07:38:53,340
and then anything else we just wanna say,

10474
07:38:53,340 --> 07:38:57,573
print ln else, something else.

10475
07:38:57,573 --> 07:39:02,573
Now, if we run this,
let me see invalid age.

10476
07:39:05,070 --> 07:39:07,020
So if I were to remove this,

10477
07:39:07,020 --> 07:39:10,440
let me say index out of bounds exceptions.

10478
07:39:15,110 --> 07:39:19,960
So index out of bounds exception
or using an abbreviation.

10479
07:39:22,650 --> 07:39:24,700
And what we see is invalid
age is still being thrown.

10480
07:39:24,700 --> 07:39:29,523
So I'm gonna change this to
just throw something else,

10481
07:39:35,440 --> 07:39:36,970
throw in legal argument, exception

10482
07:39:36,970 --> 07:39:38,520
inside of the check age method.

10483
07:39:40,380 --> 07:39:42,390
And then we're gonna see
that caught something else.

10484
07:39:42,390 --> 07:39:44,110
So something else was caught down here.

10485
07:39:44,110 --> 07:39:45,120
Now, a lot of times, what you wanna do

10486
07:39:45,120 --> 07:39:47,430
is you wanna go ahead and
re throw that exception

10487
07:39:47,430 --> 07:39:50,700
because you are not sure
what's happening here.

10488
07:39:50,700 --> 07:39:52,650
So you wanna just say, hey, you know what,

10489
07:39:52,650 --> 07:39:55,650
here is the example.

10490
07:39:56,490 --> 07:39:58,460
We have the exceptions come in.

10491
07:39:58,460 --> 07:40:01,750
And when the exception is an
illegal age exception, do this.

10492
07:40:01,750 --> 07:40:03,730
When it's an index out
of bounds exception,

10493
07:40:03,730 --> 07:40:04,563
do something else.

10494
07:40:04,563 --> 07:40:07,380
Otherwise I don't know what to
do with it, just throw this.

10495
07:40:07,380 --> 07:40:09,660
Maybe someone further up
the stack will catch it,

10496
07:40:09,660 --> 07:40:11,330
but these are the only two exceptions

10497
07:40:11,330 --> 07:40:14,190
I know how to handle inside
of this try-catch block.

10498
07:40:14,190 --> 07:40:17,120
'Cause maybe this will throw
an illegal age exception

10499
07:40:17,120 --> 07:40:19,810
and maybe some other call down here

10500
07:40:19,810 --> 07:40:23,750
that we haven't specified
yet will issue an index

10501
07:40:23,750 --> 07:40:25,389
out of bounds exception.

10502
07:40:25,389 --> 07:40:26,790
And then at that point you
can then start catching

10503
07:40:26,790 --> 07:40:28,240
and handling multiple exceptions

10504
07:40:28,240 --> 07:40:30,850
inside of your Kotlin
program or rethrow it

10505
07:40:30,850 --> 07:40:32,780
with the stack trace accordingly,

10506
07:40:32,780 --> 07:40:34,810
and then you'll get the whole stack trace

10507
07:40:34,810 --> 07:40:37,550
all the way outside the call stack.

10508
07:40:37,550 --> 07:40:39,890
So if it's further up, you'll
get the call stack as well.

10509
07:40:39,890 --> 07:40:41,940
And that's how you can catch
multiple different exceptions

10510
07:40:41,940 --> 07:40:42,773
in Kotlin.

10511
07:40:43,680 --> 07:40:45,860
Let's assume that you have some code here

10512
07:40:45,860 --> 07:40:49,300
and you want to surround this with a try

10513
07:40:49,300 --> 07:40:51,510
so you can make sure that it doesn't fail.

10514
07:40:52,490 --> 07:40:55,830
You can also, instead of using a catch,

10515
07:40:55,830 --> 07:41:00,500
you can use a finally here and
you can say for ln finally.

10516
07:41:01,440 --> 07:41:03,560
And perhaps let's have
something that was supposed

10517
07:41:03,560 --> 07:41:05,250
to execute after this.

10518
07:41:06,095 --> 07:41:11,000
So it would say print ln after check age.

10519
07:41:11,000 --> 07:41:12,710
So we should not see check age execute

10520
07:41:12,710 --> 07:41:15,030
because if the user's
age or the person's age

10521
07:41:15,030 --> 07:41:16,690
is less than 18, then we're gonna throw

10522
07:41:16,690 --> 07:41:18,270
an illegal argument exception.

10523
07:41:18,270 --> 07:41:20,410
But this is the show
you that in a try catch

10524
07:41:20,410 --> 07:41:24,300
or a try finally, the finally
block will always execute.

10525
07:41:24,300 --> 07:41:27,690
So even if an exception occurs
inside of this tribe lock,

10526
07:41:27,690 --> 07:41:29,400
if an exception occurs anywhere in here,

10527
07:41:29,400 --> 07:41:31,500
the finally block will always execute.

10528
07:41:31,500 --> 07:41:34,070
So let's go ahead and execute
that now, let's run that.

10529
07:41:34,070 --> 07:41:36,590
And what you're gonna see is that finally,

10530
07:41:36,590 --> 07:41:38,790
which is right here, finally is printed,

10531
07:41:39,640 --> 07:41:41,990
but the exception is still happening,

10532
07:41:41,990 --> 07:41:43,360
which is inside of check age.

10533
07:41:43,360 --> 07:41:46,490
And then basically the
program execution is stopping.

10534
07:41:46,490 --> 07:41:48,880
How do we know that the
program execution is stopping?

10535
07:41:48,880 --> 07:41:50,890
It's pretty simple, the print line

10536
07:41:50,890 --> 07:41:54,000
which is called after a try
is not executing at all.

10537
07:41:54,000 --> 07:41:59,000
So what ends up happening is
this block is executing and now

10538
07:41:59,290 --> 07:42:01,390
we're seeing the finely run here

10539
07:42:01,390 --> 07:42:03,900
and finally will be run
regardless what happens

10540
07:42:03,900 --> 07:42:04,733
inside of try it.

10541
07:42:04,733 --> 07:42:07,380
Now, this is very useful,
let's say if you've opened

10542
07:42:07,380 --> 07:42:12,380
a variable and it's perhaps
reading a file stream

10543
07:42:13,030 --> 07:42:17,100
or maybe an audio store, or
audio or something like that,

10544
07:42:17,100 --> 07:42:18,460
that's gonna take a lot of resources

10545
07:42:18,460 --> 07:42:21,420
that you need to close to make
sure there's no memory leak.

10546
07:42:21,420 --> 07:42:22,690
Then maybe you would say,

10547
07:42:24,144 --> 07:42:26,327
you would have some type of
variable called file stream.

10548
07:42:26,327 --> 07:42:27,710
And then inside of here, you might say,

10549
07:42:27,710 --> 07:42:30,456
hey, regardless of what happens,

10550
07:42:30,456 --> 07:42:32,080
if I'm getting an exception or I don't,

10551
07:42:32,080 --> 07:42:34,800
I wanna close down that stream
so I can kind of clean up

10552
07:42:34,800 --> 07:42:36,940
after myself and not have memory leaks.

10553
07:42:36,940 --> 07:42:39,230
So it's a very common place
to clean up for anything

10554
07:42:39,230 --> 07:42:41,470
that you need that's resource intensive

10555
07:42:41,470 --> 07:42:44,710
or could possibly provide
any type of memory leaks.

10556
07:42:44,710 --> 07:42:46,890
You can put it inside of
the finally area there.

10557
07:42:46,890 --> 07:42:48,760
So if anything were to happen.

10558
07:42:48,760 --> 07:42:52,020
Now, you can also combine a try finally

10559
07:42:52,020 --> 07:42:53,000
with a try catch.

10560
07:42:53,000 --> 07:42:57,830
So I could say catch
exception with exception,

10561
07:42:57,830 --> 07:43:00,860
and of course we can do
this, so we can stack them.

10562
07:43:00,860 --> 07:43:03,170
And this works, this is a
very common pattern here.

10563
07:43:03,170 --> 07:43:05,490
So again, you might wanna
use finally to clean up

10564
07:43:05,490 --> 07:43:07,590
after something that
you've, again, maybe opened

10565
07:43:07,590 --> 07:43:09,980
an audio source, video source,

10566
07:43:09,980 --> 07:43:11,910
something that could leak memory,

10567
07:43:12,790 --> 07:43:14,740
but you might wanna do something
inside of this exception

10568
07:43:14,740 --> 07:43:18,990
and say, print ln handled,

10569
07:43:18,990 --> 07:43:20,800
or maybe you're gonna
handle it a certain way.

10570
07:43:20,800 --> 07:43:22,850
So instead of let's,

10571
07:43:23,920 --> 07:43:26,300
it's going to catch the
illegal argument exception.

10572
07:43:26,300 --> 07:43:28,050
So let's go ahead and do illegal...

10573
07:43:31,106 --> 07:43:32,735
Let's do a legal state exception.

10574
07:43:32,735 --> 07:43:33,820
And if we run this, what we're gonna see

10575
07:43:33,820 --> 07:43:37,750
is we're still going to get
the finally that's called,

10576
07:43:37,750 --> 07:43:42,350
but we had the illegal
argument exception was thrown.

10577
07:43:42,350 --> 07:43:44,650
So what ends up happening
is check age called,

10578
07:43:45,630 --> 07:43:48,370
the exception was thrown immediately.

10579
07:43:49,910 --> 07:43:51,830
This finally block realized
an exception was thrown.

10580
07:43:51,830 --> 07:43:55,270
So finally it's printed and
then finally the program says,

10581
07:43:55,270 --> 07:43:57,660
hey, here's why we executed
with this exception.

10582
07:43:57,660 --> 07:44:01,620
Now, if we were to change this catch block

10583
07:44:01,620 --> 07:44:04,130
to catch that illegal argument exception,

10584
07:44:04,130 --> 07:44:06,600
the whole program execution changes.

10585
07:44:06,600 --> 07:44:10,870
So we're gonna see that
it's gonna execute this,

10586
07:44:11,980 --> 07:44:13,170
but it's gonna throw an exception.

10587
07:44:13,170 --> 07:44:15,690
So we're not going to
see this line of code.

10588
07:44:15,690 --> 07:44:19,250
Remember an illegal argument
exception was called or thrown.

10589
07:44:19,250 --> 07:44:21,840
The catch block sees that
says, yes, I can handle that.

10590
07:44:21,840 --> 07:44:24,300
It then prints out handled,
which is printed out

10591
07:44:24,300 --> 07:44:25,370
handled here.

10592
07:44:25,370 --> 07:44:28,190
And then as always, the finally
block will always be run.

10593
07:44:28,190 --> 07:44:31,730
So we may need to clean up after
some memory intensive stuff

10594
07:44:31,730 --> 07:44:34,360
we'll then go ahead and execute
the code inside of finally.

10595
07:44:34,360 --> 07:44:36,580
And then after that, the
program execution continues

10596
07:44:36,580 --> 07:44:38,974
because the program didn't really crash,

10597
07:44:38,974 --> 07:44:40,450
we handled it right here.

10598
07:44:40,450 --> 07:44:44,080
And at that point it's
executing after the try.

10599
07:44:44,080 --> 07:44:46,850
So you can perform a try and a catch.

10600
07:44:46,850 --> 07:44:49,280
And a finally you can stack
them all on top of each other

10601
07:44:49,280 --> 07:44:51,030
in Kotlin and that's how you do it.

10602
07:44:52,830 --> 07:44:55,860
The difference between
try, catch and try finally

10603
07:44:55,860 --> 07:44:58,700
can be illustrated in
a very simple example.

10604
07:44:58,700 --> 07:45:02,060
Here, we have a try block
inside the check age method.

10605
07:45:02,060 --> 07:45:04,900
We check the variable
for the class person.

10606
07:45:04,900 --> 07:45:06,250
And if they are under the age of 18,

10607
07:45:06,250 --> 07:45:07,660
we throw in the legal argument exception

10608
07:45:07,660 --> 07:45:08,950
with the value of boom.

10609
07:45:10,270 --> 07:45:11,940
And if we run this,
what we're going to see

10610
07:45:11,940 --> 07:45:13,090
is a few things happen.

10611
07:45:14,544 --> 07:45:16,836
We see the word finally
is printed to the output

10612
07:45:16,836 --> 07:45:19,441
and then we see the reason
why the application exited,

10613
07:45:19,441 --> 07:45:21,320
which is the illegal argument
exception which was thrown.

10614
07:45:21,320 --> 07:45:23,290
So this is interesting
because the print line

10615
07:45:23,290 --> 07:45:25,040
was not executed, which we expect

10616
07:45:25,040 --> 07:45:27,040
because it was short-circuited based upon

10617
07:45:27,040 --> 07:45:29,240
the illegal argument exception was thrown.

10618
07:45:30,980 --> 07:45:32,490
Every time this code is called,

10619
07:45:32,490 --> 07:45:34,020
finally is guaranteed to be called.

10620
07:45:34,020 --> 07:45:36,840
So finally it's going to be
called and we print finally

10621
07:45:36,840 --> 07:45:37,673
to the screen.

10622
07:45:37,673 --> 07:45:39,700
And of course, because
the application exited,

10623
07:45:39,700 --> 07:45:41,990
we are not going to
see after the try here.

10624
07:45:42,980 --> 07:45:45,200
Now, how does this differ from a catch?

10625
07:45:45,200 --> 07:45:48,360
Well, a catch allows you to
catch and do something with it.

10626
07:45:48,360 --> 07:45:50,430
Finally just executes
at all point in time.

10627
07:45:50,430 --> 07:45:53,076
So let's just go ahead and replace this,

10628
07:45:53,076 --> 07:45:54,020
comment this out right now.

10629
07:45:54,020 --> 07:45:58,600
And let's go ahead and
actually, I'm gonna go down here

10630
07:45:58,600 --> 07:45:59,950
and we'll comment this out.

10631
07:46:01,161 --> 07:46:03,600
And now we'll say catch EX exception.

10632
07:46:04,500 --> 07:46:08,220
So catch allows us to catch EX exception.

10633
07:46:08,220 --> 07:46:11,710
And we can print line
the exception message,

10634
07:46:13,560 --> 07:46:17,130
actually we're gonna print
caught just to be more clear.

10635
07:46:20,630 --> 07:46:23,780
And once we execute this,
we'll see the word caught

10636
07:46:23,780 --> 07:46:25,320
and we are then after the try it.

10637
07:46:25,320 --> 07:46:27,190
So what this allows us to
do is this whole program

10638
07:46:27,190 --> 07:46:31,060
has now executed though, except
for this line of code here,

10639
07:46:31,060 --> 07:46:33,040
because it was short-circuited
via the check age

10640
07:46:33,040 --> 07:46:36,670
because of the illegal argument
exception that was thrown.

10641
07:46:36,670 --> 07:46:38,420
So the catch, you can actually catch

10642
07:46:38,420 --> 07:46:41,590
either a particular exception,
or you can say if it's not

10643
07:46:41,590 --> 07:46:43,560
a particular exception you can...

10644
07:46:43,560 --> 07:46:45,490
Or if it is a particular exception,

10645
07:46:45,490 --> 07:46:47,450
it can also not get short-circuited

10646
07:46:47,450 --> 07:46:49,390
and still blow up the application.

10647
07:46:49,390 --> 07:46:51,240
However, anytime using a finally,

10648
07:46:51,240 --> 07:46:55,270
which it also can be combined,
a finally is executed

10649
07:46:55,270 --> 07:46:56,103
all the time.

10650
07:46:56,103 --> 07:46:59,590
So regardless if we have an
exception that is caught,

10651
07:46:59,590 --> 07:47:02,750
we have finally this
exception was not caught.

10652
07:47:02,750 --> 07:47:05,560
So it terminated the
program, finally was printed.

10653
07:47:05,560 --> 07:47:08,060
However, if this is an
illegal argument exception,

10654
07:47:09,950 --> 07:47:12,770
we're going to see that the
program execution continues on.

10655
07:47:12,770 --> 07:47:13,950
We didn't crash the application.

10656
07:47:13,950 --> 07:47:15,310
However, finally was still called.

10657
07:47:15,310 --> 07:47:18,100
So regardless of what
happens inside of the try,

10658
07:47:18,100 --> 07:47:20,800
finally is always called
while it's not guaranteed

10659
07:47:20,800 --> 07:47:22,870
to always be called with the catch,

10660
07:47:22,870 --> 07:47:24,940
because we could be filtering
it based upon the type

10661
07:47:24,940 --> 07:47:25,790
of the exception.

10662
07:47:27,610 --> 07:47:29,550
Defining a type alias can be very useful

10663
07:47:29,550 --> 07:47:31,080
in various different scenarios.

10664
07:47:31,080 --> 07:47:33,310
It allows you to alias one particular type

10665
07:47:34,390 --> 07:47:35,550
to another name type.

10666
07:47:35,550 --> 07:47:38,150
So let's assume we have a user class here

10667
07:47:38,150 --> 07:47:40,330
and has a username and
perhaps an auth token,

10668
07:47:40,330 --> 07:47:43,470
and perhaps the account
class also has an auth token

10669
07:47:43,470 --> 07:47:47,840
that is needed to request
the account details.

10670
07:47:47,840 --> 07:47:50,980
And for whatever reason,
there is a order class,

10671
07:47:50,980 --> 07:47:54,310
and it also requires
an auth token as well.

10672
07:47:54,310 --> 07:47:55,910
And it's a string.

10673
07:47:55,910 --> 07:47:57,260
Now, eventually you
start finding yourself,

10674
07:47:57,260 --> 07:48:00,000
having the word auth token all
over your entire application

10675
07:48:00,000 --> 07:48:02,050
and realize that that could be a problem.

10676
07:48:02,050 --> 07:48:05,300
Well, one thing you can
do is actually type alias

10677
07:48:05,300 --> 07:48:08,210
auth token into its own
type, or maybe you can create

10678
07:48:08,210 --> 07:48:09,043
your own type.

10679
07:48:09,043 --> 07:48:09,970
So you could do that too.

10680
07:48:09,970 --> 07:48:14,010
You could say something like
this data class auth token.

10681
07:48:14,890 --> 07:48:17,060
And what it is that just contains a token

10682
07:48:17,060 --> 07:48:17,893
that the string.

10683
07:48:21,150 --> 07:48:24,750
And then you could start
replacing this with auth token,

10684
07:48:24,750 --> 07:48:28,820
but then inside of any of your
providers or anything else

10685
07:48:28,820 --> 07:48:30,770
that's inside of your system,
that's you wanna treat it

10686
07:48:30,770 --> 07:48:33,400
like a string, well now you
have to treat it like an object

10687
07:48:33,400 --> 07:48:34,233
and it's kind of a pain,

10688
07:48:34,233 --> 07:48:36,230
but you would just love to be
able to call it auth token,

10689
07:48:36,230 --> 07:48:38,040
because it would just make much more sense

10690
07:48:38,040 --> 07:48:40,290
when you're reasoning
about your application.

10691
07:48:41,294 --> 07:48:43,010
So I'm gonna go ahead and
put this back as string.

10692
07:48:45,800 --> 07:48:47,040
So I wanna go and get rid of that.

10693
07:48:47,040 --> 07:48:49,770
What you can do is actually
perform a type alias

10694
07:48:49,770 --> 07:48:51,210
and here's how you can do that.

10695
07:48:51,210 --> 07:48:53,120
What you can do is usually
I prefer to type these

10696
07:48:53,120 --> 07:48:54,950
at the top of a file or in some type

10697
07:48:54,950 --> 07:48:58,080
of common extensions area
inside of my application.

10698
07:48:58,080 --> 07:49:00,280
So I might have a file
called extensions.kt.

10699
07:49:01,972 --> 07:49:03,510
And I'll say type alias, and then it says,

10700
07:49:03,510 --> 07:49:06,660
I wanna type alias the word account token,

10701
07:49:06,660 --> 07:49:10,450
excuse me, auth token to equal string.

10702
07:49:11,730 --> 07:49:14,530
And what that means now is I
can use the word auth token

10703
07:49:15,990 --> 07:49:16,823
anywhere.

10704
07:49:16,823 --> 07:49:19,640
So this is also a string,
this is also an auth token.

10705
07:49:21,320 --> 07:49:23,170
But now it's much easier
for me to reason about

10706
07:49:23,170 --> 07:49:25,210
because now if I'm going
to use my user class,

10707
07:49:25,210 --> 07:49:29,490
user.auth token, I could see
that it's an auth token type.

10708
07:49:29,490 --> 07:49:30,960
And then it actually gives
me a hint here saying,

10709
07:49:30,960 --> 07:49:34,000
hey, that is actually a
string behind the scenes.

10710
07:49:34,000 --> 07:49:35,390
And so I can say auth token.

10711
07:49:35,390 --> 07:49:37,660
And then again, I still
have all the same operations

10712
07:49:37,660 --> 07:49:40,340
that I would have on a string
like length and so forth.

10713
07:49:40,340 --> 07:49:43,640
But now it allows me to
have much more meaning

10714
07:49:43,640 --> 07:49:45,240
directly inside of my application.

10715
07:49:45,240 --> 07:49:47,910
So if I'm creating a new order,

10716
07:49:48,830 --> 07:49:50,740
a new order is going
to take an auth token.

10717
07:49:50,740 --> 07:49:53,730
So instead of it taking a
string, it's an auth token.

10718
07:49:53,730 --> 07:49:55,440
And so I could do one thing.

10719
07:49:55,440 --> 07:49:57,961
I could actually provide the auth token

10720
07:49:57,961 --> 07:49:59,640
and say user.auth token, that'll work,

10721
07:49:59,640 --> 07:50:01,960
or if I just have a string,
because auth tokens are string,

10722
07:50:01,960 --> 07:50:04,130
I'll say, my auth token.

10723
07:50:04,130 --> 07:50:07,110
And this will also work too
because underneath the hood,

10724
07:50:07,110 --> 07:50:10,040
Kotlin knows that auth token is a string.

10725
07:50:10,040 --> 07:50:13,890
However, just for
usability and type systems

10726
07:50:13,890 --> 07:50:15,850
inside of your application,
it makes it a lot easier

10727
07:50:15,850 --> 07:50:19,310
sometimes with various
different values to use

10728
07:50:19,310 --> 07:50:23,040
type aliasing so you can
actually get the actual types

10729
07:50:23,040 --> 07:50:24,570
that you like without
actually having to create

10730
07:50:24,570 --> 07:50:26,200
a brand new one, because
maybe that auth token

10731
07:50:26,200 --> 07:50:27,860
is just a string, but you would just like

10732
07:50:27,860 --> 07:50:31,130
to have its own type and you
can do that with type aliases.

10733
07:50:31,130 --> 07:50:34,240
And it's very easy to
do just set type alias,

10734
07:50:34,240 --> 07:50:35,970
what you wanna call the type alias equals,

10735
07:50:35,970 --> 07:50:37,050
whatever the type is.

10736
07:50:38,220 --> 07:50:40,690
One of the coolest things
about Kotlin is the ability

10737
07:50:40,690 --> 07:50:43,270
to add functions to existing classes

10738
07:50:43,270 --> 07:50:45,110
already inside of the standard library

10739
07:50:45,110 --> 07:50:47,260
or other existing libraries.

10740
07:50:47,260 --> 07:50:50,360
Now, for example, what I mean
by that is it would be great

10741
07:50:50,360 --> 07:50:53,190
if a string class, which
is what this name is.

10742
07:50:53,190 --> 07:50:55,390
If we were to specified it's string,

10743
07:50:55,390 --> 07:50:59,020
but it's already through implicit nature,

10744
07:50:59,020 --> 07:51:00,724
we already know it's a string.

10745
07:51:00,724 --> 07:51:01,660
It'd be great, if the string class

10746
07:51:01,660 --> 07:51:03,780
had an initials method on it.

10747
07:51:03,780 --> 07:51:05,340
And that would allow me to automatically

10748
07:51:05,340 --> 07:51:07,500
just say name.initials.

10749
07:51:07,500 --> 07:51:09,420
And for that name, it would automatically

10750
07:51:09,420 --> 07:51:11,070
print the initials, so it would print DF.

10751
07:51:11,070 --> 07:51:14,230
Well, we can do that in Kotlin
and here's how we can do it.

10752
07:51:15,850 --> 07:51:17,650
All right, so I've saved
the time of actually typing

10753
07:51:17,650 --> 07:51:19,910
the code for you and I'll
walk you through it here.

10754
07:51:19,910 --> 07:51:22,220
Now, what I've done is
created a new function

10755
07:51:22,220 --> 07:51:24,830
on this line here, and
this function itself,

10756
07:51:25,680 --> 07:51:28,860
we start off by saying the
type that we want to extend,

10757
07:51:28,860 --> 07:51:30,850
here is string and then we wanna say,

10758
07:51:30,850 --> 07:51:33,930
here is the actual name of the
method that we wanna create.

10759
07:51:33,930 --> 07:51:35,370
And then of course, it's going to go ahead

10760
07:51:35,370 --> 07:51:38,990
and it's going to return a string,

10761
07:51:38,990 --> 07:51:40,940
which is we see here, returning string.

10762
07:51:41,800 --> 07:51:43,230
And then at that point in time,

10763
07:51:43,230 --> 07:51:45,850
we're gonna go ahead and go
through all of this here.

10764
07:51:45,850 --> 07:51:46,750
So here we have the values,

10765
07:51:46,750 --> 07:51:49,931
we're just going to split
it on an empty string.

10766
07:51:49,931 --> 07:51:51,350
And then we're gonna
grab the first initial

10767
07:51:51,350 --> 07:51:52,230
using the sub string.

10768
07:51:52,230 --> 07:51:53,570
I'll grab the first character off

10769
07:51:53,570 --> 07:51:56,790
the first part of the array of
the first item in the array.

10770
07:51:57,788 --> 07:51:59,830
And then we're gonna
grab the first character

10771
07:51:59,830 --> 07:52:02,020
off the second item in the array.

10772
07:52:02,020 --> 07:52:03,690
And then at that point, we're
just gonna use some string

10773
07:52:03,690 --> 07:52:06,092
interpolation and return them together.

10774
07:52:06,092 --> 07:52:08,110
So now if I run this, what we're gonna see

10775
07:52:08,110 --> 07:52:09,970
is we're gonna see DF is printed.

10776
07:52:09,970 --> 07:52:14,970
So now any string that I
have, so if I say val equals,

10777
07:52:15,620 --> 07:52:19,890
I could even have the something
like book that I'm reading,

10778
07:52:19,890 --> 07:52:22,660
which is called, I read this
book called "The daily stoic",

10779
07:52:23,830 --> 07:52:28,463
say daily stoic, I could say
print ln book dot initials.

10780
07:52:31,050 --> 07:52:34,680
And what we would get back is DS.

10781
07:52:34,680 --> 07:52:38,334
So of course, DS is printed
before the other name

10782
07:52:38,334 --> 07:52:39,167
and then printed.

10783
07:52:39,167 --> 07:52:41,580
So if we move this up here
would make a little more sense.

10784
07:52:41,580 --> 07:52:43,940
So now we see DF and then DS is printed.

10785
07:52:43,940 --> 07:52:47,290
So anything that has a
string in it is going to be

10786
07:52:47,290 --> 07:52:48,650
easily created.

10787
07:52:48,650 --> 07:52:51,360
Now this is the string is not
a class that we can control.

10788
07:52:51,360 --> 07:52:53,490
This is not, if we look at string,

10789
07:52:53,490 --> 07:52:56,400
this is part of the
Kotlin standard library.

10790
07:52:56,400 --> 07:52:59,080
That's part of Java, we
can't do anything about that,

10791
07:52:59,080 --> 07:53:02,090
but we're actually able to
kind of slap on some additional

10792
07:53:02,090 --> 07:53:04,520
methods for it using extension methods.

10793
07:53:04,520 --> 07:53:07,950
So now what I usually
prefer to do in this case,

10794
07:53:08,810 --> 07:53:11,920
is I like to have a file and
I'll call this extensions.

10795
07:53:15,360 --> 07:53:17,850
And that's where I like to
put my files, my extensions.

10796
07:53:17,850 --> 07:53:20,520
And if I have a lot of them,
I'll call string extensions.

10797
07:53:20,520 --> 07:53:22,950
I'll have integer
extensions, but in this case,

10798
07:53:22,950 --> 07:53:25,690
I'll start off very simply
with one file called extension

10799
07:53:25,690 --> 07:53:28,682
that doesn't need to
be inside of a package.

10800
07:53:28,682 --> 07:53:30,290
It can be a top level
function as we're seeing here.

10801
07:53:30,290 --> 07:53:31,390
Now, at this point,

10802
07:53:31,390 --> 07:53:32,890
I can call this from
anywhere that I would like.

10803
07:53:32,890 --> 07:53:36,360
So back of my main file,
initials still works.

10804
07:53:36,360 --> 07:53:38,690
So anywhere in my application now,

10805
07:53:38,690 --> 07:53:41,290
I'm gonna be able to
use this dot initials.

10806
07:53:41,290 --> 07:53:43,550
Now the same thing can happen
over here in extensions.

10807
07:53:43,550 --> 07:53:48,550
Let's say I wanted to extend
the integer class is adult,

10808
07:53:50,100 --> 07:53:51,950
and this could return a Boolean value

10809
07:53:53,090 --> 07:53:54,590
and all this is going to do...

10810
07:53:57,344 --> 07:53:58,177
And we can actually single line this.

10811
07:53:58,177 --> 07:54:00,360
And we'll say this now
notice how he said this,

10812
07:54:00,360 --> 07:54:05,360
because this is in regards to
what type we are extending.

10813
07:54:06,890 --> 07:54:10,360
So the extension function for
string, we said this.split.

10814
07:54:10,360 --> 07:54:12,300
Here we had this is for the integer.

10815
07:54:12,300 --> 07:54:16,880
So this greater than or equal to 18.

10816
07:54:16,880 --> 07:54:17,713
So is adult.

10817
07:54:17,713 --> 07:54:19,680
So I can single line this
one, this one's easy.

10818
07:54:19,680 --> 07:54:22,110
Again, this could also
be if I wanted to do it

10819
07:54:22,110 --> 07:54:24,500
the other way, which you may
be more familiar with seeing

10820
07:54:24,500 --> 07:54:25,530
to make more sense.

10821
07:54:26,650 --> 07:54:28,000
We can do it this way here.

10822
07:54:28,950 --> 07:54:30,690
It says convert to expression body.

10823
07:54:30,690 --> 07:54:33,710
So there we go as adult
and I can even probably

10824
07:54:33,710 --> 07:54:35,220
get rid of that.

10825
07:54:35,220 --> 07:54:38,070
And so I can now really
make this succinct.

10826
07:54:38,070 --> 07:54:40,910
At this point, we are
looking at, I don't know,

10827
07:54:40,910 --> 07:54:44,030
30 characters total from
start to finish as adult.

10828
07:54:44,030 --> 07:54:48,580
What this allows us to do
is say, val age equals 35,

10829
07:54:48,580 --> 07:54:52,370
and I say, print line, age.is adult.

10830
07:54:53,600 --> 07:54:55,400
And you see how the code completion

10831
07:54:55,400 --> 07:54:57,020
found them automatically.

10832
07:54:57,020 --> 07:54:58,360
And we see that true came back.

10833
07:54:58,360 --> 07:55:01,700
So now I was able to
extend the integer class.

10834
07:55:01,700 --> 07:55:05,230
I've extended the string
class and then furthermore,

10835
07:55:05,230 --> 07:55:09,280
I could also do this with,
let's say another model.

10836
07:55:09,280 --> 07:55:11,840
So I'm gonna create another file here.

10837
07:55:11,840 --> 07:55:12,890
Call this one models.

10838
07:55:15,670 --> 07:55:18,250
Inside the models form I'm
gonna have a data class.

10839
07:55:20,030 --> 07:55:20,863
Data class.

10840
07:55:22,189 --> 07:55:23,110
Actually let's do a regular class.

10841
07:55:23,110 --> 07:55:27,153
The class person is gonna have
a val name string, a val age,

10842
07:55:30,400 --> 07:55:32,180
and that's gonna be int.

10843
07:55:33,420 --> 07:55:36,870
And then what I can do
is I might have my person

10844
07:55:39,930 --> 07:55:43,000
and I'll say, hey, today,
I'm gonna be 89 years old.

10845
07:55:43,000 --> 07:55:45,490
So Donn person age 89.

10846
07:55:45,490 --> 07:55:48,130
Now the cool thing about
this is if I had my full name

10847
07:55:48,130 --> 07:55:50,780
in here, I could do something like this.

10848
07:55:51,640 --> 07:55:52,820
I say person dot...

10849
07:55:53,890 --> 07:55:56,450
Well from here, I could say, initials,

10850
07:55:58,032 --> 07:55:59,780
person.name.initials.

10851
07:56:00,710 --> 07:56:03,940
Now the problem that we're
going to get here is that

10852
07:56:03,940 --> 07:56:07,190
the name Donn, if we run this here,

10853
07:56:07,190 --> 07:56:10,310
we're gonna get an exception
because the initials

10854
07:56:10,310 --> 07:56:14,350
is splitting on a string on a space.

10855
07:56:14,350 --> 07:56:15,900
As we see here, this is
what's happening here.

10856
07:56:15,900 --> 07:56:17,690
Splitting on a space.

10857
07:56:17,690 --> 07:56:19,610
And so there's actually
only one item in the array.

10858
07:56:19,610 --> 07:56:21,310
Therefore, it's going to be blowing up.

10859
07:56:21,310 --> 07:56:22,580
So that's not gonna work right now.

10860
07:56:22,580 --> 07:56:25,990
But if for some reason I had
my name listed as Donn Felker,

10861
07:56:27,890 --> 07:56:30,760
like that, I could then issue that

10862
07:56:30,760 --> 07:56:32,950
and I would've then get
back my correct initials.

10863
07:56:32,950 --> 07:56:35,020
I would see DF again printed.

10864
07:56:35,020 --> 07:56:38,000
So let's now go ahead and
change this person class though.

10865
07:56:38,000 --> 07:56:39,540
And let's kind of show how we can extend.

10866
07:56:39,540 --> 07:56:43,790
Let's pretend that this
class had a first name

10867
07:56:43,790 --> 07:56:45,040
and then had a last name.

10868
07:56:46,630 --> 07:56:49,400
This is a very common example
that you're gonna run into.

10869
07:56:49,400 --> 07:56:52,590
This person could be a user,
it could be anything else.

10870
07:56:52,590 --> 07:56:54,180
And it's usually going to be a class

10871
07:56:54,180 --> 07:56:55,980
that you do not control.

10872
07:56:55,980 --> 07:56:58,770
So we'll say Felker,
we've made it my last name

10873
07:57:00,169 --> 07:57:02,630
and then we'll see again, and
I've got a little bit older

10874
07:57:02,630 --> 07:57:04,680
since the last time we spoke, I'm 90 now.

10875
07:57:05,890 --> 07:57:09,020
And so a lot of times,
if I would want to print

10876
07:57:09,993 --> 07:57:11,493
someone's name, I'm gonna say,

10877
07:57:12,702 --> 07:57:13,535
of course we're gonna
do string interpolation,

10878
07:57:13,535 --> 07:57:16,320
cause it makes more sense,
I'll say person.FirstName,

10879
07:57:18,840 --> 07:57:21,870
and then I'll do a space and
then I'll do person.lastName.

10880
07:57:23,338 --> 07:57:24,370
And that works great.

10881
07:57:24,370 --> 07:57:27,150
The problem is I find myself
repeating myself over and over

10882
07:57:27,150 --> 07:57:28,840
and over my application and I'm doing this

10883
07:57:28,840 --> 07:57:29,890
all over the place.

10884
07:57:29,890 --> 07:57:32,490
But I can't come in and
modify the person class

10885
07:57:32,490 --> 07:57:34,270
because it was in a library somewhere.

10886
07:57:34,270 --> 07:57:37,190
So what I could do is I could
be in my extension class,

10887
07:57:37,190 --> 07:57:39,020
I'm in here, and I say fun person.

10888
07:57:39,020 --> 07:57:44,020
I remember that person and I
can say full name, full name.

10889
07:57:45,150 --> 07:57:47,550
And I'm gonna go ahead and
just inline this one as well.

10890
07:57:47,550 --> 07:57:50,660
And all this is gonna be as this.firstName

10891
07:57:50,660 --> 07:57:54,020
and I'm actually going to
and string interpolate this.

10892
07:57:54,020 --> 07:57:59,020
So we'll do the first name
space, this dot last name,

10893
07:58:01,630 --> 07:58:03,210
close that out.

10894
07:58:03,210 --> 07:58:05,030
And now, instead of doing this,

10895
07:58:05,030 --> 07:58:07,950
I have extended another person.

10896
07:58:07,950 --> 07:58:10,300
So I'm gonna say person.fullName.

10897
07:58:12,300 --> 07:58:14,447
I don't even need the
quotes there actually.

10898
07:58:14,447 --> 07:58:15,280
I can just get rid of all that.

10899
07:58:18,090 --> 07:58:19,340
Now it's person.fullName.

10900
07:58:20,805 --> 07:58:22,020
And if we run this,
we'll see the same thing

10901
07:58:22,020 --> 07:58:23,040
Donn Felker comes here.

10902
07:58:23,040 --> 07:58:28,040
So if we say, you know, John
Smith first and last name,

10903
07:58:28,930 --> 07:58:30,200
John Smith.

10904
07:58:30,200 --> 07:58:31,750
So we've actually, again,

10905
07:58:31,750 --> 07:58:35,144
we're assuming that this
person classes in some other

10906
07:58:35,144 --> 07:58:35,977
library somewhere, we
don't have control over it,

10907
07:58:35,977 --> 07:58:37,360
but we do wanna use it.

10908
07:58:37,360 --> 07:58:39,110
And we wanna make it easier to use.

10909
07:58:39,986 --> 07:58:42,530
We can create an extension
function called full name.

10910
07:58:42,530 --> 07:58:44,350
We can create any type of other function

10911
07:58:44,350 --> 07:58:47,120
that we wanna throw on to those types

10912
07:58:47,120 --> 07:58:50,709
such as we're building
on top of the built-in

10913
07:58:50,709 --> 07:58:52,060
primitive types that are
inside of the type system,

10914
07:58:52,060 --> 07:58:55,380
such as string and int or
even custom types that maybe

10915
07:58:55,380 --> 07:58:58,060
we have control over or we
don't have control over.

10916
07:58:58,060 --> 07:59:00,820
And we would like to provide
extension functions to them.

10917
07:59:00,820 --> 07:59:02,940
A lot of times you might
find an extension function,

10918
07:59:02,940 --> 07:59:06,660
very useful in a particular
domain of your application,

10919
07:59:06,660 --> 07:59:07,820
maybe in a couple of modules.

10920
07:59:07,820 --> 07:59:10,460
And you might put that
extension function over there,

10921
07:59:10,460 --> 07:59:14,100
but that's how you can create
extension functions in Kotlin.

10922
07:59:14,100 --> 07:59:16,040
Let's say that you have a string in Kotlin

10923
07:59:17,070 --> 07:59:17,903
and you wanna print it out.

10924
07:59:17,903 --> 07:59:19,440
But what happens if this string

10925
07:59:19,440 --> 07:59:22,850
was from an expensive operation,
what would you do then?

10926
07:59:24,040 --> 07:59:29,040
You perhaps might wanna use a
lazy keyword inside of Kotlin.

10927
07:59:29,600 --> 07:59:33,450
And so this allows lazy
evaluation inside of Kotlin.

10928
07:59:33,450 --> 07:59:36,610
So what this will do is this
doesn't look any different

10929
07:59:36,610 --> 07:59:37,950
than what we had before.

10930
07:59:40,370 --> 07:59:44,100
Now, if I run this, what
we're gonna see here

10931
07:59:44,100 --> 07:59:46,309
is that we have Donn's printed.

10932
07:59:46,309 --> 07:59:48,710
Now however, something
interesting happens here,

10933
07:59:48,710 --> 07:59:52,310
print line inside of here,
and I'm gonna say computed.

10934
07:59:55,448 --> 07:59:57,180
And then what I'm gonna do is
I'm gonna print this twice.

10935
07:59:57,180 --> 07:59:58,620
And so what we're gonna see
is two different things.

10936
07:59:58,620 --> 07:59:59,980
We should see Donn printed twice,

10937
07:59:59,980 --> 08:00:01,150
but we should also see computed,

10938
08:00:01,150 --> 08:00:05,580
but we're only going to see
computed as printed once

10939
08:00:05,580 --> 08:00:07,750
yet the second Donn is here as well.

10940
08:00:07,750 --> 08:00:10,460
So I printed both the names as done here,

10941
08:00:12,090 --> 08:00:16,700
but we only see computed showing up once.

10942
08:00:16,700 --> 08:00:21,000
And the reason why is
because the first time

10943
08:00:22,130 --> 08:00:25,970
the call to this name has been called,

10944
08:00:25,970 --> 08:00:28,650
Kotlin will then go ahead and
evaluate and execute the code

10945
08:00:28,650 --> 08:00:29,950
that's inside of here.

10946
08:00:29,950 --> 08:00:31,570
And this could be a very
long running operation.

10947
08:00:31,570 --> 08:00:33,670
And then at that point
Kotlin will remember

10948
08:00:33,670 --> 08:00:35,820
the computed value and
then we'll return it

10949
08:00:36,989 --> 08:00:39,366
each subsequent time that it's called.

10950
08:00:39,366 --> 08:00:40,199
So we'll not actually execute it again.

10951
08:00:40,199 --> 08:00:42,480
So if I run this, we'll
see computed and then Don

10952
08:00:42,480 --> 08:00:44,000
will be printed three times.

10953
08:00:44,000 --> 08:00:46,090
So a good way to emulate this is actually,

10954
08:00:46,090 --> 08:00:47,690
if we just did a sleep function.

10955
08:00:48,635 --> 08:00:51,530
And we'll do sleep, I'm
gonna sleep for three seconds

10956
08:00:51,530 --> 08:00:54,650
and sleep is just part
of the Java library.

10957
08:00:54,650 --> 08:00:58,000
So three, not 3000, there we go.

10958
08:00:58,000 --> 08:01:00,210
This is simulating a
long running operation.

10959
08:01:03,752 --> 08:01:05,960
Maybe we had to go off
into a background session

10960
08:01:05,960 --> 08:01:08,510
or we had to do some type
of really complicated

10961
08:01:08,510 --> 08:01:11,680
number crunching and to return this value.

10962
08:01:11,680 --> 08:01:13,740
And this value here is as Don.

10963
08:01:13,740 --> 08:01:15,010
So the first time it's gonna happen,

10964
08:01:15,010 --> 08:01:16,540
we're gonna see print computed,

10965
08:01:16,540 --> 08:01:18,970
and then it's gonna wait 3000 milliseconds

10966
08:01:18,970 --> 08:01:19,810
or three seconds.

10967
08:01:19,810 --> 08:01:22,310
And then we're gonna see
Donn printed most likely

10968
08:01:22,310 --> 08:01:23,510
three times really fast.

10969
08:01:23,510 --> 08:01:26,170
So let's run this here down
here in the output window,

10970
08:01:26,170 --> 08:01:29,320
you're gonna see computed
it's waiting and then boom,

10971
08:01:29,320 --> 08:01:30,430
all three of them were computed.

10972
08:01:30,430 --> 08:01:34,360
So what ended up happening was
the first time this executed,

10973
08:01:34,360 --> 08:01:37,810
all this was being executed
on this first line.

10974
08:01:37,810 --> 08:01:41,090
So the first time this code was executed,

10975
08:01:41,970 --> 08:01:43,740
it was executed right here.

10976
08:01:43,740 --> 08:01:47,020
Now each subsequent call, which happens,

10977
08:01:47,020 --> 08:01:51,130
which ended up happening here and here,

10978
08:01:51,130 --> 08:01:52,360
it got the remembered value.

10979
08:01:52,360 --> 08:01:55,490
So as soon as it came
out, this came out, said,

10980
08:01:55,490 --> 08:01:59,640
all right, well, the new
calculated value is X.

10981
08:01:59,640 --> 08:02:01,820
And then what ends up
happening is each time

10982
08:02:01,820 --> 08:02:04,700
the subsequent calls are
made that calculated value

10983
08:02:04,700 --> 08:02:06,990
is remembered and it's
not executed anymore.

10984
08:02:06,990 --> 08:02:10,230
So on the first execution
when you're using by lazy,

10985
08:02:10,230 --> 08:02:13,540
it'll execute this code
and then drop it into here.

10986
08:02:13,540 --> 08:02:16,452
So that's how you can use by lazy

10987
08:02:16,452 --> 08:02:17,340
to remember computed values

10988
08:02:17,340 --> 08:02:18,990
so things are a little bit faster

10989
08:02:20,146 --> 08:02:21,760
and so you can have a
little bit more performance.

10990
08:02:22,682 --> 08:02:24,223
And if you want the value
remembered inside of your

10991
08:02:24,223 --> 08:02:25,523
application in the future.

10992
08:02:26,680 --> 08:02:29,070
In Kotlin, you can have
lazy property valuation,

10993
08:02:29,070 --> 08:02:31,020
and you can also just have a lazy block

10994
08:02:32,036 --> 08:02:33,980
in which you can state some
type of expensive operation

10995
08:02:33,980 --> 08:02:35,920
needs to be lazy evaluated.

10996
08:02:35,920 --> 08:02:37,210
And all you have to really do is provide

10997
08:02:37,210 --> 08:02:38,520
some type of block in here.

10998
08:02:38,520 --> 08:02:41,300
And you can either write
your code inside of here,

10999
08:02:41,300 --> 08:02:43,500
and you can put your code here,

11000
08:02:43,500 --> 08:02:46,310
or maybe you need to call an
actual method as I'm doing here

11001
08:02:46,310 --> 08:02:48,960
to perform some expensive operation.

11002
08:02:48,960 --> 08:02:51,660
And so what I have here is I have a method

11003
08:02:51,660 --> 08:02:52,860
that returns an integer.

11004
08:02:54,405 --> 08:02:56,270
And when it's the first
time it's executed,

11005
08:02:56,270 --> 08:02:58,770
or every time it's executed,
this method is gonna call

11006
08:02:58,770 --> 08:03:01,290
and print out this word computed.

11007
08:03:01,290 --> 08:03:02,910
And then it's gonna sleep for one second

11008
08:03:02,910 --> 08:03:06,390
and then it's gonna return
a randomized integer

11009
08:03:06,390 --> 08:03:09,340
or somewhat random because
that's just the nature

11010
08:03:09,340 --> 08:03:10,280
of the random class,

11011
08:03:10,280 --> 08:03:12,590
but it's gonna randomize
based upon the current time

11012
08:03:12,590 --> 08:03:14,810
milliseconds and et cetera.

11013
08:03:14,810 --> 08:03:16,720
So it's gonna give us a
different random number

11014
08:03:16,720 --> 08:03:18,130
each time.

11015
08:03:18,130 --> 08:03:21,040
So what we wanna see here is what happens

11016
08:03:21,040 --> 08:03:22,010
when we print this out.

11017
08:03:22,010 --> 08:03:24,400
So all we're gonna do
is have a lazy result,

11018
08:03:24,400 --> 08:03:25,440
which is an integer.

11019
08:03:25,440 --> 08:03:28,500
We're gonna print it and
then we actually wanna see,

11020
08:03:28,500 --> 08:03:30,130
there's actually a property on this

11021
08:03:30,130 --> 08:03:33,274
and it's called is initialized.

11022
08:03:33,274 --> 08:03:35,020
And so we're gonna run
this and what we'll see

11023
08:03:35,020 --> 08:03:38,550
is that the first one
when we print the result,

11024
08:03:38,550 --> 08:03:40,930
it says lazy value not initialized yet.

11025
08:03:40,930 --> 08:03:43,390
And I said, is this
initialized and it's false.

11026
08:03:43,390 --> 08:03:46,000
And so we have a couple
of other options on here,

11027
08:03:46,000 --> 08:03:50,390
result.initialized or get
value or just value itself.

11028
08:03:50,390 --> 08:03:54,600
So it's print this line here,
so print line result.value.

11029
08:03:55,690 --> 08:03:58,352
And then what we're gonna
see here is we're of course

11030
08:03:58,352 --> 08:03:59,920
gonna see non initialize,
it's gonna be false.

11031
08:03:59,920 --> 08:04:02,250
And is gonna say computed
and then it returned us

11032
08:04:02,250 --> 08:04:05,910
a number here based
upon the randomization.

11033
08:04:05,910 --> 08:04:09,030
Now to verify that the
lazy evaluation is working

11034
08:04:09,030 --> 08:04:11,790
and lazily evaluating meaning,
it's going to remember

11035
08:04:11,790 --> 08:04:15,130
its future values, let's
execute this a few times

11036
08:04:15,130 --> 08:04:16,930
to see what happens.

11037
08:04:16,930 --> 08:04:20,380
If for some reason, lazy
is not doing its job,

11038
08:04:20,380 --> 08:04:23,360
then we should see computed
printed three times

11039
08:04:23,360 --> 08:04:26,840
and we should see every time
1000 milliseconds sleeps,

11040
08:04:26,840 --> 08:04:29,570
so about a second in between
each one of these values.

11041
08:04:29,570 --> 08:04:31,230
So if we run this, what
we'll see is again,

11042
08:04:31,230 --> 08:04:33,560
we'll see the top two values
printed computed, boom.

11043
08:04:33,560 --> 08:04:34,970
And then all three of these came out

11044
08:04:34,970 --> 08:04:38,210
almost the exact same time, very quickly.

11045
08:04:38,210 --> 08:04:40,680
And what that means is the
first time that this value

11046
08:04:40,680 --> 08:04:43,000
was computed inside of
this lazy evaluation,

11047
08:04:43,000 --> 08:04:44,190
Kotlin then remembered it.

11048
08:04:44,190 --> 08:04:48,010
So for each subsequent time,
we received the same value.

11049
08:04:48,010 --> 08:04:50,650
And then of course, because
we weren't sleeping,

11050
08:04:50,650 --> 08:04:52,230
the milliseconds would
have been different here,

11051
08:04:52,230 --> 08:04:55,310
which means we would got a
most likely a different number

11052
08:04:55,310 --> 08:04:56,900
in one of these values.

11053
08:04:56,900 --> 08:05:00,190
So we can tell here with
a high level of certainty

11054
08:05:00,190 --> 08:05:03,420
that Kotlin is returning
basically a cached value of that

11055
08:05:03,420 --> 08:05:06,010
which been cached for this lazy operation.

11056
08:05:06,010 --> 08:05:08,640
So if we know that we want
that same value over and over,

11057
08:05:08,640 --> 08:05:12,218
and we don't wanna call a
particular method or function

11058
08:05:12,218 --> 08:05:13,940
or class, because it's very expensive,

11059
08:05:13,940 --> 08:05:17,300
more than once we can
wrap it in a lazy block

11060
08:05:17,300 --> 08:05:19,220
and it will be only
executed the first time.

11061
08:05:19,220 --> 08:05:21,780
And then at that point,
all future invocations

11062
08:05:21,780 --> 08:05:25,410
of that operation will then
return the cached value,

11063
08:05:25,410 --> 08:05:28,890
which is cache via the
Kotlin lazy operator,

11064
08:05:28,890 --> 08:05:31,120
which we can see here
creates a new lazy instance

11065
08:05:31,120 --> 08:05:33,910
of the specified initialization function.

11066
08:05:33,910 --> 08:05:37,960
So that's how you can use
the lazy block in Kotlin

11067
08:05:37,960 --> 08:05:39,700
to help speed up your application

11068
08:05:39,700 --> 08:05:41,840
and be a little more performant.

11069
08:05:41,840 --> 08:05:43,700
When creating files
instead of your project,

11070
08:05:43,700 --> 08:05:45,780
you want to think about organization

11071
08:05:45,780 --> 08:05:47,720
and where to put these files.

11072
08:05:47,720 --> 08:05:50,570
Files are usually organized
into various different packages

11073
08:05:50,570 --> 08:05:53,520
inside of your project
and the project explorer

11074
08:05:53,520 --> 08:05:54,990
on the left-hand side.

11075
08:05:54,990 --> 08:05:57,010
And the SRC directory, you
can create a new package

11076
08:05:57,010 --> 08:06:00,820
by going to new package, and
then you can enter a package.

11077
08:06:00,820 --> 08:06:03,780
So one common one that you see a lot used,

11078
08:06:03,780 --> 08:06:08,200
instead of example
projects is com.example.

11079
08:06:08,200 --> 08:06:11,370
As we create com.example, we
see we have kind of what looks

11080
08:06:11,370 --> 08:06:13,120
like a new folder with a dot in it,

11081
08:06:14,421 --> 08:06:15,890
and that signifies it as a package.

11082
08:06:15,890 --> 08:06:18,789
And let's say we wanted
to create another package

11083
08:06:18,789 --> 08:06:19,622
inside of the example.

11084
08:06:19,622 --> 08:06:22,389
We could say, we wanna create another one.

11085
08:06:22,389 --> 08:06:23,750
We could say com.example

11086
08:06:24,840 --> 08:06:26,500
and we see here that the
directory already exists.

11087
08:06:26,500 --> 08:06:28,200
And why does it say directory?

11088
08:06:28,200 --> 08:06:30,300
We'll get to that in a second.

11089
08:06:30,300 --> 08:06:32,550
Let's say we wanna
create a models package,

11090
08:06:32,550 --> 08:06:34,200
we wanna create a models package.

11091
08:06:35,670 --> 08:06:37,840
And so we said com.example.models.

11092
08:06:38,700 --> 08:06:41,444
And so it's kind of been pre pended here.

11093
08:06:41,444 --> 08:06:43,250
Now, as we see these
dots and it kind of looks

11094
08:06:43,250 --> 08:06:46,220
like a backwards domain name
and that's kind of what it is.

11095
08:06:46,220 --> 08:06:48,520
Now the interesting part
about how these files

11096
08:06:48,520 --> 08:06:50,390
are stored in the disc
is if we look at them

11097
08:06:50,390 --> 08:06:53,070
inside of our file
explorer and I'm on a Mac,

11098
08:06:53,070 --> 08:06:56,560
so I'm using finder,
you'll see, we have models,

11099
08:06:57,680 --> 08:06:59,360
an example com.

11100
08:06:59,360 --> 08:07:01,480
And if we go backwards, we
basically gonna come up here

11101
08:07:01,480 --> 08:07:05,500
to our Castro column, our SRC folder,

11102
08:07:05,500 --> 08:07:08,090
which kind of maps to
this folder over here,

11103
08:07:08,090 --> 08:07:13,090
we see our IO our com and
see how we have io.Caster

11104
08:07:14,200 --> 08:07:15,500
package over here.

11105
08:07:15,500 --> 08:07:20,070
So com example models,
each one of the items

11106
08:07:20,070 --> 08:07:22,820
that are separated between the
separators, which are dots,

11107
08:07:22,820 --> 08:07:24,800
periods is actually a new folder.

11108
08:07:25,650 --> 08:07:28,030
So let's say for whatever reason,

11109
08:07:28,030 --> 08:07:31,700
I wanted to create a file
inside of the models project.

11110
08:07:31,700 --> 08:07:35,070
What I would do is they
file new and inside of here,

11111
08:07:35,070 --> 08:07:36,840
I might wanna create a person,

11112
08:07:38,189 --> 08:07:39,639
it's called a customer class.

11113
08:07:41,550 --> 08:07:43,200
And it's customer, you
notice how it automatically

11114
08:07:43,200 --> 08:07:46,270
adds the value package at the top.

11115
08:07:46,270 --> 08:07:49,403
And this is the package
declaration that lets you know

11116
08:07:49,403 --> 08:07:50,236
what package is file is in.

11117
08:07:50,236 --> 08:07:53,760
So here, this is inside of the
package com.example.models.

11118
08:07:53,760 --> 08:07:56,380
And I can have my class
and maybe it would have

11119
08:07:56,380 --> 08:07:59,800
a regular name and a
string for a customer.

11120
08:07:59,800 --> 08:08:00,990
And those are all kinds of common things

11121
08:08:00,990 --> 08:08:01,940
we might have here.

11122
08:08:03,891 --> 08:08:07,740
And then we might have another customer

11123
08:08:07,740 --> 08:08:10,030
or we might have another
value inside of there.

11124
08:08:10,030 --> 08:08:12,020
And now let's go, we're over
here to our other file here.

11125
08:08:12,020 --> 08:08:13,790
Let's say we have something else.

11126
08:08:13,790 --> 08:08:16,050
And let's say we have in
cast or we have something

11127
08:08:16,050 --> 08:08:18,360
known as a video file
and that's a video class,

11128
08:08:18,360 --> 08:08:21,440
we'll say class video and it has a URL.

11129
08:08:21,440 --> 08:08:24,540
That's a string that's
associated with that URL.

11130
08:08:25,650 --> 08:08:28,220
And then inside of there,
we have some other things.

11131
08:08:28,220 --> 08:08:32,100
But maybe it also has some
customers that have watched it.

11132
08:08:32,100 --> 08:08:36,190
So we might have a function,
say something like fun.

11133
08:08:36,190 --> 08:08:40,740
And it would be customers who viewed this

11134
08:08:43,770 --> 08:08:45,856
and perhaps this goes to a database.

11135
08:08:45,856 --> 08:08:48,656
And this database is gonna
go return a list of customers

11136
08:08:50,070 --> 08:08:50,903
of customers.

11137
08:08:51,920 --> 08:08:53,340
Now we're gonna see is we
have a list of customers

11138
08:08:53,340 --> 08:08:56,700
and we see right here IntelliJ has found

11139
08:08:56,700 --> 08:08:59,880
based upon us typing and code completion

11140
08:08:59,880 --> 08:09:01,650
that a customer class have been found.

11141
08:09:01,650 --> 08:09:04,100
Now, if I hit tab, which I'm going to do,

11142
08:09:05,000 --> 08:09:08,800
automatically, what happens
is something is imported.

11143
08:09:08,800 --> 08:09:12,030
This import is basically
saying, look, we wanna use

11144
08:09:12,030 --> 08:09:14,670
a customer from a different package.

11145
08:09:14,670 --> 08:09:15,650
And we're gonna use this from

11146
08:09:15,650 --> 08:09:17,720
the com.example.model's package.

11147
08:09:17,720 --> 08:09:20,430
Now of course I could just
hear, I could just hit return

11148
08:09:20,430 --> 08:09:22,280
just to get the compiler to be happy.

11149
08:09:22,280 --> 08:09:24,560
I could return them to the list.

11150
08:09:24,560 --> 08:09:26,060
So we're returning a customer.

11151
08:09:26,920 --> 08:09:29,380
So what we are using it
inside of this video class,

11152
08:09:29,380 --> 08:09:31,690
on the side, we're using
something from different package

11153
08:09:31,690 --> 08:09:32,840
over here.

11154
08:09:32,840 --> 08:09:33,830
Now we could also have
additional packages.

11155
08:09:33,830 --> 08:09:36,420
For example, I wanna
show you another trick

11156
08:09:36,420 --> 08:09:38,070
and go over here.

11157
08:09:38,070 --> 08:09:39,800
And let's say, for example, in models,

11158
08:09:39,800 --> 08:09:42,930
we happened to come to the
file system and type in here

11159
08:09:42,930 --> 08:09:44,840
and we'll say util.

11160
08:09:44,840 --> 08:09:47,570
Now, if we go back over
here, look what happens.

11161
08:09:47,570 --> 08:09:50,598
All of a sudden IntelliJ
recognize we have another folder

11162
08:09:50,598 --> 08:09:52,420
in there, hey, there's actually
some other stuff in here.

11163
08:09:52,420 --> 08:09:55,443
And a lot of times people
will actually create things

11164
08:09:55,443 --> 08:09:59,670
in here that are perhaps view,
we call it model extension

11165
08:09:59,670 --> 08:10:00,620
or something like that.

11166
08:10:00,620 --> 08:10:02,530
Will create some extensions files in here

11167
08:10:02,530 --> 08:10:06,340
for anything that's going to
be like an extension function

11168
08:10:06,340 --> 08:10:09,320
or anything like that, create extensions.

11169
08:10:10,180 --> 08:10:12,630
And this where they'll path
all of their extensions,

11170
08:10:12,630 --> 08:10:13,950
et cetera, or so forth

11171
08:10:13,950 --> 08:10:16,170
and it looks like it was misnamed there.

11172
08:10:16,170 --> 08:10:20,570
So we'll say extensions.kt not a big deal.

11173
08:10:20,570 --> 08:10:25,200
So we have multiple different
packages inside of here.

11174
08:10:25,200 --> 08:10:26,690
And so you can have multiple packages

11175
08:10:26,690 --> 08:10:27,630
inside of your projects.

11176
08:10:27,630 --> 08:10:29,220
So, here we have a couple of them.

11177
08:10:29,220 --> 08:10:32,150
You may import a different
package from another library

11178
08:10:32,150 --> 08:10:33,539
altogether.

11179
08:10:33,539 --> 08:10:36,090
So if we're inside of our
models here and we wanted

11180
08:10:36,090 --> 08:10:38,840
to import something else
from a different project,

11181
08:10:40,060 --> 08:10:42,530
as long as we have imported
inside of whatever build tool

11182
08:10:42,530 --> 08:10:45,687
we're using, we can go
ahead and reference that

11183
08:10:45,687 --> 08:10:48,390
just as we had referenced
to inside of our video file

11184
08:10:48,390 --> 08:10:49,800
over here.

11185
08:10:49,800 --> 08:10:51,980
Now, if for whatever reason you don't,

11186
08:10:51,980 --> 08:10:54,480
you would just create a
file and we don't put it

11187
08:10:54,480 --> 08:10:56,300
inside of a package.

11188
08:10:56,300 --> 08:11:00,340
So let's call this and say,
I'm gonna call it a favorite.

11189
08:11:00,340 --> 08:11:01,250
We'll call it a favorite class.

11190
08:11:01,250 --> 08:11:03,451
And if you're gonna favorite something,

11191
08:11:03,451 --> 08:11:07,060
say class favorite,
and maybe it has an IDE

11192
08:11:08,781 --> 08:11:10,660
that you did for whatever reason.

11193
08:11:10,660 --> 08:11:14,080
This class is in this right
here, it's in the SRC directory.

11194
08:11:14,080 --> 08:11:19,030
It does not have at all,
it does not have a package.

11195
08:11:19,030 --> 08:11:20,800
So the default package, it has no name.

11196
08:11:20,800 --> 08:11:22,410
So at this point, it's
part of the default package

11197
08:11:22,410 --> 08:11:25,420
of the application and the default package

11198
08:11:25,420 --> 08:11:28,450
of the application is nothing,
there's no name for it.

11199
08:11:28,450 --> 08:11:30,200
So here, you're just kind
of sitting at the top level

11200
08:11:30,200 --> 08:11:31,380
of your application.

11201
08:11:31,380 --> 08:11:33,050
This is not recommended to put files

11202
08:11:33,050 --> 08:11:33,900
here at the top level here.

11203
08:11:33,900 --> 08:11:36,800
It's always good to
have a place to put them

11204
08:11:36,800 --> 08:11:38,840
inside of your application.

11205
08:11:38,840 --> 08:11:40,170
So where should you put them,

11206
08:11:40,170 --> 08:11:42,660
maybe you don't have a good idea.

11207
08:11:42,660 --> 08:11:44,620
A lot of times if you're just
working with a sample app

11208
08:11:44,620 --> 08:11:46,020
and you want someplace to put them,

11209
08:11:46,020 --> 08:11:50,190
I recommend just using
com.example or org.example.

11210
08:11:50,190 --> 08:11:53,080
And that puts them in kind
of like an example namespace,

11211
08:11:53,080 --> 08:11:56,040
just so it gives you a little
bit a level of organization,

11212
08:11:56,040 --> 08:11:58,960
or maybe if you have your
own website, like I do,

11213
08:11:58,960 --> 08:12:01,680
what I will do is I'll put
them in my own package.

11214
08:12:01,680 --> 08:12:04,060
And so you can see, I
have a Caster one there,

11215
08:12:04,060 --> 08:12:06,610
but I also have a Donn Felker one.

11216
08:12:06,610 --> 08:12:09,460
So I'll say Donn Felker,
which is my website.

11217
08:12:09,460 --> 08:12:10,830
And I might say something like models.

11218
08:12:10,830 --> 08:12:12,110
If it's something has to do with models,

11219
08:12:12,110 --> 08:12:15,490
it has to do with IO, it might
have to do with input output,

11220
08:12:15,490 --> 08:12:18,240
if it has to do with, I'm
building some calculation stuff

11221
08:12:18,240 --> 08:12:20,060
or math or anything like that,

11222
08:12:20,060 --> 08:12:21,970
I might have it inside of there.

11223
08:12:21,970 --> 08:12:24,480
Or if I'm gonna build some services,

11224
08:12:24,480 --> 08:12:28,120
I have com.Donn Felker.services.

11225
08:12:28,120 --> 08:12:31,320
And now I have some packages in here.

11226
08:12:31,320 --> 08:12:34,140
And if you notice com now has realized,

11227
08:12:34,140 --> 08:12:37,140
hey, well, we have a couple
of packages inside of here

11228
08:12:37,140 --> 08:12:42,140
that also are from the same
root TLD, which is the com,

11229
08:12:43,740 --> 08:12:45,238
let me create a file here.

11230
08:12:45,238 --> 08:12:46,071
And inside of here, we'll have something

11231
08:12:46,071 --> 08:12:49,580
like a customer service, maybe
it does something special

11232
08:12:49,580 --> 08:12:53,090
for customers, or let's just
say it's a tweet service

11233
08:12:53,090 --> 08:12:56,670
for whatever reason I'm
connecting to Twitter.

11234
08:12:59,392 --> 08:13:00,225
So there, we got a tweet service.

11235
08:13:00,225 --> 08:13:03,550
And so this is just to
illustrate that you can have

11236
08:13:03,550 --> 08:13:06,310
multiple different packages inside of here

11237
08:13:06,310 --> 08:13:10,940
and the tweet services inside
of com.Donn Felker services.

11238
08:13:10,940 --> 08:13:13,180
Example over here we have the models,

11239
08:13:13,180 --> 08:13:16,240
we have models in here and
packages give you a way

11240
08:13:16,240 --> 08:13:20,320
to organize your code
into logical groupings.

11241
08:13:20,320 --> 08:13:22,000
So a lot of times you'll see a lot of code

11242
08:13:22,000 --> 08:13:24,830
that's related, maybe it's
with file L IO together,

11243
08:13:24,830 --> 08:13:26,640
database code will be together.

11244
08:13:26,640 --> 08:13:30,660
You'll see services together
and various different projects

11245
08:13:30,660 --> 08:13:31,610
will have a different way.

11246
08:13:31,610 --> 08:13:33,640
So it depends on the
project you're working on.

11247
08:13:33,640 --> 08:13:36,080
Some will be kind of grouped
together by function,

11248
08:13:36,080 --> 08:13:37,700
some will be grouped together by feature,

11249
08:13:37,700 --> 08:13:39,140
kind of depends on what it is.

11250
08:13:39,140 --> 08:13:41,850
But packages allow you
to group your various

11251
08:13:41,850 --> 08:13:44,800
different pieces of your
application and your classes

11252
08:13:44,800 --> 08:13:45,780
into different locations.

11253
08:13:45,780 --> 08:13:49,320
And again, if it's not part
of a particular package

11254
08:13:49,320 --> 08:13:52,486
and it's at the root level,
perhaps just right here

11255
08:13:52,486 --> 08:13:54,370
in the source directory, it's
part of the default package,

11256
08:13:54,370 --> 08:13:55,710
which has no name at all.

11257
08:13:55,710 --> 08:13:58,380
And usually this isn't
recommended when you're developing

11258
08:13:58,380 --> 08:14:00,250
a real production application.

11259
08:14:00,250 --> 08:14:03,000
And that's how you work with
packages inside of Kotlin.

11260
08:14:04,230 --> 08:14:06,500
Kotlin has type inference.

11261
08:14:06,500 --> 08:14:09,210
Let's talk about exactly what that means.

11262
08:14:09,210 --> 08:14:13,050
Now at a real high level,
what that really means

11263
08:14:13,050 --> 08:14:16,410
is that Kotlin can infer a
particular type of variable.

11264
08:14:16,410 --> 08:14:18,300
Now Kotlin is a strongly typed language.

11265
08:14:18,300 --> 08:14:22,700
That means that each variable
has a particular type.

11266
08:14:22,700 --> 08:14:24,270
The competitor's gonna check those types

11267
08:14:24,270 --> 08:14:25,830
and we have a lot of competitor things

11268
08:14:25,830 --> 08:14:28,410
that the competitor does that
makes our life a lot easier.

11269
08:14:28,410 --> 08:14:30,580
And one of those things is type checking.

11270
08:14:30,580 --> 08:14:32,750
However, in traditional
languages, such as Java,

11271
08:14:32,750 --> 08:14:35,040
you have to inform the compiler,

11272
08:14:35,040 --> 08:14:36,940
here's the type that I'm going to use.

11273
08:14:37,904 --> 08:14:38,737
And then you can start using the variable.

11274
08:14:38,737 --> 08:14:40,050
Kotlin has type inference.

11275
08:14:40,050 --> 08:14:45,050
So here we have a variable
or value by the name of name.

11276
08:14:46,460 --> 08:14:48,640
And it contains the value of Don

11277
08:14:48,640 --> 08:14:49,730
and we have another value here,

11278
08:14:49,730 --> 08:14:51,830
which contains the value of age.

11279
08:14:51,830 --> 08:14:54,999
And this could also be
a var, it doesn't matter

11280
08:14:54,999 --> 08:14:59,040
if it's a val or a var,
Kotlin one for both.

11281
08:14:59,040 --> 08:15:01,810
And the old we can see
here just through the helps

11282
08:15:01,810 --> 08:15:05,510
inside of IntelliJ is that
Kotlin has already inferred

11283
08:15:05,510 --> 08:15:08,740
that the name variable here is a string.

11284
08:15:08,740 --> 08:15:11,120
And the reason how it's
doing that is it's looking

11285
08:15:11,120 --> 08:15:13,880
on the right hand side of
the equal sign and saying,

11286
08:15:13,880 --> 08:15:17,680
well, you have omitted declare a variable

11287
08:15:17,680 --> 08:15:18,950
and you want me to call it a name?

11288
08:15:18,950 --> 08:15:21,660
Okay, and then you wanna
assign the value Don

11289
08:15:21,660 --> 08:15:24,220
and I already know the
value Donn is a string.

11290
08:15:24,220 --> 08:15:28,630
And someone gonna put a
string inside of the name.

11291
08:15:28,630 --> 08:15:31,530
So that means that most
likely that name is a string.

11292
08:15:31,530 --> 08:15:33,000
So I'm gonna infer the name of the string.

11293
08:15:33,000 --> 08:15:35,690
And the same thing goes for over here,

11294
08:15:35,690 --> 08:15:39,050
you will want the value
33 and 33 is integer,

11295
08:15:39,050 --> 08:15:40,900
and you wanna shove it into the name,

11296
08:15:41,971 --> 08:15:44,360
excuse me, into the age variable.

11297
08:15:44,360 --> 08:15:47,020
Well, I'm gonna assume
that that age variable

11298
08:15:47,020 --> 08:15:48,330
is actually gonna be an integer.

11299
08:15:48,330 --> 08:15:49,870
And as we can see here from the help

11300
08:15:49,870 --> 08:15:52,040
that compiler is actually
getting this right.

11301
08:15:52,040 --> 08:15:53,160
And this does a few things,

11302
08:15:53,160 --> 08:15:56,060
it allows us to not have
to declare the variable.

11303
08:15:56,060 --> 08:15:57,760
Now we could, of course, just say,

11304
08:15:58,936 --> 08:15:59,769
hey, this is gonna be a string,

11305
08:15:59,769 --> 08:16:01,780
but we're actually kind of
just writing a bunch of code

11306
08:16:01,780 --> 08:16:04,260
that we don't really need to write.

11307
08:16:05,740 --> 08:16:07,090
So we don't really don't have to do this.

11308
08:16:07,090 --> 08:16:11,030
Now that's really nice thing
about us instead of Kotlin,

11309
08:16:11,030 --> 08:16:13,260
with variables, we can
infer them automatically.

11310
08:16:13,260 --> 08:16:15,110
Now there is a caveat here.

11311
08:16:15,110 --> 08:16:18,470
If you remember late
initializations who have a var,

11312
08:16:18,470 --> 08:16:22,270
and we could say maybe your favorite food.

11313
08:16:22,270 --> 08:16:23,103
You could say something like this.

11314
08:16:23,103 --> 08:16:26,300
Well, I'm going to do this
later and again, late init

11315
08:16:26,300 --> 08:16:30,360
means, hey, Kotlin, don't
worry about this yet.

11316
08:16:30,360 --> 08:16:33,840
I'm going to go ahead and
populate the food variable.

11317
08:16:33,840 --> 08:16:34,770
I'm just not gonna do it yet,

11318
08:16:34,770 --> 08:16:37,583
I'm gonna do it somewhere
later down the line,

11319
08:16:37,583 --> 08:16:38,416
but don't worry I got this covered.

11320
08:16:38,416 --> 08:16:39,249
I'll handle it.

11321
08:16:39,249 --> 08:16:42,210
So that's what we're telling
Kotlin at this point in time.

11322
08:16:42,210 --> 08:16:45,900
However, Kotlin says, well, I can infer

11323
08:16:45,900 --> 08:16:48,140
the type of the variable
if you give it to me

11324
08:16:48,140 --> 08:16:50,700
during the initialization,
which is what we're doing here,

11325
08:16:50,700 --> 08:16:53,930
we're allowing the initialization
of the variable to occur

11326
08:16:53,930 --> 08:16:56,030
and therefore type
inference can take place.

11327
08:16:56,030 --> 08:16:58,430
So names like, okay,
that's gonna be a strain

11328
08:16:59,714 --> 08:17:00,970
'cause you're basically
setting it equal to a string.

11329
08:17:00,970 --> 08:17:03,250
In age is gonna be
equivalent to an integer

11330
08:17:03,250 --> 08:17:05,580
because well, you're
setting it equal to 33.

11331
08:17:05,580 --> 08:17:08,900
But late in it food, I don't
know that's gonna be yet

11332
08:17:08,900 --> 08:17:11,710
because somewhere further
down the line here

11333
08:17:11,710 --> 08:17:14,050
in our application, who
knows if it's inside

11334
08:17:15,312 --> 08:17:16,145
of an if statement,
inside of a catch block,

11335
08:17:16,145 --> 08:17:17,740
who knows where it's at.

11336
08:17:17,740 --> 08:17:19,510
But you're gonna set it
somewhere and I don't know

11337
08:17:19,510 --> 08:17:21,310
what it is yet, so you have to tell me.

11338
08:17:21,310 --> 08:17:25,240
So in this instance, I actually
have to define the type

11339
08:17:25,240 --> 08:17:26,570
for the compiler to be happy.

11340
08:17:26,570 --> 08:17:31,400
So I cannot infer a type with
a late initialized variable.

11341
08:17:31,400 --> 08:17:33,880
Well, this also works too if you have...

11342
08:17:33,880 --> 08:17:36,870
For example, let's say we wanna
use a name that's reversed.

11343
08:17:38,060 --> 08:17:40,990
And we have a method which we
have down here at the bottom.

11344
08:17:40,990 --> 08:17:44,300
And this method right here,
we'll just take in a string

11345
08:17:44,300 --> 08:17:45,133
and we reverse it.

11346
08:17:45,133 --> 08:17:46,850
Now, of course we could do that by hand,

11347
08:17:46,850 --> 08:17:49,760
but this is just to illustrate the concept

11348
08:17:49,760 --> 08:17:53,230
that you can have a function
that also return something.

11349
08:17:53,230 --> 08:17:55,500
And we'll take that,
we'll take in the name.

11350
08:17:55,500 --> 08:17:57,220
And what will happen as
Kotlin will then go ahead

11351
08:17:57,220 --> 08:18:00,390
and take a look at this function here

11352
08:18:00,390 --> 08:18:03,152
and say, all right, well,
you wanna use name reverse.

11353
08:18:03,152 --> 08:18:04,320
Okay, well I'm gonna go
look at this function name,

11354
08:18:04,320 --> 08:18:06,230
reversed and then I'm gonna see,

11355
08:18:06,230 --> 08:18:09,260
oh, a name reversed actually
turns a string, oh, okay.

11356
08:18:09,260 --> 08:18:11,872
So in that case, I'm just gonna go ahead

11357
08:18:11,872 --> 08:18:13,060
and make reversed a string.

11358
08:18:14,120 --> 08:18:18,050
So again, kind of as real
quick, just kind of Kotlin says,

11359
08:18:18,050 --> 08:18:19,290
I'm gonna go look at this function here.

11360
08:18:19,290 --> 08:18:21,390
I see it as a string and then, okay, cool.

11361
08:18:22,259 --> 08:18:23,130
It looks like I'm gonna go ahead and make

11362
08:18:23,130 --> 08:18:24,930
this reverse value a string.

11363
08:18:25,990 --> 08:18:27,610
So pretty simple.

11364
08:18:29,818 --> 08:18:31,700
And what is doing behind the
scenes, so you can do that.

11365
08:18:31,700 --> 08:18:33,840
Kotlin will also do some inferring too,

11366
08:18:33,840 --> 08:18:37,960
So, let's say we have two
prices, so price equals 10.

11367
08:18:37,960 --> 08:18:41,140
Now this is gonna be an
integer and I've priced two.

11368
08:18:41,140 --> 08:18:44,750
And whoops, so this might be price two

11369
08:18:44,750 --> 08:18:46,250
and this could be val as well.

11370
08:18:47,714 --> 08:18:48,547
So 20.01.

11371
08:18:50,124 --> 08:18:52,524
And then I say, all right,
print line price one.

11372
08:18:55,390 --> 08:18:56,840
I'd say print line price two.

11373
08:19:01,920 --> 08:19:03,710
If we look at what the
competitor is telling us here

11374
08:19:03,710 --> 08:19:06,110
is it, well, price is an integer

11375
08:19:07,090 --> 08:19:08,350
and price two is a double.

11376
08:19:09,891 --> 08:19:12,524
And then what happens if
we initialize another one?

11377
08:19:12,524 --> 08:19:14,293
And we say, this is a total number.

11378
08:19:14,293 --> 08:19:16,643
The total is gonna be
the price plus price two.

11379
08:19:17,565 --> 08:19:18,398
Now what's gonna happen here.

11380
08:19:18,398 --> 08:19:19,231
We're combining two different types.

11381
08:19:19,231 --> 08:19:21,450
Well, this is a double
and this is an integer.

11382
08:19:21,450 --> 08:19:23,740
Well, Kotlin is like, well,
what am I gonna do here?

11383
08:19:23,740 --> 08:19:26,290
Well, Kotlin is smart
enough to know the compiler

11384
08:19:27,337 --> 08:19:28,510
is well, you're getting
an integer and a double.

11385
08:19:28,510 --> 08:19:31,550
So most likely you want the
precision of this to be a double

11386
08:19:31,550 --> 08:19:33,930
because otherwise you
would lose some precision

11387
08:19:33,930 --> 08:19:35,510
if we just stuck with an integer,

11388
08:19:35,510 --> 08:19:38,338
meaning that we would
end up with, you know,

11389
08:19:38,338 --> 08:19:39,820
what would this be, it
would be 30 most likely.

11390
08:19:39,820 --> 08:19:42,310
So at this point in time,
total is gonna end up

11391
08:19:42,310 --> 08:19:46,070
being a double, which we can
see here from the IDE help.

11392
08:19:46,070 --> 08:19:48,810
So Kotlin is then doing type inference

11393
08:19:48,810 --> 08:19:53,450
based upon a calculation
of an integer and a double.

11394
08:19:53,450 --> 08:19:56,308
Now in other languages,
you might have to do

11395
08:19:56,308 --> 08:19:57,141
particular types of casting to make sure

11396
08:19:57,141 --> 08:19:58,690
that you don't lose any precision,

11397
08:19:58,690 --> 08:20:00,210
because if you didn't do the casting,

11398
08:20:00,210 --> 08:20:01,650
you might have precision problems,

11399
08:20:01,650 --> 08:20:04,010
meaning you're losing decimals, et cetera.

11400
08:20:04,010 --> 08:20:05,290
But Kotlin is smart enough to figure

11401
08:20:05,290 --> 08:20:07,090
some of these things out here.

11402
08:20:07,090 --> 08:20:11,230
So this is basically an essence,
what type of inference is.

11403
08:20:11,230 --> 08:20:14,220
And so you can get inference
when you are initializing

11404
08:20:14,220 --> 08:20:17,810
variables and then different
types of returned, et cetera,

11405
08:20:17,810 --> 08:20:22,270
are going to be inferred, such
as the function name is here.

11406
08:20:22,270 --> 08:20:25,170
And Kotlin will both go
basically look throughout

11407
08:20:25,170 --> 08:20:26,820
the execution path as a code set,

11408
08:20:27,836 --> 08:20:28,669
all right, what is being returned here?

11409
08:20:28,669 --> 08:20:32,440
Okay, it's being set into
this other value up here.

11410
08:20:32,440 --> 08:20:33,370
Okay, that sounds good.

11411
08:20:33,370 --> 08:20:35,930
So it looks like reversed is that point

11412
08:20:35,930 --> 08:20:38,460
is now going to be a
string and we can go ahead

11413
08:20:38,460 --> 08:20:40,120
and infer that for you.

11414
08:20:40,120 --> 08:20:42,200
For some reason, though,
if we are using again,

11415
08:20:42,200 --> 08:20:44,830
a late init and we're gonna
go ahead and use a var

11416
08:20:45,897 --> 08:20:46,730
and have our favorite food,

11417
08:20:48,030 --> 08:20:51,740
we will have to actually declare
the type when we declare it

11418
08:20:51,740 --> 08:20:53,270
because Kotlin is not
smart enough to know,

11419
08:20:53,270 --> 08:20:55,170
hey, I don't know what this is gonna be.

11420
08:20:55,170 --> 08:20:56,870
And because it's a
strongly typed language,

11421
08:20:56,870 --> 08:20:59,620
we can't just kind of let this
type just kind of be floating

11422
08:20:59,620 --> 08:21:02,090
around and nowhere and
we don't know what it is.

11423
08:21:02,090 --> 08:21:04,450
So you do have to declare the type here,

11424
08:21:04,450 --> 08:21:06,310
if it's gonna be late initialized.

11425
08:21:06,310 --> 08:21:09,410
And that's how type
inference works in Kotlin.

11426
08:21:09,410 --> 08:21:12,120
Okay, let's talk about lambda functions.

11427
08:21:12,120 --> 08:21:15,900
Now, lambda in Kotlin is
defined as the following.

11428
08:21:15,900 --> 08:21:18,010
And these can look very
confusing the first few times

11429
08:21:18,010 --> 08:21:19,520
you see them.

11430
08:21:19,520 --> 08:21:21,150
So if we're gonna build
our own lambda function

11431
08:21:21,150 --> 08:21:22,340
so you can understand what they are.

11432
08:21:22,340 --> 08:21:24,750
And basically functions
are functions that are,

11433
08:21:24,750 --> 08:21:26,760
I'm not gonna get really
mathematical about you

11434
08:21:26,760 --> 08:21:28,910
and high order functions
and everything like that,

11435
08:21:28,910 --> 08:21:31,710
though I really advise you
to go read the documentation.

11436
08:21:33,217 --> 08:21:34,190
Lambda functions are
basically little functions

11437
08:21:34,190 --> 08:21:37,290
that you can create and
start parsing around

11438
08:21:37,290 --> 08:21:38,270
inside of your application

11439
08:21:38,270 --> 08:21:41,417
and allows you to be very
functional in nature.

11440
08:21:41,417 --> 08:21:44,350
So enough of that let's
get into implementation.

11441
08:21:44,350 --> 08:21:48,380
So a lambda is defined as
having a name of a lambda,

11442
08:21:48,380 --> 08:21:50,080
and then you have its input types,

11443
08:21:50,917 --> 08:21:52,390
which are gonna be the
parameters that are parsed in,

11444
08:21:52,390 --> 08:21:54,880
and then it's gonna have a return value.

11445
08:21:54,880 --> 08:21:57,360
And then inside of that,
you're gonna actually have

11446
08:21:57,360 --> 08:21:59,720
some arguments that you get
to provide the names for,

11447
08:21:59,720 --> 08:22:01,330
and you have to provide their types again,

11448
08:22:01,330 --> 08:22:03,170
that's gonna be the input type over here,

11449
08:22:03,170 --> 08:22:04,730
so we can go and change
this to input types

11450
08:22:04,730 --> 08:22:07,200
so it makes more sense and put type.

11451
08:22:07,200 --> 08:22:09,600
And then you're gonna have
the body of your actual

11452
08:22:09,600 --> 08:22:12,030
Lambda function which does its work.

11453
08:22:12,030 --> 08:22:14,050
Now, a lot of type inference
will happen with this,

11454
08:22:14,050 --> 08:22:15,520
which we can get into in a second,

11455
08:22:15,520 --> 08:22:17,600
but let's go and create a first one.

11456
08:22:17,600 --> 08:22:19,350
And the first one we're
gonna call is the end result

11457
08:22:19,350 --> 08:22:22,280
is what we wanna be able
to do is say greeter.

11458
08:22:22,280 --> 08:22:24,500
We wanna be able to do this,

11459
08:22:24,500 --> 08:22:26,170
and I wanna be able to parse in my name.

11460
08:22:26,170 --> 08:22:30,890
And what I want to happen
is I want hello Don

11461
08:22:30,890 --> 08:22:32,560
to come out somehow.

11462
08:22:32,560 --> 08:22:34,300
So how are we gonna do that?

11463
08:22:34,300 --> 08:22:37,040
So this is a very rudimentary example

11464
08:22:37,040 --> 08:22:38,990
of what you could normally
write a regular function for,

11465
08:22:38,990 --> 08:22:42,450
but this illustrates the lambda functions.

11466
08:22:42,450 --> 08:22:44,440
And so what we would say is it's a val,

11467
08:22:44,440 --> 08:22:47,750
it's a greeter and we do colon
and then we need to provide

11468
08:22:47,750 --> 08:22:49,120
the input types.

11469
08:22:49,120 --> 08:22:51,504
So remember, let's look
at our example again,

11470
08:22:51,504 --> 08:22:55,130
we have greeter and inside
of the greeter function,

11471
08:22:56,211 --> 08:22:57,660
we wanna be able to parse in the word Don.

11472
08:22:58,730 --> 08:22:59,563
And so here, what we need to do is say,

11473
08:22:59,563 --> 08:23:01,510
hey, we need to parse in an input type.

11474
08:23:01,510 --> 08:23:03,400
That input type is gonna be a string.

11475
08:23:04,370 --> 08:23:07,490
And then what do we expect the
return type of greeter to be,

11476
08:23:07,490 --> 08:23:09,690
remember what we wanted
it to be Donn Felker

11477
08:23:10,616 --> 08:23:11,449
is what we want it to come out of it.

11478
08:23:11,449 --> 08:23:13,590
So we expect a return type to be a string.

11479
08:23:14,700 --> 08:23:17,460
Now we need to start defining
what our lambda expression

11480
08:23:17,460 --> 08:23:19,650
looks like, a lambda function.

11481
08:23:19,650 --> 08:23:22,180
And so in here, we actually
are gonna have the parameters.

11482
08:23:22,180 --> 08:23:24,880
So our first parameter here,
which is parsing is Donn.

11483
08:23:25,938 --> 08:23:26,771
That's a string.

11484
08:23:26,771 --> 08:23:28,456
Let's go ahead and give it a
name so we can work with it.

11485
08:23:28,456 --> 08:23:29,300
So let's just call it name.

11486
08:23:29,300 --> 08:23:30,750
And of course we know
it's gonna be a string.

11487
08:23:30,750 --> 08:23:32,690
So again, we have to
provide it right here.

11488
08:23:32,690 --> 08:23:36,150
That's the one of the arguments
and provide its input type.

11489
08:23:36,150 --> 08:23:38,170
And now we actually provide the code body.

11490
08:23:38,170 --> 08:23:40,890
And so now this is the actual body of code

11491
08:23:40,890 --> 08:23:41,960
in which we can do some stuff.

11492
08:23:41,960 --> 08:23:44,040
So here, what we can say is, hello

11493
08:23:44,966 --> 08:23:47,910
and then we can use string
interpolation and we'll say name.

11494
08:23:47,910 --> 08:23:51,940
And what ends up happening
is the last value

11495
08:23:51,940 --> 08:23:54,030
that's inside of this lambda expression

11496
08:23:54,030 --> 08:23:56,430
of this block of code is the return type.

11497
08:23:56,430 --> 08:23:58,730
So whatever this type is, is
going to be the return type.

11498
08:23:58,730 --> 08:24:00,570
So if this was multiple lines,

11499
08:24:00,570 --> 08:24:03,170
which it could be what we can
put these on different lines

11500
08:24:03,170 --> 08:24:05,100
and we can have multiple lines,

11501
08:24:05,100 --> 08:24:06,720
whatever is the last one here I could say,

11502
08:24:06,720 --> 08:24:10,200
val foo equals zero, it
doesn't really do anything.

11503
08:24:10,200 --> 08:24:13,010
And then we get this nice
little lambda notation here.

11504
08:24:13,010 --> 08:24:16,320
It says, hey, this is the
return value of our lambda.

11505
08:24:16,320 --> 08:24:18,260
So whatever this type is
gonna be the return value.

11506
08:24:18,260 --> 08:24:19,290
So it's a string.

11507
08:24:19,290 --> 08:24:21,930
So if I said, hey, I want
the length of the string,

11508
08:24:21,930 --> 08:24:24,500
we're gonna get a compiler
error because it's gonna say

11509
08:24:24,500 --> 08:24:26,260
we are requiring a string.

11510
08:24:26,260 --> 08:24:28,540
Again, this is the return
type of the lambda,

11511
08:24:28,540 --> 08:24:30,260
but you're actually giving us an integer

11512
08:24:30,260 --> 08:24:32,160
because this is the last line on here.

11513
08:24:33,029 --> 08:24:35,787
We're not seeing return
anywhere, but by default,

11514
08:24:35,787 --> 08:24:37,670
the last value is the value returned.

11515
08:24:37,670 --> 08:24:40,160
So since we can single line
this, we'll do that now,

11516
08:24:40,160 --> 08:24:41,530
it's pretty easy.

11517
08:24:41,530 --> 08:24:43,430
And we'll get everything back on one line.

11518
08:24:43,430 --> 08:24:44,850
And then what we can do is we can go ahead

11519
08:24:44,850 --> 08:24:48,260
and execute greeter and we'll
go ahead and parse name Donn.

11520
08:24:48,260 --> 08:24:50,280
And so it looks like a regular function.

11521
08:24:50,280 --> 08:24:53,140
And we can see here when we did that,

11522
08:24:53,140 --> 08:24:55,280
we created the new greeter here.

11523
08:24:56,320 --> 08:25:01,220
We could see that it's
going to take in a string.

11524
08:25:01,220 --> 08:25:02,680
Let's go ahead and run it.

11525
08:25:02,680 --> 08:25:04,960
And then what we're gonna
see is that nothing happens

11526
08:25:04,960 --> 08:25:06,080
down here in the output window.

11527
08:25:06,080 --> 08:25:09,530
We're expecting something to
show up here, but nothing did.

11528
08:25:09,530 --> 08:25:12,720
And the reason why is
because greeter is a function

11529
08:25:12,720 --> 08:25:14,400
that takes a string and return to string,

11530
08:25:14,400 --> 08:25:15,430
it doesn't do anything with it.

11531
08:25:15,430 --> 08:25:17,180
So we actually have to
actually do something with it.

11532
08:25:17,180 --> 08:25:19,610
So let's go and print that return value,

11533
08:25:19,610 --> 08:25:23,330
which we could just do this
too just so you're aware.

11534
08:25:23,330 --> 08:25:28,330
We could actually say greeting
equals greeter like that.

11535
08:25:29,409 --> 08:25:31,020
And then we could say print line greeting.

11536
08:25:32,545 --> 08:25:33,500
And then when we run this,

11537
08:25:33,500 --> 08:25:35,180
what we're gonna see is the output finally

11538
08:25:35,180 --> 08:25:37,130
at that function since say, hello Donn.

11539
08:25:38,357 --> 08:25:39,701
So again, to kind of cover this here,

11540
08:25:39,701 --> 08:25:42,820
we have the name of the lambda,
which is coming right here.

11541
08:25:42,820 --> 08:25:45,970
The name of the lambda, we'll
do a little simple line here.

11542
08:25:45,970 --> 08:25:49,540
So it's the name of the lambda
then we have the input type.

11543
08:25:49,540 --> 08:25:52,380
Then we have the return
type and then we're having

11544
08:25:52,380 --> 08:25:54,830
the arguments and their
corresponding input,

11545
08:25:54,830 --> 08:25:56,930
the corresponding type was a string.

11546
08:25:56,930 --> 08:26:00,810
And then this little section
over here is the code body,

11547
08:26:00,810 --> 08:26:03,690
which comes right here,
that's the code body.

11548
08:26:04,580 --> 08:26:07,040
So that's how all that's
mapping right here.

11549
08:26:07,040 --> 08:26:09,040
So now let's take this a
little bit further though.

11550
08:26:09,040 --> 08:26:13,980
Let's say for some reason
we wanted to be able to say,

11551
08:26:13,980 --> 08:26:15,350
like we said, we have Donn Felker here,

11552
08:26:15,350 --> 08:26:16,650
but instead of saying, hello, Donn.

11553
08:26:16,650 --> 08:26:18,500
So we got that wrong.

11554
08:26:18,500 --> 08:26:20,390
So there was a bug in our code.

11555
08:26:20,390 --> 08:26:22,030
How are we gonna fix this?.

11556
08:26:22,030 --> 08:26:24,280
This actually should
say, hello, Donn Felker.

11557
08:26:25,860 --> 08:26:26,900
Okay, well, that's easy enough.

11558
08:26:26,900 --> 08:26:29,842
We could just say hello, you know,

11559
08:26:29,842 --> 08:26:30,680
we just put Donn Felker in
there and that would work.

11560
08:26:30,680 --> 08:26:33,140
But what if we wanted to bill
accept two different names

11561
08:26:33,140 --> 08:26:37,070
because in our database,
everything is separated out.

11562
08:26:37,070 --> 08:26:39,864
So we need to have this
greeter and it's built

11563
08:26:39,864 --> 08:26:41,650
to two values.

11564
08:26:41,650 --> 08:26:44,010
So again, we need to come
into our expression and say,

11565
08:26:44,010 --> 08:26:46,860
all right, it's gonna take
an input type of string

11566
08:26:46,860 --> 08:26:48,360
and another input type of string.

11567
08:26:48,360 --> 08:26:49,450
So it's gonna have two.

11568
08:26:49,450 --> 08:26:51,900
Think of this, like the when
you write a regular function

11569
08:26:51,900 --> 08:26:54,360
like this or a function, my function.

11570
08:26:55,310 --> 08:26:57,770
And then inside of this
function, you have some stuff

11571
08:26:57,770 --> 08:27:01,650
and it's gonna be name,
string foo whatever it is,

11572
08:27:01,650 --> 08:27:04,140
last name, string.

11573
08:27:04,140 --> 08:27:07,160
Well, notice how this, the
way I like to think about it

11574
08:27:07,160 --> 08:27:08,760
is these parentheses right here.

11575
08:27:10,735 --> 08:27:12,230
it almost like maps
directly to that print.

11576
08:27:12,230 --> 08:27:13,500
So you kind of map there that prints,

11577
08:27:13,500 --> 08:27:14,560
they maps there and basically says,

11578
08:27:14,560 --> 08:27:18,460
hey, look, there's a string
here and there's a string here.

11579
08:27:18,460 --> 08:27:21,170
And that's how I of visualize
what these parentheses

11580
08:27:21,170 --> 08:27:22,180
up here are.

11581
08:27:22,180 --> 08:27:25,005
So this is gonna take
in some type of string

11582
08:27:25,005 --> 08:27:25,838
is one parameter.

11583
08:27:25,838 --> 08:27:28,361
The next type of in that next
parameter is gonna be string.

11584
08:27:28,361 --> 08:27:32,520
And the whole lambda expression
is still just gonna return

11585
08:27:32,520 --> 08:27:34,026
a string.

11586
08:27:34,026 --> 08:27:35,621
Now we get a problem over here.

11587
08:27:35,621 --> 08:27:36,490
It says, hey, we're
expecting two parameters

11588
08:27:36,490 --> 08:27:37,430
of type string and string.

11589
08:27:37,430 --> 08:27:40,710
Remember we were taking
a two now, but over here,

11590
08:27:41,971 --> 08:27:42,804
this is the list of arguments.

11591
08:27:42,804 --> 08:27:45,234
Remember, this is where the
list of arguments map in.

11592
08:27:45,234 --> 08:27:46,067
And if there's more than one,

11593
08:27:46,067 --> 08:27:47,120
then we need to put a comma here,

11594
08:27:47,120 --> 08:27:50,950
just like we would traditionally
in a regular function.

11595
08:27:50,950 --> 08:27:52,560
So I'm gonna rename this as first name,

11596
08:27:52,560 --> 08:27:54,881
'cause I can name the same thing I want.

11597
08:27:54,881 --> 08:27:57,360
And then I'm gonna say a last name string.

11598
08:27:57,360 --> 08:28:00,594
And now I'm starting to run
out of a little bit room here

11599
08:28:00,594 --> 08:28:01,640
so I could shrink this down a little bit.

11600
08:28:02,980 --> 08:28:05,090
But what I have over here,
I need to change this

11601
08:28:05,090 --> 08:28:09,370
to first name and then last name.

11602
08:28:10,832 --> 08:28:11,665
And I'll do string interpolation again.

11603
08:28:13,150 --> 08:28:16,680
And now we have a lambda
expression that's gonna take

11604
08:28:16,680 --> 08:28:17,992
in to values.

11605
08:28:17,992 --> 08:28:19,648
So you see right here, it
says, hey, we're waiting

11606
08:28:19,648 --> 08:28:23,110
for the second value P two,
which can be a second parameter.

11607
08:28:23,110 --> 08:28:25,540
So I'll take a Donn Felker, there we go.

11608
08:28:27,659 --> 08:28:28,765
And I'm gonna go ahead and run this again

11609
08:28:28,765 --> 08:28:29,598
and what we're gonna
and what we're gonna see

11610
08:28:29,598 --> 08:28:30,880
on the greeting now is
it Donn Felker's returned

11611
08:28:30,880 --> 08:28:32,970
because we're parsing in a string here,

11612
08:28:32,970 --> 08:28:34,590
Donn and on our string for Felker.

11613
08:28:34,590 --> 08:28:37,080
These basically, if you take
a look at how this maps,

11614
08:28:37,080 --> 08:28:39,260
this one is mapping to this one,

11615
08:28:39,260 --> 08:28:41,560
and this one is mapping to this one.

11616
08:28:41,560 --> 08:28:43,240
That's how they're mapping right there.

11617
08:28:44,444 --> 08:28:46,866
And we can see that the
first strings we're calling

11618
08:28:46,866 --> 08:28:47,699
that one first name, the second string,

11619
08:28:47,699 --> 08:28:48,830
we're calling that last name.

11620
08:28:48,830 --> 08:28:51,050
And then at that point
was since we're inside

11621
08:28:51,050 --> 08:28:53,540
of this lambda expression, we
have access to those variables

11622
08:28:53,540 --> 08:28:55,680
and we do whatever we want with them.

11623
08:28:55,680 --> 08:28:57,920
Now, if for whatever reason
we wanted to get kind of do

11624
08:28:57,920 --> 08:29:01,510
some hokey pokiness stuff,
some hokey stuff in here,

11625
08:29:01,510 --> 08:29:03,450
we could, we could actually
do some different things.

11626
08:29:03,450 --> 08:29:08,450
So let's go a val modified first F name.

11627
08:29:09,350 --> 08:29:11,677
Actually first name is spelled out.

11628
08:29:11,677 --> 08:29:14,710
And what we could just say
his first name.two upper case

11629
08:29:14,710 --> 08:29:16,445
for whatever reason.

11630
08:29:16,445 --> 08:29:20,690
And I'm gonna say val modified last name.

11631
08:29:20,690 --> 08:29:24,150
We can say, last name,
not owner exception.

11632
08:29:26,190 --> 08:29:31,190
Last name, last name that two
lowercase for whatever reason.

11633
08:29:32,240 --> 08:29:33,820
And then we can go ahead and replace this

11634
08:29:33,820 --> 08:29:37,580
with the two modified
ones, modified first name,

11635
08:29:37,580 --> 08:29:38,850
modified last name.

11636
08:29:42,037 --> 08:29:44,289
And now if we run this,
now, what we're gonna see

11637
08:29:44,289 --> 08:29:46,750
is that we have a lambda
expression with multiple lines.

11638
08:29:46,750 --> 08:29:47,870
Hello, Donn Felker.

11639
08:29:47,870 --> 08:29:50,670
So we've capitalized and
done different things here.

11640
08:29:50,670 --> 08:29:51,503
Okay, that's cool.

11641
08:29:51,503 --> 08:29:53,640
So we see that the,
again, the last line here

11642
08:29:53,640 --> 08:29:56,300
is the one that's returning the type here

11643
08:29:56,300 --> 08:29:58,650
and that's the type that's
going to be basically

11644
08:29:58,650 --> 08:30:00,660
this lambda is saying, all right, look,

11645
08:30:00,660 --> 08:30:03,330
we have a return type of
string and that's mapping

11646
08:30:03,330 --> 08:30:04,490
to right here.

11647
08:30:04,490 --> 08:30:08,650
So string, which is right
here is mapping to this

11648
08:30:08,650 --> 08:30:10,430
and the last line of
the lambda expression,

11649
08:30:10,430 --> 08:30:13,340
whatever its type is, it
needs to match this up here.

11650
08:30:13,340 --> 08:30:14,840
So it's go and get rid of that.

11651
08:30:16,020 --> 08:30:19,980
So let's just say for whatever
reason we wanted to say

11652
08:30:19,980 --> 08:30:22,810
greeter needs to return an integer value

11653
08:30:22,810 --> 08:30:26,257
and it could be the number of characters

11654
08:30:26,257 --> 08:30:27,195
inside of this greeting.

11655
08:30:27,195 --> 08:30:28,100
I don't know, for whatever reason.

11656
08:30:28,100 --> 08:30:29,980
We've changed this
integer, which means now

11657
08:30:29,980 --> 08:30:34,470
that this lambda expression
needs to return an integer,

11658
08:30:34,470 --> 08:30:36,840
but down here, the last line
is what's going to be returned

11659
08:30:36,840 --> 08:30:39,300
in rest last line is returning a string.

11660
08:30:39,300 --> 08:30:40,340
So this is not gonna work.

11661
08:30:40,340 --> 08:30:43,120
So what we can do is we
can just go over here

11662
08:30:43,120 --> 08:30:46,520
and may just return the
length of this name.

11663
08:30:46,520 --> 08:30:48,560
If we run this, now
what's gonna be returned.

11664
08:30:48,560 --> 08:30:50,790
It's still gonna take
in a first and last name

11665
08:30:50,790 --> 08:30:54,080
and it's gonna concatenate hello on there,

11666
08:30:54,080 --> 08:30:55,020
but then we're gonna grab the link

11667
08:30:55,020 --> 08:30:56,070
and we're gonna print the link.

11668
08:30:56,070 --> 08:30:58,940
That's what greeter's gonna
do at this point in time.

11669
08:30:58,940 --> 08:30:59,810
Okay, that sounds cool,

11670
08:30:59,810 --> 08:31:01,090
but maybe that's not what we really want.

11671
08:31:01,090 --> 08:31:02,740
So let's take this back to string.

11672
08:31:04,460 --> 08:31:07,610
Now let's assume that we
really like what it does,

11673
08:31:07,610 --> 08:31:10,524
but we just want greeter
to actually just to display

11674
08:31:10,524 --> 08:31:12,590
the greeting, so we don't
wanna have to do this.

11675
08:31:12,590 --> 08:31:13,670
We don't wanna have to print this.

11676
08:31:13,670 --> 08:31:15,710
We just want, as soon as the call greeter

11677
08:31:15,710 --> 08:31:19,130
to automatically just print
line hello, Donn Felker.

11678
08:31:19,130 --> 08:31:19,963
So how can we do that?

11679
08:31:19,963 --> 08:31:23,530
Well, this return value is what
the is going to be returned

11680
08:31:23,530 --> 08:31:24,900
from the lambda expression.

11681
08:31:24,900 --> 08:31:27,000
So we can change it to unit.

11682
08:31:27,000 --> 08:31:29,820
Unit is basically like
void in Java, which means,

11683
08:31:29,820 --> 08:31:31,340
hey, we're not gonna return anything,

11684
08:31:31,340 --> 08:31:33,310
we're just gonna do something,

11685
08:31:33,310 --> 08:31:34,750
but we're not gonna return any value.

11686
08:31:34,750 --> 08:31:37,250
So here we're just gonna
go ahead and return unit,

11687
08:31:38,400 --> 08:31:39,233
which has nothing.

11688
08:31:39,233 --> 08:31:41,340
And then what we can do here
is we can say print line,

11689
08:31:42,530 --> 08:31:46,510
inside of here and we can just do that.

11690
08:31:46,510 --> 08:31:49,080
And then what's gonna
happen now when we run this,

11691
08:31:49,080 --> 08:31:51,800
what we're gonna see is we're
gonna call the first name,

11692
08:31:51,800 --> 08:31:53,920
the last name that'd be parsed in

11693
08:31:53,920 --> 08:31:54,840
and then we're just gonna print line.

11694
08:31:54,840 --> 08:31:57,340
There it goes, hello, Donn Felker.

11695
08:31:57,340 --> 08:31:58,780
So we can do all different kinds of stuff.

11696
08:31:58,780 --> 08:31:59,830
And there's gonna be multiple lines,

11697
08:31:59,830 --> 08:32:01,300
could be hundreds of lines of, you know.

11698
08:32:01,300 --> 08:32:03,650
Of course I don't recommend
that if you wanna make

11699
08:32:03,650 --> 08:32:05,400
your code easily read and so forth.

11700
08:32:06,470 --> 08:32:08,730
Because Kotlin has type inference,

11701
08:32:08,730 --> 08:32:10,370
you can actually clean
this up quite a bit.

11702
08:32:10,370 --> 08:32:12,310
We don't need a lot of this stuff in here.

11703
08:32:13,247 --> 08:32:15,650
So what we can tell Kotlin is
because Kotlin can look inside

11704
08:32:15,650 --> 08:32:17,543
of this lambda expression and say,

11705
08:32:17,543 --> 08:32:18,380
well, we know we have one parameter,

11706
08:32:18,380 --> 08:32:20,080
we know we have another parameter.

11707
08:32:21,196 --> 08:32:22,029
Okay, so this first parameter is a string.

11708
08:32:22,029 --> 08:32:23,620
We know the second parameter is a string.

11709
08:32:23,620 --> 08:32:26,670
Okay, we can do that, Kotlin's
figuring that out for us.

11710
08:32:26,670 --> 08:32:28,500
And then is looking at
this last line down here

11711
08:32:28,500 --> 08:32:31,150
and Kotlin saying, well,
this lambda expression

11712
08:32:31,150 --> 08:32:32,430
is not returning anything.

11713
08:32:32,430 --> 08:32:36,080
So it's actually gonna
be unit so it can infer

11714
08:32:36,080 --> 08:32:39,929
the return type and it can
infer the parameter list.

11715
08:32:39,929 --> 08:32:41,590
So we can actually do
due to type inferences,

11716
08:32:41,590 --> 08:32:44,730
just go ahead and get rid of that.

11717
08:32:44,730 --> 08:32:49,730
So now we have a very succinct
or much more sustained

11718
08:32:51,220 --> 08:32:52,053
lambda expression.

11719
08:32:52,053 --> 08:32:55,050
So if we wanna do the simple
one, so we wanna do it

11720
08:32:55,050 --> 08:32:57,010
just as simple one,
greet, we could've done

11721
08:32:57,010 --> 08:32:58,010
something like this.

11722
08:32:58,983 --> 08:33:03,710
We could have said name,
string and then it gets to this

11723
08:33:03,710 --> 08:33:07,650
print line, hello name.

11724
08:33:08,900 --> 08:33:11,260
And there, we have our
very simple little greet.

11725
08:33:11,260 --> 08:33:12,800
So of course we have our greeter that does

11726
08:33:12,800 --> 08:33:16,290
a bunch of different stuff,
modify some variables,

11727
08:33:16,290 --> 08:33:18,300
which we'll move up
here just so is obvious.

11728
08:33:18,300 --> 08:33:21,250
And then we have the very simple
version right here, greet.

11729
08:33:24,080 --> 08:33:27,910
If we print these, of course,
we got the spelling wrong.

11730
08:33:27,910 --> 08:33:29,630
And if we print these,
what we're gonna see here

11731
08:33:29,630 --> 08:33:33,830
is we have both of these
printing out values.

11732
08:33:33,830 --> 08:33:37,130
Now lambda expressions are
not limited to one or two

11733
08:33:37,130 --> 08:33:39,170
or three different types.

11734
08:33:40,065 --> 08:33:40,898
You can parse in many different types

11735
08:33:40,898 --> 08:33:42,130
into your lambda expressions.

11736
08:33:43,110 --> 08:33:44,510
If for some reason, when you're writing

11737
08:33:44,510 --> 08:33:46,900
your lambda expressions,
and for some reason Kotlin

11738
08:33:46,900 --> 08:33:49,610
cannot do perform type inference,

11739
08:33:49,610 --> 08:33:52,360
you will have to provide these hints.

11740
08:33:52,360 --> 08:33:54,210
And sometimes you'll run
into weird situations

11741
08:33:54,210 --> 08:33:56,910
where based upon something
that you're doing,

11742
08:33:56,910 --> 08:33:59,850
you're going to have to tell
Kotlin, hey, by the way,

11743
08:33:59,850 --> 08:34:02,923
here's how we're gonna go
ahead and do all this stuff.

11744
08:34:02,923 --> 08:34:05,217
It's gonna be unit or
whatever and so forth.

11745
08:34:07,730 --> 08:34:09,460
So you'll have to provide all information.

11746
08:34:09,460 --> 08:34:11,490
And this is the blueprint up here.

11747
08:34:11,490 --> 08:34:13,310
This is the blueprint that
you just need to remember,

11748
08:34:13,310 --> 08:34:15,610
that you're gonna have lambda name,

11749
08:34:15,610 --> 08:34:16,640
then you're provided input type,

11750
08:34:16,640 --> 08:34:20,606
the return type equals
whatever this lambda is.

11751
08:34:20,606 --> 08:34:21,439
And it's gonna have your arguments,

11752
08:34:21,439 --> 08:34:23,090
which is gonna have one to many of them.

11753
08:34:23,090 --> 08:34:24,840
You have the body of it, et cetera.

11754
08:34:26,400 --> 08:34:29,497
And that's understanding
lambda expressions.

11755
08:34:29,497 --> 08:34:31,630
Using lambda expressions in your code

11756
08:34:31,630 --> 08:34:35,011
can be very beneficial,
especially if you decide

11757
08:34:35,011 --> 08:34:38,000
to take lambda expressions
as a function parameter.

11758
08:34:38,000 --> 08:34:40,150
So it's assumed that you have a function

11759
08:34:40,150 --> 08:34:42,350
and you want to make something repeat,

11760
08:34:43,510 --> 08:34:45,210
actually it's call it line logger.

11761
08:34:46,336 --> 08:34:48,600
And you want something
to kind of log various

11762
08:34:48,600 --> 08:34:50,550
different lines over and over and over.

11763
08:34:51,460 --> 08:34:55,030
And so what you could do is
you could take a message.

11764
08:34:56,010 --> 08:34:57,710
There is a string.

11765
08:34:57,710 --> 08:34:59,480
And then perhaps if you wanted some logs

11766
08:34:59,480 --> 08:35:02,950
to very basically kind of look like this,

11767
08:35:02,950 --> 08:35:07,540
you want a bunch of these kind
of lines separating your logs

11768
08:35:07,540 --> 08:35:10,473
just for maybe 'cause you
have really chatty logs,

11769
08:35:10,473 --> 08:35:11,306
you could do something like this.

11770
08:35:11,306 --> 08:35:15,560
You could say repeat five
times and then you parse it

11771
08:35:15,560 --> 08:35:18,010
on little lambda expression.

11772
08:35:18,010 --> 08:35:20,090
It's a print line and then let's go ahead

11773
08:35:21,002 --> 08:35:24,530
and put in one, two, three,
four, four, five, six,

11774
08:35:24,530 --> 08:35:26,056
seven, eight of these lines.

11775
08:35:26,056 --> 08:35:28,210
And let's do that twice
and then what we'll do

11776
08:35:28,210 --> 08:35:31,360
is do print line our message.

11777
08:35:31,360 --> 08:35:32,710
Now this works pretty well.

11778
08:35:33,710 --> 08:35:36,760
So anytime we wanna use
this, we can say line logger

11779
08:35:36,760 --> 08:35:38,940
and to say hello there.

11780
08:35:39,867 --> 08:35:41,040
And then if we run this
down in our output window,

11781
08:35:41,040 --> 08:35:43,620
what we're gonna see down
here is we're gonna see

11782
08:35:43,620 --> 08:35:45,500
that hello there is printed out.

11783
08:35:46,698 --> 08:35:49,400
Maybe this is useful to kind
of help break up your logs

11784
08:35:49,400 --> 08:35:50,390
for a visual aspect or whatever.

11785
08:35:51,390 --> 08:35:54,090
But sometimes that can
be not what we wanna do

11786
08:35:54,090 --> 08:35:56,980
and there's a way we can
actually make this much more

11787
08:35:56,980 --> 08:36:01,460
in tune with being able to
do anything we really want

11788
08:36:01,460 --> 08:36:02,922
inside of here.

11789
08:36:02,922 --> 08:36:05,197
What if we wanna provide not one message,

11790
08:36:05,197 --> 08:36:06,030
but we wanna provide two messages.

11791
08:36:06,030 --> 08:36:09,650
So let's go message two, two string.

11792
08:36:10,490 --> 08:36:11,323
Now we're gonna come in here.

11793
08:36:11,323 --> 08:36:14,490
we're gonna say print line message two.

11794
08:36:16,380 --> 08:36:19,050
We are in this again, we get
our message one, message two.

11795
08:36:19,990 --> 08:36:21,860
It looks like we're missing
message two up here.

11796
08:36:21,860 --> 08:36:25,270
Of course, we forgot to add
that to the parameter list.

11797
08:36:25,270 --> 08:36:27,880
Hello again and when
we run this this time,

11798
08:36:27,880 --> 08:36:28,810
we're gonna see hello again.

11799
08:36:28,810 --> 08:36:31,370
Now the problem is as
we continue to grow this

11800
08:36:31,370 --> 08:36:34,850
and our requirements increase,
what we're gonna run into

11801
08:36:34,850 --> 08:36:37,540
is a situation where we're
just becoming overloaded here.

11802
08:36:37,540 --> 08:36:40,440
And what we really wanna
do is be able to have a way

11803
08:36:41,511 --> 08:36:44,030
for us to print this kind
of this block at the top

11804
08:36:44,030 --> 08:36:45,260
and the block in the bottom,

11805
08:36:45,260 --> 08:36:47,220
and then whatever we want
right here in the middle.

11806
08:36:47,220 --> 08:36:50,280
And so yeah, we could
build our own strengths.

11807
08:36:50,280 --> 08:36:51,300
We'll just leave it at one string.

11808
08:36:51,300 --> 08:36:54,670
We could build our own string
up here and I could do this.

11809
08:36:54,670 --> 08:36:57,330
I can kind of maybe kind of
do this like a little weird.

11810
08:36:58,280 --> 08:37:00,520
I could do this thing up here
where I do like a new line

11811
08:37:00,520 --> 08:37:02,300
thing and I kind of got there,

11812
08:37:02,300 --> 08:37:03,800
but then it starts getting really hacky

11813
08:37:03,800 --> 08:37:06,190
as soon as I wanna get anything
else kinda done in there.

11814
08:37:06,190 --> 08:37:08,400
But there's a way we can solve
this with lambda expressions.

11815
08:37:08,400 --> 08:37:10,660
And so what we can do
is what we're gonna do

11816
08:37:10,660 --> 08:37:12,470
is I'm gonna call this block.

11817
08:37:12,470 --> 08:37:14,930
And this is again, this is
the name of the variable,

11818
08:37:14,930 --> 08:37:15,763
it's called block.

11819
08:37:15,763 --> 08:37:17,030
And then what type of it's gonna be,

11820
08:37:17,030 --> 08:37:18,570
it's gonna be a lambda expression.

11821
08:37:18,570 --> 08:37:20,530
It's not gonna have any parameters

11822
08:37:20,530 --> 08:37:22,930
and it's just gonna go return a unit.

11823
08:37:22,930 --> 08:37:24,240
So again, remember, let's go ahead

11824
08:37:24,240 --> 08:37:26,620
and take a brief review here.

11825
08:37:26,620 --> 08:37:30,700
We have the input type,
which is right here.

11826
08:37:30,700 --> 08:37:33,000
That's gonna be, there's
no nothing input type,

11827
08:37:33,000 --> 08:37:34,450
so it's no parameters.

11828
08:37:34,450 --> 08:37:37,154
And then the lambda has a return type.

11829
08:37:37,154 --> 08:37:38,870
And what does that return
type, the return type

11830
08:37:38,870 --> 08:37:40,410
is gonna be unit, so it's
not gonna do anything.

11831
08:37:40,410 --> 08:37:42,760
And again, the name of
it is just called block.

11832
08:37:43,805 --> 08:37:44,638
And the reason why we're
calling it block here

11833
08:37:44,638 --> 08:37:46,430
is because it can be a block of code.

11834
08:37:47,430 --> 08:37:48,750
And so this is a block and
so I can get rid of this.

11835
08:37:48,750 --> 08:37:50,960
Now, what I can do is
just invoke this block

11836
08:37:52,050 --> 08:37:53,250
since this is basically just a function.

11837
08:37:53,250 --> 08:37:54,850
I'm saying, hey, this is
a function I wanna do.

11838
08:37:54,850 --> 08:37:58,220
And so what I can do now is I
can get rid of this code here

11839
08:37:58,220 --> 08:38:00,220
and I can actually just do this.

11840
08:38:00,220 --> 08:38:02,760
Now, of course you wondering
where did the parentheses go?

11841
08:38:02,760 --> 08:38:04,750
So I could just do exactly this.

11842
08:38:04,750 --> 08:38:07,190
And then I need to put
my code block in there.

11843
08:38:07,190 --> 08:38:09,020
But what you're gonna see
here is this little squiggly

11844
08:38:09,020 --> 08:38:12,120
and say, hey, you can go ahead
and move the lambda argument

11845
08:38:12,120 --> 08:38:13,748
out of the parentheses.

11846
08:38:13,748 --> 08:38:16,320
It's just a convention that
is allowed inside of Kotlin.

11847
08:38:16,320 --> 08:38:17,760
So now I can just say
anything I want here.

11848
08:38:17,760 --> 08:38:22,630
I say print line message one.

11849
08:38:22,630 --> 08:38:25,890
I can say two, I can say three.

11850
08:38:25,890 --> 08:38:28,570
I could do something like
this, I could run this.

11851
08:38:30,148 --> 08:38:31,210
I could even put my own
loop inside of here.

11852
08:38:31,210 --> 08:38:36,210
I could say repeat five times
I could do my own lambda

11853
08:38:37,400 --> 08:38:39,450
express, you know, 'cause
that repeat thing takes

11854
08:38:39,450 --> 08:38:40,470
on its own land expression.

11855
08:38:40,470 --> 08:38:43,784
Repeat as part of the Kotlin
standard library, by the way.

11856
08:38:43,784 --> 08:38:45,810
And if we run that
again, what we'll see now

11857
08:38:45,810 --> 08:38:49,030
is we'll see message one,
two, three, four, five,

11858
08:38:49,030 --> 08:38:50,710
repeated right here in the middle,

11859
08:38:50,710 --> 08:38:55,710
all separated by our top and
our bottom parts of our line.

11860
08:38:57,380 --> 08:39:01,940
So what this has allowed
us to do is create

11861
08:39:01,940 --> 08:39:05,070
a much more extendable function.

11862
08:39:05,920 --> 08:39:08,590
So we now have a function
called line logger

11863
08:39:08,590 --> 08:39:10,520
that I can pars in whatever I want.

11864
08:39:10,520 --> 08:39:12,960
I can do 20 different logs and
hearing do 10 different logs.

11865
08:39:12,960 --> 08:39:15,750
And it'll help me be able
to find perhaps my logs

11866
08:39:15,750 --> 08:39:16,780
instead of a logger.

11867
08:39:16,780 --> 08:39:19,650
That's a very naive and simple example,

11868
08:39:19,650 --> 08:39:22,180
but it shows you the power
of basically delegating

11869
08:39:22,180 --> 08:39:24,360
the responsibility back to the caller.

11870
08:39:24,360 --> 08:39:26,590
So I'm yielding this call.

11871
08:39:26,590 --> 08:39:29,420
So right here, I'm gonna be
yielding whatever's happening

11872
08:39:29,420 --> 08:39:31,520
here to execute what's gonna happen here.

11873
08:39:31,520 --> 08:39:34,530
So what's, let's think
about this for a second.

11874
08:39:34,530 --> 08:39:36,790
First thing that happens
is we called line logger,

11875
08:39:36,790 --> 08:39:38,750
line lager said, hey, no problem, cool.

11876
08:39:39,704 --> 08:39:41,079
I have a block.

11877
08:39:41,079 --> 08:39:42,786
And then the first line
of code executes and says,

11878
08:39:42,786 --> 08:39:44,300
all right, well, I'm gonna
print this thing five times.

11879
08:39:44,300 --> 08:39:45,870
And then now after that,

11880
08:39:45,870 --> 08:39:49,200
what I have now is I have
this little block of code.

11881
08:39:49,200 --> 08:39:52,500
And this little block of code
right here, I need to run.

11882
08:39:52,500 --> 08:39:55,610
Then that little block of
code is this stuff right here.

11883
08:39:55,610 --> 08:39:58,080
It's whatever's in between
these two brackets up here

11884
08:39:59,550 --> 08:40:00,383
and that's gonna run that block of code.

11885
08:40:00,383 --> 08:40:03,134
And then after that's
done, it's gonna go ahead

11886
08:40:03,134 --> 08:40:06,020
and return back down and it's
gonna run the next three,

11887
08:40:06,020 --> 08:40:09,140
next five iterations of this repeat loop.

11888
08:40:09,140 --> 08:40:12,200
So it's basically going
inside of here, running this,

11889
08:40:12,200 --> 08:40:13,810
hopping back out, doing something out here

11890
08:40:13,810 --> 08:40:16,520
and then hopping back in
and finishing up down here.

11891
08:40:16,520 --> 08:40:19,210
And so it's a very simple
way that you can actually

11892
08:40:19,210 --> 08:40:22,330
implement a lambda expression
inside of a function.

11893
08:40:23,420 --> 08:40:26,990
Now let's also create maybe
another lambda expression here.

11894
08:40:26,990 --> 08:40:28,910
Let's call this one repeater.

11895
08:40:28,910 --> 08:40:31,920
So repeater we'll wanna say,

11896
08:40:31,920 --> 08:40:33,790
maybe you wanna do
something over and over.

11897
08:40:33,790 --> 08:40:37,400
Kind of like very similar
to like a loop would have.

11898
08:40:37,400 --> 08:40:38,820
So let's do the same thing.

11899
08:40:38,820 --> 08:40:41,200
Let's create the same signature here,

11900
08:40:41,200 --> 08:40:45,430
but this time I'm gonna
say repeat five times.

11901
08:40:45,430 --> 08:40:47,240
And then what we're gonna
do is we're gonna call

11902
08:40:47,240 --> 08:40:48,910
the block five times over.

11903
08:40:50,420 --> 08:40:53,120
So then what we could do is we
could do something like this

11904
08:40:53,120 --> 08:40:55,370
and we're gonna call, I'm
just gonna comment this out

11905
08:40:55,370 --> 08:40:57,730
for now 'cause we don't wanna
see that inside of the output.

11906
08:40:57,730 --> 08:41:01,670
So we'll say repeater, and
then it's gonna take it out

11907
08:41:01,670 --> 08:41:02,503
in a block.

11908
08:41:02,503 --> 08:41:05,757
And so inside of here, I can
just say, print ln, hello.

11909
08:41:08,605 --> 08:41:10,570
And what's gonna happen
is I'm gonna run this,

11910
08:41:10,570 --> 08:41:12,130
repeater is gonna run
and it's gonna print it

11911
08:41:12,130 --> 08:41:13,801
five times in a row.

11912
08:41:13,801 --> 08:41:16,403
But now of course, we're
trying to make our application

11913
08:41:16,403 --> 08:41:17,420
a lot more user-friendly.

11914
08:41:17,420 --> 08:41:19,340
So we wanna be able to
provide how many times

11915
08:41:19,340 --> 08:41:21,964
we think these things should repeat.

11916
08:41:21,964 --> 08:41:22,797
And so what we can do is
we can go ahead and say,

11917
08:41:22,797 --> 08:41:24,750
all right, one or five in here.

11918
08:41:24,750 --> 08:41:27,970
And so I'm saying number
five, but there's no way

11919
08:41:27,970 --> 08:41:29,140
we can tell repeater
to do that, but we can.

11920
08:41:29,140 --> 08:41:31,730
So we can go down here
and say, how many times

11921
08:41:31,730 --> 08:41:33,850
do we want you to repeat,
and that's an integer value.

11922
08:41:33,850 --> 08:41:36,270
And I can take the energy
value and just drop it

11923
08:41:36,270 --> 08:41:37,650
right into this repeat function.

11924
08:41:37,650 --> 08:41:39,890
Again, we're kind of duplicating
what's happening here,

11925
08:41:39,890 --> 08:41:43,720
but I'm basically telling,
hey, I want our little repeater

11926
08:41:43,720 --> 08:41:47,670
to run five times and then
what's gonna end up happening

11927
08:41:47,670 --> 08:41:49,070
is it's gonna run five times.

11928
08:41:49,070 --> 08:41:50,340
Now for whatever reason later on,

11929
08:41:50,340 --> 08:41:53,240
I decided I want this
repeater to run three times

11930
08:41:53,240 --> 08:41:56,150
or 13 times, I'll run this here,

11931
08:41:56,150 --> 08:41:59,290
our little repeater
thing will run 13 times.

11932
08:41:59,290 --> 08:42:03,490
Now, as I start thinking about
it, eventually I realized

11933
08:42:03,490 --> 08:42:06,140
it would be really
great if there was a way

11934
08:42:08,185 --> 08:42:10,600
that I can get to what iteration I was on,

11935
08:42:10,600 --> 08:42:15,600
because I realized that when
I am gonna repeat five times,

11936
08:42:17,150 --> 08:42:18,650
I wanna say hello three times.

11937
08:42:19,610 --> 08:42:21,360
So hello, three times.

11938
08:42:22,300 --> 08:42:26,010
And then I wanna say goodbye two times

11939
08:42:26,010 --> 08:42:27,010
for whatever reason.

11940
08:42:28,440 --> 08:42:30,700
So how would I do that,
so I wanna say print line,

11941
08:42:32,930 --> 08:42:34,510
I'll say goodbye.

11942
08:42:34,510 --> 08:42:36,180
But how am I gonna say that on the first

11943
08:42:36,180 --> 08:42:37,950
couple of iterations, I
don't know what that is.

11944
08:42:37,950 --> 08:42:41,500
So what I need to do is expose
that value to the block.

11945
08:42:41,500 --> 08:42:43,080
So basically I needed to tell the block,

11946
08:42:43,080 --> 08:42:45,540
hey, you need to be
able to get some value.

11947
08:42:45,540 --> 08:42:49,830
Now, remember this value, this
right here is the input type.

11948
08:42:49,830 --> 08:42:50,900
There's no input types here,

11949
08:42:50,900 --> 08:42:53,550
we didn't provide any parameters.

11950
08:42:53,550 --> 08:42:55,870
It's still gonna return a unit,

11951
08:42:55,870 --> 08:42:57,160
so it's not gonna do anything.

11952
08:42:57,160 --> 08:42:59,410
But what I wanted to change
is to say, hey, you know what,

11953
08:42:59,410 --> 08:43:00,870
I want this block.

11954
08:43:00,870 --> 08:43:03,690
So again, this chunk of
code, I want it to be able

11955
08:43:03,690 --> 08:43:05,090
to accept a parameter and this parameter

11956
08:43:05,090 --> 08:43:06,560
is gonna be an integer value.

11957
08:43:06,560 --> 08:43:09,190
And now immediately, what
you'll notice right here,

11958
08:43:09,190 --> 08:43:10,710
we have a squiggly error saying,

11959
08:43:10,710 --> 08:43:12,785
hey, there's something wrong.

11960
08:43:12,785 --> 08:43:13,900
And what that means is
that we need to parse

11961
08:43:13,900 --> 08:43:15,180
a value in there.

11962
08:43:15,180 --> 08:43:18,200
Now, little did you know
that the repeat function

11963
08:43:18,200 --> 08:43:20,980
that is built into the standard library

11964
08:43:20,980 --> 08:43:22,100
actually it gives us an index,

11965
08:43:22,100 --> 08:43:23,750
we just were not using it before.

11966
08:43:25,068 --> 08:43:26,770
And so I'm just gonna
go ahead and use it now.

11967
08:43:26,770 --> 08:43:29,701
And so I'm gonna parse an
index and every time the repeat

11968
08:43:29,701 --> 08:43:30,760
function fires off, it's
gonna give us an index.

11969
08:43:30,760 --> 08:43:34,830
I'm gonna send that index
directly back to our block

11970
08:43:34,830 --> 08:43:36,190
and that's gonna get
called inside of here.

11971
08:43:36,190 --> 08:43:38,190
And so let's go ahead and use our index.

11972
08:43:39,630 --> 08:43:42,748
There's our index and now
we can do something with it.

11973
08:43:42,748 --> 08:43:43,790
So what we can do in here is we can say,

11974
08:43:43,790 --> 08:43:48,790
if index is less than
three, go ahead and do this.

11975
08:43:51,110 --> 08:43:53,360
And else we're gonna go
ahead and print this.

11976
08:43:54,280 --> 08:43:56,530
So now we run this, what
we're gonna see here

11977
08:43:57,870 --> 08:43:59,520
is hello, hello, hello, goodbye, goodbye.

11978
08:43:59,520 --> 08:44:02,555
Because what's happening is
the index is being print.

11979
08:44:02,555 --> 08:44:04,110
So it's go ahead and
print line on the index.

11980
08:44:05,060 --> 08:44:09,780
For each iteration of this
loop, we can see down here.

11981
08:44:12,090 --> 08:44:13,860
Each time, so remember
what we're calling repeat,

11982
08:44:13,860 --> 08:44:16,070
which is built into the Kotlin
center library just tells,

11983
08:44:16,070 --> 08:44:20,790
hey, repeat this little
function however many times

11984
08:44:20,790 --> 08:44:22,720
we tell at the time, we told it five.

11985
08:44:22,720 --> 08:44:25,250
And each time iterate is
gonna call this block.

11986
08:44:25,250 --> 08:44:27,510
And this block, all this block is,

11987
08:44:27,510 --> 08:44:30,330
is this chunk of code
here, this is the block.

11988
08:44:30,330 --> 08:44:31,740
And then what it's gonna do is gonna parse

11989
08:44:31,740 --> 08:44:33,680
its current index in here,
which is what we decided

11990
08:44:33,680 --> 08:44:34,680
to do here.

11991
08:44:34,680 --> 08:44:37,930
And now we can decide to
start iterating inside of here

11992
08:44:37,930 --> 08:44:40,250
and perhaps perform some logic.

11993
08:44:40,250 --> 08:44:42,280
And if it's less than three, of course,

11994
08:44:42,280 --> 08:44:44,050
we're just gonna print hello.

11995
08:44:44,050 --> 08:44:45,560
Otherwise we're gonna print and goodbye.

11996
08:44:45,560 --> 08:44:47,800
Now this can be done for
any number of things,

11997
08:44:47,800 --> 08:44:49,180
we could decide to use the index.

11998
08:44:49,180 --> 08:44:51,760
We decided not to use
the index or whatever.

11999
08:44:51,760 --> 08:44:53,500
And again, if we don't wanna
use it, we don't have to,

12000
08:44:53,500 --> 08:44:55,260
we can just kind of get rid of it.

12001
08:44:55,260 --> 08:44:57,640
Again we'd have to make sure
we're not using the variable,

12002
08:44:57,640 --> 08:44:58,473
but here we are.

12003
08:44:59,380 --> 08:45:01,950
So this is how you can go
ahead and parse a variable

12004
08:45:01,950 --> 08:45:06,950
into a lambda function and
basically receive that variable

12005
08:45:07,060 --> 08:45:09,140
back into the block itself.

12006
08:45:09,990 --> 08:45:12,300
So we've created a
function called repeater.

12007
08:45:12,300 --> 08:45:14,660
We're gonna tell it how many
times it needs to do something.

12008
08:45:14,660 --> 08:45:16,860
And then we're saying, hey,
every time you do something,

12009
08:45:16,860 --> 08:45:19,310
we want you to call a particular function,

12010
08:45:19,310 --> 08:45:20,920
this function we're gonna call it block.

12011
08:45:20,920 --> 08:45:22,480
It's gonna take in an integer,

12012
08:45:22,480 --> 08:45:24,040
I don't care what the integer is,

12013
08:45:24,040 --> 08:45:25,260
but it's gonna take an integer

12014
08:45:25,260 --> 08:45:27,040
and it's not gonna return anything.

12015
08:45:27,040 --> 08:45:28,620
And then inside of our function, we say,

12016
08:45:28,620 --> 08:45:32,089
hey, we're gonna use the
built-in function called repeat.

12017
08:45:32,089 --> 08:45:32,922
It's gonna repeat.

12018
08:45:32,922 --> 08:45:33,755
And then every time
it's gonna give an index

12019
08:45:33,755 --> 08:45:35,770
and we're gonna parse
that index into here.

12020
08:45:35,770 --> 08:45:37,660
Now I could parse any number I want here.

12021
08:45:37,660 --> 08:45:39,260
If I want it through the
whole time, I can just parse

12022
08:45:39,260 --> 08:45:40,640
number three, it doesn't matter.

12023
08:45:40,640 --> 08:45:41,870
It doesn't have to be the index.

12024
08:45:41,870 --> 08:45:44,750
I could be three times
1000, it doesn't matter.

12025
08:45:44,750 --> 08:45:47,880
All this block, all this
sick function signature

12026
08:45:47,880 --> 08:45:52,280
is saying is this block is
expecting its first parameter

12027
08:45:52,280 --> 08:45:55,340
to be an integer and it's
not going to return anything.

12028
08:45:55,340 --> 08:45:56,173
That's all it's saying.

12029
08:45:56,173 --> 08:46:01,100
So it doesn't matter if this
value right here is the index,

12030
08:46:01,100 --> 08:46:04,850
or if it's a random number,
that's up for you to decide.

12031
08:46:04,850 --> 08:46:08,710
Here, we're parsing in the
index because we wanna know

12032
08:46:08,710 --> 08:46:11,710
when we're using a repeater
function, what index we are.

12033
08:46:11,710 --> 08:46:14,050
And when we're repeating,
are we the fifth iteration,

12034
08:46:14,050 --> 08:46:15,700
et cetera, or the 20th iteration,

12035
08:46:16,863 --> 08:46:17,696
what are we doing at that point in time.

12036
08:46:17,696 --> 08:46:19,630
Okay, so now we have that repeater.

12037
08:46:19,630 --> 08:46:21,580
So let's go ahead and comment this out.

12038
08:46:22,660 --> 08:46:25,640
So let's assume we wanted
to have to do something

12039
08:46:25,640 --> 08:46:27,053
a little different.

12040
08:46:27,053 --> 08:46:29,146
So let's say we have,
what's called a function

12041
08:46:29,146 --> 08:46:29,979
called Derby announcer.

12042
08:46:31,430 --> 08:46:35,180
This Derby announcer
function is gonna take in

12043
08:46:35,180 --> 08:46:38,370
a lambda expression.

12044
08:46:38,370 --> 08:46:39,760
This lambda expression
will look like this.

12045
08:46:39,760 --> 08:46:42,490
There'll be a block of code,
it's gonna take in a string.

12046
08:46:42,490 --> 08:46:44,656
So this first parameter
is gonna be a string

12047
08:46:44,656 --> 08:46:46,830
and then it's actually
gonna return a string.

12048
08:46:46,830 --> 08:46:49,510
So this lambda expression
is gonna return a string

12049
08:46:50,830 --> 08:46:52,630
and this announcer is spelled wrong.

12050
08:46:55,436 --> 08:46:58,029
And so what we'll do here
is let me fill this out.

12051
08:46:58,029 --> 08:46:59,730
Okay, we're back soon
and have to see me tight.

12052
08:46:59,730 --> 08:47:01,910
So the Derby announcer
function does a few things.

12053
08:47:01,910 --> 08:47:04,830
It has a lambda expression, it's a block.

12054
08:47:04,830 --> 08:47:08,290
That block takes in a
string as a parameter,

12055
08:47:08,290 --> 08:47:09,600
and then it returns a string.

12056
08:47:09,600 --> 08:47:12,267
And then what we're gonna
do here is this gonna be

12057
08:47:12,267 --> 08:47:13,100
like a home run Derby announcer.

12058
08:47:13,100 --> 08:47:14,150
And these are different names of perhaps

12059
08:47:14,150 --> 08:47:15,320
some baseball players.

12060
08:47:15,320 --> 08:47:17,380
So you McGuire, can say,
go Honeycutt, Davis,

12061
08:47:17,380 --> 08:47:19,220
Dolly Weiss, et cetera.

12062
08:47:19,220 --> 08:47:21,330
And then what we're gonna do
is we're gonna randomly choose

12063
08:47:21,330 --> 08:47:23,250
a player's name and then to the screen,

12064
08:47:23,250 --> 08:47:24,860
we're gonna put the next player's name.

12065
08:47:24,860 --> 08:47:27,630
The next player is whatever
this random word is.

12066
08:47:27,630 --> 08:47:28,990
No it's gonna be, you
know, we can change this

12067
08:47:28,990 --> 08:47:29,840
to random player.

12068
08:47:32,219 --> 08:47:34,440
At that point, this will
print to the screen.

12069
08:47:34,440 --> 08:47:35,850
And then what we wanna
do is maybe we wanna have

12070
08:47:35,850 --> 08:47:37,970
some type of log that we
wanna print to the screen,

12071
08:47:37,970 --> 08:47:39,975
but we don't know what that's gonna be,

12072
08:47:39,975 --> 08:47:42,970
or print some other type of
thing we could call it a log,

12073
08:47:42,970 --> 08:47:45,440
could call it something
from the announcer,

12074
08:47:47,620 --> 08:47:50,430
announcer topic, announcer
message, do that.

12075
08:47:51,870 --> 08:47:53,571
But we don't know what that's gonna be

12076
08:47:53,571 --> 08:47:54,700
'cause it could vary between announcer.

12077
08:47:54,700 --> 08:47:57,160
And so each announcer could
be a little bit different.

12078
08:47:57,160 --> 08:48:00,200
And so what we wanna do
is allow the announcer

12079
08:48:00,200 --> 08:48:02,260
to say what they wanna say.

12080
08:48:02,260 --> 08:48:05,583
And so we're gonna delegate
that back up to the block.

12081
08:48:05,583 --> 08:48:06,610
And remember we're gonna
parse into the random player

12082
08:48:06,610 --> 08:48:09,053
that we chose, we're gonna
parse back up to them.

12083
08:48:09,053 --> 08:48:10,313
But this block also
returns a string, remember.

12084
08:48:10,313 --> 08:48:13,546
So if we look at this
block, it takes in a string

12085
08:48:13,546 --> 08:48:16,240
right here, it takes in a string

12086
08:48:16,240 --> 08:48:17,690
and then it returns a string.

12087
08:48:19,119 --> 08:48:19,952
So if we were to implement this,

12088
08:48:19,952 --> 08:48:22,270
what we could do is we
would say Derby announcer,

12089
08:48:23,680 --> 08:48:26,457
and we're just gonna parse
him a lambda expression.

12090
08:48:26,457 --> 08:48:28,780
Again, this is gonna take in a player

12091
08:48:28,780 --> 08:48:29,700
is what's gonna be sent in.

12092
08:48:29,700 --> 08:48:31,100
So it's gonna take a string.

12093
08:48:32,686 --> 08:48:33,550
We could say, this is a string,

12094
08:48:33,550 --> 08:48:35,440
or we could use type inference.

12095
08:48:35,440 --> 08:48:36,900
And then we can go ahead and do something.

12096
08:48:36,900 --> 08:48:39,729
And now we need to return
something out of here.

12097
08:48:39,729 --> 08:48:44,120
And we can say something like
this, player is a great asset

12098
08:48:45,220 --> 08:48:46,390
to the team.

12099
08:48:49,280 --> 08:48:50,960
And this is the value that's
gonna be returned, remember

12100
08:48:50,960 --> 08:48:52,650
'cause it's the last value
in the lambda expression.

12101
08:48:52,650 --> 08:48:55,517
It's what's going to be
returned inside of here.

12102
08:48:55,517 --> 08:48:58,450
Now, if I did length, we're
gonna run into a problem.

12103
08:48:58,450 --> 08:49:00,780
Why, because we're expecting a string,

12104
08:49:00,780 --> 08:49:02,570
but we're giving it back an integer.

12105
08:49:03,723 --> 08:49:04,556
So, okay, now we have this.

12106
08:49:04,556 --> 08:49:07,640
So the Derby announcer
is gonna say something.

12107
08:49:07,640 --> 08:49:08,880
The Derby announcer's
gonna say this player

12108
08:49:08,880 --> 08:49:10,020
is a great asset to the team.

12109
08:49:10,020 --> 08:49:12,110
So now what's gonna happen if we run this

12110
08:49:13,450 --> 08:49:14,610
is it the Derby announcer.

12111
08:49:14,610 --> 08:49:16,710
We don't know what player we're gonna get,

12112
08:49:17,612 --> 08:49:19,300
but here we get the
next player is Consaco.

12113
08:49:19,300 --> 08:49:21,280
Consaco is a great asset to the team.

12114
08:49:22,708 --> 08:49:24,710
And again, the way this
happens is Derby announcer

12115
08:49:24,710 --> 08:49:27,990
gets called, we have a list of players.

12116
08:49:27,990 --> 08:49:30,660
We grab a random player off of that list,

12117
08:49:30,660 --> 08:49:32,750
we then print something to the screen.

12118
08:49:32,750 --> 08:49:36,200
We then take that random
player, we send it to the block,

12119
08:49:37,519 --> 08:49:39,150
which is this player here.

12120
08:49:39,150 --> 08:49:41,510
We then do something with it,
so this could be any string.

12121
08:49:41,510 --> 08:49:43,210
So it depends on the Derby announcer,

12122
08:49:43,210 --> 08:49:46,330
whoever's using the Derby
announcer lambda expression.

12123
08:49:46,330 --> 08:49:47,470
It could be a number of things.

12124
08:49:47,470 --> 08:49:49,503
I mean, it could be
going out to a database,

12125
08:49:49,503 --> 08:49:50,336
could be going to a web service.

12126
08:49:50,336 --> 08:49:54,280
It could be going to a
Megatron at a big ballpark

12127
08:49:54,280 --> 08:49:56,320
to degenerate stuff.

12128
08:49:56,320 --> 08:50:00,040
And then once that is happens, we go ahead

12129
08:50:00,040 --> 08:50:02,780
and take that value and we send that value

12130
08:50:02,780 --> 08:50:05,430
of whatever message we have,
we're gonna send it back

12131
08:50:07,092 --> 08:50:07,925
through the lambda expression saying,

12132
08:50:07,925 --> 08:50:08,980
here's what we wanna return.

12133
08:50:09,930 --> 08:50:11,730
The lemon expression takes
that and then does something

12134
08:50:11,730 --> 08:50:13,790
with it and here, it's just
gonna print it to the screen.

12135
08:50:13,790 --> 08:50:16,560
So we're basically coming
in here, hopping back out,

12136
08:50:16,560 --> 08:50:18,510
doing something, grabbing
the value outside

12137
08:50:18,510 --> 08:50:21,890
of this external function
of this lambda expression

12138
08:50:21,890 --> 08:50:24,590
inside of here, bringing it
back inside of this function

12139
08:50:24,590 --> 08:50:26,180
and then doing something with it again.

12140
08:50:26,180 --> 08:50:28,950
So we're allowing it to
like yield some control.

12141
08:50:28,950 --> 08:50:31,330
This line right here is allowing
us to yield some control

12142
08:50:31,330 --> 08:50:33,950
to some outside caller,
which is really powerful.

12143
08:50:33,950 --> 08:50:36,580
And this enables you to do
some really powerful things.

12144
08:50:36,580 --> 08:50:37,690
And it doesn't have to be a string,

12145
08:50:37,690 --> 08:50:39,767
it could be any types of things.

12146
08:50:39,767 --> 08:50:40,862
It doesn't have to return a string,

12147
08:50:40,862 --> 08:50:43,142
it could be returning all
different kinds of things.

12148
08:50:43,142 --> 08:50:45,170
And so this is how you
can use lambda expressions

12149
08:50:45,170 --> 08:50:48,370
by parsing them as parameters,

12150
08:50:48,370 --> 08:50:50,450
as arguments into other functions.

12151
08:50:51,305 --> 08:50:54,180
You can create your own lambed
expressions to parse around.

12152
08:50:54,180 --> 08:50:55,840
You can create your own
functions that require

12153
08:50:55,840 --> 08:50:57,260
lambda expressions.

12154
08:50:57,260 --> 08:51:01,160
And then you can delegate
behavior back to up to the caller.

12155
08:51:01,160 --> 08:51:04,030
You may be developing an API
and you know that you wanted

12156
08:51:04,030 --> 08:51:06,250
to get something from the end
user, but you don't know what,

12157
08:51:06,250 --> 08:51:08,230
but you wanna give them
a little bit of data.

12158
08:51:08,230 --> 08:51:10,810
Here I'm saying this is my announcer.

12159
08:51:10,810 --> 08:51:14,810
Perhaps I'm creating some
code for a baseball field.

12160
08:51:14,810 --> 08:51:18,352
And this announcer is gonna be, you know,

12161
08:51:18,352 --> 08:51:19,185
get a random player for whatever reason.

12162
08:51:19,185 --> 08:51:20,020
There is a home run Derby.

12163
08:51:20,020 --> 08:51:21,490
And so we're gonna get the random player,

12164
08:51:21,490 --> 08:51:23,090
who knows what they're
gonna say from there,

12165
08:51:23,090 --> 08:51:24,707
but I need to get that information back

12166
08:51:24,707 --> 08:51:27,270
because maybe I need to
take this information

12167
08:51:27,270 --> 08:51:28,880
and give it to a teleprompter.

12168
08:51:28,880 --> 08:51:31,020
Maybe it needs to show up on
a teleprompter, I don't know.

12169
08:51:31,020 --> 08:51:32,510
So all different kinds
of things you can do,

12170
08:51:32,510 --> 08:51:34,440
but you can delegate
this stuff pretty easily

12171
08:51:34,440 --> 08:51:35,910
using lambda expressions.

12172
08:51:38,211 --> 08:51:40,820
Let's assume that you're
creating a lorem ipsum generator,

12173
08:51:40,820 --> 08:51:43,570
which is Latin text that's typically used

12174
08:51:43,570 --> 08:51:46,020
in a lot of copywriting
when you're not sure

12175
08:51:46,020 --> 08:51:49,034
what you wanna write and
you're designing some texts.

12176
08:51:49,034 --> 08:51:51,540
And when you're doing this,
here's for example, the code,

12177
08:51:51,540 --> 08:51:54,220
we have a bunch of Latin words here,

12178
08:51:54,220 --> 08:51:57,050
and we want to randomly
get a bunch of words.

12179
08:51:57,050 --> 08:52:01,560
And we have a function here
that basically says lorem ipsum

12180
08:52:01,560 --> 08:52:03,650
takes in the number of times we want,

12181
08:52:03,650 --> 08:52:05,950
number of basically words
or loops we wanna do

12182
08:52:07,536 --> 08:52:09,839
and then basically it does a repeat.

12183
08:52:09,839 --> 08:52:11,850
And what happens is we will do
something a number of times.

12184
08:52:11,850 --> 08:52:14,680
So it's five times, it'll
repeat this five times

12185
08:52:14,680 --> 08:52:16,860
giving us the index of each time.

12186
08:52:16,860 --> 08:52:19,910
And then what we do is we look
at the list of Latin words

12187
08:52:19,910 --> 08:52:20,860
to get a random word.

12188
08:52:20,860 --> 08:52:25,290
And then we send that back to
whatever the block is here.

12189
08:52:25,290 --> 08:52:29,590
In that case, it's going
to be this caller here

12190
08:52:29,590 --> 08:52:31,370
and you're gonna get back to the index.

12191
08:52:31,370 --> 08:52:33,790
So basically the current iteration.

12192
08:52:33,790 --> 08:52:36,296
So if it's the first one,
it would be number one,

12193
08:52:36,296 --> 08:52:37,730
if it's the fifth iteration, it'd be five.

12194
08:52:37,730 --> 08:52:39,030
And then whatever the random word is.

12195
08:52:39,030 --> 08:52:41,000
And at that point, you can
do whatever you wanna do

12196
08:52:41,000 --> 08:52:44,590
with this random words
from this lorem ipsum text.

12197
08:52:44,590 --> 08:52:46,890
So let's say you do that
and you run this now,

12198
08:52:46,890 --> 08:52:49,750
and then you have this text here.

12199
08:52:49,750 --> 08:52:51,920
And of course this is
gonna change each time

12200
08:52:51,920 --> 08:52:54,420
because everything is kind of random.

12201
08:52:54,420 --> 08:52:56,770
Now notice one thing here is
that we're not really using

12202
08:52:56,770 --> 08:52:58,210
this index parameter.

12203
08:52:58,210 --> 08:53:01,526
And so we do need the word parameter.

12204
08:53:01,526 --> 08:53:04,330
So what we can actually do in this case

12205
08:53:04,330 --> 08:53:05,920
is a couple of things to clean this up.

12206
08:53:05,920 --> 08:53:09,470
First of all, due to
type inference in Kotlin,

12207
08:53:09,470 --> 08:53:11,290
we can get rid of the types.

12208
08:53:11,290 --> 08:53:14,310
So alrighty, Kotlin is gonna know.

12209
08:53:14,310 --> 08:53:16,940
Sounds good, we already know
that the first type here

12210
08:53:16,940 --> 08:53:20,050
is gonna be an integer because
that's declared right here.

12211
08:53:20,050 --> 08:53:22,838
And the second type is
going to be a string

12212
08:53:22,838 --> 08:53:23,671
because that's declared there.

12213
08:53:23,671 --> 08:53:25,450
So we don't need you to
define the types for us,

12214
08:53:25,450 --> 08:53:26,940
we can do that for us.

12215
08:53:26,940 --> 08:53:31,530
Next by default, there
is a kind of standard

12216
08:53:31,530 --> 08:53:33,210
that when a parameter is not used,

12217
08:53:33,210 --> 08:53:35,830
but we do need to declare
it here for the purposes

12218
08:53:35,830 --> 08:53:39,670
of the compiler, you can use a underscore.

12219
08:53:39,670 --> 08:53:40,990
And that basically tells Kotlin,

12220
08:53:40,990 --> 08:53:42,990
hey, we know that there's a variable here,

12221
08:53:42,990 --> 08:53:45,400
but just go ahead and ignore that.

12222
08:53:45,400 --> 08:53:48,440
And so if we run this
again, we can execute it

12223
08:53:48,440 --> 08:53:49,970
and that would work just fine.

12224
08:53:49,970 --> 08:53:52,400
Now, another interesting
thing is if for some reason

12225
08:53:52,400 --> 08:53:54,450
we didn't wanna do anything with it here,

12226
08:53:55,350 --> 08:53:56,900
say, we didn't wanna use word either.

12227
08:53:56,900 --> 08:53:58,200
Now we also get this here.

12228
08:53:59,340 --> 08:54:01,440
We can rename both of these to underscore,

12229
08:54:02,331 --> 08:54:04,300
and that's kind of the default mechanism

12230
08:54:04,300 --> 08:54:07,150
and the default nomenclature for variables

12231
08:54:07,150 --> 08:54:09,280
inside of a lambda
expression that are not used.

12232
08:54:09,280 --> 08:54:12,277
So basically this means unused.

12233
08:54:12,277 --> 08:54:14,630
So anytime you see an underscore inside

12234
08:54:14,630 --> 08:54:17,287
of a lambda expression that you're using

12235
08:54:17,287 --> 08:54:19,630
or in code somewhere, it means
whatever this variable is,

12236
08:54:19,630 --> 08:54:21,420
it's not being used, so
therefore it's been turned

12237
08:54:21,420 --> 08:54:22,370
into an underscore.

12238
08:54:24,710 --> 08:54:27,470
It's very common that a
Kotlin lambda expression

12239
08:54:27,470 --> 08:54:30,810
only has one parameter as the
repeat function does here,

12240
08:54:30,810 --> 08:54:33,410
which is built into the
Kotlin standard library

12241
08:54:33,410 --> 08:54:34,243
as shown here.

12242
08:54:35,167 --> 08:54:37,460
It has one value and that's the index

12243
08:54:37,460 --> 08:54:39,770
that is currently iterating upon.

12244
08:54:39,770 --> 08:54:43,140
So if we were to run this
right now and we told it

12245
08:54:43,140 --> 08:54:44,200
to repeat 10 times,

12246
08:54:44,200 --> 08:54:46,870
we would see that this is
iteration zero through nine.

12247
08:54:46,870 --> 08:54:49,080
Again, this is zero base indexing.

12248
08:54:49,080 --> 08:54:50,850
So we have 10 iterations here.

12249
08:54:50,850 --> 08:54:52,890
So this is printed 10 times.

12250
08:54:52,890 --> 08:54:56,730
Now, anytime you're working
with a lambda expression

12251
08:54:56,730 --> 08:54:59,870
that has one parameter the
compiler is usually smart enough

12252
08:54:59,870 --> 08:55:04,180
to figure out in almost all
of the instances, the types.

12253
08:55:04,180 --> 08:55:06,540
So it can move the type
that's one can prove me here,

12254
08:55:06,540 --> 08:55:08,870
but you can actually improve
this a little bit further

12255
08:55:08,870 --> 08:55:11,829
by actually completely
removing the parameter

12256
08:55:11,829 --> 08:55:16,829
all together and on a single
on a lambda expression

12257
08:55:17,940 --> 08:55:22,940
with one parameter, by default
Kotlin we'll call it it.

12258
08:55:24,810 --> 08:55:28,520
So it can infer the type
of the actual parameter.

12259
08:55:28,520 --> 08:55:30,630
So if it's a single
parameter in this case,

12260
08:55:30,630 --> 08:55:33,490
repeat only has a single
parameter, it'll show as it.

12261
08:55:35,122 --> 08:55:35,955
Now the same thing happens
for many other things

12262
08:55:35,955 --> 08:55:39,160
like the map, instead of
the collections of map,

12263
08:55:39,160 --> 08:55:41,050
you're gonna have
filter, you're gonna have

12264
08:55:41,050 --> 08:55:43,120
a bunch of other things of that nature.

12265
08:55:43,120 --> 08:55:45,410
And it only has one parameter,
you can reference it

12266
08:55:45,410 --> 08:55:47,590
with the word it and Kotlin

12267
08:55:47,590 --> 08:55:49,290
will automatically map it to that.

12268
08:55:50,379 --> 08:55:51,212
So now if we run this again,

12269
08:55:51,212 --> 08:55:52,045
we'll get the same exact result,

12270
08:55:52,045 --> 08:55:55,400
but we save herself a number
of characters when we're coding

12271
08:55:55,400 --> 08:55:59,370
and over the course of a long
weeks and months of times,

12272
08:55:59,370 --> 08:56:01,850
it's a lot of code and less cognitive load

12273
08:56:01,850 --> 08:56:03,400
for you to read in the future.

12274
08:56:03,400 --> 08:56:06,470
And you can just replace all
the extra code with the word it

12275
08:56:06,470 --> 08:56:07,930
and make sure you include the dollar sign

12276
08:56:07,930 --> 08:56:12,322
if you're using anything in
regards to string interpolation.

12277
08:56:12,322 --> 08:56:16,350
Otherwise, if you didn't
wanna use string interpolation

12278
08:56:16,350 --> 08:56:18,706
and you were going to
use something like this,

12279
08:56:18,706 --> 08:56:23,706
you could then go and
say it, plus maybe one,

12280
08:56:24,240 --> 08:56:25,073
let's say you wanted to do that.

12281
08:56:25,073 --> 08:56:27,430
And you're gonna print that line.

12282
08:56:27,430 --> 08:56:28,710
So it again is just a variable.

12283
08:56:30,007 --> 08:56:31,860
And now we get one through
10 because we added one

12284
08:56:31,860 --> 08:56:33,230
to the index.

12285
08:56:33,230 --> 08:56:35,060
And that's how you can use the it keyword

12286
08:56:35,060 --> 08:56:37,000
in Kotlin in lambda expressions.

12287
08:56:38,080 --> 08:56:40,700
Let's talk about how you
can call Kotlin classes

12288
08:56:40,700 --> 08:56:42,260
from within Java.

12289
08:56:42,260 --> 08:56:45,070
So we'll talk about
the JVM interrupt here.

12290
08:56:45,070 --> 08:56:47,800
So let's assume we have
a couple of files here.

12291
08:56:47,800 --> 08:56:50,980
One on the left-hand side,
we have a customer model.

12292
08:56:50,980 --> 08:56:54,880
All it is a Kotlin data class
that contains the customer

12293
08:56:54,880 --> 08:56:55,900
and it has a function in it.

12294
08:56:55,900 --> 08:56:58,360
And basically the function
checks if the customer

12295
08:56:58,360 --> 08:57:01,960
has a long, we have maybe
some type of service.

12296
08:57:01,960 --> 08:57:04,550
So we have a couple of packages here.

12297
08:57:04,550 --> 08:57:07,260
And inside of this application,
we have some Kotlin,

12298
08:57:07,260 --> 08:57:08,490
some Java for whatever reason.

12299
08:57:08,490 --> 08:57:11,440
It has to be Java, or it's
just maybe a very large file

12300
08:57:11,440 --> 08:57:13,440
that we haven't converted to Kotlin yet.

12301
08:57:14,400 --> 08:57:16,390
And you need to call into some Kotlin,

12302
08:57:16,390 --> 08:57:17,980
maybe that was written.

12303
08:57:17,980 --> 08:57:18,820
Now you can actually do that.

12304
08:57:18,820 --> 08:57:21,330
So here we're in a Java file
and let's say that we need

12305
08:57:21,330 --> 08:57:23,400
to interact with the customer.

12306
08:57:23,400 --> 08:57:26,790
And so let's have a method
called process customer.

12307
08:57:26,790 --> 08:57:30,080
So we'll say public void process customer.

12308
08:57:32,120 --> 08:57:33,980
And then what we need
to do is we need to work

12309
08:57:33,980 --> 08:57:35,680
with the customer, so we need
to take a parameter here.

12310
08:57:35,680 --> 08:57:38,500
So we're gonna say customer
and there is customer,

12311
08:57:40,033 --> 08:57:42,650
so we'll do it just like Java
has it open, closed brackets.

12312
08:57:42,650 --> 08:57:43,590
We need to import this.

12313
08:57:43,590 --> 08:57:46,090
Now again, this is a Kotlin class.

12314
08:57:46,090 --> 08:57:48,080
So if we look, go through the definition,

12315
08:57:48,080 --> 08:57:49,770
we're gonna see that now
we're back in Kotlin.

12316
08:57:49,770 --> 08:57:54,260
And that's it, now we are able
to work with this customer.

12317
08:57:54,260 --> 08:57:56,320
If we wanna do something
with the customer,

12318
08:57:56,320 --> 08:57:59,450
we can say customer dot, and
then we have all of the methods

12319
08:57:59,450 --> 08:58:00,283
that are available to us.

12320
08:58:00,283 --> 08:58:04,080
So customer has long name,
that's a Boolean value.

12321
08:58:04,080 --> 08:58:06,710
That's over here, that's
this method right here.

12322
08:58:08,762 --> 08:58:10,580
If we want to get the customer's name,

12323
08:58:11,785 --> 08:58:13,130
we don't have get name,
now this is interesting.

12324
08:58:13,130 --> 08:58:16,140
So get name, actually goes to name,

12325
08:58:16,140 --> 08:58:18,580
but we never defined a get name method.

12326
08:58:18,580 --> 08:58:21,110
Now Kotlin takes care of that
forest underneath the hood

12327
08:58:21,110 --> 08:58:24,700
basically creates a get
name and set name for us.

12328
08:58:24,700 --> 08:58:28,520
But if we look there is no set name,

12329
08:58:28,520 --> 08:58:31,950
and the reason why is
because this is a val.

12330
08:58:31,950 --> 08:58:33,650
So this is a read only.

12331
08:58:34,670 --> 08:58:37,770
So we cannot reassign this
value, it's a read only type.

12332
08:58:37,770 --> 08:58:41,650
If for whatever reason,
this needed to be writable,

12333
08:58:41,650 --> 08:58:45,840
needed to be mutated, we
could then change this

12334
08:58:45,840 --> 08:58:48,780
if we had access to the Kotlin code.

12335
08:58:48,780 --> 08:58:53,500
And then at that point, Kotlin
will give us the set name

12336
08:58:53,500 --> 08:58:57,590
and we can parse in the value,
whatever the new name is.

12337
08:58:57,590 --> 08:59:02,590
Now, at this point, you can
call into Kotlin very easily.

12338
08:59:03,140 --> 08:59:07,310
You can say customer.customer
has long name,

12339
08:59:07,310 --> 08:59:09,680
and you can do anything that
you would really like to do

12340
08:59:09,680 --> 08:59:11,050
at this point in time.

12341
08:59:11,050 --> 08:59:13,250
The only thing you really
have to really worry about

12342
08:59:13,250 --> 08:59:16,160
with these classes is the different types.

12343
08:59:16,160 --> 08:59:18,690
And you can know that
the getters and setters

12344
08:59:18,690 --> 08:59:21,900
are generated for you automatically

12345
08:59:21,900 --> 08:59:25,220
for through Kotlin
because inside of Kotlin,

12346
08:59:25,220 --> 08:59:28,830
we don't need to actually
generate the getters and setters

12347
08:59:28,830 --> 08:59:30,810
because we just will access it directly

12348
08:59:30,810 --> 08:59:32,000
off of the name properties.

12349
08:59:32,000 --> 08:59:34,200
We can just set the
name equal to something.

12350
08:59:35,460 --> 08:59:38,360
And that's how you can call
very simple objects in Kotlin.

12351
08:59:39,460 --> 08:59:41,872
Let's assume that we have this Java class

12352
08:59:41,872 --> 08:59:44,300
and we need to call it from Kotlin.

12353
08:59:44,300 --> 08:59:46,380
Well, that's pretty easy to do.

12354
08:59:46,380 --> 08:59:47,840
This class has a couple of options.

12355
08:59:47,840 --> 08:59:50,480
One is we can get a customer
from a social profile.

12356
08:59:50,480 --> 08:59:52,740
So this would assume
that this was going out

12357
08:59:52,740 --> 08:59:57,740
to some social media API, and
it would get the customer,

12358
08:59:57,750 --> 08:59:58,980
and then returned customer back.

12359
08:59:58,980 --> 09:00:01,620
Maybe we would look it up by
their social media handle.

12360
09:00:02,918 --> 09:00:04,920
And this method basically
returns a list of process

12361
09:00:04,920 --> 09:00:07,310
customers, which doing some
processing in the background.

12362
09:00:07,310 --> 09:00:08,840
The implementation is not important,

12363
09:00:08,840 --> 09:00:11,710
but what is, is the types
and how it's being called.

12364
09:00:11,710 --> 09:00:14,900
And then we have a Kotlin
file called customer facade,

12365
09:00:14,900 --> 09:00:16,780
following a very common facade pattern

12366
09:00:16,780 --> 09:00:18,290
where maybe it's interacting with a bunch

12367
09:00:18,290 --> 09:00:20,740
of different services to perform some work

12368
09:00:20,740 --> 09:00:22,510
on some customer objects.

12369
09:00:22,510 --> 09:00:24,980
And lastly, of course, we
have the customer object,

12370
09:00:24,980 --> 09:00:28,440
which just has customers name
and similar methods in here,

12371
09:00:28,440 --> 09:00:30,270
which are negligible at this point.

12372
09:00:32,333 --> 09:00:33,166
So inside of customer facade, let's assume

12373
09:00:33,166 --> 09:00:36,250
that we need to call into
the customer service,

12374
09:00:36,250 --> 09:00:37,950
which is Java.

12375
09:00:37,950 --> 09:00:39,814
How would we do that?

12376
09:00:39,814 --> 09:00:40,820
Well, let's assume we wanted to parse it

12377
09:00:40,820 --> 09:00:41,940
via the constructor.

12378
09:00:41,940 --> 09:00:44,190
So what we can say, this
is customer service,

12379
09:00:44,190 --> 09:00:47,542
and now we are working directly
with the customer service

12380
09:00:47,542 --> 09:00:48,375
and we can say something like this.

12381
09:00:48,375 --> 09:00:50,765
We wanna get the customer, customer.

12382
09:00:50,765 --> 09:00:54,940
And then we can say equals
customer service.customer

12383
09:00:56,684 --> 09:00:59,430
from social, and then maybe
we'll parse in user name.

12384
09:00:59,430 --> 09:01:01,070
This is an example username.

12385
09:01:02,240 --> 09:01:07,240
Here we are now calling
into Java from Kotlin,

12386
09:01:07,870 --> 09:01:10,290
but there's something
interesting to note here,

12387
09:01:10,290 --> 09:01:12,820
is if you look at this right here,

12388
09:01:13,700 --> 09:01:16,240
you'll see the customer has an
exclamation point at the end.

12389
09:01:16,240 --> 09:01:19,990
And what that means is
that it is a platform type.

12390
09:01:19,990 --> 09:01:24,990
And this means right
here, that T could be null

12391
09:01:27,070 --> 09:01:28,180
or it could not be null.

12392
09:01:28,180 --> 09:01:30,680
So we're not sure, you
have to decide for yourself

12393
09:01:31,926 --> 09:01:32,759
because you're calling into Kotlin.

12394
09:01:32,759 --> 09:01:34,510
So there's a couple of
things you could do here.

12395
09:01:34,510 --> 09:01:36,280
Now, of course, if I were to just type

12396
09:01:36,280 --> 09:01:40,230
inside of my application, I
would just type in customer.name

12397
09:01:44,261 --> 09:01:46,930
I could do this, I could say
print line customer, not name.

12398
09:01:46,930 --> 09:01:48,010
And that should work.

12399
09:01:48,010 --> 09:01:50,323
As long as the customer is not know about.

12400
09:01:50,323 --> 09:01:52,436
However, there is a chance
that this customer object

12401
09:01:52,436 --> 09:01:53,269
could be null.

12402
09:01:53,269 --> 09:01:54,420
And if it does come back
null, I am going to get

12403
09:01:54,420 --> 09:01:55,920
a null pointer exception.

12404
09:01:55,920 --> 09:01:59,320
So couple of ways to handle
this inside of our Kotlin code,

12405
09:01:59,320 --> 09:02:00,770
we could of course, just go ahead and use

12406
09:02:00,770 --> 09:02:03,120
the double bang operator that
will force it to not be null.

12407
09:02:03,120 --> 09:02:05,890
However, that is a little
bit of a code smell.

12408
09:02:05,890 --> 09:02:08,980
We could use require not
null, that will work as well,

12409
09:02:08,980 --> 09:02:11,310
but again, this will
crash the application.

12410
09:02:12,250 --> 09:02:13,680
Sometimes that's the only thing you can do

12411
09:02:13,680 --> 09:02:14,790
when you're calling into a library

12412
09:02:14,790 --> 09:02:16,590
you don't have control over.

12413
09:02:16,590 --> 09:02:18,400
Then at this point you're
saying, well, I know the customer

12414
09:02:18,400 --> 09:02:19,890
is not gonna be null
because I'm requiring it

12415
09:02:19,890 --> 09:02:21,190
not to be null.

12416
09:02:21,190 --> 09:02:23,490
you could write this in a try-catch.

12417
09:02:23,490 --> 09:02:26,130
If you have access though,
to the actual Java code,

12418
09:02:26,130 --> 09:02:27,930
you can go to this
implementation and you can slap

12419
09:02:27,930 --> 09:02:29,450
on an annotation.

12420
09:02:29,450 --> 09:02:32,676
You can slap on the not null annotation,

12421
09:02:32,676 --> 09:02:34,420
and you could re various
different ones from the JSR

12422
09:02:34,420 --> 09:02:37,566
to I'm using JetBrains version here,

12423
09:02:37,566 --> 09:02:38,760
there's one for Android as well.

12424
09:02:38,760 --> 09:02:42,000
And what this will do is tell Kotlin that,

12425
09:02:42,000 --> 09:02:45,090
hey, trust us, we know what we're doing.

12426
09:02:45,090 --> 09:02:47,440
If we return from this,
it's not gonna be null.

12427
09:02:48,340 --> 09:02:50,860
So now if you notice the
exclamation point went away.

12428
09:02:50,860 --> 09:02:53,610
Kotlin saying, well, you are
telling me via this annotation

12429
09:02:53,610 --> 09:02:56,701
that whoever calls into
customer from social

12430
09:02:56,701 --> 09:02:57,750
will get back a customer object

12431
09:02:57,750 --> 09:02:59,950
and that customer object will not be null.

12432
09:02:59,950 --> 09:03:00,920
So we're gonna go ahead and trust you

12433
09:03:00,920 --> 09:03:03,760
and then we can go ahead
and execute accordingly.

12434
09:03:03,760 --> 09:03:06,110
And at that point in time,
I can do whatever I want.

12435
09:03:07,071 --> 09:03:07,940
Now, this also can be a
little bit further here.

12436
09:03:07,940 --> 09:03:09,760
Let's take a look at the other method.

12437
09:03:11,053 --> 09:03:11,970
The other method is processed customers.

12438
09:03:11,970 --> 09:03:15,850
So process customers here,
let's say val customers,

12439
09:03:17,040 --> 09:03:20,220
you can say a customer
service.processed customers.

12440
09:03:20,220 --> 09:03:23,550
Maybe you're processing them
to update account details

12441
09:03:23,550 --> 09:03:24,490
or whatever.

12442
09:03:24,490 --> 09:03:25,680
Now notice the same thing.

12443
09:03:25,680 --> 09:03:28,740
Again, a platform type
is being returned here.

12444
09:03:28,740 --> 09:03:32,094
We have the exclamation
points that are determined.

12445
09:03:32,094 --> 09:03:32,927
Now we have two of them.

12446
09:03:32,927 --> 09:03:34,700
We have a list and we have the customers.

12447
09:03:34,700 --> 09:03:39,680
Now what this is saying is
like, hey, caller, Kotlin folks,

12448
09:03:39,680 --> 09:03:42,060
we're not sure if this
is a read only list,

12449
09:03:42,060 --> 09:03:44,110
we're not sure if this is a mutable list.

12450
09:03:45,349 --> 09:03:46,182
We're not sure if this
is null, we're not sure

12451
09:03:46,182 --> 09:03:48,870
if this is nullable, we
don't really know yet.

12452
09:03:48,870 --> 09:03:51,990
Because you're calling
into a platform type,

12453
09:03:51,990 --> 09:03:53,280
we're not sure what it is.

12454
09:03:53,280 --> 09:03:55,580
And so you can start slapping
on additional annotations

12455
09:03:55,580 --> 09:03:57,190
on here, but for example, you can also put

12456
09:03:57,190 --> 09:03:58,630
a not null annotation here.

12457
09:04:00,060 --> 09:04:03,371
That is not null annotation
and again, we'll remove that

12458
09:04:03,371 --> 09:04:05,620
saying, hey, at this point,
this is a list that's not

12459
09:04:05,620 --> 09:04:06,530
gonna be null.

12460
09:04:06,530 --> 09:04:09,870
So therefore, if we do perform
some operations on the list,

12461
09:04:09,870 --> 09:04:12,490
which we get at this point, which is nice,

12462
09:04:12,490 --> 09:04:14,680
we can actually map over this list,

12463
09:04:14,680 --> 09:04:18,050
which is interesting because
we're calling into Kotlin,

12464
09:04:18,980 --> 09:04:20,680
we're getting back in a array list

12465
09:04:22,339 --> 09:04:23,172
and then, and then array
list, we're getting it back

12466
09:04:23,172 --> 09:04:24,005
inside of Kotlin.

12467
09:04:24,005 --> 09:04:27,151
And now we can start
performing using our Kotlin

12468
09:04:27,151 --> 09:04:29,051
standard library collection utilities.

12469
09:04:30,134 --> 09:04:31,170
Now this makes life a lot easier.

12470
09:04:31,170 --> 09:04:33,901
I can perform filtering I can perform

12471
09:04:33,901 --> 09:04:36,300
all different types of things
directly inside of Kotlin

12472
09:04:36,300 --> 09:04:38,410
after I've called into Java.

12473
09:04:40,073 --> 09:04:41,200
So a bunch of different stuff you can do.

12474
09:04:41,200 --> 09:04:43,050
One thing you just wanna be
aware of is when you are calling

12475
09:04:43,050 --> 09:04:46,350
into these various platform
types that you check

12476
09:04:47,595 --> 09:04:50,502
for nullables and make
sure that you don't have

12477
09:04:50,502 --> 09:04:51,335
no pointer exceptions.

12478
09:04:51,335 --> 09:04:53,520
Let's assume that we have
this extension function

12479
09:04:53,520 --> 09:04:57,240
inside of a string extensions.kt file.

12480
09:04:57,240 --> 09:05:00,330
And this extension function
extends this string class

12481
09:05:00,330 --> 09:05:02,440
and allows us to grab the initials.

12482
09:05:02,440 --> 09:05:04,850
So if we were to have something like this,

12483
09:05:06,212 --> 09:05:07,910
have a string that says Donn Felker,

12484
09:05:09,099 --> 09:05:09,932
the output would then equal DF.

12485
09:05:11,811 --> 09:05:12,644
It would just grab those initials.

12486
09:05:12,644 --> 09:05:13,477
So it's not a very robust function.

12487
09:05:13,477 --> 09:05:15,320
Actually it could be quite error prone,

12488
09:05:15,320 --> 09:05:17,620
but for simplicity sake,
this is what it does.

12489
09:05:18,688 --> 09:05:20,860
If you parse in a string
with that separated by space,

12490
09:05:20,860 --> 09:05:21,780
you'll get back the initials

12491
09:05:21,780 --> 09:05:23,480
and let's just assume it the name.

12492
09:05:24,640 --> 09:05:26,580
Now, if you wanna call this from Kotlin,

12493
09:05:26,580 --> 09:05:28,380
of course, we're very
easy, we can do that.

12494
09:05:28,380 --> 09:05:30,580
So with let's assume
we have a customer here

12495
09:05:31,739 --> 09:05:32,572
and the customer has a name property.

12496
09:05:32,572 --> 09:05:35,610
So again, if we go look
at what a customer is,

12497
09:05:35,610 --> 09:05:37,330
it's we have a customer class.

12498
09:05:38,450 --> 09:05:40,190
So it's a very simple data class.

12499
09:05:41,759 --> 09:05:42,592
Now, if we have a name, a name as a string

12500
09:05:42,592 --> 09:05:45,050
as we can see here, and we
can just get the initials

12501
09:05:45,050 --> 09:05:48,950
off of the name, so that's
pretty easy in Kotlin.

12502
09:05:48,950 --> 09:05:50,920
So now we have the initials,
we can do whatever we want

12503
09:05:50,920 --> 09:05:51,950
and make sense.

12504
09:05:51,950 --> 09:05:53,690
However, there are times
when you would like

12505
09:05:53,690 --> 09:05:58,060
to call these extinction
functions from a Java file.

12506
09:05:58,060 --> 09:05:59,380
The question is, can you do it?

12507
09:05:59,380 --> 09:06:01,250
So let's assume that
we have this Java file

12508
09:06:01,250 --> 09:06:04,542
that processes customers,
and in this method,

12509
09:06:04,542 --> 09:06:05,600
customer from social.

12510
09:06:05,600 --> 09:06:08,250
Assume, we are retrieving
a customer profile

12511
09:06:09,917 --> 09:06:12,787
from a social API, and here
we have the customer object.

12512
09:06:12,787 --> 09:06:14,237
Now we wanna use user's name.

12513
09:06:15,658 --> 09:06:16,690
So of course we have get named,
which is generated for us.

12514
09:06:16,690 --> 09:06:19,577
Now if we were to type
initials, we're gonna see

12515
09:06:19,577 --> 09:06:21,100
that it doesn't exist
because extension functions

12516
09:06:21,100 --> 09:06:22,950
don't exist in Java,

12517
09:06:22,950 --> 09:06:27,220
but we can still use that
code that we'd wrote in Kotlin

12518
09:06:27,220 --> 09:06:29,050
as an extension function.

12519
09:06:29,050 --> 09:06:31,280
And previously, if you've
worked inside of Java,

12520
09:06:31,280 --> 09:06:33,180
you've probably written
a lot of helper functions

12521
09:06:33,180 --> 09:06:36,220
and they've been inside of
basically static classes.

12522
09:06:36,220 --> 09:06:39,990
And so what we'll go ahead and
do is the string extensions

12523
09:06:39,990 --> 09:06:43,840
file actually generates a file for you.

12524
09:06:43,840 --> 09:06:47,298
So this is a top of a function
it's not inside of a class

12525
09:06:47,298 --> 09:06:48,790
at all, but it does
generate a file for you.

12526
09:06:50,155 --> 09:06:50,988
And so if we type string extensions,

12527
09:06:50,988 --> 09:06:53,550
you'll see string extensions
and a kt at the end.

12528
09:06:53,550 --> 09:06:56,790
String of tensions kt and
then there's a static method

12529
09:06:56,790 --> 09:07:00,009
called initials, you parse in a string,

12530
09:07:00,009 --> 09:07:01,910
and now you can get your initials.

12531
09:07:02,879 --> 09:07:05,410
So you can say string initials equals.

12532
09:07:06,820 --> 09:07:09,180
And this will call into
if I go to the definition,

12533
09:07:09,180 --> 09:07:11,330
calls into this extension function.

12534
09:07:12,780 --> 09:07:15,120
So this is how you can call
into an extension function

12535
09:07:15,120 --> 09:07:17,410
inside of Kotlin.

12536
09:07:17,410 --> 09:07:19,070
So any extinction function you have,

12537
09:07:19,070 --> 09:07:20,820
you'll wanna look at the actual file name.

12538
09:07:20,820 --> 09:07:23,990
Now there is a way to modify
the file name and using

12539
09:07:25,377 --> 09:07:26,210
the JVM name annotation.

12540
09:07:26,210 --> 09:07:28,220
And I'll show you that in another video,

12541
09:07:28,220 --> 09:07:30,720
but if you wanna call into
any of your extensions.

12542
09:07:31,842 --> 09:07:33,060
So if this was just called extensions.kt,

12543
09:07:34,914 --> 09:07:35,747
then in that case, it would
just be extensions kt.

12544
09:07:35,747 --> 09:07:38,270
So basically slaps the
two letter kt at the end.

12545
09:07:39,307 --> 09:07:40,140
And then at that point in time,

12546
09:07:40,140 --> 09:07:43,030
you can access it just as if
you did with a regular helper

12547
09:07:43,030 --> 09:07:46,141
function that you may
have traditionally built

12548
09:07:46,141 --> 09:07:46,974
inside of Java.

12549
09:07:46,974 --> 09:07:49,890
And that's how you call an
extension can function from Java.

12550
09:07:51,660 --> 09:07:55,300
Calling an extinction
function from Java works,

12551
09:07:55,300 --> 09:07:57,950
but let's be honest, it looks
a little bit clunky here.

12552
09:07:57,950 --> 09:08:01,230
There's this weird kt thing
that we have at the end,

12553
09:08:01,230 --> 09:08:03,090
which we didn't specify there.

12554
09:08:03,090 --> 09:08:04,940
Inside of the string extensions file,

12555
09:08:06,073 --> 09:08:06,906
it just looks like this.

12556
09:08:06,906 --> 09:08:08,880
We never specified a kt in here.

12557
09:08:08,880 --> 09:08:11,130
So having kt riddled
throughout your code base

12558
09:08:11,130 --> 09:08:14,990
can be kind of a weird feeling
and kind of a code smell.

12559
09:08:14,990 --> 09:08:17,990
Thankfully, the folks
over who developed Kotlin

12560
09:08:17,990 --> 09:08:19,040
thought of this.

12561
09:08:19,040 --> 09:08:21,310
And what you can do is
actually change the name

12562
09:08:21,310 --> 09:08:22,730
of the actual file is generated.

12563
09:08:22,730 --> 09:08:25,410
And what you can do is add
this annotation called file,

12564
09:08:25,410 --> 09:08:28,580
JVM name and provide the name of the file.

12565
09:08:28,580 --> 09:08:31,090
So here, I would wanna
say string extensions,

12566
09:08:31,090 --> 09:08:34,170
or I could say string utils,
so say a tree extensions.

12567
09:08:35,940 --> 09:08:37,780
Let's save that and we'll go
back to where I'm calling it

12568
09:08:37,780 --> 09:08:38,613
from Java.

12569
09:08:38,613 --> 09:08:40,920
And then immediately we
noticed that our previous call

12570
09:08:40,920 --> 09:08:42,720
in here is not working anymore.

12571
09:08:42,720 --> 09:08:44,940
So if we were just
typed string extensions,

12572
09:08:44,940 --> 09:08:47,180
now we just see string
extensions.initials.

12573
09:08:48,299 --> 09:08:50,860
So I can go ahead and fix
this by just ruin the kt.

12574
09:08:50,860 --> 09:08:55,860
Now I don't even really know
that I'm using Kotlin at all.

12575
09:08:55,940 --> 09:08:58,100
It's not basically polluting my code base

12576
09:08:58,100 --> 09:08:59,710
inside of my Java files.

12577
09:09:01,053 --> 09:09:02,410
Now there may be various
reasons why you can't move this

12578
09:09:02,410 --> 09:09:04,270
to Kotlin, and if that's the case,

12579
09:09:04,270 --> 09:09:06,220
this might be a very good use to you.

12580
09:09:06,220 --> 09:09:08,270
Or if you're exposing
your extension functions

12581
09:09:08,270 --> 09:09:11,100
to outside callers in other JVM languages,

12582
09:09:11,100 --> 09:09:13,165
you may wanna go ahead
and provide a JVM name.

12583
09:09:13,165 --> 09:09:16,200
So it's nice and extensible and readable

12584
09:09:16,200 --> 09:09:18,150
and doesn't pollute their code as well.

12585
09:09:19,802 --> 09:09:20,635
Now you can name this, anything you want.

12586
09:09:20,635 --> 09:09:21,710
It doesn't have to be
whatever the file name is.

12587
09:09:21,710 --> 09:09:26,710
If I want this to be happy
clown file, happy clown stuff.

12588
09:09:26,830 --> 09:09:29,712
I'm gonna go over to customer
service and we're gonna see

12589
09:09:29,712 --> 09:09:30,545
that this doesn't work.

12590
09:09:30,545 --> 09:09:33,630
I'm gonna have to replace
this with happy clown stuff.

12591
09:09:33,630 --> 09:09:36,620
And so I can give that JVM
file name whatever I want,

12592
09:09:36,620 --> 09:09:37,950
that's what that's gonna be.

12593
09:09:37,950 --> 09:09:39,650
And so that wouldn't work anymore.

12594
09:09:40,800 --> 09:09:42,160
So of course we would never
wanna name something like that,

12595
09:09:42,160 --> 09:09:46,100
but we can go and take it
back to string extensions.

12596
09:09:46,100 --> 09:09:48,550
We'll save that, again
that's not gonna work

12597
09:09:48,550 --> 09:09:50,470
the string extensions.

12598
09:09:50,470 --> 09:09:53,120
So anytime you are working with something

12599
09:09:53,120 --> 09:09:56,200
like the Kotlin file that has
a lot of top level functions,

12600
09:09:56,200 --> 09:09:57,710
which this is a top level function

12601
09:09:57,710 --> 09:09:59,030
that's not inside of a class.

12602
09:09:59,030 --> 09:10:00,960
It's just basically sitting
inside of a file somewhere

12603
09:10:00,960 --> 09:10:02,810
at the top level function.

12604
09:10:02,810 --> 09:10:05,900
And you need to expose those
to other JVM languages,

12605
09:10:05,900 --> 09:10:09,580
such as Java, and you want it
to have a nice pretty name.

12606
09:10:09,580 --> 09:10:12,270
Go ahead and slap the JVM
name annotation on there

12607
09:10:12,270 --> 09:10:14,880
at the top of the file, and
it will change the name.

12608
09:10:14,880 --> 09:10:17,310
So therefore when you call
it from another language,

12609
09:10:17,310 --> 09:10:19,550
it'll look nice and
won't pollute the code.

12610
09:10:20,830 --> 09:10:22,790
Quick little hack I wanna show you.

12611
09:10:22,790 --> 09:10:24,880
Instead of any file, you
can put a top level function

12612
09:10:24,880 --> 09:10:27,170
called main and inside
of this main function

12613
09:10:28,247 --> 09:10:29,080
anywhere you want, you can print line

12614
09:10:29,080 --> 09:10:30,300
or do whatever you want.

12615
09:10:30,300 --> 09:10:32,210
And what you can do is type code here.

12616
09:10:32,210 --> 09:10:35,460
Now I can actually run this
directly here inside of the IDE

12617
09:10:35,460 --> 09:10:36,890
and it will execute this code.

12618
09:10:36,890 --> 09:10:38,920
Now I do have another main file down here,

12619
09:10:38,920 --> 09:10:41,600
which is where my main
application would normally start.

12620
09:10:41,600 --> 09:10:44,510
However, if I'm buried
somewhere in my application

12621
09:10:44,510 --> 09:10:46,040
and I would like to test out a quick idea,

12622
09:10:46,040 --> 09:10:48,980
maybe I'm kind of working with
the red I wanna play with.

12623
09:10:48,980 --> 09:10:51,030
I can just run this directly
right here and I can hit run.

12624
09:10:51,030 --> 09:10:53,763
I can do debugging everything.

12625
09:10:53,763 --> 09:10:56,320
And if I hit run down in the
output window, we'll see foo.

12626
09:10:56,320 --> 09:10:58,620
So this can be anywhere,
I can take this here.

12627
09:10:59,825 --> 09:11:00,658
I can go over to a customer class.

12628
09:11:00,658 --> 09:11:02,110
I can put a function over here

12629
09:11:05,500 --> 09:11:06,580
and I can do something here

12630
09:11:06,580 --> 09:11:07,930
and I can run something from here.

12631
09:11:07,930 --> 09:11:10,210
So anywhere you put a main
on top of main function,

12632
09:11:10,210 --> 09:11:12,110
you can execute it with inside of the IDE

12633
09:11:12,110 --> 09:11:15,150
for quick feedback loop
inside of IntelliJ.

12634
09:11:15,150 --> 09:11:17,540
Sometimes you wanna
interact with your code

12635
09:11:17,540 --> 09:11:20,780
and a session where you
can kind of play with it.

12636
09:11:20,780 --> 09:11:23,050
One way you can do that
is with the Kotlin repl,

12637
09:11:23,050 --> 09:11:25,230
which is a real evil print loop.

12638
09:11:26,070 --> 09:11:28,890
And to do that again, that's
through tools, Kotlin,

12639
09:11:28,890 --> 09:11:32,600
Kotlin repl, and once
everything is loaded,

12640
09:11:32,600 --> 09:11:34,030
then you can start typing code into here.

12641
09:11:34,030 --> 09:11:36,320
So for example, let's assume
that we wanted to go ahead

12642
09:11:36,320 --> 09:11:37,610
and build a string.

12643
09:11:37,610 --> 09:11:40,500
So we say val name equals Donn.

12644
09:11:41,590 --> 09:11:43,710
And then I use command enter
to enter into a new line.

12645
09:11:43,710 --> 09:11:46,680
I can say name.length, command line.

12646
09:11:46,680 --> 09:11:49,730
It'll tell me if they integer
it's four characters long.

12647
09:11:50,710 --> 09:11:53,160
I can do other things such
as name that substring

12648
09:11:56,010 --> 09:11:58,460
and I'll get the nice IntelliSense in here

12649
09:11:58,460 --> 09:12:00,390
or code completion.

12650
09:12:00,390 --> 09:12:02,340
And we go with the first
character, there is D.

12651
09:12:02,340 --> 09:12:05,670
I can also use, for example,
some of the classes I have.

12652
09:12:05,670 --> 09:12:08,150
I have a customer class
here, which is a data class.

12653
09:12:08,150 --> 09:12:10,879
I can use that inside of my
repl, 'cause it was loaded,

12654
09:12:10,879 --> 09:12:11,940
so I can say customer.

12655
09:12:11,940 --> 09:12:14,330
So I can go down tab, and what will happen

12656
09:12:14,330 --> 09:12:16,760
is you'll see it actually
imported customer there for me.

12657
09:12:16,760 --> 09:12:21,760
And so I'm gonna say val
customer equals customer

12658
09:12:24,260 --> 09:12:25,810
Donn enter.

12659
09:12:26,690 --> 09:12:28,550
And so had to import it
because if I don't import it,

12660
09:12:28,550 --> 09:12:30,130
I won't know about it inside of the repl.

12661
09:12:30,130 --> 09:12:32,110
So I can say customer and if
I hit enter on a customer,

12662
09:12:32,110 --> 09:12:34,010
it'll tell me the type of the customer

12663
09:12:34,976 --> 09:12:36,360
and then what the two string value is.

12664
09:12:36,360 --> 09:12:37,890
And so I can say customer.name.

12665
09:12:41,612 --> 09:12:43,440
I can also do customer.name.initials.

12666
09:12:44,806 --> 09:12:49,806
Now notice this I'm actually
calling in a extension function

12667
09:12:52,170 --> 09:12:53,410
that I have, it's called initials

12668
09:12:53,410 --> 09:12:55,712
and we we have an exception there.

12669
09:12:55,712 --> 09:12:56,545
And the reason why we got an exception

12670
09:12:56,545 --> 09:12:58,720
is because the string value of customer,

12671
09:12:58,720 --> 09:13:00,290
it does not have a space in it.

12672
09:13:00,290 --> 09:13:01,880
So if I were to redefine my customer,

12673
09:13:01,880 --> 09:13:03,280
so we'd do another customer,

12674
09:13:05,175 --> 09:13:07,200
customer two equals Howard Parr.

12675
09:13:08,155 --> 09:13:08,988
I had my full name with a space

12676
09:13:08,988 --> 09:13:10,480
then the initials function would work.

12677
09:13:11,840 --> 09:13:12,673
And I didn't tell it to execute yet,

12678
09:13:12,673 --> 09:13:15,430
I just pressed the enter,

12679
09:13:15,430 --> 09:13:20,130
and I say, initial
customer two.name.initials.

12680
09:13:20,130 --> 09:13:20,963
Now, if I enter here,

12681
09:13:20,963 --> 09:13:23,270
we'll see that it does execute properly.

12682
09:13:23,270 --> 09:13:26,180
So you can actually interact
and do all different types

12683
09:13:26,180 --> 09:13:28,890
of things inside of the Kotlin repl.

12684
09:13:28,890 --> 09:13:32,110
And again, that's access
via the tools, Kotlin.

12685
09:13:32,110 --> 09:13:33,531
Kotlin repl.

12686
09:13:33,531 --> 09:13:34,730
So it's a good place to
come around and play around

12687
09:13:34,730 --> 09:13:37,130
with some code that you're maybe testing,

12688
09:13:37,130 --> 09:13:38,730
trying to figure out if
it's going to work or not.

12689
09:13:38,730 --> 09:13:41,710
Maybe you're trying to
understand a certain interaction

12690
09:13:41,710 --> 09:13:43,942
with the library and you don't
wanna fire up an application.

12691
09:13:43,942 --> 09:13:45,890
The repl is a great place
where you can do that.

12692
09:13:45,890 --> 09:13:47,750
And when you're done, you
can go ahead and over here

12693
09:13:47,750 --> 09:13:50,600
and hit the close button and
then you're out of the repl.

12694
09:13:51,760 --> 09:13:55,290
So let's go ahead and
create a actual Kotlin

12695
09:13:55,290 --> 09:13:56,420
simple calculator.

12696
09:13:56,420 --> 09:13:57,520
To do that, you open IntelliJ,

12697
09:13:57,520 --> 09:14:00,300
you'll click create new project.

12698
09:14:00,300 --> 09:14:03,310
You're gonna wanna select
Kotlin from the left-hand side,

12699
09:14:03,310 --> 09:14:04,280
then JVM idea.

12700
09:14:06,637 --> 09:14:09,180
You wanna give it a name, I
want to say simple calculator.

12701
09:14:10,680 --> 09:14:13,810
You can you leave these
default settings enabled

12702
09:14:13,810 --> 09:14:14,643
and hit finish.

12703
09:14:16,970 --> 09:14:19,697
This is gonna go ahead and
create a new project for us.

12704
09:14:19,697 --> 09:14:20,730
On the left-hand side if the
project window is not open,

12705
09:14:20,730 --> 09:14:23,732
go ahead and click the
project window to open it,

12706
09:14:23,732 --> 09:14:24,565
the project explorer.

12707
09:14:24,565 --> 09:14:27,217
And instead of SRC, we're
just gonna create a new file.

12708
09:14:27,217 --> 09:14:28,660
So you can right click or command in.

12709
09:14:30,379 --> 09:14:33,150
So right click new cotton file class.

12710
09:14:33,150 --> 09:14:34,350
I wanna call it main.kt.

12711
09:14:36,980 --> 09:14:37,910
Now it's an empty file here.

12712
09:14:37,910 --> 09:14:39,680
Now at this point in time,
we needed to go ahead

12713
09:14:39,680 --> 09:14:43,860
and fill this out so we can say fun main.

12714
09:14:43,860 --> 09:14:46,360
That's gonna be the main
function, open and close.

12715
09:14:48,260 --> 09:14:49,860
And now we have a main function.

12716
09:14:52,266 --> 09:14:53,099
Now typically a main function

12717
09:14:53,099 --> 09:14:56,142
will have some type of
parameters it can be parsed to it

12718
09:14:56,142 --> 09:14:56,975
from a command line.

12719
09:14:56,975 --> 09:14:59,588
So that's gonna be var Argh, Argh string,

12720
09:14:59,588 --> 09:15:00,421
which means that there
could be many variable

12721
09:15:00,421 --> 09:15:02,340
amount of arguments that are parsed in.

12722
09:15:03,578 --> 09:15:04,411
It's been basically great out

12723
09:15:04,411 --> 09:15:05,950
'cause they're not used right now.

12724
09:15:07,638 --> 09:15:08,471
So none at this point in time,

12725
09:15:08,471 --> 09:15:09,870
we're ready to start
building our application.

12726
09:15:09,870 --> 09:15:11,980
And the first thing we can
do is provide some type

12727
09:15:11,980 --> 09:15:16,980
of basic output and we'll
say, please enter and arith.

12728
09:15:21,230 --> 09:15:22,980
Please enter an arithmetic problem.

12729
09:15:24,693 --> 09:15:27,147
And if we save this and then
we click this little run button

12730
09:15:27,147 --> 09:15:29,420
now and hit run main kt, will
know this is going to build

12731
09:15:29,420 --> 09:15:31,260
down here, and then down at the bottom,

12732
09:15:31,260 --> 09:15:32,890
the run window will open and it'll say,

12733
09:15:32,890 --> 09:15:35,090
please enter an arithmetic problem.

12734
09:15:35,090 --> 09:15:36,860
At this point in time,
you've actually created

12735
09:15:36,860 --> 09:15:40,060
your first Kotlin program,
though all it does really

12736
09:15:40,060 --> 09:15:43,450
is write some text to a console and exit,

12737
09:15:43,450 --> 09:15:46,049
and we can see that
the program has exited.

12738
09:15:46,049 --> 09:15:47,400
So basically the execution of program

12739
09:15:47,400 --> 09:15:48,700
started the main function.

12740
09:15:49,779 --> 09:15:51,780
It printed this, had nothing
left to do and it exited.

12741
09:15:51,780 --> 09:15:54,617
So that is the beginning
of our application.

12742
09:15:54,617 --> 09:15:57,620
So we've built the first
version of our application,

12743
09:15:57,620 --> 09:16:00,510
but we need to receive
some input from the user.

12744
09:16:00,510 --> 09:16:02,970
And to do that, we can
use the read line function

12745
09:16:02,970 --> 09:16:04,920
that's built into kotlin.io.

12746
09:16:04,920 --> 09:16:07,130
And his is built into the platform.

12747
09:16:07,130 --> 09:16:09,240
And this allows us to read
some input from the user

12748
09:16:09,240 --> 09:16:10,490
on the command line.

12749
09:16:10,490 --> 09:16:12,590
And then what we can do is say print line,

12750
09:16:13,815 --> 09:16:15,840
let's say you entered the
value that you entered

12751
09:16:15,840 --> 09:16:17,190
using string interpolation.

12752
09:16:18,280 --> 09:16:21,941
And if we go ahead and run
this now in the output window,

12753
09:16:21,941 --> 09:16:24,050
down below, what you're
going to see down here

12754
09:16:24,050 --> 09:16:26,470
is that please enter
your arithmetic problem.

12755
09:16:26,470 --> 09:16:30,250
Let's see one plus two and
then we'll see over here

12756
09:16:30,250 --> 09:16:32,130
that you entered one plus two,

12757
09:16:33,558 --> 09:16:34,720
and then of course the application exited

12758
09:16:34,720 --> 09:16:36,340
at that point in time.

12759
09:16:36,340 --> 09:16:39,030
So this works great, we
can now get some values

12760
09:16:39,030 --> 09:16:39,863
from the user.

12761
09:16:39,863 --> 09:16:42,030
But just like a regular calculator,

12762
09:16:42,030 --> 09:16:44,580
a calculator is not going
to stop after you enter

12763
09:16:44,580 --> 09:16:46,670
one problem, so we need to
enter multiple problems.

12764
09:16:46,670 --> 09:16:49,670
And this is a perfect
opportunity to use a wile loop.

12765
09:16:49,670 --> 09:16:52,740
So what we're gonna say is,
while while is not null,

12766
09:16:54,650 --> 09:16:58,590
then we can go ahead and grab some values.

12767
09:16:58,590 --> 09:17:03,590
And so it we'll say here is we
need to get the input again,

12768
09:17:08,984 --> 09:17:10,657
and then let's go ahead
and print this here.

12769
09:17:11,669 --> 09:17:12,768
So we did val, we need
to make this a var now,

12770
09:17:12,768 --> 09:17:15,681
'cause we're gonna be
resetting it every time.

12771
09:17:15,681 --> 09:17:17,360
Now let's go ahead and
print line what we know

12772
09:17:18,465 --> 09:17:21,750
you entered input.

12773
09:17:21,750 --> 09:17:23,490
Now we're gonna run into a problem here

12774
09:17:23,490 --> 09:17:27,740
because we haven't told a way
for the while line to exit.

12775
09:17:27,740 --> 09:17:30,030
And if we know anything
about the read line,

12776
09:17:30,030 --> 09:17:32,660
what read line says is
it will return a read

12777
09:17:32,660 --> 09:17:35,550
or null if the input stream
is redirected to the file.

12778
09:17:35,550 --> 09:17:36,840
We're not redirecting to a file,

12779
09:17:36,840 --> 09:17:38,830
so we're not going to get null back.

12780
09:17:38,830 --> 09:17:41,680
So if I press enter, we're
probably gonna get a line feed

12781
09:17:42,515 --> 09:17:43,348
inside of here.

12782
09:17:43,348 --> 09:17:45,836
So what we need to do is
have a way to short circuit

12783
09:17:45,836 --> 09:17:46,669
out of the wild loop.

12784
09:17:46,669 --> 09:17:49,260
Otherwise this chunk of code
will just continually run on

12785
09:17:49,260 --> 09:17:50,910
forever, there's no way
for us to get out of it.

12786
09:17:50,910 --> 09:17:53,110
So if we were to run this
now, let's go and see

12787
09:17:53,110 --> 09:17:54,550
what that looks like.

12788
09:17:54,550 --> 09:17:57,530
Let's run it and that's enter a problem.

12789
09:17:57,530 --> 09:18:02,493
One plus two, okay, two plus
three, five divided by 10.

12790
09:18:03,590 --> 09:18:08,510
If I enter, we can't get
out of this, we're stuck.

12791
09:18:08,510 --> 09:18:10,270
So we need to wait it to
short suit circuit out.

12792
09:18:10,270 --> 09:18:11,961
So I'm gonna stop the program.

12793
09:18:11,961 --> 09:18:14,310
So we do need to actually figure out a way

12794
09:18:14,310 --> 09:18:15,143
to get out of this.

12795
09:18:15,143 --> 09:18:17,610
So what we can do is we can check to see

12796
09:18:18,453 --> 09:18:19,286
if the input is null.

12797
09:18:19,286 --> 09:18:20,600
So if the input does not equal to null,

12798
09:18:21,640 --> 09:18:22,473
that's what we're doing,
but let's also check

12799
09:18:22,473 --> 09:18:23,306
to see if it's empty.

12800
09:18:23,306 --> 09:18:27,770
So, and the input is not blank.

12801
09:18:28,850 --> 09:18:31,590
So if we go look at the
implementation of that,

12802
09:18:31,590 --> 09:18:34,650
returns true if it's not empty
and contains some characters

12803
09:18:34,650 --> 09:18:36,350
except the white space characters.

12804
09:18:37,736 --> 09:18:38,569
So we wanna make sure it's not blank

12805
09:18:38,569 --> 09:18:39,610
it just contain something.

12806
09:18:41,446 --> 09:18:44,176
So if that's the case,
then this piece of code

12807
09:18:44,176 --> 09:18:45,009
will just continue executing.

12808
09:18:45,009 --> 09:18:46,700
And this will be the main in a moment,

12809
09:18:47,675 --> 09:18:49,390
this would be the main
section of our calculator app.

12810
09:18:50,406 --> 09:18:51,239
So let's go ahead and run this again

12811
09:18:51,239 --> 09:18:52,072
to see what this looks like.

12812
09:18:53,400 --> 09:18:56,300
And once we run this, we'll
see, okay, one plus two,

12813
09:18:56,300 --> 09:18:58,160
there we go, we got two plus three,

12814
09:18:59,561 --> 09:19:00,394
we got five divided by 10,

12815
09:19:00,394 --> 09:19:01,440
so we can keep entering
things over and over.

12816
09:19:01,440 --> 09:19:04,410
However, now if I press
enter, what we're gonna see

12817
09:19:04,410 --> 09:19:07,220
is that the process finished right there.

12818
09:19:07,220 --> 09:19:08,840
So it exited out of the application,

12819
09:19:08,840 --> 09:19:13,840
because what it made it exit
out is basically it is blank.

12820
09:19:15,430 --> 09:19:17,860
So therefore it only
continues if it's not blank.

12821
09:19:17,860 --> 09:19:20,040
Therefore the application
said, well, it's blank.

12822
09:19:20,040 --> 09:19:22,250
And at that point it exited.

12823
09:19:22,250 --> 09:19:24,621
So now you can do a couple of things here.

12824
09:19:24,621 --> 09:19:26,250
So if you wanted to say goodbye,

12825
09:19:27,437 --> 09:19:28,270
you could pretty much do that right here.

12826
09:19:28,270 --> 09:19:29,990
You could say print ln goodbye.

12827
09:19:34,491 --> 09:19:35,660
And then you would know that
the proper program exited.

12828
09:19:35,660 --> 09:19:37,410
So we could do this very easily.

12829
09:19:37,410 --> 09:19:40,610
You'd hit run here and now we can enter

12830
09:19:41,729 --> 09:19:44,530
that arithmetic problems,
one plus two, three,

12831
09:19:44,530 --> 09:19:47,903
33 plus two and an enter
and I was like, goodbye.

12832
09:19:47,903 --> 09:19:48,736
And then it exits.

12833
09:19:48,736 --> 09:19:50,660
So we know that the
actual program is exiting.

12834
09:19:51,881 --> 09:19:52,714
Of course, we do know
that already from here,

12835
09:19:52,714 --> 09:19:53,750
but when we compile it later,

12836
09:19:53,750 --> 09:19:56,470
it would be nice to have
some user feedback to say,

12837
09:19:56,470 --> 09:19:58,270
hey, we're done with the program.

12838
09:19:58,270 --> 09:20:01,000
So now we can actually
create our calculator

12839
09:20:01,000 --> 09:20:02,860
inside of this piece here,

12840
09:20:02,860 --> 09:20:05,850
because we can now process
many different problems.

12841
09:20:05,850 --> 09:20:07,050
One after another.

12842
09:20:07,050 --> 09:20:09,020
Each time we're gonna get some new input

12843
09:20:09,020 --> 09:20:11,420
via this read line method,
which then will change.

12844
09:20:11,420 --> 09:20:13,020
And then we can process it,

12845
09:20:13,020 --> 09:20:14,970
which we'll end up doing right in here.

12846
09:20:16,030 --> 09:20:17,630
Now that we have the user input,

12847
09:20:17,630 --> 09:20:20,420
we need to decide what to
do with that user input.

12848
09:20:20,420 --> 09:20:21,580
So when you kind of need to break it apart

12849
09:20:21,580 --> 09:20:23,662
into a couple of sections.

12850
09:20:23,662 --> 09:20:25,890
If we have a problem
that's entered like this,

12851
09:20:25,890 --> 09:20:27,310
we need three different components.

12852
09:20:27,310 --> 09:20:29,610
We need the first number when the operator

12853
09:20:30,470 --> 09:20:31,970
and we need the second number.

12854
09:20:33,125 --> 09:20:33,958
So we're gonna need three
different types of variables

12855
09:20:33,958 --> 09:20:34,791
from that one string.

12856
09:20:35,754 --> 09:20:36,710
And we can do that very easily,

12857
09:20:36,710 --> 09:20:37,870
so it's go and get rid of this.

12858
09:20:37,870 --> 09:20:41,340
We can do it very easily by
declaring another variable

12859
09:20:41,340 --> 09:20:42,920
called values.

12860
09:20:42,920 --> 09:20:44,840
And what we're going to
do is we're gonna split

12861
09:20:44,840 --> 09:20:48,410
the string on a space.

12862
09:20:48,410 --> 09:20:50,750
And what that will do is it'll
give us a list of strings

12863
09:20:50,750 --> 09:20:52,480
that we can go ahead and check on.

12864
09:20:52,480 --> 09:20:53,610
So let's go ahead and take a look

12865
09:20:53,610 --> 09:20:54,980
at each one of these strings.

12866
09:20:54,980 --> 09:20:58,220
So we'll say values zero.

12867
09:20:58,220 --> 09:21:01,240
I'm gonna duplicate this line
a few times, one and two.

12868
09:21:02,624 --> 09:21:04,430
Now of course, this is
not gonna be error proof.

12869
09:21:05,384 --> 09:21:07,450
If for some reason we do not
get enough values in here,

12870
09:21:07,450 --> 09:21:09,800
we could crash the program,

12871
09:21:11,138 --> 09:21:11,971
which we'll see here in a second.

12872
09:21:11,971 --> 09:21:15,000
If we run the main program,
what we'll see here,

12873
09:21:15,000 --> 09:21:17,760
please enter arithmetic
problem one plus two.

12874
09:21:17,760 --> 09:21:20,195
We'll then see that we
have all of the operators

12875
09:21:20,195 --> 09:21:22,350
now separated, so we have
the number one, number two.

12876
09:21:22,350 --> 09:21:24,500
If we were to do five plus four,

12877
09:21:25,390 --> 09:21:26,410
we would get those broken apart.

12878
09:21:26,410 --> 09:21:28,540
But if I only put five in here,

12879
09:21:28,540 --> 09:21:31,150
we're gonna get an index
out of bounds exception

12880
09:21:31,150 --> 09:21:32,980
right here on the 10th line,

12881
09:21:32,980 --> 09:21:36,240
because I'm just pressing
press five in there

12882
09:21:36,240 --> 09:21:38,550
is split on a string, so it's
not finding this and saying,

12883
09:21:38,550 --> 09:21:41,400
hey, there is nothing inside of here.

12884
09:21:42,614 --> 09:21:43,590
It looks like by found a
string or or a new line

12885
09:21:43,590 --> 09:21:44,540
or something there.

12886
09:21:45,820 --> 09:21:48,290
So we can't find anything in that regard.

12887
09:21:48,290 --> 09:21:50,490
So we're gonna go ahead
and don't acception.

12888
09:21:51,640 --> 09:21:53,060
So this isn't really
foolproof, but it does give us

12889
09:21:53,060 --> 09:21:57,310
the ability to actually start
performing our operation.

12890
09:21:57,310 --> 09:21:59,340
Now, the one that's really
important to us right now

12891
09:21:59,340 --> 09:22:01,470
is actually this first one.

12892
09:22:01,470 --> 09:22:05,010
And this is because this is
what's gonna give us our plus,

12893
09:22:05,010 --> 09:22:09,210
our minus our multiplication
or our divide operator.

12894
09:22:09,210 --> 09:22:10,689
And then at that point,

12895
09:22:10,689 --> 09:22:14,150
we can decide how we wanna
progress in our application.

12896
09:22:14,150 --> 09:22:19,150
And so, based upon if
this value is a plus sign,

12897
09:22:23,960 --> 09:22:26,990
well, then at that point, I
wanna do add something together.

12898
09:22:28,200 --> 09:22:30,900
And so it's gonna say we're
actually doing print line.

12899
09:22:32,080 --> 09:22:33,060
There we go.

12900
09:22:33,060 --> 09:22:35,470
If the value is a plus
sign, then we're gonna go on

12901
09:22:35,470 --> 09:22:37,940
and go ahead and add it together.

12902
09:22:37,940 --> 09:22:41,130
Otherwise, you know, we
can say else if values

12903
09:22:42,030 --> 09:22:46,310
is values one equals equals minus,

12904
09:22:46,310 --> 09:22:48,310
then we can do something else.

12905
09:22:48,310 --> 09:22:51,170
So we could continue this
path down of else if.

12906
09:22:51,170 --> 09:22:52,840
And this will work, there's
nothing wrong with this.

12907
09:22:52,840 --> 09:22:54,810
We could do this, this'll work.

12908
09:22:54,810 --> 09:22:57,070
However, it does get a little clunky.

12909
09:22:57,070 --> 09:22:59,090
This is a perfect opportunity for us

12910
09:22:59,090 --> 09:23:01,700
to use a when statement.

12911
09:23:01,700 --> 09:23:06,000
So I'm gonna say when values
one, so check that value one.

12912
09:23:07,974 --> 09:23:12,117
And when you say is plus
I wanna do something,

12913
09:23:13,080 --> 09:23:14,610
so, say print line, when is.

12914
09:23:24,270 --> 09:23:25,630
And it is not gonna be needed here

12915
09:23:25,630 --> 09:23:27,880
because we're actually
just using it to directly

12916
09:23:27,880 --> 09:23:28,780
against the value.

12917
09:23:30,110 --> 09:23:34,250
So we'll say, plus, we can say minus

12918
09:23:39,799 --> 09:23:42,030
that's it print line, subtract.

12919
09:23:44,529 --> 09:23:45,362
I'll go ahead and
duplicate these real quick.

12920
09:23:45,362 --> 09:23:47,326
And then we can go ahead
and of course we'll say

12921
09:23:47,326 --> 09:23:48,640
multiply and divide.

12922
09:23:48,640 --> 09:23:53,100
It'd be pretty easy and divide.

12923
09:23:56,100 --> 09:23:57,130
And then for whatever reason,

12924
09:23:57,130 --> 09:23:59,130
if we don't have something that matches,

12925
09:24:00,377 --> 09:24:02,927
we might wanna say, throw
legal argument exception.

12926
09:24:07,057 --> 09:24:10,000
Let me say invalid operator
and we'll just go ahead

12927
09:24:10,000 --> 09:24:13,040
and parse in whatever that value is.

12928
09:24:14,610 --> 09:24:18,660
So parse it in and values one.

12929
09:24:18,660 --> 09:24:19,750
And then that's gonna allow us to go

12930
09:24:19,750 --> 09:24:20,850
and get rid of this down here.

12931
09:24:20,850 --> 09:24:23,620
This will allow us to actually
see and do to something

12932
09:24:23,620 --> 09:24:26,872
different based upon each
one of these input types.

12933
09:24:26,872 --> 09:24:27,705
So let's go ahead and run this program.

12934
09:24:27,705 --> 09:24:31,550
We'll put a few of the
arithmetic problems in here.

12935
09:24:31,550 --> 09:24:34,690
So one plus one, so it
looks like we have add.

12936
09:24:34,690 --> 09:24:38,800
So I have one minus four, subtract.

12937
09:24:38,800 --> 09:24:43,290
We have six times seven, multiply,

12938
09:24:43,290 --> 09:24:47,470
42 divided by 10 is divide.

12939
09:24:47,470 --> 09:24:50,320
And let's go ahead and just
throw something crazy in there.

12940
09:24:50,320 --> 09:24:53,220
Let's do like for example,
maybe we wanna do powers of,

12941
09:24:53,220 --> 09:24:54,400
but we haven't implemented it.

12942
09:24:54,400 --> 09:24:57,130
We could do 10 to the power of five.

12943
09:24:58,100 --> 09:25:01,280
Boom, we have an exception
invalid operator.

12944
09:25:01,280 --> 09:25:03,220
And we add D to the power of operator,

12945
09:25:03,220 --> 09:25:06,220
which is normally used in
map instead of programs.

12946
09:25:06,220 --> 09:25:09,220
So here, our calculator
is a simple calculator.

12947
09:25:09,220 --> 09:25:13,310
It's only gonna process these
different types of inputs.

12948
09:25:13,310 --> 09:25:16,100
So now let's go ahead and
implement each one of these

12949
09:25:16,100 --> 09:25:18,050
and I'll be right back while I do that.

12950
09:25:18,887 --> 09:25:19,720
So you don't have to see me type.

12951
09:25:19,720 --> 09:25:20,553
Okay, now we're back.

12952
09:25:20,553 --> 09:25:24,400
So I've done this very easily,
I've taken the first value.

12953
09:25:24,400 --> 09:25:26,960
I convert it to a double
and take the second value

12954
09:25:26,960 --> 09:25:27,890
and I converted to a double.

12955
09:25:27,890 --> 09:25:29,190
I've converted everything to doubles here

12956
09:25:29,190 --> 09:25:31,037
so we don't lose any precision.

12957
09:25:31,037 --> 09:25:32,520
Now there's one thing I would like to do,

12958
09:25:32,520 --> 09:25:34,420
that would like to clean
this up a little bit.

12959
09:25:34,420 --> 09:25:37,070
So what I'm gonna do here
is let me go ahead and say,

12960
09:25:38,730 --> 09:25:42,740
I'm gonna refactor this,
and I'm just gonna say,

12961
09:25:42,740 --> 09:25:44,280
extract this into a variable.

12962
09:25:45,310 --> 09:25:47,190
And it's gonna ask me to
replace two occurrences

12963
09:25:47,190 --> 09:25:49,040
because it's occurring two places.

12964
09:25:49,040 --> 09:25:51,210
Sure and we call this operator,

12965
09:25:52,340 --> 09:25:53,900
just so it reads a little bit better.

12966
09:25:58,230 --> 09:26:00,080
It's actually saying we can
move it into the declaration

12967
09:26:00,080 --> 09:26:00,913
of the when.

12968
09:26:01,993 --> 09:26:04,080
And if we were to do that,
here's what it would look like.

12969
09:26:04,080 --> 09:26:05,790
I could just move that
into the declaration there.

12970
09:26:05,790 --> 09:26:07,660
I don't like the way that
looks, it looks a little bit,

12971
09:26:07,660 --> 09:26:09,010
it's too much for me to read.

12972
09:26:09,010 --> 09:26:10,420
This is a lot easier for me to read,

12973
09:26:10,420 --> 09:26:12,400
so I'm gonna leave it like that.

12974
09:26:12,400 --> 09:26:13,400
So I'm the operator.

12975
09:26:15,853 --> 09:26:16,880
And then what I could also
say is something like this.

12976
09:26:16,880 --> 09:26:19,990
I could go ahead and extract
this good refractor it.

12977
09:26:21,327 --> 09:26:22,340
I can extract this into a variable

12978
09:26:23,580 --> 09:26:24,700
and it does occur four times.

12979
09:26:24,700 --> 09:26:28,019
So we were repeating ourselves,
which could be problematic

12980
09:26:28,019 --> 09:26:28,852
for updating our code later.

12981
09:26:28,852 --> 09:26:30,840
So I'm gonna call this
LHS for left-hand side.

12982
09:26:33,436 --> 09:26:34,320
I'm gonna do the same thing over here.

12983
09:26:38,137 --> 09:26:39,381
I'm gonna go out and extract a variable.

12984
09:26:39,381 --> 09:26:40,700
We're gonna call right-hand side RHS

12985
09:26:41,791 --> 09:26:42,630
for all four occurrences.

12986
09:26:44,280 --> 09:26:48,980
So now we have our ever input
and we've got our operator,

12987
09:26:48,980 --> 09:26:50,500
our left hand side and
our right hand side.

12988
09:26:50,500 --> 09:26:52,710
And then this is pretty easy to see.

12989
09:26:52,710 --> 09:26:54,170
So when the operator is a plus sign,

12990
09:26:54,170 --> 09:26:56,220
we're gonna go ahead and print out the...

12991
09:26:57,286 --> 09:26:59,235
We're gonna convert all
these to doubles and say,

12992
09:26:59,235 --> 09:27:00,360
all right, so we don't lose any precision

12993
09:27:00,360 --> 09:27:02,990
which can happen sometimes in
multiplication and division,

12994
09:27:02,990 --> 09:27:05,115
depending upon what you're doing.

12995
09:27:05,115 --> 09:27:06,511
And then we're gonna go ahead

12996
09:27:06,511 --> 09:27:07,420
and actually perform the operation.

12997
09:27:07,420 --> 09:27:09,020
And then what we're gonna
do at that point in time

12998
09:27:09,020 --> 09:27:10,600
is we're gonna go and print that value

12999
09:27:10,600 --> 09:27:13,834
and then we're gonna go
ahead and do a read line.

13000
09:27:13,834 --> 09:27:15,310
So let's go and run this
to see what happens.

13001
09:27:17,140 --> 09:27:20,880
So I've entered arithmetic
problem one plus one, we get two.

13002
09:27:20,880 --> 09:27:24,160
Two times five and we see an index

13003
09:27:24,160 --> 09:27:25,340
right out of our exception.

13004
09:27:25,340 --> 09:27:27,288
That's because we didn't
put a space there.

13005
09:27:27,288 --> 09:27:29,030
So we do have a cup, some input problems

13006
09:27:29,030 --> 09:27:30,840
that we probably do need to process.

13007
09:27:30,840 --> 09:27:32,870
So let's go and see if we
can get you to one of these

13008
09:27:32,870 --> 09:27:33,820
to run accordingly.

13009
09:27:36,020 --> 09:27:39,360
So we already did a plus let's
go ahead and do a subtraction

13010
09:27:40,590 --> 09:27:41,490
minus six.

13011
09:27:41,490 --> 09:27:45,980
Okay, that makes sense,
eight times seven, 56.

13012
09:27:45,980 --> 09:27:50,530
Let's do 60 divided by ten, six.

13013
09:27:50,530 --> 09:27:51,810
So all that makes sense.

13014
09:27:51,810 --> 09:27:56,381
So our application does work
now, we now have a application,

13015
09:27:56,381 --> 09:28:01,381
which is a simple calculator
that shows us how to do adding,

13016
09:28:01,400 --> 09:28:03,150
subtracting, multiplying, dividing.

13017
09:28:04,300 --> 09:28:06,110
Our application works fine at this point,

13018
09:28:06,110 --> 09:28:08,720
but we do need to provide
some type of validation.

13019
09:28:08,720 --> 09:28:12,130
For example, let's go ahead
and run our application.

13020
09:28:12,130 --> 09:28:15,349
And let's assume that we
make a mistake during typing,

13021
09:28:15,349 --> 09:28:16,182
which could be very common.

13022
09:28:16,182 --> 09:28:18,910
We say one plus, and we forget to enter,

13023
09:28:18,910 --> 09:28:20,470
what, let's say one plus one works,

13024
09:28:20,470 --> 09:28:22,310
but we do one plus and we forget to enter

13025
09:28:22,310 --> 09:28:24,380
the additional value and we hit enter.

13026
09:28:25,626 --> 09:28:28,394
We receive an index out
of bounds exception.

13027
09:28:28,394 --> 09:28:29,480
So what we need to do
is check that we have

13028
09:28:29,480 --> 09:28:31,831
the proper number of arguments.

13029
09:28:31,831 --> 09:28:34,310
So what we can do is
say, if values dot size

13030
09:28:35,290 --> 09:28:36,750
is less than three, 'cause we need

13031
09:28:36,750 --> 09:28:40,060
at least three parameters,
then we're gonna throw

13032
09:28:40,060 --> 09:28:44,220
an illegal argument exception,
let's say invalid input,

13033
09:28:47,584 --> 09:28:51,153
expected value plus value received.

13034
09:28:54,250 --> 09:28:55,850
And then whatever the input was.

13035
09:28:57,750 --> 09:28:58,910
So now if we run this, what will happen

13036
09:29:00,276 --> 09:29:01,960
is we're not gonna get index
out of bounds exception.

13037
09:29:01,960 --> 09:29:05,200
What will happen is we can
still enter one plus one.

13038
09:29:05,200 --> 09:29:06,985
We'll still get that.

13039
09:29:06,985 --> 09:29:09,150
But if we enter one plus
something, we forget to enter

13040
09:29:09,150 --> 09:29:12,210
the additional value, we'll
now get an legal argument,

13041
09:29:12,210 --> 09:29:13,500
exception that was thrown.

13042
09:29:13,500 --> 09:29:16,350
It's an invalid input, expected
value, blah, blah, blah.

13043
09:29:16,350 --> 09:29:17,940
It was this particular value.

13044
09:29:19,934 --> 09:29:20,767
Now you could decide to crash the program

13045
09:29:20,767 --> 09:29:23,589
if that's what you'd like
to do, or you can decide

13046
09:29:23,589 --> 09:29:26,620
to skip this completely
so we could change this.

13047
09:29:26,620 --> 09:29:29,400
So instead of having
it throw an exception,

13048
09:29:29,400 --> 09:29:32,200
we could actually just
have it say print line.

13049
09:29:34,530 --> 09:29:36,740
We print line of idle
less than three else.

13050
09:29:40,260 --> 09:29:41,490
And then we can wrap everything else

13051
09:29:41,490 --> 09:29:43,480
since I have an else here.

13052
09:29:43,480 --> 09:29:46,180
And what will happen now,
when we run the application,

13053
09:29:49,480 --> 09:29:52,660
run us and we'll go one plus one is two.

13054
09:29:52,660 --> 09:29:55,060
We do one, does it age two plus something,

13055
09:29:55,060 --> 09:29:57,170
we make a mistake, enter, invalid input,

13056
09:29:57,170 --> 09:30:00,729
expected value of up plus
value of received two plus.

13057
09:30:00,729 --> 09:30:03,516
Okay, let's try it again, two plus three.

13058
09:30:03,516 --> 09:30:04,349
Okay, it works.

13059
09:30:04,349 --> 09:30:05,280
So now our application is a crashing.

13060
09:30:05,280 --> 09:30:07,030
We've performed some level of validation.

13061
09:30:07,030 --> 09:30:09,140
We're providing the feedback to the user

13062
09:30:09,140 --> 09:30:11,100
and we can continue using
the app and it works

13063
09:30:11,100 --> 09:30:12,660
as we would expect.

13064
09:30:12,660 --> 09:30:15,090
But we also have another problem.

13065
09:30:15,090 --> 09:30:17,290
The other problem is
gonna be let's go ahead

13066
09:30:18,316 --> 09:30:19,149
and run this.

13067
09:30:19,149 --> 09:30:21,430
What happens if for whatever reason,

13068
09:30:22,930 --> 09:30:25,560
a user enters one plus
two and then the next time

13069
09:30:25,560 --> 09:30:29,680
they say one plus dog,
what's gonna happen there.

13070
09:30:29,680 --> 09:30:31,650
We get another exception from the program

13071
09:30:31,650 --> 09:30:34,350
and the program crashes and
a calculator doesn't know

13072
09:30:34,350 --> 09:30:36,920
how to handle the word string dog.

13073
09:30:36,920 --> 09:30:39,430
And so it says number format exception

13074
09:30:39,430 --> 09:30:41,020
for input string dog.

13075
09:30:41,020 --> 09:30:43,110
And if we take a look at line number 18,

13076
09:30:44,088 --> 09:30:44,921
it's happening right here.

13077
09:30:44,921 --> 09:30:47,641
And the reason why it's happening
is on the right hand side,

13078
09:30:47,641 --> 09:30:49,580
we're trying to convert
that value to RHS value,

13079
09:30:49,580 --> 09:30:51,680
which came from here, which is the second,

13080
09:30:53,004 --> 09:30:53,860
the third item in the list.

13081
09:30:53,860 --> 09:30:55,910
We're trying to convert it to a double

13082
09:30:55,910 --> 09:30:56,970
and that's where the problem occurs.

13083
09:30:56,970 --> 09:30:58,320
So we need to do something here.

13084
09:30:58,320 --> 09:31:01,180
So one quick thing that we can easily do,

13085
09:31:01,180 --> 09:31:03,250
which works very well
because at this point,

13086
09:31:03,250 --> 09:31:05,050
this isn't an illegal argument.

13087
09:31:05,050 --> 09:31:06,150
We shouldn't be able to handle this

13088
09:31:06,150 --> 09:31:08,010
inside of our application.

13089
09:31:08,010 --> 09:31:12,980
What you could do is you
would say to double or null.

13090
09:31:12,980 --> 09:31:15,080
And then what we're gonna
do here is we're gonna do

13091
09:31:15,080 --> 09:31:16,900
the Elvis operator.

13092
09:31:16,900 --> 09:31:20,560
And the Elvis operator says,
hey, if something happens here

13093
09:31:20,560 --> 09:31:23,670
and this is null, the I want
you to return another value.

13094
09:31:23,670 --> 09:31:28,110
And so this is gonna say,
throw legal argument exception,

13095
09:31:30,310 --> 09:31:31,170
invalid input.

13096
09:31:33,712 --> 09:31:34,545
And then we'll go ahead
and actually just go ahead

13097
09:31:34,545 --> 09:31:37,170
and render that input values zero.

13098
09:31:39,320 --> 09:31:42,170
Now what's gonna happen here
is if this value right here

13099
09:31:42,170 --> 09:31:44,810
can be converted to a
double, it will be converted

13100
09:31:44,810 --> 09:31:46,600
to a double and it will be returned here.

13101
09:31:46,600 --> 09:31:48,570
Otherwise, if it can not
be returned to a double,

13102
09:31:48,570 --> 09:31:50,070
a null will be returned.

13103
09:31:50,070 --> 09:31:52,710
At that point, the Elvis
operator will interrupt

13104
09:31:53,639 --> 09:31:57,000
and say, hey, on the left hand
side over here, this is null,

13105
09:31:57,000 --> 09:31:59,430
so we need to do something
on the right-hand side.

13106
09:32:00,543 --> 09:32:02,180
And then we're telling it,
hey, if you encounter null,

13107
09:32:02,180 --> 09:32:04,000
throw an illegal argument exception.

13108
09:32:04,000 --> 09:32:05,260
So basically we're trying to parse it.

13109
09:32:05,260 --> 09:32:06,450
We couldn't parse it as a double.

13110
09:32:06,450 --> 09:32:08,120
So therefore it was returned as a null,

13111
09:32:08,120 --> 09:32:10,220
and at that point, and
then short-circuited

13112
09:32:10,220 --> 09:32:11,460
to the right-hand side over here.

13113
09:32:11,460 --> 09:32:14,210
So we'll do the same thing
over here to double or null.

13114
09:32:16,013 --> 09:32:17,670
And I'm just gonna copy
this to save some typing.

13115
09:32:19,836 --> 09:32:22,790
There we go, and then
this'll be value one.

13116
09:32:22,790 --> 09:32:25,450
Now, if you could see over
here, all these are grayed out,

13117
09:32:25,450 --> 09:32:28,170
'cause we're already
casting these two a double.

13118
09:32:28,170 --> 09:32:30,370
I can actually remove
these redundant calls.

13119
09:32:31,859 --> 09:32:32,692
So boom, we'll just go ahead
and remove these real fast,

13120
09:32:32,692 --> 09:32:33,550
I'll be right back.

13121
09:32:49,069 --> 09:32:52,050
Okay, now I'm back, we
have our very succinct

13122
09:32:52,050 --> 09:32:56,410
and clean version of our calculation.

13123
09:32:56,410 --> 09:32:59,950
And so very nice here, very succinct here,

13124
09:33:01,146 --> 09:33:02,740
but what's happening and we
can actually print things

13125
09:33:02,740 --> 09:33:03,573
directly to the screen.

13126
09:33:03,573 --> 09:33:06,120
So if we were to run it
now say one plus two,

13127
09:33:12,278 --> 09:33:14,420
we'll get back three,
if I say one plus dog,

13128
09:33:15,620 --> 09:33:17,110
we're gonna get an
illegal argument exception

13129
09:33:17,110 --> 09:33:18,370
and valid input.

13130
09:33:18,370 --> 09:33:20,230
Now, of course, this is
crashing the application.

13131
09:33:20,230 --> 09:33:22,430
So there's a couple of
things that you could do here

13132
09:33:22,430 --> 09:33:24,130
and in which I would challenge you

13133
09:33:24,130 --> 09:33:25,980
that we're not gonna do,
that you could do on your own

13134
09:33:25,980 --> 09:33:28,450
to challenge yourself,
is remove the illegal

13135
09:33:28,450 --> 09:33:29,400
argument exception.

13136
09:33:31,120 --> 09:33:33,320
And you can either
decide to make it a zero.

13137
09:33:34,779 --> 09:33:35,612
So you could just do something like this

13138
09:33:35,612 --> 09:33:37,440
that would make it a zero
so that it would be a double

13139
09:33:38,318 --> 09:33:39,160
or zero, which wouldn't work.

13140
09:33:39,160 --> 09:33:42,268
So because as you see here,

13141
09:33:42,268 --> 09:33:43,880
the type inference has
given you an example,

13142
09:33:43,880 --> 09:33:46,170
or you can go ahead
and say double or null.

13143
09:33:47,682 --> 09:33:48,820
At that point in time,
it could be a double

13144
09:33:48,820 --> 09:33:50,480
and the same thing down here

13145
09:33:50,480 --> 09:33:52,510
and then check to see if you have nulls

13146
09:33:52,510 --> 09:33:53,343
for either one of them.

13147
09:33:53,343 --> 09:33:56,040
If you do, perhaps provide
a message to the user

13148
09:33:56,040 --> 09:33:59,230
and then let the application
continue to keep going.

13149
09:33:59,230 --> 09:34:00,450
Here, though we're just gonna keep this

13150
09:34:00,450 --> 09:34:02,560
where it's gonna continue
to short circuit.

13151
09:34:02,560 --> 09:34:05,220
So at this point in time,
we now have an application

13152
09:34:05,220 --> 09:34:08,130
that tells the user that
they're invalid input

13153
09:34:08,130 --> 09:34:10,930
is occurring for their
first or their second value,

13154
09:34:10,930 --> 09:34:13,050
otherwise it's gonna continue on.

13155
09:34:13,050 --> 09:34:14,150
Now, there's one last little thing

13156
09:34:14,150 --> 09:34:15,910
that I would like to
do here in this program

13157
09:34:15,910 --> 09:34:17,290
to clean it up just a little bit

13158
09:34:17,290 --> 09:34:18,700
'cause we have a little
bit of duplication here

13159
09:34:18,700 --> 09:34:19,900
with this print line.

13160
09:34:19,900 --> 09:34:21,870
And what we can do is we
can actually turn a value

13161
09:34:21,870 --> 09:34:22,900
from a when clause.

13162
09:34:22,900 --> 09:34:26,018
So I'm gonna say val result equals when,

13163
09:34:26,018 --> 09:34:28,420
and then we're just gonna
get rid of these print line

13164
09:34:28,420 --> 09:34:32,120
statements and get rid
of the other parentheses

13165
09:34:32,120 --> 09:34:32,970
on the other end.

13166
09:34:36,701 --> 09:34:38,520
And now we have a double that we can use.

13167
09:34:38,520 --> 09:34:41,000
And then what we can use is just go ahead

13168
09:34:41,000 --> 09:34:43,010
and print line the result.

13169
09:34:44,730 --> 09:34:47,330
And this really cleans up our when clause.

13170
09:34:47,330 --> 09:34:49,660
Now we can actually see,
it's really easy to read

13171
09:34:49,660 --> 09:34:50,930
and it's very easy to follow.

13172
09:34:50,930 --> 09:34:53,950
We have an operator, we have
left-hand side right-hand side.

13173
09:34:53,950 --> 09:34:57,686
Based upon the operator if
it's plus minus multiplication

13174
09:34:57,686 --> 09:34:59,140
or divide, we're gonna
perform those operations

13175
09:34:59,140 --> 09:35:00,930
with the left hand side
in the right hand side.

13176
09:35:00,930 --> 09:35:03,320
Otherwise we don't support
whatever operation is thrown

13177
09:35:03,320 --> 09:35:05,480
and we'll basically throw an exception.

13178
09:35:05,480 --> 09:35:08,336
And then it finally, once
that result is returned,

13179
09:35:08,336 --> 09:35:09,584
we'll go ahead and print the results.

13180
09:35:09,584 --> 09:35:10,417
So let's go ahead and run
the application again,

13181
09:35:10,417 --> 09:35:11,680
just to see what it looks like.

13182
09:35:14,390 --> 09:35:18,020
So one plus two, there's
three, three plus five,

13183
09:35:19,050 --> 09:35:24,050
10 times seven, 70, 90 divided by six, 15.

13184
09:35:27,530 --> 09:35:28,980
So now our application works.

13185
09:35:28,980 --> 09:35:31,770
We've added some validation
in here to accept

13186
09:35:31,770 --> 09:35:34,020
the only valid chunks of input.

13187
09:35:34,020 --> 09:35:37,200
We've made sure that we can
only accept certain parameters

13188
09:35:37,200 --> 09:35:38,770
and we're providing feedback to the user.

13189
09:35:38,770 --> 09:35:41,260
And then of course, when we're
done, we can just hit enter

13190
09:35:42,570 --> 09:35:44,210
and the application will say goodbye,

13191
09:35:44,210 --> 09:35:47,710
that we're completely done
and then the process exits.

13192
09:35:47,710 --> 09:35:50,060
And you've now written
your first calculator app.

13193
09:35:51,222 --> 09:35:52,055
Now the next thing is how to deploy it

13194
09:35:52,055 --> 09:35:53,380
so other people can use it.

13195
09:35:55,375 --> 09:35:56,208
You've built your first application

13196
09:35:56,208 --> 09:35:57,210
and it runs within the IDE.

13197
09:35:57,210 --> 09:35:59,050
However you would like
to share with others,

13198
09:35:59,050 --> 09:36:01,200
to do that, you can build a jar file.

13199
09:36:01,200 --> 09:36:04,210
What you'll need to do is go
to file, project structure.

13200
09:36:05,370 --> 09:36:07,280
You wanna make sure that
you have the artifacts item

13201
09:36:07,280 --> 09:36:10,740
selected on the left-hand
side, you'll hit the plus icon,

13202
09:36:11,770 --> 09:36:15,180
select jar from modules with dependencies

13203
09:36:16,700 --> 09:36:18,680
to make sure your module is selected.

13204
09:36:18,680 --> 09:36:21,750
In our case, simple calculator's
the one that I want.

13205
09:36:21,750 --> 09:36:23,530
Then I'm going to select the main file,

13206
09:36:24,650 --> 09:36:27,100
which has main kt in our
case, we'll click, okay.

13207
09:36:28,310 --> 09:36:31,320
Now at this point you
can press apply and okay,

13208
09:36:31,320 --> 09:36:33,280
you're now ready to build your jar file.

13209
09:36:33,280 --> 09:36:37,250
To do so, you'll go to build
menu and then build artifacts

13210
09:36:38,380 --> 09:36:40,980
and you'll get the pop
up and just click build.

13211
09:36:40,980 --> 09:36:42,710
And you'll notice the build
is happening down here

13212
09:36:42,710 --> 09:36:45,960
in the bottom and actually
it's already done.

13213
09:36:45,960 --> 09:36:48,090
And what will happen
is some files be placed

13214
09:36:48,090 --> 09:36:51,090
into the outfielder, so let's
go and expand those out.

13215
09:36:51,090 --> 09:36:54,610
You'll see artifacts,
simple calculator jar.

13216
09:36:54,610 --> 09:36:57,350
And there is our jar
file that can be executed

13217
09:36:57,350 --> 09:36:58,290
on the command line.

13218
09:36:58,290 --> 09:36:59,850
So you'd be able to actually
send us to someone else

13219
09:36:59,850 --> 09:37:02,230
and they could execute
it, so let's do that.

13220
09:37:02,230 --> 09:37:04,220
I'm gonna right click and open this area

13221
09:37:04,220 --> 09:37:05,910
in the terminal down here.

13222
09:37:05,910 --> 09:37:07,160
And this is gonna open up a terminal

13223
09:37:07,160 --> 09:37:08,790
directly in this folder path here

13224
09:37:08,790 --> 09:37:12,110
so I can see out artifacts,
simple calculator jar.

13225
09:37:13,085 --> 09:37:16,190
So what we see here is this
exact folder that's right here.

13226
09:37:16,190 --> 09:37:19,371
So we are now in the
terminal of this location.

13227
09:37:19,371 --> 09:37:21,990
We can see LS and I can
run this jar file by typing

13228
09:37:21,990 --> 09:37:25,790
Java, jar, simple calculator.jar.

13229
09:37:28,274 --> 09:37:31,143
Hit enter and now our
program is executing.

13230
09:37:31,143 --> 09:37:32,053
Please enter arithmetic problem.

13231
09:37:32,053 --> 09:37:36,560
One plus two is three,
four plus five is this.

13232
09:37:37,740 --> 09:37:41,150
40 divided by seven is that value.

13233
09:37:41,150 --> 09:37:45,890
Eight times 22 is this value.

13234
09:37:45,890 --> 09:37:48,460
Hit enter and of course we get to exit.

13235
09:37:48,460 --> 09:37:51,620
So now you have built your
first Java application,

13236
09:37:51,620 --> 09:37:54,020
compiled it down to a jar file,

13237
09:37:54,020 --> 09:37:56,360
which then you can take
and send to anybody else

13238
09:37:56,360 --> 09:37:58,860
and they can execute this
program on their computer.

13239
09:37:58,860 --> 09:38:01,360
Now be aware if you do
send a jar file over email,

13240
09:38:01,360 --> 09:38:03,840
most likely most email
providers are probably going

13241
09:38:03,840 --> 09:38:06,520
to strip that file out
as it can be considered

13242
09:38:06,520 --> 09:38:07,520
unexecutable.

13243
09:38:07,520 --> 09:38:08,980
So you'll need to get it
to them a different way,

13244
09:38:08,980 --> 09:38:12,120
maybe through a file sharing
service of some sorts.

13245
09:38:12,120 --> 09:38:14,700
So that's how you can build a jar file

13246
09:38:14,700 --> 09:38:18,340
simply through IntelliJ and
then you'll get your jar file.

13247
09:38:18,340 --> 09:38:21,700
Congratulations on creating
your first application.

13248
09:38:21,700 --> 09:38:23,750
Playing with Kotlin and
Simon IDE is gonna be

13249
09:38:23,750 --> 09:38:25,300
the best way for you to learn.

13250
09:38:25,300 --> 09:38:28,200
However, sometimes you can
also learn directly on the web.

13251
09:38:29,150 --> 09:38:32,562
And to do that, the folks
over JetBrains have set up

13252
09:38:32,562 --> 09:38:36,430
play.Kotlinlane.org. and
here you can log in for free,

13253
09:38:36,430 --> 09:38:38,630
not even log in just
access, play.kotlin.org

13254
09:38:39,580 --> 09:38:42,530
and start writing code
right here in the browser.

13255
09:38:42,530 --> 09:38:44,650
So now what we can do is
we'll say hello from Donn,

13256
09:38:44,650 --> 09:38:47,030
for example, and I can run this code.

13257
09:38:47,030 --> 09:38:48,880
And what we'll see, it'll run and compile,

13258
09:38:48,880 --> 09:38:50,480
and we'll see the output.

13259
09:38:50,480 --> 09:38:52,530
Now, one of the coolest things
we can do inside of here,

13260
09:38:52,530 --> 09:38:55,716
we can write a bunch of code
and then you can also share it.

13261
09:38:55,716 --> 09:38:58,730
So you can click share
and you can copy this link

13262
09:38:58,730 --> 09:39:01,580
or you can directly embed
it, send it to medium.

13263
09:39:01,580 --> 09:39:03,030
And so let's say I've
taken this and I've sent it

13264
09:39:03,030 --> 09:39:03,930
to somebody else.

13265
09:39:03,930 --> 09:39:06,080
So I have a new incognito
window open here.

13266
09:39:07,926 --> 09:39:08,990
If I paste this, what
we'll see here is we have

13267
09:39:08,990 --> 09:39:12,570
play.Kotlinlane.org
and automatically loads

13268
09:39:14,787 --> 09:39:15,620
the code that I've written.

13269
09:39:15,620 --> 09:39:17,570
So hello from Donn has
been pasted inside here.

13270
09:39:18,693 --> 09:39:19,670
So actually, if you actually take that URL

13271
09:39:19,670 --> 09:39:22,040
that you saw here in the
video and pasted it in,

13272
09:39:22,965 --> 09:39:23,798
you should see this directly from me

13273
09:39:23,798 --> 09:39:24,910
right here in your browser.

13274
09:39:25,770 --> 09:39:27,110
Now this is a great place to play around.

13275
09:39:27,110 --> 09:39:29,410
There's also the hands-on
and there are some examples

13276
09:39:29,410 --> 09:39:30,320
in koans.

13277
09:39:30,320 --> 09:39:31,990
Now Kotlin koans are great.

13278
09:39:31,990 --> 09:39:34,370
Koans are a series of set of
exercises that are allow you

13279
09:39:34,370 --> 09:39:37,910
to get familiar with the actual
Kotlin programming language.

13280
09:39:37,910 --> 09:39:40,390
And the nice thing about it
is they actually give you

13281
09:39:40,390 --> 09:39:43,840
a test that you can actually
have to basically make pars.

13282
09:39:43,840 --> 09:39:45,520
So you have to actually fix the code

13283
09:39:45,520 --> 09:39:47,080
and make these things parse in real time.

13284
09:39:47,080 --> 09:39:48,820
And you can do it right
here on your browser.

13285
09:39:48,820 --> 09:39:51,510
They give you progress that
you can follow along the way.

13286
09:39:51,510 --> 09:39:53,840
So if you learn Kotlin
for me and you're watching

13287
09:39:53,840 --> 09:39:55,630
these videos and you've
picked up quite a bit,

13288
09:39:55,630 --> 09:39:57,700
and you wanna take your
exercises a little bit further

13289
09:39:57,700 --> 09:40:00,420
and challenge yourself, I
advise you go to Kotlin.

13290
09:40:00,420 --> 09:40:02,250
Go to play.Kotlinlane.org.

13291
09:40:02,250 --> 09:40:04,211
You can play in the round the playground,

13292
09:40:04,211 --> 09:40:06,161
and you can also visit the Kotlin koans

13293
09:40:06,999 --> 09:40:07,850
and explore other examples as well.

13294
09:40:07,850 --> 09:40:08,700
I hope you enjoy.

13295
09:40:09,780 --> 09:40:11,880
Woo, you made it.

13296
09:40:13,100 --> 09:40:15,918
Congratulations on finishing the Kotlin

13297
09:40:15,918 --> 09:40:16,770
programming language course.

13298
09:40:16,770 --> 09:40:19,921
It was over nine hours of
content you just watched.

13299
09:40:19,921 --> 09:40:22,818
You should feel proud of
yourself for finishing this.

13300
09:40:22,818 --> 09:40:23,651
This is quite the accomplishment.

13301
09:40:23,651 --> 09:40:26,650
You now should have a solid
fundamental understanding

13302
09:40:26,650 --> 09:40:28,400
of the Kotlin programming language,

13303
09:40:29,372 --> 09:40:30,710
and you shouldn't be able
to go start providing value

13304
09:40:30,710 --> 09:40:33,450
at your company's project,
your own personal project.

13305
09:40:33,450 --> 09:40:35,510
It doesn't matter if you're
a developer, engineer,

13306
09:40:35,510 --> 09:40:37,590
scientist, doctor, or whatever.

13307
09:40:37,590 --> 09:40:40,070
I hope you have received a
lot of value from this course.

13308
09:40:40,070 --> 09:40:42,850
I hope you have learned
Kotlin and I hope it produces

13309
09:40:42,850 --> 09:40:45,080
a ton of value in your
career moving forward.

13310
09:40:45,080 --> 09:40:47,880
And I wish you nothing,
but the best going forward.

13311
09:40:47,880 --> 09:40:49,560
Thanks again for watching the video

13312
09:40:49,560 --> 09:40:50,890
and I'll catch you next time.

