1
00:00:00,490 --> 00:00:01,323
- Всем привет.

2
00:00:01,323 --> 00:00:03,380
Меня зовут Дон Фэлкер.
Добро пожаловать на курс

3
00:00:03,380 --> 00:00:04,990
по изучению языка Котлин.

4
00:00:04,990 --> 00:00:06,900
Я буду вашим проводником
и инструктором в этом путешествии.

5
00:00:06,900 --> 00:00:10,040
Вы смотрите видео длиной
более 9-ти часов

6
00:00:10,040 --> 00:00:12,500
о языке программирования Котлин

7
00:00:12,500 --> 00:00:14,410
Это видео можно смотреть двумя способами:

8
00:00:14,410 --> 00:00:16,770
Если хотите, вы можете посмотреть
все видео целиком,

9
00:00:16,770 --> 00:00:19,410
или, если вы хотите смотреть
курс частями на манер плэйлиста

10
00:00:19,410 --> 00:00:21,900
в виде небольших видео уроков,

11
00:00:21,900 --> 00:00:23,760
вы можете найти ссылку
на плэйлист ниже

12
00:00:23,760 --> 00:00:24,820
в описании видео.

13
00:00:24,820 --> 00:00:27,370
Заходите на него и смотрите
весь материал

14
00:00:27,370 --> 00:00:30,980
разбитый на
130 раздельных урока.

15
00:00:30,980 --> 00:00:33,790
Главная цель данного курса
дать вам возможность

16
00:00:33,790 --> 00:00:36,520
приносить ценность и пользу
в любой котлин проект

17
00:00:36,520 --> 00:00:37,450
который есть в открытом доступе.

18
00:00:37,450 --> 00:00:40,370
Мы рассмотрим теорию и изучим
переменные, функции

19
00:00:40,370 --> 00:00:43,740
классы, узнаем как работать с дженериками

20
00:00:43,740 --> 00:00:45,420
как работать со списками, изменять списки,

21
00:00:45,420 --> 00:00:48,360
рассмотрим различные структуры
данных, словари и массивы

22
00:00:48,360 --> 00:00:50,910
и даже немного поговорим
про лямда выражения.

23
00:00:50,910 --> 00:00:52,720
Курс мы закончим написанием вашего

24
00:00:52,720 --> 00:00:55,720
первого Котлин проекта,
который вы сможете запустить

25
00:00:55,720 --> 00:00:57,240
локально на вашем компьюетере.

26
00:00:57,240 --> 00:00:58,590
Когда вы закончите этот курс,

27
00:00:58,590 --> 00:01:01,060
вы сможете уверенно читать
код проекта написанного на Kotlin

28
00:01:01,060 --> 00:01:03,660
и чувствоать себя достаточно уверенно

29
00:01:03,660 --> 00:01:05,450
для внесения изменений в код.

30
00:01:05,450 --> 00:01:07,340
Уточню, что в этом курсе
будут вещи, которые мы не затронем

31
00:01:07,340 --> 00:01:10,830
в основном это будут сложные темы,
такие как корутины, флоу

32
00:01:10,830 --> 00:01:12,040
и подобные им вещи.

33
00:01:12,040 --> 00:01:15,360
Однако, как только вы поймете
и изучите основы

34
00:01:15,360 --> 00:01:16,650
представленные в этом курсе,

35
00:01:16,650 --> 00:01:19,560
вы сможете самостоятельно начать
изучение более сложных вещей.

36
00:01:19,560 --> 00:01:21,430
Осталась одна единственная
вещь, которую я хотел сказать

37
00:01:21,430 --> 00:01:22,580
вам перед тем как мы начнем.

38
00:01:22,580 --> 00:01:26,680
Со временем шаги по установке
могут сильно измениться,

39
00:01:26,680 --> 00:01:28,880
все зависит от того "когда"
вы смотрите это видео,

40
00:01:28,880 --> 00:01:32,270
это значит что шаги по установки
окружения IntelliJ community edition

41
00:01:32,270 --> 00:01:34,650
для Котлин, которые будут
в первых нескольких минутах

42
00:01:34,650 --> 00:01:37,140
этого видео,

43
00:01:37,140 --> 00:01:38,570
со временем могут измениться.

44
00:01:38,570 --> 00:01:40,330
Веб страница скорее всего будет
выглядеть по другому,

45
00:01:40,330 --> 00:01:42,250
процесс установки будет
выглядеть немного иначе.

46
00:01:42,250 --> 00:01:45,040
И первая страница, где вы будете
создавать новый проект

47
00:01:45,040 --> 00:01:46,560
будет немного отличаться.

48
00:01:46,560 --> 00:01:49,190
Моя совет вам, когда вы
установите IntelliJ

49
00:01:49,190 --> 00:01:51,330
просто следуйте инструкциям
на сайте

50
00:01:51,330 --> 00:01:53,810
создайте новый проект, убедитесь
что в качестве языка у вас выбран Kotlin.

51
00:01:53,810 --> 00:01:55,240
После этого проблем,

52
00:01:55,240 --> 00:01:57,280
у вас быть не должно.

53
00:01:57,280 --> 00:01:58,870
Надеюсь, что скоро смогу поздравить

54
00:01:58,870 --> 00:02:01,330
вас в конце видео, в связи с его окончанием.

55
00:02:01,330 --> 00:02:03,080
А пока этого не произошло,
если у вас есть вопросы

56
00:02:03,080 --> 00:02:06,130
задавайте их в комментариях,
увидимся в конце видео.

57
00:02:06,130 --> 00:02:06,963
Удачи.

58
00:02:06,963 --> 00:02:08,800
Чтобы начать писать на Котлин,

59
00:02:08,800 --> 00:02:11,370
вам нужно установить специальную
среду для разработки,

60
00:02:11,370 --> 00:02:12,530
сокращенно - IDE (integrated
development environment)

61
00:02:13,911 --> 00:02:15,800
Вы можете скачать ее
на сайте free@jetbrains.com

62
00:02:15,800 --> 00:02:17,650
зайдите в "Tools" (Инструменты)
и выберете IntelliJ IDEA.

63
00:02:18,970 --> 00:02:21,260
Далее найдите и нажмите
на ссылку для скачивания.

64
00:02:22,120 --> 00:02:24,590
Здесь вы можете скачать
бесплатную версию IDEA

65
00:02:24,590 --> 00:02:27,640
для нужной вам
операционной системы

66
00:02:27,640 --> 00:02:30,670
Windows, MacOS, Linux.

67
00:02:31,620 --> 00:02:33,490
Для этого курса я буду использовать
версию для MacOS

68
00:02:33,490 --> 00:02:35,440
я загружаю бесплатную версию.

69
00:02:36,440 --> 00:02:37,860
Как только файл скачается,

70
00:02:37,860 --> 00:02:39,900
вы можете вернуться на сайт

71
00:02:39,900 --> 00:02:43,322
и следовать инструкции по установке
для операционной системы

72
00:02:43,322 --> 00:02:44,155
которую вы используете.

73
00:02:44,155 --> 00:02:45,900
Я не буду показывать все

74
00:02:45,900 --> 00:02:49,310
инструкции по установке
потому что они отличаются

75
00:02:49,310 --> 00:02:52,320
и зависят от операционной системы.

76
00:02:52,320 --> 00:02:54,930
Время от времени и сами инструкции

77
00:02:54,930 --> 00:02:56,630
по установке могут меняться,

78
00:02:56,630 --> 00:02:59,390
поэтому не удивляйтесь, если
то что вы видите на сайте

79
00:02:59,390 --> 00:03:01,590
и то что вы видете сейча,
в этом курсе
может немного отличаться

80
00:03:01,590 --> 00:03:03,470
может немного отличаться.

81
00:03:03,470 --> 00:03:06,220
Если вы с этим столкнулись
просто убедитесь, что вы

82
00:03:08,144 --> 00:03:08,977
скачиваете бесплатную версию

83
00:03:08,977 --> 00:03:11,200
и найдите инструкции по установке.

84
00:03:11,200 --> 00:03:13,980
Как только приложение установится
и вы будете котовы

85
00:03:13,980 --> 00:03:17,260
работать в IntelliJ,
вы можете начинать писать код

86
00:03:17,260 --> 00:03:19,820
на языке Котлин.

87
00:03:19,820 --> 00:03:21,680
Как только IntelliJ установилась,

88
00:03:21,680 --> 00:03:23,720
вы можете запустить приложение
и увидите окно, которое

89
00:03:23,720 --> 00:03:25,700
похоже на это.

90
00:03:25,700 --> 00:03:28,640
Нажмите "Создать новый проект"
и появится список с

91
00:03:28,640 --> 00:03:31,518
различными настройками
слева экрана

92
00:03:31,518 --> 00:03:34,800
Выберите вкладку Котлин,
и пункт Котлин JVM

93
00:03:36,220 --> 00:03:39,590
нажмите "далее", теперь
назовите ваш проект

94
00:03:39,590 --> 00:03:41,820
Я назову его Caster Kotlin

95
00:03:42,800 --> 00:03:44,950
Вы можете назвать его как
только захотите

96
00:03:44,950 --> 00:03:46,920
Вы можете не менять SDK
для проекта

97
00:03:46,920 --> 00:03:50,040
и все оставить как оно есть
дальше нажмите "Закончить"

98
00:03:54,205 --> 00:03:55,160
Вы можете закрыть "Подсказку дня"

99
00:03:55,160 --> 00:03:57,990
и закрыть все

100
00:03:57,990 --> 00:03:59,960
всплывающие окна.

101
00:03:59,960 --> 00:04:01,600
Слева вы видите окно

102
00:04:01,600 --> 00:04:04,400
оно содержит файловую структуру
вашего проекта.

103
00:04:04,400 --> 00:04:06,930
Внутри этого окна
мы видим пакеты, файлы

104
00:04:06,930 --> 00:04:09,420
и другие вещи связанные
с проектом.

105
00:04:10,540 --> 00:04:13,970
Первым делом
откройте это папку.

106
00:04:13,970 --> 00:04:15,370
Вы увидите папку "src".

107
00:04:15,370 --> 00:04:17,390
В этой папке будет хранится код.

108
00:04:18,860 --> 00:04:21,440
Для начала давайте создадим наш
первый файл.

109
00:04:21,440 --> 00:04:25,660
Нажмите правой кнопкой мышки на
папке и выберете New -> Kotlin file class

110
00:04:26,832 --> 00:04:27,910
давайте назовем его main.kt

111
00:04:29,521 --> 00:04:32,410
"kt" - это расширение для
Котлин файлов. Нажмите "ok"

112
00:04:34,550 --> 00:04:37,082
Теперь вы готовы написать

113
00:04:37,082 --> 00:04:37,915
свою первую строчку
кода на Котлин.

114
00:04:39,095 --> 00:04:40,000
Если у вас появится такое уведомление,

115
00:04:40,000 --> 00:04:42,180
вы можете выбрать "Install"
чтобы установить плагины для Котлин,

116
00:04:42,180 --> 00:04:43,013
если захотите.

117
00:04:43,013 --> 00:04:45,280
Если у вас не было такого
уведомления

118
00:04:45,280 --> 00:04:47,600
вы можете пропустить эту часть
видео

119
00:04:47,600 --> 00:04:49,410
Вы будете получать подобные
уведомления

120
00:04:49,410 --> 00:04:51,970
когда будут выходить новые
версии Котлин или

121
00:04:51,970 --> 00:04:53,820
Котлин плагинов

122
00:04:53,820 --> 00:04:56,190
Теперь нажмите кнопку "Install"

123
00:04:56,190 --> 00:04:58,380
Идея загрузит новый плагин

124
00:04:58,380 --> 00:05:00,180
и покажет прогресс загрузки тут.

125
00:05:00,180 --> 00:05:02,380
Это плагин для нашей среды разработки

126
00:05:03,297 --> 00:05:05,790
Вы можете посмотреть эти плагины
здесь зайдя в настройки

127
00:05:05,790 --> 00:05:07,610
И здесь нажмите "Plugins".

128
00:05:07,610 --> 00:05:11,540
Заходим в настройки, пишем "plugins".

129
00:05:13,580 --> 00:05:15,700
Тут можно увидеть все установленные
плагины, которые

130
00:05:15,700 --> 00:05:17,520
установлены в вашей InltelliJ Idea.

131
00:05:17,520 --> 00:05:22,120
Наберите в поиске Kotlin
и вы увидите,

132
00:05:22,120 --> 00:05:24,530
что мы только что установили его,

133
00:05:24,530 --> 00:05:26,167
поэтому нам нужно перезапустить IDE,

134
00:05:26,167 --> 00:05:28,320
это дополнительно написано
в этом окне.

135
00:05:28,320 --> 00:05:30,179
После того как вы нажмете "restart",

136
00:05:30,179 --> 00:05:33,280
IntelliJ перезапустится
и загрузится с новой

137
00:05:33,280 --> 00:05:34,113
версие плагина.

138
00:05:35,840 --> 00:05:37,878
Мы можем закрыть это окно
и вернуться

139
00:05:37,878 --> 00:05:38,900
к нашему main.kt файлу.

140
00:05:38,900 --> 00:05:41,270
Котлин плагин должен был
обновиться внутри

141
00:05:41,270 --> 00:05:43,470
IntelliJ и мы готовы начинать.

142
00:05:43,470 --> 00:05:46,660
Для того чтобы создать свой
первое "Hello World" приложение,

143
00:05:46,660 --> 00:05:50,380
вам нужно создать "main" функцию
в вашем файле.

144
00:05:50,380 --> 00:05:52,310
И это выглядит как fun main.

145
00:05:52,310 --> 00:05:54,390
Тут будут открытая и закрытая скобки

146
00:05:54,390 --> 00:05:56,610
и открытая и закрытая фигурные скобки.

147
00:05:56,610 --> 00:06:00,100
Каждый раз, когда вы пишите
подобную конструкцию в IntelliJ

148
00:06:00,100 --> 00:06:02,854
в любом Котлин файле,
слева будет появляться зеленая стрелочка.

149
00:06:02,854 --> 00:06:04,440
По клику на эту стрелку вы можете
запустить или проебажить

150
00:06:04,440 --> 00:06:05,800
вашу программу.

151
00:06:07,154 --> 00:06:07,990
Мы поговорим об этом
через секунду.

152
00:06:07,990 --> 00:06:09,170
Если мы запустим программу прямо сейчас

153
00:06:09,170 --> 00:06:10,630
ничего не произойдет.

154
00:06:10,630 --> 00:06:13,392
Поэтому, для начала
мы попробуем вывести что-нибудь

155
00:06:13,392 --> 00:06:14,225
на экран.

156
00:06:14,225 --> 00:06:16,990
Мы хотим написать "Hello, World" ("Привет, Мир").

157
00:06:16,990 --> 00:06:20,820
Функция println это стандартная
функция в Котлин,

158
00:06:20,820 --> 00:06:24,120
Которая позволяет выводить
заданный ей текст

159
00:06:24,120 --> 00:06:27,520
и переводить каретку на новую
строку в "стандартный способ вывода"

160
00:06:27,520 --> 00:06:28,860
В нашем случае стандартный способ вывода

161
00:06:28,860 --> 00:06:31,430
Это просто окно снизу экрана.

162
00:06:31,430 --> 00:06:33,690
Если мы вернумся назад к нашей стрелке,

163
00:06:33,690 --> 00:06:36,393
и нажмем "Run main.kt",
hit play and hit run main.kt,

164
00:06:36,393 --> 00:06:39,180
мы увидим что код компилируется
и выполняется.

165
00:06:39,180 --> 00:06:41,704
Это может занимать немного больше
времени у вас,

166
00:06:41,704 --> 00:06:43,870
все зависит от характеристик вашего
ПК или ноутбука.

167
00:06:43,870 --> 00:06:46,500
И теперь тут, в окне вы
можете увидеть ваше сообщение hello world.

168
00:06:46,500 --> 00:06:48,620
Таким образом вы смогли написать
свою первую программу

169
00:06:48,620 --> 00:06:49,590
на языке Kotlin.

170
00:06:49,590 --> 00:06:52,690
Переменные - основной винтик
в вашей программе.

171
00:06:52,690 --> 00:06:55,970
Чтобы создать переменную в Котлине
используется ключевое слово var,

172
00:06:55,970 --> 00:06:57,740
после него вы пишите название
вашей переменной.

173
00:06:57,740 --> 00:06:59,690
В этом случае мы назовем ее
"полное имя" (fullName)

174
00:07:00,556 --> 00:07:02,610
и напишем что оно равно значению.

175
00:07:02,610 --> 00:07:06,570
Тут я задам переменной строковое
значение "Donn Felker"

176
00:07:06,570 --> 00:07:08,890
теперь у нас есть переменная
с именем "fullName"

177
00:07:08,890 --> 00:07:11,580
и она содержит значение "Donn Felker"

178
00:07:12,743 --> 00:07:14,767
Если мы захотим вывести ее на экран,

179
00:07:14,767 --> 00:07:15,950
то мы можем использовать функцию println

180
00:07:17,065 --> 00:07:19,060
и теперь мы можем нажать стрелочку
и запустить программу

181
00:07:19,060 --> 00:07:20,060
и нажать "Run main.kt"

182
00:07:21,555 --> 00:07:23,569
Программа скомпилируется, об этом
написано снизу

183
00:07:23,569 --> 00:07:25,569
и программа выведет значение "Donn Felker".

184
00:07:44,950 --> 00:07:45,783
Запустим заново

185
00:07:49,540 --> 00:07:51,700
Вы видите "Donn Felker" и "John Felker".

186
00:07:52,600 --> 00:07:57,600
Вы таким же образом можете
присвоить пустое значение

187
00:07:57,810 --> 00:07:59,160
и вывести его на экран,

188
00:08:00,440 --> 00:08:01,944
не смотря на то что мы не видим
результата программы

189
00:08:01,944 --> 00:08:03,820
потому что переменная пустая,
мы можем запустить программу

190
00:08:03,820 --> 00:08:06,280
и увидеть, что в конце появилась
дополнительная пустая строка.

191
00:08:06,280 --> 00:08:08,430
Вместо одной, теперь тут две
пустые строки

192
00:08:08,430 --> 00:08:10,130
потому что вы вывели одну
пустую строку.

193
00:08:12,090 --> 00:08:14,700
Когда мы работаем с переменными,


194
00:08:14,700 --> 00:08:16,820
мы имеем полный доступ к их методам

195
00:08:16,820 --> 00:08:19,540
Например, мы хотим проверить
характеристику строки

196
00:08:19,540 --> 00:08:22,760
и вызвать фунцию, которая
проверит пустая она или нет.

197
00:08:22,760 --> 00:08:25,600
Я напишу isEmpty и это метод для

198
00:08:25,600 --> 00:08:26,830
строковой переменной.

199
00:08:26,830 --> 00:08:29,557
С помощью нее мы можем проверить
нашу переменную.

200
00:08:29,557 --> 00:08:32,619
Я нажму cmd+B чтобы посмотреть
код функции.

201
00:08:32,619 --> 00:08:34,440
Тут можно увидеть, что метод isEmpty,

202
00:08:34,440 --> 00:08:36,960
возвращает true, когда длина
последовательности

203
00:08:36,960 --> 00:08:39,100
символов равняется нулю.

204
00:08:39,995 --> 00:08:41,850
Последовательность символов это строка.

205
00:08:41,850 --> 00:08:44,480
Если переменная пустая, тогда функция
вернет true, иначе вернет false.

206
00:08:44,480 --> 00:08:47,530
Если запустить программу мы получим
"Donn Felker", "John Felker",

207
00:08:47,530 --> 00:08:50,600
пустую строку и затем
мы увидим слово true.

208
00:08:50,600 --> 00:08:51,750
Давайте проверим

209
00:08:53,222 --> 00:08:54,334
Теперь вы сами видите снизу
в окне вывода

210
00:08:54,334 --> 00:08:57,910
"Donn Felker", "John Felker",
пустую строку и "true"

211
00:08:57,910 --> 00:09:00,920
Ключевой момент, который нужно запомнить:

212
00:09:00,920 --> 00:09:03,710
если вы используете ключевое слово
"var" это значит, что в любой момент

213
00:09:03,710 --> 00:09:06,130
вы или другие объекты программы
могут изменить значение вашей переменной,

214
00:09:06,130 --> 00:09:08,170
если вы хотите менять значение -
миспользуйте "var".

215
00:09:08,170 --> 00:09:11,740
Например, я могу написать, что age = 32

216
00:09:11,740 --> 00:09:14,190
и в любой момент без проблем могу
изменить значение на другое

217
00:09:15,183 --> 00:09:16,356
Еще одно замечание.

218
00:09:16,356 --> 00:09:18,730
Если я снова напишу "var age"

219
00:09:18,730 --> 00:09:19,850
то мы увидим красную линию под
переменной

220
00:09:19,850 --> 00:09:22,900
В подсказке написано, что у нас
две конфликтующие переменные

221
00:09:22,900 --> 00:09:26,040
это значит что мы не можем дважды
объявить одну и ту же переменную

222
00:09:26,040 --> 00:09:28,672
в скоупе выполнения

223
00:09:28,672 --> 00:09:30,300
в данном примере - в рамках
функции main()

224
00:09:30,300 --> 00:09:32,870
Если я хочу задать переменной новое
значение, я не буду писать "var"

225
00:09:32,870 --> 00:09:35,330
я просто напишу что age равно 32

226
00:09:35,330 --> 00:09:36,840
и это изменит значение.

227
00:09:36,840 --> 00:09:40,980
Я так же могу вывести
значение age в консоль

228
00:09:40,980 --> 00:09:43,400
напишем age и увидим, что age

229
00:09:43,400 --> 00:09:47,800
выведет в консоль 32, не смотря на то
что переменная создавалась со значением 30

230
00:09:47,800 --> 00:09:50,760
В консоль выводится 32

231
00:09:51,920 --> 00:09:54,650
Последнее важное замечание,

232
00:09:54,650 --> 00:09:57,360
что переменной age при создании
неявно присвоился целочисленный тип

233
00:09:57,360 --> 00:09:59,170
При этом мы нигде явно этого не указывали

234
00:10:00,500 --> 00:10:01,880
Компилятор достатоно умный для того
чтобы присвоить тип переменной

235
00:10:01,880 --> 00:10:04,060
в зависимости от того, что вы в нее кладете

236
00:10:04,060 --> 00:10:06,080
в нашем случае - целочисленный тип.

237
00:10:07,330 --> 00:10:09,510
В котлин вы можете создавать переменные

238
00:10:09,510 --> 00:10:13,220
с помощью ключевого слова "var",
но если вы хотите создать

239
00:10:13,220 --> 00:10:14,320
неизменяемое значение,

240
00:10:14,320 --> 00:10:16,780
то нужно использовать ключевое
слово "val".

241
00:10:16,780 --> 00:10:19,591
Давайте попробуем проделать все
то же самое.

242
00:10:19,591 --> 00:10:20,940
Мы создадим новую переменную

243
00:10:20,940 --> 00:10:23,959
но на этот раз будем использовать
ключевое слово "val"

244
00:10:23,959 --> 00:10:26,809
и присвоим ей значение
"Donn Felker" как раньше

245
00:10:27,730 --> 00:10:29,800
И выведем все в консоль

246
00:10:29,800 --> 00:10:32,240
На данный момент ничего не поменялось

247
00:10:32,240 --> 00:10:34,180
Результат будет точно такой же

248
00:10:34,180 --> 00:10:37,090
Мы создали переменную "fullName"

249
00:10:37,090 --> 00:10:38,870
со значением "Donn Felker"

250
00:10:38,870 --> 00:10:41,700
И когда мы запускаем программу, мы
видим "Donn Felker"

251
00:10:41,700 --> 00:10:43,140
в выводе консоли.

252
00:10:43,140 --> 00:10:46,950
Но самое большое отличие тут то,
что мы использовали

253
00:10:46,950 --> 00:10:50,130
ключевое слово "val".
Тем самым мы создали переменную

254
00:10:50,130 --> 00:10:52,560
которую нельзя изменять

255
00:10:52,560 --> 00:10:55,140
Если я попытаюсь задать у нее
другое значение

256
00:10:55,140 --> 00:10:58,730
например, попрубую заменить
ее на "John Felker"

257
00:11:00,260 --> 00:11:02,900
я автоматически получу предупреждение -
красную полосу

258
00:11:02,900 --> 00:11:07,090
потому что Котлин понимает, что
так делать нельзя

259
00:11:07,090 --> 00:11:09,500
И в подсказке написано, что значения
"val" переменных нельзя менять

260
00:11:09,500 --> 00:11:11,650
И если я попробую проигнорировать
IDE и запущу программу

261
00:11:11,650 --> 00:11:12,990
нажму на кнопку Run

262
00:11:12,990 --> 00:11:16,370
Компилятор запустится
и напишет что произошла ошибка компиляции

263
00:11:16,370 --> 00:11:19,100
Компилятор скажет, что он
не смог скомпилировать программу

264
00:11:19,100 --> 00:11:20,160
потому что в коде ошибка

265
00:11:20,160 --> 00:11:24,450
и вы попытались поменять val переменную
в строчке 5

266
00:11:24,450 --> 00:11:26,510
Мы посмотрим на строчку 5 и вот
наша попытка поменять значение val

267
00:11:26,510 --> 00:11:29,680
переменной

268
00:11:29,680 --> 00:11:33,180
Как только мы создаем val переменную

269
00:11:33,180 --> 00:11:35,940
ее значение больше не может
меняться

270
00:11:35,940 --> 00:11:37,690
То же самое работает для всех

271
00:11:37,690 --> 00:11:41,230
других типов данных. Например
если это будет 32

272
00:11:41,230 --> 00:11:44,100
вы так же можете вывести ее в консоль

273
00:11:44,100 --> 00:11:47,670
Но если попробуете изменить ее

274
00:11:47,670 --> 00:11:49,130
например присвоить 42

275
00:11:51,114 --> 00:11:52,060
вы можете увидеть ту же самую
проблему

276
00:11:52,060 --> 00:11:54,880
Ради эксперимента запустим программу
и увидим все

277
00:11:54,880 --> 00:11:56,480
ту же ошибку компилятора,
который говорит

278
00:11:56,480 --> 00:11:57,760
что val нельзя изменять

279
00:11:57,760 --> 00:11:58,920
и покажет что ошибка в строке 8

280
00:11:58,920 --> 00:12:01,930
Номер строки это первая цифра в
этом сообщении об ошибке

281
00:12:01,930 --> 00:12:06,290
И вот тут на строке 8 пытаемся
поменять val переменную

282
00:12:06,290 --> 00:12:09,080
Поэтому мы не можем менять val
переменные

283
00:12:09,080 --> 00:12:10,470
и можем только читать их

284
00:12:10,470 --> 00:12:13,140
Поэтому это отличный вариант, когда вам
нужно создать то что нельзя менять

285
00:12:13,140 --> 00:12:16,340
в вашей программе и эту

286
00:12:16,340 --> 00:12:18,720
неизменчивость вы делигируете
и проверяете

287
00:12:18,720 --> 00:12:19,970
с помощью компилятора.

288
00:12:19,970 --> 00:12:24,300
До этого момента все переменные
неявно получали свой тип данных

289
00:12:24,300 --> 00:12:28,040
Однако, если у вас есть
переменная fullName

290
00:12:28,040 --> 00:12:31,860
и мы присваиваем ей строку
равную "Donn Felker"

291
00:12:31,860 --> 00:12:34,290
неявно она получит строковый тип

292
00:12:34,290 --> 00:12:35,690
И мы можем это проверить

293
00:12:35,690 --> 00:12:38,030
используя встроенные функции
рефлексии

294
00:12:38,030 --> 00:12:41,000
Напишем println функцию
и в скобках напишем fullName::class

295
00:12:41,000 --> 00:12:44,710
Чтобы проверить к какому классу
принадлежит эта переменная

296
00:12:44,710 --> 00:12:47,510
Если мы запустим программу, то в

297
00:12:47,510 --> 00:12:49,730
консоли мы увидим, что переменная
принадлежит к классу String

298
00:12:49,730 --> 00:12:51,530
Так мы понимаем что работаем со строкой

299
00:12:52,480 --> 00:12:54,770
Бывают случаи, когда вам нужно

300
00:12:54,770 --> 00:12:57,180
явно указать тип переменной

301
00:12:57,180 --> 00:13:00,010
и выможете это сделать, если после
названия переменной напишите

302
00:13:00,010 --> 00:13:04,150
двоеточие и тип, который вам нужен

303
00:13:04,150 --> 00:13:05,550
в нашем примере будет String

304
00:13:06,933 --> 00:13:08,120
И справа значение "Donn Felker"

305
00:13:08,120 --> 00:13:10,630
Если я тут напишу неправильный тип

306
00:13:10,630 --> 00:13:13,983
например целочисленный Integer
и значение будет равно

307
00:13:13,983 --> 00:13:14,816
"Donn Felker", то мы получим ошибку

308
00:13:14,816 --> 00:13:16,640
И в ошибке сказано, что тип переменной
и присвоенное значение не совпадают

309
00:13:17,721 --> 00:13:20,200
Значением должно быть число

310
00:13:20,200 --> 00:13:21,970
а вы пытаетесь присвоить строку

311
00:13:21,970 --> 00:13:23,050
и это просто не сработает

312
00:13:23,050 --> 00:13:25,800
если вы попробуете запустить
программу, игнорируя ошибку

313
00:13:26,671 --> 00:13:27,660
то компилятор скажет вам все тоже самое:

314
00:13:27,660 --> 00:13:30,780
Присвоенный тип строковый, а

315
00:13:30,780 --> 00:13:32,280
ожидался целочисленный

316
00:13:32,280 --> 00:13:36,490
Поэтому нужно поменять либо
ожидаемый тип

317
00:13:36,490 --> 00:13:38,670
либо заменить присваеваемое значение.

318
00:13:38,670 --> 00:13:41,540
Еще пример, если мы создадим
переменную age

319
00:13:41,540 --> 00:13:43,820
и явно захотим указать ее тип

320
00:13:44,670 --> 00:13:46,440
то мы напишем тип перед значением

321
00:13:46,440 --> 00:13:49,520
Таким образом, каждый раз когда
вы хотите явно указать тип

322
00:13:49,520 --> 00:13:54,520
для val/var переменной
вы пишите двоеточие и тип

323
00:13:54,840 --> 00:13:57,350
вы пишите двоеточие и тип

324
00:13:57,350 --> 00:13:59,100
после названия переменной

325
00:14:00,590 --> 00:14:02,660
В языке Котлин есть несколько
строенных типов

326
00:14:02,660 --> 00:14:05,620
Для начала рассмотрим
числовые типы

327
00:14:05,620 --> 00:14:08,450
Самый маленький из них - Byte (байт)

328
00:14:08,450 --> 00:14:10,536
Я создам переменную и назову
ее myByte

329
00:14:10,536 --> 00:14:12,423
и укажу ей тип Byte

330
00:14:12,423 --> 00:14:14,630
я присвою ей значение 8

331
00:14:14,630 --> 00:14:18,110
Байт - целоцисленное значение
размеровм 8 бит

332
00:14:20,750 --> 00:14:23,680
Следующее число Short
я создам переменную

333
00:14:23,680 --> 00:14:28,630
myShort и явно укажу тип Short

334
00:14:28,630 --> 00:14:31,170
Этой переменной я присвою
значение 16

335
00:14:31,170 --> 00:14:34,960
и это целочисленное значение
размером 16 бит

336
00:14:34,960 --> 00:14:38,380
Как вы уже могли заметить,
чем дальше тем

337
00:14:38,380 --> 00:14:40,170
больше становятся размеры типов

338
00:14:40,170 --> 00:14:42,070
Это значит, что максимальная величина
числа, котоаря может в них

339
00:14:42,070 --> 00:14:46,090
хранится, тоже становится больше.
Мы подходим к самомму популярному

340
00:14:46,090 --> 00:14:49,090
типу, который вы будете видеть
чаще всего,

341
00:14:49,090 --> 00:14:50,950
и это тип Integer.

342
00:14:50,950 --> 00:14:53,890
Integer может хранить

343
00:14:53,890 --> 00:14:54,960
в себе 32 бита информации.

344
00:14:57,270 --> 00:14:59,920
Дальше идет тип Long.

345
00:14:59,920 --> 00:15:01,820
этот тип может вмещать всебя очень
длинные числа

346
00:15:02,674 --> 00:15:03,712
наверное поэтому он так и называется

347
00:15:03,712 --> 00:15:05,725
Этот тип удобно использовать

348
00:15:05,725 --> 00:15:08,340
когда вы работаете с большими числами
и он вмещает в себя

349
00:15:09,300 --> 00:15:10,133
64-бита информации

350
00:15:12,600 --> 00:15:14,120
Это встроенные числовые типы языка

351
00:15:14,120 --> 00:15:17,027
вы будете работать с ними,

352
00:15:17,027 --> 00:15:17,937
если используете числа в программе.

353
00:15:17,937 --> 00:15:19,110
Скорее всего, самым частым
в использовании для вас

354
00:15:19,110 --> 00:15:23,940
станет Integer, который покрывает
90% кейсов при работе с числами

355
00:15:23,940 --> 00:15:26,910
Если числа у вас будут очень большие

356
00:15:26,910 --> 00:15:28,410
то лучше использовать Long

357
00:15:29,426 --> 00:15:30,259
И когда это действительно необходимо,

358
00:15:30,259 --> 00:15:32,820
и вы будете работать с действительно
большими числами

359
00:15:34,020 --> 00:15:36,180
используйте Long

360
00:15:36,180 --> 00:15:38,756
Однако бывают ситуации
когда вам нужно будет работать

361
00:15:38,756 --> 00:15:39,589
с десятичными числами.

362
00:15:39,589 --> 00:15:42,000
Если вам нужно хранить десятичные чиста

363
00:15:42,000 --> 00:15:44,900
Вы можете использовать тип Float

364
00:15:45,780 --> 00:15:47,750
Запишем переменную с типом Float

365
00:15:47,750 --> 00:15:52,030
и допустим ее значение равно 32.00

366
00:15:52,865 --> 00:15:54,650
Я поставлю 'F' на конце, потому что

367
00:15:54,650 --> 00:15:57,200
это значит что этот литерал имеет тип Float

368
00:15:57,200 --> 00:16:00,180
Float содержить 32 бита информации

369
00:16:01,380 --> 00:16:02,480
и так же называется числом
с плавающей точной

370
00:16:05,130 --> 00:16:07,640
Этот минимальный по размеру тип
данных для чисел с плавающей точкой

371
00:16:07,640 --> 00:16:09,420
Если вам нужны числа больше

372
00:16:09,420 --> 00:16:11,900
то вы можете использовать
тип Double

373
00:16:11,900 --> 00:16:15,140
и называется он Double потому что
хранит в два раза больше информации

374
00:16:15,140 --> 00:16:19,900
а именно число с плавоющей точкой
размером 64 байта

375
00:16:21,050 --> 00:16:22,760
Итак, это основные численные типы

376
00:16:22,760 --> 00:16:23,690
Которые вы будете использовать

377
00:16:23,690 --> 00:16:27,000
внутри вашей программы

378
00:16:27,000 --> 00:16:29,900
Есть у них всех необычная особенность

379
00:16:29,900 --> 00:16:31,770
Если мы посмотрим определение
любого из этих типов

380
00:16:31,770 --> 00:16:32,670
например Byte

381
00:16:32,670 --> 00:16:34,850
мы можем увидеть, что оно расширяет
тип Number (число)

382
00:16:36,070 --> 00:16:39,010
То же самое с типом Short

383
00:16:39,010 --> 00:16:41,220
Short тоже расширяет тип Number

384
00:16:41,220 --> 00:16:43,610
И мы можем пройти по каждому из них

385
00:16:43,610 --> 00:16:46,210
и заметим что каждый из них

386
00:16:46,210 --> 00:16:51,210
Integer, Long, Float и т.д.

387
00:16:51,980 --> 00:16:56,170
все они расширяют абстрактный класс
Number

388
00:16:56,170 --> 00:16:57,280
Давайте посмотрим на Number

389
00:16:57,280 --> 00:16:59,400
и узнаем из чего он сотоит

390
00:16:59,400 --> 00:17:01,150
Если мы зайдем в реализацию
типа Number

391
00:17:01,150 --> 00:17:03,460
мы увидим, что внутри него находится
множество разных функций

392
00:17:03,460 --> 00:17:05,530
к которым у нас есть доступ

393
00:17:05,530 --> 00:17:08,000
Здесь возникает важная для
Котлин концепция

394
00:17:08,000 --> 00:17:13,000
о том что любой тип это объект

395
00:17:13,670 --> 00:17:14,620
в языке Котлин

396
00:17:14,620 --> 00:17:18,260
Даже если вот это целое число - это объект

397
00:17:18,260 --> 00:17:21,860
Этот лонг - объект
Этот байт - объект

398
00:17:21,860 --> 00:17:24,109
А это значит, что мы можем вызывать методы

399
00:17:24,109 --> 00:17:25,660
и свойства этих объектов

400
00:17:25,660 --> 00:17:29,540
Например, если я захочу вывести myByte

401
00:17:32,980 --> 00:17:35,870
Допустим я хочу поделить его на что-нибудь

402
00:17:35,870 --> 00:17:38,530
тут можно увидеть кучу математических
функций готовых для этого класса

403
00:17:38,530 --> 00:17:42,520
И это уже готовые функции для
всех встроенных типов

404
00:17:42,520 --> 00:17:45,210
Возможно я хочу использовать toDouble
я могу написать toDouble

405
00:17:45,210 --> 00:17:47,170
и это превратит мой байт в double тип

406
00:17:47,170 --> 00:17:49,970
И эти преобразования реализованы
в классе Number

407
00:17:50,897 --> 00:17:54,310
Если мы пойдем в родительский класс

408
00:17:54,310 --> 00:17:56,630
мы увидим, что эта функция
лежит именно там

409
00:17:56,630 --> 00:17:58,940
и возвращает Double

410
00:17:59,840 --> 00:18:01,940
И если я сейчас возьму этот байт и

411
00:18:01,940 --> 00:18:03,100
преобразую его в Double

412
00:18:03,100 --> 00:18:04,860
Если мы сейчас выведем его тип

413
00:18:04,860 --> 00:18:08,510
консоль, используя ::class

414
00:18:08,510 --> 00:18:09,690
и запустим программу

415
00:18:09,690 --> 00:18:11,920
вы увидите, что тип нашего байта
стал double

416
00:18:14,750 --> 00:18:16,060
Теперь, если мы сменим

417
00:18:16,060 --> 00:18:18,550
это значение на toLong

418
00:18:20,410 --> 00:18:23,630
и запустим снова, то увидим
что тип стал Long

419
00:18:26,003 --> 00:18:28,010
Мы получаем восемь

420
00:18:28,010 --> 00:18:31,270
просто мы забыли добавить ::class

421
00:18:32,340 --> 00:18:36,340
Вот теперь вывод показывает
тип Kotlin.Long

422
00:18:36,340 --> 00:18:39,200
Когда мы работаем с такими специфичными
типами, как Long

423
00:18:39,200 --> 00:18:41,340
мы можем использовать литералы

424
00:18:43,380 --> 00:18:46,390
Назовем переменную bigLong
и укажем тип Long

425
00:18:46,390 --> 00:18:48,640
И теперь мы можем использовать интересный
синтаксис языка

426
00:18:49,500 --> 00:18:53,440
Такой способ записи встроен
в синтаксис языка Котлим

427
00:18:53,440 --> 00:18:54,830
и читать большие числа в такой записи
гораздо легче

428
00:18:54,830 --> 00:18:56,520
Это значение равно одному миллиону

429
00:18:56,520 --> 00:19:00,590
И теперь, если мы захотим

430
00:19:00,590 --> 00:19:03,760
напечатать это число в консоль

431
00:19:03,760 --> 00:19:06,300
мы увидим что в выводе
будет просто один миллион,

432
00:19:06,300 --> 00:19:08,550
но читать такую запись
гораздо проще

433
00:19:08,550 --> 00:19:11,270
просто из-за визуального
разделения

434
00:19:11,270 --> 00:19:14,080
...

435
00:19:14,080 --> 00:19:16,950
Такой вид записи полезен,
когда у вас в программе

436
00:19:16,950 --> 00:19:19,530
есть, например, переменная в 1 миллион

437
00:19:19,530 --> 00:19:20,370
или в тысячу, неважно

438
00:19:20,370 --> 00:19:22,590
Вы можете упростить чтение

439
00:19:22,590 --> 00:19:26,120
потому что, допустим
если у вас будет миллиард

440
00:19:26,120 --> 00:19:29,920
такая запись гораздо легче,
чем без подчеркиваний

441
00:19:29,920 --> 00:19:31,680
потому что вы просто не понимаете
сразу с первого взгляда

442
00:19:31,680 --> 00:19:34,960
что это 1 миллион или
10 миллионов

443
00:19:34,960 --> 00:19:36,680
Это очень трудно определить

444
00:19:36,680 --> 00:19:39,310
но если добавить подчеркивания

445
00:19:39,310 --> 00:19:41,410
то разница становится очевидна

446
00:19:41,410 --> 00:19:43,110
что это 1 миллиард

447
00:19:43,110 --> 00:19:46,450
Еще одна вещь, которую
можно делать с числами -

448
00:19:46,450 --> 00:19:48,310
конечно мы можем их складывать

449
00:19:48,310 --> 00:19:50,250
Заведем переменную myInt

450
00:19:51,470 --> 00:19:55,000
а точнее newInt и напишем
что она равна myInt+12

451
00:19:55,000 --> 00:19:57,080
и это будет равно 44

452
00:19:57,080 --> 00:20:01,110
Выведем это число через println

453
00:20:01,110 --> 00:20:03,900
и когда мы запусти программу
внизу экрана

454
00:20:03,900 --> 00:20:08,030
мы увидим что newInt равен 44

455
00:20:08,030 --> 00:20:09,980
Еще мы можем использовать

456
00:20:09,980 --> 00:20:11,530
встроенные в Котлин методы

457
00:20:13,330 --> 00:20:15,360
напишем plus и число 12

458
00:20:17,240 --> 00:20:18,170
Теперь мы можем запустить

459
00:20:18,170 --> 00:20:20,640
Так вот, это очень удобный синтаксический
сахар для сложения

460
00:20:20,640 --> 00:20:22,070
мы так же получим 44

461
00:20:22,070 --> 00:20:25,570
Мы так же можем сделать minus и

462
00:20:25,570 --> 00:20:27,640
если запустим то увидим 20 (не 44)

463
00:20:28,681 --> 00:20:30,720
И таких математических функций
очень много

464
00:20:30,720 --> 00:20:32,600
мы можем посмотреть их все разом

465
00:20:32,600 --> 00:20:35,560
если просто введем точку,
чтобы среда подсказала

466
00:20:35,560 --> 00:20:36,860
нам эти методы.

467
00:20:36,860 --> 00:20:39,090
И если вы не знаете
какие-то из них

468
00:20:39,090 --> 00:20:40,020
вы можете посмореть их

469
00:20:40,020 --> 00:20:41,980
Например, вы не знаете

470
00:20:41,980 --> 00:20:45,200
метод "and" вы можете нажать
cmd+B

471
00:20:45,200 --> 00:20:47,210
и посмотреть определения функции
что and проводит

472
00:20:47,210 --> 00:20:49,250
побитовое "И" на двух числах

473
00:20:49,250 --> 00:20:52,980
Если вам нужны побитовые операции
вы ожете использовать для этого "and"

474
00:20:52,980 --> 00:20:57,520
вы можете вызвать функции "plus"
"multiply" или "times"

475
00:20:57,520 --> 00:20:58,580
и вы можете запустить
программу и посмотреть результат

476
00:20:58,580 --> 00:21:03,580
Умножая 32 на 12 мы получим 384

477
00:21:04,260 --> 00:21:06,910
Итак, все это базовые типы от
маленьких к большим

478
00:21:06,910 --> 00:21:09,230
Мы начинаем в byte, short,
int, long

479
00:21:10,094 --> 00:21:10,927
а потом переходим на десятичные

480
00:21:10,927 --> 00:21:11,890
типы float и double

481
00:21:11,890 --> 00:21:14,190
Это встроенные бызовые числовые
типы языка Котлин

482
00:21:15,380 --> 00:21:18,410
В языке котлин строки
тоже являются объектами

483
00:21:18,410 --> 00:21:21,460
Если мы вернемся к нашему
первому примеру с полным именем

484
00:21:21,460 --> 00:21:25,210
и явно укажем у fullName
строковый тип String

485
00:21:25,210 --> 00:21:28,320
и запишем значение "Donn Felker"
мы получим строковый объект

486
00:21:28,320 --> 00:21:32,280
с названием fullName
и значением "Donn Felker"

487
00:21:33,140 --> 00:21:36,180
У него мы можем вызывать

488
00:21:36,180 --> 00:21:38,950
методы, напечатав точку

489
00:21:38,950 --> 00:21:40,310
например, чтобы узнать длину строки

490
00:21:41,768 --> 00:21:43,792
Так мы получим длину строки

491
00:21:43,792 --> 00:21:46,130
Я скопирую эту строку с помощью
хоткея cmd+D

492
00:21:46,130 --> 00:21:50,630
Можно получить все символы строки

493
00:21:50,630 --> 00:21:53,690
которые мы получим в виде
набора символов

494
00:21:53,690 --> 00:21:55,730
Можно использовать очень много

495
00:21:55,730 --> 00:21:57,300
готовых функций

496
00:21:57,300 --> 00:22:00,060
например, я могу привести к
строчному виду первый символ строки

497
00:22:00,060 --> 00:22:01,880
Давайте приведем к строчному виду

498
00:22:01,880 --> 00:22:06,250
и запустим программу,
снизу мы увидим

499
00:22:06,250 --> 00:22:11,250
"donn Felker" - наша строка
в строчном виде

500
00:22:11,350 --> 00:22:14,820
Если мы будем работать с предложением,
допустим строкой "Hello World"

501
00:22:15,860 --> 00:22:18,220
если я снова запущу
программу, мы увидим

502
00:22:18,220 --> 00:22:20,450
что первый символ новой строки

503
00:22:20,450 --> 00:22:21,740
будет строчным

504
00:22:21,740 --> 00:22:24,060
Если я захочу, чтобы вся строка
была в нижнем регистре

505
00:22:24,060 --> 00:22:27,730
анпишем toLowercase
и запустим программу

506
00:22:27,730 --> 00:22:30,280
и это позволяет сделать все символы

507
00:22:30,280 --> 00:22:31,910
строки в строчном виде

508
00:22:31,910 --> 00:22:36,910
Строки в котлине можно создавать
используя две кавычки

509
00:22:38,780 --> 00:22:41,320
Мы можем написать firastName "Donn"

510
00:22:41,320 --> 00:22:42,153
обязательно через две кавычки

511
00:22:42,153 --> 00:22:43,060
Есть еще один тип, когда

512
00:22:43,060 --> 00:22:45,480
мы хотим работать с единичными
символами

513
00:22:45,480 --> 00:22:47,900
мы можем использовать тип Char
(character - символ)

514
00:22:47,900 --> 00:22:51,000
Я напишу "val c"
с типом Char

515
00:22:51,000 --> 00:22:54,330
и присвою ему значение X

516
00:22:55,700 --> 00:22:57,850
Стоп, что-то идет не так

517
00:22:58,710 --> 00:23:01,450
Почему ругается компилятор?

518
00:23:01,450 --> 00:23:04,670
Все потому что, если в Котлине
вы хотите объявить символ

519
00:23:04,670 --> 00:23:07,880
Вам нужно использовать литерал
одинарных ковычек (апострофоф)

520
00:23:07,880 --> 00:23:11,550
Апострофы дают возможность создать

521
00:23:11,550 --> 00:23:13,810
символьные объекты

522
00:23:15,170 --> 00:23:18,940
Тут есть небольшой подвох

523
00:23:18,940 --> 00:23:22,930
Символы бывают разными, например
символ Tab отступа

524
00:23:22,930 --> 00:23:25,060
для того чтобы его создать
нужно указать символ "\" перед "t"

525
00:23:25,060 --> 00:23:27,221
есть еще перенос строки '\n'

526
00:23:27,221 --> 00:23:29,850
и, конечно, если вы хотите создать
символ "\", вам нужно написать '\\'

527
00:23:29,850 --> 00:23:31,670
в Котлине есть еще много специальных
символов, которые вы

528
00:23:31,670 --> 00:23:33,750
можете найти самостоятельно.

529
00:23:33,750 --> 00:23:38,650
В котлине тип Char это
16-ти битный юникод символ

530
00:23:39,710 --> 00:23:43,272
Поэтому каждый раз, когда
вам понадобится символ

531
00:23:43,272 --> 00:23:44,750
спокойно используйте тип Char

532
00:23:44,750 --> 00:23:46,800
Но ничего вам не межает использовать

533
00:23:46,800 --> 00:23:49,140
строковый тип с одним символом

534
00:23:52,695 --> 00:23:54,395
Можем написать переменную "foo"
с типом String и написать, что

535
00:23:55,540 --> 00:23:56,410
это равно "Y" и это
будет работать

536
00:23:56,410 --> 00:23:59,360
В этом случае вы будете работать
с типом String

537
00:23:59,360 --> 00:24:01,890
Единственная разнича, что
строка в памяти будет занимать

538
00:24:03,010 --> 00:24:04,450
больше места, чем "Char"

539
00:24:04,450 --> 00:24:06,100
Но вряд ли это на что-то сильно повлияет
и вы можете работать со строкой

540
00:24:06,100 --> 00:24:08,821
Однако, если вы точно знаете, что
у переменной будет только один

541
00:24:08,821 --> 00:24:11,150
символ, то лучше работать
с типом Char

542
00:24:13,030 --> 00:24:13,863
Иногда, при создании строки,
вам нужно написать ее в

543
00:24:13,863 --> 00:24:17,120
несколько строк

544
00:24:17,120 --> 00:24:19,180
Наприме, если у нас есть
переменная "message"

545
00:24:19,180 --> 00:24:21,700
и значение у нее будет "Hello"

546
00:24:21,700 --> 00:24:22,920
символ переноса строки

547
00:24:25,118 --> 00:24:27,550
"меня зову Донн Фэлкер"
символ новой строки

548
00:24:29,217 --> 00:24:30,360
"как ваши дела" и выведу это
на экран

549
00:24:31,660 --> 00:24:34,310
И когда я запущу,
я увижу все свое сообщение

550
00:24:34,310 --> 00:24:36,510
на нескольких строках

551
00:24:36,510 --> 00:24:39,240
Но выглядит это очень убого

552
00:24:39,240 --> 00:24:41,480
В Котлине есть способ для
таких случаев

553
00:24:41,480 --> 00:24:43,880
можно использовать три
ковычки подряд

554
00:24:45,006 --> 00:24:49,493
Перепишем наш текст и уберем
символы переносы строки

555
00:24:50,853 --> 00:24:52,260
и снова запустим программу

556
00:24:54,040 --> 00:24:55,910
Я для запуска использую шорткат

557
00:24:55,910 --> 00:24:59,520
который можно посмотреть здесь.
Это шорткат

558
00:24:59,520 --> 00:25:01,540
control+shift+R на Маке

559
00:25:03,004 --> 00:25:05,075
В окне вывода можно увидеть,
что результат тот же самый

560
00:25:05,075 --> 00:25:05,908
"Hello, my name is Donn Felker."

561
00:25:05,908 --> 00:25:06,741
Но что значит trimIndent

562
00:25:06,741 --> 00:25:07,960
Что тут происходит

563
00:25:07,960 --> 00:25:11,290
Наш текст форматируется так же как
он записывается в тройные кавычки

564
00:25:11,290 --> 00:25:14,068
функция trimIndent просто затирает
ненужные пробелы

565
00:25:14,068 --> 00:25:14,970
Мы можем посмотреть
документацию функции

566
00:25:14,970 --> 00:25:18,470
trimIndent затирает отступы
в каждой строке

567
00:25:18,470 --> 00:25:20,520
вашего предложения

568
00:25:20,520 --> 00:25:23,390
Если мы уберем этот метод
мы увидим что

569
00:25:23,390 --> 00:25:26,130
появилось много ненужных отступов

570
00:25:26,130 --> 00:25:27,280
Строка наша начнется с символа новой строки

571
00:25:27,280 --> 00:25:29,440
и каждая отдельная строка
будет иметь большой отступ

572
00:25:29,440 --> 00:25:32,118
Запустим и проверим

573
00:25:32,118 --> 00:25:32,951
Вот наш перенос строки

574
00:25:32,951 --> 00:25:34,490
и везде появились отступы

575
00:25:34,490 --> 00:25:38,240
Вернем наш метод обратно, чтобы

576
00:25:38,240 --> 00:25:42,970
убрать переносы и лишние отступы

577
00:25:42,970 --> 00:25:46,340
Я перезапушу программу, чтобы
вернуть все назад

578
00:25:46,340 --> 00:25:49,920
Теперь посмотрим на функцию
replaceIndent

579
00:25:49,920 --> 00:25:52,160
Если напрмер я хочу самомстоятельно
заменить отступы в

580
00:25:52,160 --> 00:25:55,020
строке, но не хочу их убирать,
а хочу подставить что-то другое

581
00:25:55,020 --> 00:25:57,700
а хочу подставить что-то другое

582
00:25:57,700 --> 00:26:02,700
например строку "abc" и символ
вертикальной черточки

583
00:26:03,710 --> 00:26:05,210
или что-то другое

584
00:26:05,210 --> 00:26:07,770
Если я запущу это, программа
заменит отступы

585
00:26:07,770 --> 00:26:11,160
в каждой строке на то что
я ей сказал

586
00:26:11,160 --> 00:26:15,390
выглядит очень круто

587
00:26:15,390 --> 00:26:17,890
Еще это форматирование
можно регулировать

588
00:26:17,890 --> 00:26:20,760
с помощью метода

589
00:26:20,760 --> 00:26:25,760
trimMargin. напишем наш метод
и укажем какой-нибудь префикс

590
00:26:27,310 --> 00:26:29,740
Например я хочу чтобы в тексте

591
00:26:29,740 --> 00:26:33,590
форматировались только строки у
которых в начале три стрелочки ">>>"

592
00:26:33,590 --> 00:26:37,600
Если я запущу программу со строкой
в таком виде, то мы уидим

593
00:26:37,600 --> 00:26:39,160
что программа не нашла нашего префикса

594
00:26:39,160 --> 00:26:40,540
поэтому ничего не меняла

595
00:26:40,540 --> 00:26:43,550
Это значит, что для этой функции

596
00:26:43,550 --> 00:26:44,383
в строке должны быть стрелочки

597
00:26:44,383 --> 00:26:45,216
Допустим эти стрелочки

598
00:26:45,216 --> 00:26:46,870
появились, добавим их везде

599
00:26:49,279 --> 00:26:50,540
И если теперь это запустим

600
00:26:50,540 --> 00:26:51,890
мы увидим, что все три строки
теперь без отступов

601
00:26:51,890 --> 00:26:55,670
Если мы уберем значение
префикса из функции

602
00:26:56,917 --> 00:26:59,020
то эти стрелочки появятся в
выводе вместе с отступами

603
00:26:59,020 --> 00:27:03,450
У метода trimmargin
есть значение по дефолту

604
00:27:03,450 --> 00:27:07,960
это символ вертикальной черты "|"

605
00:27:09,830 --> 00:27:13,480
Я допишу символы и запущу программу

606
00:27:13,480 --> 00:27:15,320
Функция нашла строки с вертикальной
чертой и убрала все отступы

607
00:27:15,320 --> 00:27:16,860
и саму черту

608
00:27:16,860 --> 00:27:19,470
Вот таким образом можно делать

609
00:27:19,470 --> 00:27:21,570
многострочные предложение

610
00:27:21,570 --> 00:27:24,430
Еще одна интересная штуковина:
допустим, у нас есть

611
00:27:24,430 --> 00:27:26,650
переменная "name" со значением "Donn"

612
00:27:26,650 --> 00:27:29,470
Иногда, у вас может возникнуть
необходимость вывести

613
00:27:29,470 --> 00:27:30,610
сообщение в консоль таким образом:

614
00:27:30,610 --> 00:27:32,460
представьте, что мы хотим поприветствовать
человека и написать "Hello Donn"

615
00:27:33,414 --> 00:27:35,760
Мы сделаем это с помощью
конкатенации строк

616
00:27:35,760 --> 00:27:38,980
это самый стандартный метод
для многих языков и он рабочий

617
00:27:39,920 --> 00:27:42,581
Запустим и увидим в консоли
"Hello Donn"

618
00:27:42,581 --> 00:27:43,414
Все работает как должно

619
00:27:43,414 --> 00:27:45,050
Но обратите внимание, что
копилятор подчеркнул нашу строку

620
00:27:45,050 --> 00:27:47,260
В подсказке он предлагает
перевести конкатенацию в шаблон

621
00:27:47,260 --> 00:27:49,510
В Котлине вы можете соединять
строки без конкатенации,

622
00:27:49,510 --> 00:27:50,920
а с помощью шаблонов

623
00:27:50,920 --> 00:27:54,060
На подсвеченной строке нажмем alt+enter
и возникнет подсказка

624
00:27:54,060 --> 00:27:55,970
выберем первый пункт и

625
00:27:55,970 --> 00:27:57,540
компилятор сам исправит наш код

626
00:27:57,540 --> 00:27:59,290
И новый код делает
ровно ту же вещь

627
00:28:00,596 --> 00:28:03,130
С единственным исключением
что в коде это

628
00:28:03,130 --> 00:28:04,730
выглядит как одна строка

629
00:28:05,820 --> 00:28:08,290
Добавим еще возраст

630
00:28:08,290 --> 00:28:09,460
допустим 32

631
00:28:10,957 --> 00:28:12,410
И скажем "Приввет имя, твой возраст"

632
00:28:12,410 --> 00:28:15,948
и добавим age переменную
в конце

633
00:28:15,948 --> 00:28:19,650
И теперь возраст тоже выведется
в этой строке.

634
00:28:20,780 --> 00:28:23,416
Еще одна интересная вещь,
которую мы можем

635
00:28:23,416 --> 00:28:25,030
делать через шаблоны -

636
00:28:25,030 --> 00:28:25,863
напишем в таком виде

637
00:28:25,863 --> 00:28:30,860
Привет, дальше имя, возраст
и добавим "длина твоего имени"

638
00:28:31,890 --> 00:28:33,430
поставим знак доллара

639
00:28:34,780 --> 00:28:37,100
откроем фигурные скобки и
у переменной вызовем функцию

640
00:28:37,100 --> 00:28:39,420
через точку, чтобы вывести длину
переменной

641
00:28:40,910 --> 00:28:42,240
получится ${name.length}

642
00:28:43,450 --> 00:28:44,283
И теперь в консоль выведется

643
00:28:44,283 --> 00:28:46,520
Привет Дон, тебе 32 года

644
00:28:46,520 --> 00:28:51,520
и твое имя такой-то длинны

645
00:28:52,630 --> 00:28:53,530
запустим этот код

646
00:28:55,530 --> 00:28:57,540
Привет Дон, тебе 32 года и твое имя

647
00:28:57,540 --> 00:28:58,490
длинной 4 символа

648
00:28:58,490 --> 00:29:03,330
Таким образом вместо сложной
конкатенации строк

649
00:29:03,330 --> 00:29:04,700
можно просто

650
00:29:04,700 --> 00:29:07,390
использовать интерполяцию строк

651
00:29:07,390 --> 00:29:08,870
и шаблонами передавать значения

652
00:29:08,870 --> 00:29:11,470
Если вы не вызываете методов
то можно просто писать знак доллара

653
00:29:11,470 --> 00:29:14,660
а методы нужно оборачивать в
фигурные скобки

654
00:29:14,660 --> 00:29:17,550
В любом случае компилятор

655
00:29:17,550 --> 00:29:21,120
и IDE подскажет вам, если что-то
лишнее или чего-то не хватает

656
00:29:21,120 --> 00:29:23,260
так вы можете писать код прямо в строку

657
00:29:23,260 --> 00:29:25,440
и оборачивать его в фигурные скобки

658
00:29:26,430 --> 00:29:29,890
И последний важный тип - Boolean

659
00:29:29,890 --> 00:29:31,720
Мы можем объявить его
следующим образом

660
00:29:31,720 --> 00:29:33,150
Создадим переменную isBlank

661
00:29:34,298 --> 00:29:37,040
с типом Boolean, переменная будет
обозначать "правда" или "ложь"

662
00:29:37,040 --> 00:29:39,960
присвоим ей "false" значение

663
00:29:39,960 --> 00:29:42,480
И у этого типа есть всего
два варианта

664
00:29:42,480 --> 00:29:44,780
он может быть либо true, либо false.
Посмотрим на реализацию этого типа

665
00:29:44,780 --> 00:29:47,300
Мы опять видим что это объект

666
00:29:47,300 --> 00:29:49,280
И в нем есть встроенные
методы операторы, например "not()"

667
00:29:49,280 --> 00:29:52,020
С помощью него можно
инвертировать значение

668
00:29:52,020 --> 00:29:55,350
Если мы хотим узнать...
Давайте я сразу напишу

669
00:29:55,350 --> 00:30:00,350
вызовем println и вставим переменную

670
00:30:03,410 --> 00:30:05,860
и напишем то же самое, но укажем
в конце "not()", чтобы инвертировать

671
00:30:05,860 --> 00:30:09,110
Если мы запустим сейчас этот код
в выводе мы увиди

672
00:30:09,110 --> 00:30:11,120
в первую очередь - оригинальное
значение "false" и инверсию "true"

673
00:30:11,120 --> 00:30:13,450
Мы инициализировали переменную
как false, а оператор инверсии

674
00:30:13,450 --> 00:30:16,910
вернул true
Также мы можем проинициализировать

675
00:30:16,910 --> 00:30:20,430
тип Boolean с помощью пустой строки
и вызвать на ней метод isBlank()

676
00:30:21,800 --> 00:30:22,760
Напишем пустую строку

677
00:30:22,760 --> 00:30:26,950
и вызовем метод

678
00:30:26,950 --> 00:30:29,440
Функция isBlank у строки проверяет

679
00:30:29,440 --> 00:30:31,430
длину последовательности символов

680
00:30:31,430 --> 00:30:36,110
и возвращает нам тип Boolean
в зависимости от того,

681
00:30:36,110 --> 00:30:38,320
пустая она или нет
если пустая, то вернет true

682
00:30:38,320 --> 00:30:40,010
теперь мы можем вывести результат тут

683
00:30:40,010 --> 00:30:44,440
я просто скопирую код
и мы сможем увидеть

684
00:30:44,440 --> 00:30:45,380
результат true или false

685
00:30:47,480 --> 00:30:50,220
Запустим программу,
очевидно что наша строка пустая

686
00:30:50,220 --> 00:30:53,970
Если я поменяю пустую строку на имя

687
00:30:53,970 --> 00:30:55,940
и запущу, то результат будет false

688
00:30:56,807 --> 00:30:58,480
единственный true вывод это
результат действия

689
00:30:58,480 --> 00:30:59,610
оператора "not"

690
00:30:59,610 --> 00:31:02,500
У класса Boolean есть еще
несколько методов

691
00:31:02,500 --> 00:31:05,330
которые вы можете
посмотреть самостоятельно

692
00:31:05,330 --> 00:31:08,150
в основном это логически "и", "или",
"xor" и т.д.

693
00:31:08,150 --> 00:31:09,510
И еще разные другие

694
00:31:09,510 --> 00:31:10,970
Вы можете их посмотреть, нажав
cmd+клик на типе Boolean

695
00:31:10,970 --> 00:31:13,600
или ctrl+клик на Windows

696
00:31:13,600 --> 00:31:16,310
Если вам нужна переменная, которая
имеет два состояния "ложь" или "правда"

697
00:31:16,310 --> 00:31:18,340
то вам нужно использовать тип Boolean

698
00:31:19,310 --> 00:31:21,630
Работа с такими условными типами
это очень частая вещь в языке Котлин

699
00:31:21,630 --> 00:31:23,224
тип Boolean используется везде,
где есть проверки на истинность

700
00:31:23,224 --> 00:31:26,040
Давайте представим, что вы работаете
над приложением, которое

701
00:31:26,040 --> 00:31:28,580
отслеживает ваше дневное
потребление калорий

702
00:31:28,580 --> 00:31:31,300
Допустим мы начинаем день с 2,500 калорий

703
00:31:31,300 --> 00:31:34,530
и это калории, которые мы
уже получили за день

704
00:31:34,530 --> 00:31:37,328
точнее говоря, пользователь
уже употребил 2500 калорий

705
00:31:37,328 --> 00:31:38,330
и следит за своей нормой.

706
00:31:38,330 --> 00:31:40,410
Допустим у нас есть условие, которое
гласит, что если

707
00:31:40,410 --> 00:31:43,980
пользователь употребил больше
2000 калорий, то мы должны вывести

708
00:31:43,980 --> 00:31:47,300
ему сообщение

709
00:31:47,300 --> 00:31:50,240
о том, что они уже употребили
достаточно калорий на сегодня

710
00:31:50,240 --> 00:31:52,740
и нужно воздержаться.

711
00:31:55,260 --> 00:31:57,370
Я добавил сообщение, которое

712
00:31:57,370 --> 00:31:58,260
выведет это в консоль

713
00:31:58,260 --> 00:32:00,330
Если мы запустим, то
внизу мы увидим сообщение

714
00:32:00,330 --> 00:32:02,590
что пользователь может

715
00:32:02,590 --> 00:32:04,630
больше ничего не употреблять

716
00:32:04,630 --> 00:32:06,190
и наше условие выполнилось

717
00:32:06,190 --> 00:32:10,380
Теперь, если мы изменим
значение на 1900

718
00:32:10,380 --> 00:32:13,261
Мы увидим, что сообщение
больше не выводится

719
00:32:13,261 --> 00:32:15,480
потому что мы не попали в условный
блок и наше кол-во калорий

720
00:32:15,480 --> 00:32:18,160
меньше чем 2000.

721
00:32:18,160 --> 00:32:20,730
Если мы не попали в блок if
то все что в нем написано не запустится

722
00:32:20,730 --> 00:32:25,050
Давайте допустим, что мы хотим вывести
что-то другое, если норма калорий

723
00:32:25,970 --> 00:32:28,240
не превысила желаемую

724
00:32:28,240 --> 00:32:29,930
для этого мы будем использовать
блок else

725
00:32:29,930 --> 00:32:31,930
и напишем другой текст.

726
00:32:31,930 --> 00:32:33,080
напишем println.

727
00:32:35,700 --> 00:32:36,970
И если мы запустим код в таком
виде, то увидим что вывелось второе

728
00:32:36,970 --> 00:32:39,950
сообщение, о том, что
нужно добавить еще калорий

729
00:32:39,950 --> 00:32:42,080
Так выглядят условные if-else
блоки

730
00:32:42,080 --> 00:32:44,967
Если условие после if выполняется,
то мы выполним код в "if", а иначе - код из "else"

731
00:32:44,967 --> 00:32:48,080
Если будет больше 2000 калорий

732
00:32:48,932 --> 00:32:50,200
то мы попадем сюда

733
00:32:51,234 --> 00:32:53,445
иначе - попадем в этот блок кода

734
00:32:53,445 --> 00:32:55,100
На это разветвление логики влияет
условие в круглых скодках

735
00:32:55,100 --> 00:32:58,210
И если калорий меньше 2000 мы попадем
во второй блок

736
00:32:58,210 --> 00:33:03,000
Давайте вставим 2001 и перезапустим

737
00:33:03,000 --> 00:33:05,790
увидим что мы вывели сообщение
из первого блока

738
00:33:05,790 --> 00:33:07,390
и пользователю достаточно калорий.

739
00:33:08,476 --> 00:33:09,610
Теперь давайте допустим, что
вы работаете с кем-то

740
00:33:09,610 --> 00:33:11,910
и они решили, или вы решили, что в вашем

741
00:33:12,766 --> 00:33:15,110
приложении вам нужно убедиться, что
пользователь

742
00:33:15,110 --> 00:33:18,320
точно употребил больше 1500 калорий

743
00:33:19,200 --> 00:33:21,080
И вам нужно его мотивировать,

744
00:33:21,080 --> 00:33:23,100
если он еще не достиг
этой цели и чтобы он

745
00:33:23,100 --> 00:33:25,170
еще взял чего-нибудь перекусить

746
00:33:25,170 --> 00:33:29,020
И вы можете написать:
Если калорий меньше чем...

747
00:33:29,950 --> 00:33:33,800
простите, больше чем 1500

748
00:33:33,800 --> 00:33:37,781
допустим сейчас их 2000.

749
00:33:37,781 --> 00:33:38,750
Итак, если их больше чем 1500

750
00:33:38,750 --> 00:33:42,020
напишем что нужно съесть

751
00:33:42,020 --> 00:33:45,820
еще немного

752
00:33:46,860 --> 00:33:49,320
И если мы сейчас запустим,
мы увидим, что выводится

753
00:33:49,320 --> 00:33:50,520
самое первое условие

754
00:33:50,520 --> 00:33:53,020
и пользователь употребил
достаточно калорий

755
00:33:53,020 --> 00:33:54,380
Теперь немного поменяем количество
калорий

756
00:33:54,380 --> 00:33:58,460
пусть это будет 1750
и перезапустим.

757
00:33:58,460 --> 00:34:00,080
теперь программа скажет

758
00:34:00,080 --> 00:34:01,960
фразу из второго блока, о том
что нужно еще поднажать.

759
00:34:02,808 --> 00:34:04,030
Вот в выводе это написано

760
00:34:04,030 --> 00:34:08,120
И если теперь поменяем значение
на 1499

761
00:34:08,120 --> 00:34:10,520
оба наших условия будут false

762
00:34:10,520 --> 00:34:11,800
И программа провалится в последний

763
00:34:11,800 --> 00:34:13,010
блок кода и выполнит только его

764
00:34:13,010 --> 00:34:16,420
первые два условия не пройдут,
останется только else, который

765
00:34:16,420 --> 00:34:19,750
выполнится, если ни одно из предыдущих
не выполнилось.

766
00:34:19,750 --> 00:34:22,480
Перезапустим и увидим на деле.

767
00:34:22,480 --> 00:34:26,350
Вы можете строить такие цепочки
из if, else if сколько угодно

768
00:34:26,350 --> 00:34:27,990
Давайте добавим еще одно условие

769
00:34:27,990 --> 00:34:30,450
пусть это будет еще один else-if

770
00:34:30,450 --> 00:34:31,920
Представим, что есть еще рубеж,

771
00:34:31,920 --> 00:34:36,920
например, в 1200 калорий

772
00:34:39,290 --> 00:34:41,790
и добавим еще одно сообщение
в этом случае

773
00:34:45,200 --> 00:34:48,070
И запустим теперь с другим
значением

774
00:34:48,070 --> 00:34:51,690
например с 1400, и выводе

775
00:34:52,540 --> 00:34:54,140
внизу увидим

776
00:34:54,140 --> 00:34:56,670
наше новое сообщение.

777
00:34:56,670 --> 00:34:59,400
Мы можем написать сколько
угодно таких проверок.

778
00:34:59,400 --> 00:35:01,820
В Котлине нет предела на использование
блоков else-if.

779
00:35:01,820 --> 00:35:03,400
В Котлине нет предела на использование
блоков else-if.

780
00:35:03,400 --> 00:35:05,510
Если у вас много условий

781
00:35:05,510 --> 00:35:09,220
или у вас есть одно if else
условия

782
00:35:09,220 --> 00:35:10,520
например так

783
00:35:11,909 --> 00:35:13,260
самое простое if или else

784
00:35:13,260 --> 00:35:15,300
Вам совсем необязательны все другие
условия

785
00:35:15,300 --> 00:35:17,890
И даже если вам else не нужен

786
00:35:19,193 --> 00:35:21,650
вы можете просто выполнить одну
if провеку и если

787
00:35:21,650 --> 00:35:24,640
условие будет true, то
выведется этот текст

788
00:35:24,640 --> 00:35:26,540
Это я к тому что использование

789
00:35:26,540 --> 00:35:29,190
'else' и 'if else'

790
00:35:29,190 --> 00:35:30,720
необязательны в логических блоках.

791
00:35:30,720 --> 00:35:33,920
Повторим, у нас есть блок с 'if'

792
00:35:33,920 --> 00:35:37,540
и мы можем добалять сколько угодно
'else if' блоков

793
00:35:37,540 --> 00:35:39,890
можем добавить еще один

794
00:35:39,890 --> 00:35:43,800
и например в нем будет проверка
на 1000 калорий,

795
00:35:43,800 --> 00:35:48,800
можете написать другой текст

796
00:35:50,060 --> 00:35:54,640
И если по условию мы придем
сюда, то выведется

797
00:35:54,640 --> 00:35:56,110
эта строка о том

798
00:35:57,397 --> 00:35:58,230
что еще много калорий нужно употребить

799
00:35:58,230 --> 00:36:02,080
И снова, допустим у нас есть
сейчас 800 калорий

800
00:36:02,080 --> 00:36:04,340
и мы запустили программу

801
00:36:04,340 --> 00:36:06,774
то выведется нижнее сообщение

802
00:36:06,774 --> 00:36:09,260
потому что калорий не больше
чем 2000

803
00:36:09,260 --> 00:36:12,350
Не больше чем 1500,
Не больше чем 1200,

804
00:36:12,350 --> 00:36:13,770
Не больше чем 1000.

805
00:36:13,770 --> 00:36:16,690
Поэтому самое последнее условие
будет выведено

806
00:36:16,690 --> 00:36:20,460
И это очень простая
условная проверка

807
00:36:20,460 --> 00:36:21,293
которую вы можете использовать.

808
00:36:21,293 --> 00:36:23,380
Такие типы проверок будут
часто встречаться

809
00:36:23,380 --> 00:36:24,920
в ваших программах.

810
00:36:24,920 --> 00:36:28,330
В Котлине вы можете в условных
выражениях вообще не писать

811
00:36:28,330 --> 00:36:31,660
фигурных скобок и это будет
выглядеть как однострочные условия

812
00:36:31,660 --> 00:36:34,550
Допустим, если возраст больше
10 то можно вывести

813
00:36:34,550 --> 00:36:39,110
текст, который будет об этом
уведомлять

814
00:36:40,200 --> 00:36:43,630
Давайте поменяем на 11
и запустим программу

815
00:36:43,630 --> 00:36:45,460
Мы увидем в выводе сообщение
о том что

816
00:36:45,460 --> 00:36:46,960
возраст больше чем 10.

817
00:36:48,376 --> 00:36:50,430
Если, по какой-то причине значение
станет девяткой

818
00:36:50,430 --> 00:36:54,370
Заметьте, что никакой ошибки нет

819
00:36:54,370 --> 00:36:57,470
но мы не видим теперь наш текст

820
00:36:57,470 --> 00:37:02,470
Просто наше условие не выполняется
но при этом

821
00:37:03,410 --> 00:37:04,280
мы не пишем никаких фигурных скобок.
Все тоже самое.

822
00:37:04,280 --> 00:37:06,750
Но постарайтесь избегать
такой формы записи

823
00:37:06,750 --> 00:37:09,130
Чем сложнее условие в "if"
и операции, которые нужно сделать

824
00:37:09,130 --> 00:37:10,430
если оно выполняется.
Например мы напишем что-то вроде этого

825
00:37:12,102 --> 00:37:13,140
Напишем еще один вывод

826
00:37:14,415 --> 00:37:15,248
Основываясь на отступе, вам будет казаться

827
00:37:15,248 --> 00:37:17,300
что второй текст не будет выведен

828
00:37:17,300 --> 00:37:21,340
но на самом деле, второй текст
уже не входит в if блок

829
00:37:21,340 --> 00:37:23,770
Подсвеченый код - это и есть

830
00:37:23,770 --> 00:37:25,170
if условие, которое выполнится

831
00:37:26,717 --> 00:37:29,070
Вторая часть в этот блок не входит

832
00:37:29,070 --> 00:37:31,130
хотя выглядит идентично.

833
00:37:31,130 --> 00:37:33,230
Поэтому если у вас есть код
в несколько строчек

834
00:37:33,230 --> 00:37:34,300
который должен выполнится по

835
00:37:34,300 --> 00:37:36,940
условию, то лучше явно указать
фигурные скобки, чтобы

836
00:37:36,940 --> 00:37:40,350
было явно видно, что будет
выполнено, если выполнится условие

837
00:37:41,408 --> 00:37:42,241
И когда вы пишите код, постарайтесь

838
00:37:42,241 --> 00:37:44,220
писать его так, чтобы вы могли понять

839
00:37:44,220 --> 00:37:46,280
его через какое-то время

840
00:37:46,280 --> 00:37:49,250
Я заикался про однострочные
условия, но так и не показал

841
00:37:49,250 --> 00:37:52,820
что это значин

842
00:37:52,820 --> 00:37:54,560
Это значит, что вы можете
написать все if условие

843
00:37:54,560 --> 00:37:55,540
на одной строке

844
00:37:55,540 --> 00:37:58,880
Если мы запустим программу

845
00:37:58,880 --> 00:38:00,420
мы увидим, что условие не выполнилось
и в консоли нет строки из if блоака

846
00:38:00,420 --> 00:38:02,290
А вот "Hello there" вывелся, потому

847
00:38:02,290 --> 00:38:05,040
что он вне условия,
а само услое не прошло, потому что

848
00:38:05,040 --> 00:38:06,090
возраст должен быть больше 10

849
00:38:06,090 --> 00:38:08,180
Если поменяем на 11

850
00:38:08,180 --> 00:38:11,273
и перезапустим, то однострочный
if выполнится

851
00:38:11,273 --> 00:38:13,922
и такое выражение очень просто читается

852
00:38:13,922 --> 00:38:16,340
Итак, если мы пишем условие
в одну строку

853
00:38:16,340 --> 00:38:20,360
то это удобно читать и мы понимаем,
что код снизу

854
00:38:20,360 --> 00:38:22,880
не будет зависеть от условия

855
00:38:22,880 --> 00:38:25,673
Если вы пишете в таком формате

856
00:38:25,673 --> 00:38:27,210
то фигурные скобки можно не писать,
все просто и понятно

857
00:38:28,490 --> 00:38:30,050
очень хороший и понятный код

858
00:38:30,050 --> 00:38:31,220
Если я запущу, то обе

859
00:38:31,220 --> 00:38:33,365
строки выведутся в консоль

860
00:38:33,365 --> 00:38:35,790
Если поменяем возраст на девятку

861
00:38:35,790 --> 00:38:38,270
то увидим только вторую строку,
она не входит

862
00:38:38,270 --> 00:38:40,490
в условие, а пожтому всегда
выаодится

863
00:38:40,490 --> 00:38:43,448
Можно еще немного усложнить
и дописать это до 'if else' условия

864
00:38:43,448 --> 00:38:44,840
Если вы понимаете, что ваше 'if else'
условие будет достаточно коротким

865
00:38:44,840 --> 00:38:47,800
то можно дописать else и опять же
не ставить фигурные

866
00:38:47,800 --> 00:38:48,633
скобки. И все делать в одну линию

867
00:38:48,633 --> 00:38:53,360
Итак, выводим один текст, если возраст
меньше 10

868
00:38:54,280 --> 00:38:56,440
И все наше условное выражение будет

869
00:38:56,440 --> 00:38:57,880
в одну строку

870
00:38:57,880 --> 00:39:00,270
и оно хорошо читается.

871
00:39:00,270 --> 00:39:02,551
Если запустим, то увидим

872
00:39:02,551 --> 00:39:04,230
Что вывелся текст для условия

873
00:39:04,230 --> 00:39:07,410
меньше 10 и наш нижний текст

874
00:39:07,410 --> 00:39:11,560
Поменяем возраст на 17
и перезапустим

875
00:39:11,560 --> 00:39:14,962
Теперь увидим, что появился другой текст

876
00:39:14,962 --> 00:39:16,730
и все еще наш независимый

877
00:39:16,730 --> 00:39:19,170
от условия текст снизу

878
00:39:19,170 --> 00:39:22,670
Вы можете спокойно писать такие выражения

879
00:39:22,670 --> 00:39:24,870
если они короткие и их

880
00:39:24,870 --> 00:39:27,170
будет просто читать

881
00:39:27,170 --> 00:39:29,550
Стоит отметить, что если
в однострочном 'if else'

882
00:39:29,550 --> 00:39:33,340
ваш текст уползает далеко

883
00:39:33,340 --> 00:39:34,850
за пределы экрана.

884
00:39:34,850 --> 00:39:39,190
Допустим куда-то вот сюда

885
00:39:39,190 --> 00:39:42,960
и в эдиторе вам приходится скроллить,

886
00:39:42,960 --> 00:39:44,860
то в какой-то момент вы заметите
серую вертикальную линию

887
00:39:46,026 --> 00:39:48,110
Эта линия обозначает рекомендуемую длину
строки, за которую лучше не переходить.

888
00:39:48,110 --> 00:39:50,370
И вот если у вас будет мнооого текста

889
00:39:50,370 --> 00:39:51,720
всякого разного

890
00:39:53,384 --> 00:39:54,560
и ваша строка заполжет за эту линию

891
00:39:54,560 --> 00:39:58,150
то это индикатор того, что в вашей строке

892
00:39:58,150 --> 00:40:01,200
немного раньше этой линии
должен быть перенос на новую строку

893
00:40:01,200 --> 00:40:05,590
и ваш однострочный 'if else'
лучше преобразовать в "традиционный"

894
00:40:05,590 --> 00:40:07,520
'if else' с фигурными скобками.

895
00:40:07,520 --> 00:40:08,930
Так его будет

896
00:40:08,930 --> 00:40:10,660
гораздо легче читать и понимать.

897
00:40:10,660 --> 00:40:13,610
В таком случае вам и тем кто с вами
работает не придется скроллить

898
00:40:13,610 --> 00:40:15,550
ваши условия и будет легче
понять код

899
00:40:15,550 --> 00:40:17,160
просто посмотрев на него

900
00:40:17,160 --> 00:40:20,280
Базовые знания таблиц
инстинности помогут

901
00:40:20,280 --> 00:40:23,560
вам лучше понимать, что
происходит в вашем 'if' условии

902
00:40:23,560 --> 00:40:25,730
и будет оно равно 'true'

903
00:40:25,730 --> 00:40:29,850
или результат превратится в 'false'
и выполнится этот блок

904
00:40:29,850 --> 00:40:30,683
снизу.

905
00:40:31,671 --> 00:40:32,504
Давайте быстро пройдемся

906
00:40:32,504 --> 00:40:34,190
по простым таблицам истинности.

907
00:40:34,190 --> 00:40:36,090
Я создал две таблицы,

908
00:40:37,078 --> 00:40:40,093
столбец слева это таблица
истинности для "И" условия

909
00:40:40,093 --> 00:40:40,926
о ней мы поговорим вначале,

910
00:40:40,926 --> 00:40:43,990
А потом мы поговорим про
"ИЛИ" условие

911
00:40:43,990 --> 00:40:47,480
В Логическом отношении "И"
у нас есть две Boolean переменные

912
00:40:47,480 --> 00:40:48,820
"P" и "Q"

913
00:40:50,218 --> 00:40:51,800
И справа результат

914
00:40:51,800 --> 00:40:55,660
Читается как "P И Q"

915
00:40:55,660 --> 00:40:57,310
Читается как "P И Q"

916
00:40:57,310 --> 00:40:59,412
И снузу результат логического И

917
00:40:59,412 --> 00:41:02,490
Если "P" истина и "Q" истина

918
00:41:02,490 --> 00:41:06,000
То результат "истина И истина"
будет "истина"

919
00:41:07,954 --> 00:41:10,700
Если P - истина, но Q - ложь

920
00:41:10,700 --> 00:41:14,440
то и результат будет "ложь"

921
00:41:14,440 --> 00:41:15,273
в логисеском "И"

922
00:41:15,273 --> 00:41:18,980
Если первое выражение..
Давайте вернемся в код,

923
00:41:18,980 --> 00:41:23,400
если наше первое выражение истина
и второе выражение

924
00:41:23,400 --> 00:41:26,120
это ложь, и мы используем логическое "И"

925
00:41:26,120 --> 00:41:28,770
оператор "&&" означает
логическое "И",

926
00:41:28,770 --> 00:41:33,770
тогда результат условия будет "ложь"

927
00:41:34,110 --> 00:41:36,180
потому что выражение справа ложь

928
00:41:36,180 --> 00:41:37,480
Посмотрим на третью строчку

929
00:41:37,480 --> 00:41:41,270
если первое ложь и
второе - истина

930
00:41:41,270 --> 00:41:43,450
то результат будет ложь,
потому что в логическом "И"

931
00:41:43,450 --> 00:41:46,720
истина будет только, если оба
выражения истина

932
00:41:46,720 --> 00:41:50,700
Вернемся к коду, левая часть будет
ложью и правая истина

933
00:41:50,700 --> 00:41:52,050
то результат "И"

934
00:41:53,247 --> 00:41:54,080
все равно будет "ложь"

935
00:41:54,080 --> 00:41:56,017
поэтому мы попадем

936
00:41:56,017 --> 00:41:57,670
В нижний блок кода

937
00:41:57,670 --> 00:42:01,830
И последняя, если оба выражения
"ложь" и мы применяем "И"

938
00:42:01,830 --> 00:42:04,292
то результат такого

939
00:42:04,292 --> 00:42:05,125
отношения будет "ложь"

940
00:42:05,125 --> 00:42:07,770
Обратно в код - если левое и
правое условие

941
00:42:07,770 --> 00:42:11,000
ложь то и результат будет ложь

942
00:42:11,000 --> 00:42:13,630
и мы снова попадаем в нижний блок

943
00:42:13,630 --> 00:42:14,720
Теперь посомтим вторую забличку

944
00:42:14,720 --> 00:42:16,990
тут у нас логическое "ИЛИ"

945
00:42:16,990 --> 00:42:19,713
В коде это выглядит по другому,

946
00:42:19,713 --> 00:42:20,546
вернемся в код

947
00:42:20,546 --> 00:42:24,820
И сменим "&&" на "||"

948
00:42:24,820 --> 00:42:26,890
это оператор логического "ИЛИ"

949
00:42:27,834 --> 00:42:31,870
Теперь это значит, что условие будет

950
00:42:31,870 --> 00:42:34,110
истиной, если одно из подусловий
истина

951
00:42:34,110 --> 00:42:35,650
И если одно из них истина

952
00:42:35,650 --> 00:42:39,260
то мы попадем

953
00:42:39,260 --> 00:42:43,000
в блок кода под if

954
00:42:43,000 --> 00:42:44,900
Но если они оба false

955
00:42:44,900 --> 00:42:47,050
тогда мы перейдем в "else" блок

956
00:42:47,050 --> 00:42:48,040
вот сюда

957
00:42:48,040 --> 00:42:48,910
Посмотрим еще раз на таблицу

958
00:42:48,910 --> 00:42:52,525
У нас опять "P" и "Q"
переменные

959
00:42:52,525 --> 00:42:54,993
и вот этот знак "V" обозначает

960
00:42:54,993 --> 00:42:55,826
логическое "ИЛИ"

961
00:42:55,826 --> 00:42:58,760
Если "P" или "Q" это истина

962
00:42:58,760 --> 00:43:01,440
то и результат будет истина

963
00:43:02,320 --> 00:43:06,510
Если и "P" истина и "Q" ложь
мы как бы говорим

964
00:43:06,510 --> 00:43:07,960
"Все истина, если хотя бы одно

965
00:43:07,960 --> 00:43:09,370
из них истина"

966
00:43:09,370 --> 00:43:12,670
Это значит, что если хотя бы одно

967
00:43:12,670 --> 00:43:13,830
истина, то мы можем продолжать

968
00:43:13,830 --> 00:43:17,020
Или, если это истина, то все окей
и можно продолжать

969
00:43:17,020 --> 00:43:19,690
Тоже самое тут, если первое
условие ложь

970
00:43:19,690 --> 00:43:23,570
"P" - ложь, а "Q" - истина

971
00:43:23,570 --> 00:43:26,890
то результат будет истиной

972
00:43:26,890 --> 00:43:29,739
и логическое "ИЛИ" вернет истину

973
00:43:29,739 --> 00:43:31,860
если это у нас будет ложью

974
00:43:32,814 --> 00:43:35,330
ложь, то мы перейдем
люда

975
00:43:35,330 --> 00:43:36,830
и это будет истиной

976
00:43:38,245 --> 00:43:39,078
В общем выражение говорит:
Я нашла истину, а значит

977
00:43:39,078 --> 00:43:40,620
я буду выполнять это строчку кода

978
00:43:41,575 --> 00:43:44,096
И наконец, если у нас ложь "ИЛИ" ложь

979
00:43:44,096 --> 00:43:46,683
Вернемся к коду

980
00:43:46,683 --> 00:43:49,720
Если оба подвыражения ложь

981
00:43:49,720 --> 00:43:52,000
а значит они оба не истина

982
00:43:53,117 --> 00:43:54,420
то мы попадем в "else" блок

983
00:43:55,741 --> 00:43:56,574
Один важный момент

984
00:43:56,574 --> 00:43:57,830
Когда мы используем операторы "&&" и "||"

985
00:43:57,830 --> 00:44:02,000
нужно помнить что это оптимизированные
логические операторы

986
00:44:02,000 --> 00:44:04,250
это значит, что если

987
00:44:05,833 --> 00:44:09,073
первое условие ложь

988
00:44:10,780 --> 00:44:12,530
то оператор даже не будет проверять
правое условие

989
00:44:14,025 --> 00:44:14,858
Котлин при проверке

990
00:44:14,858 --> 00:44:15,930
будет смотреть на левое вырадение

991
00:44:15,930 --> 00:44:17,630
и если он увидит, что левое значение

992
00:44:20,815 --> 00:44:23,350
ложь, то он сразу

993
00:44:23,350 --> 00:44:24,183
будет понимать,

994
00:44:24,183 --> 00:44:26,392
что дальше проверка

995
00:44:26,392 --> 00:44:28,390
безполезна и все выражение

996
00:44:28,390 --> 00:44:30,550
будет ложью, потому что

997
00:44:30,550 --> 00:44:33,670
одна из частей ложь

998
00:44:33,670 --> 00:44:36,500
И котлин под капотом

999
00:44:36,500 --> 00:44:39,549
будет оптимизировать эту проверку

1000
00:44:39,549 --> 00:44:40,530
потому что, если левое выражение ложь

1001
00:44:40,530 --> 00:44:42,770
то правое выражение

1002
00:44:42,770 --> 00:44:46,206
никак не повлияет на результат.

1003
00:44:46,206 --> 00:44:49,120
Они оба должны быть true

1004
00:44:49,120 --> 00:44:50,440
чтобы мы попали в if блок

1005
00:44:50,440 --> 00:44:53,170
С другой стороны оператор
"||" Котлин оптимизирует

1006
00:44:54,030 --> 00:44:56,662
немного по другому

1007
00:44:56,662 --> 00:44:59,598
Если первая часть выражения истина

1008
00:44:59,598 --> 00:45:01,310
то котлин не будет проверять правую

1009
00:45:01,310 --> 00:45:04,890
часть выражения

1010
00:45:04,890 --> 00:45:08,035
Потому что уже есть результат

1011
00:45:08,035 --> 00:45:10,280
и в любом случае выполнение

1012
00:45:10,280 --> 00:45:11,370
кода продолжется в блоке "if"

1013
00:45:11,370 --> 00:45:13,760
Получается правая часть улсловия
не проверится

1014
00:45:13,760 --> 00:45:14,620
потому что левая уже истина

1015
00:45:14,620 --> 00:45:17,441
и Котлин при выполнении скажет:

1016
00:45:17,441 --> 00:45:18,570
"Все ок, левое истина, значит все истина"

1017
00:45:18,570 --> 00:45:21,290
Но если левая часть будет ложью

1018
00:45:22,316 --> 00:45:23,370
То котлин пойдет проверять правую

1019
00:45:23,370 --> 00:45:24,990
чать, потому что ему недостаточно

1020
00:45:24,990 --> 00:45:27,190
инофрмации, чтобы сделать вывод
о логическом "ИЛИ"

1021
00:45:28,387 --> 00:45:29,220
Котлин скажет, ок правая часть истина

1022
00:45:29,220 --> 00:45:30,610
и этого достаточно

1023
00:45:30,610 --> 00:45:32,930
чтобы пойти в блок "If"

1024
00:45:32,930 --> 00:45:35,160
и проверки могут продолжаться дальше,
если например у вас есть

1025
00:45:35,160 --> 00:45:39,463
еще одно условие, например
мой возраст

1026
00:45:41,370 --> 00:45:43,470
должен быть равен длине моего имени

1027
00:45:45,703 --> 00:45:46,630
И тогда у нас будет три выражения

1028
00:45:46,630 --> 00:45:50,510
И результат этого, например, ложь

1029
00:45:50,510 --> 00:45:52,060
А этого - истина

1030
00:45:52,932 --> 00:45:54,040
И если это истина, то следующая
проверка пропустится

1031
00:45:54,040 --> 00:45:55,800
потому что по таблице истинности

1032
00:45:55,800 --> 00:45:58,400
не вжно что будет дальше,
результат уже будет истиной

1033
00:45:59,611 --> 00:46:02,071
и Котлин это понимает

1034
00:46:02,071 --> 00:46:04,720
Умение читать условные выражения
и знания таблиц истинности

1035
00:46:04,720 --> 00:46:06,230
это маст хэв навык, чтобы понимать
в какую сторону "пойдет" код

1036
00:46:06,230 --> 00:46:07,780
в ваших условных выражениях.

1037
00:46:10,460 --> 00:46:12,590
В котлине два вида вида
сравния -

1038
00:46:12,590 --> 00:46:15,230
по значению и по ссылке

1039
00:46:15,230 --> 00:46:17,810
Допустим у нас есть две
строковые переменные

1040
00:46:17,810 --> 00:46:20,970
с именами nameOne и nameTwo

1041
00:46:20,970 --> 00:46:23,700
обе содержат разные строки

1042
00:46:23,700 --> 00:46:26,780
мы можем сравнить их

1043
00:46:26,780 --> 00:46:30,650
по значению используя
оператор сравнения "=="

1044
00:46:30,650 --> 00:46:33,470
Нельзя писать просто "=" потому что
"=" это оператор присваивания

1045
00:46:33,470 --> 00:46:36,720
Тут мы проверяем равно
ли nameOne и nameTwo

1046
00:46:36,720 --> 00:46:38,930
и если запустим, то в

1047
00:46:38,930 --> 00:46:41,550
терминале будет false

1048
00:46:41,550 --> 00:46:44,000
и первое имя не равно второму

1049
00:46:44,840 --> 00:46:46,710
это реализовано, как и в других
языках программироваия

1050
00:46:46,710 --> 00:46:50,490
напрмер в Java для этого используется
метод equals()

1051
00:46:50,490 --> 00:46:52,150
И это можно увидеть тут -

1052
00:46:52,150 --> 00:46:56,110
если запусти, то результат тоже
будет false

1053
00:46:56,110 --> 00:46:57,700
Заметьте что Котлин подчеркнул
нашу такую запись

1054
00:46:57,700 --> 00:47:00,850
Можете навести курсор и нажать
alt+enter

1055
00:47:00,850 --> 00:47:01,910
появится окно

1056
00:47:01,910 --> 00:47:04,580
Еще можно нажать на лампочку

1057
00:47:04,580 --> 00:47:07,030
и нажать "заменить на "==""

1058
00:47:07,030 --> 00:47:10,140
Использовать "==" вместо "equals"
это синтаксический сахар Котлина

1059
00:47:10,140 --> 00:47:14,880
Это условие проверяет равенство
двух имен

1060
00:47:14,880 --> 00:47:18,100
Если мы поменяем второе имя

1061
00:47:18,100 --> 00:47:21,840
на аналогичное первому

1062
00:47:21,840 --> 00:47:23,620
условие превратится в true

1063
00:47:24,694 --> 00:47:27,050
потому что контент двух строк одинаковый

1064
00:47:27,050 --> 00:47:29,230
и они одного типа..

1065
00:47:29,230 --> 00:47:31,010
Одного типа и с одним и тем же
содержимым

1066
00:47:32,137 --> 00:47:33,770
поэтому равенство будет давать истину

1067
00:47:33,770 --> 00:47:36,020
Вернем второе имя назад, допустим
мы хотим проверить

1068
00:47:36,020 --> 00:47:37,870
что они разные

1069
00:47:37,870 --> 00:47:40,580
для этого мы можем использовать
оператор неравенства

1070
00:47:40,580 --> 00:47:44,431
выглядеть он будет как отрицание
равенства "!="

1071
00:47:44,431 --> 00:47:47,431
Если теперь запустим то получим true

1072
00:47:48,853 --> 00:47:50,100
потому что имена не равны

1073
00:47:50,100 --> 00:47:53,520
Если опять поменяем второе имя,

1074
00:47:54,936 --> 00:47:55,940
то что получится теперь?

1075
00:47:55,940 --> 00:47:58,486
"Donn" != "Donn"

1076
00:47:58,486 --> 00:47:59,870
ответ будет false
потому что жти два

1077
00:47:59,870 --> 00:48:01,060
имени одинаковые.

1078
00:48:02,602 --> 00:48:06,940
Таким образом можно проверять
на равенство по значению

1079
00:48:06,940 --> 00:48:08,750
в языке Котлин

1080
00:48:08,750 --> 00:48:12,080
Вы будете использовать "=="
при проверках равенства

1081
00:48:12,080 --> 00:48:14,744
значений

1082
00:48:14,744 --> 00:48:19,130
И "!=" при проверке на неравенство.

1083
00:48:19,130 --> 00:48:20,890
Еще один тип сравнения -

1084
00:48:20,890 --> 00:48:23,390
сравнение по ссылке.

1085
00:48:23,390 --> 00:48:26,740
Для него используется другой оператор

1086
00:48:26,740 --> 00:48:30,360
Допустим у нас есть переменна A со
значением 12

1087
00:48:30,360 --> 00:48:34,760
И переменная B со значением 12

1088
00:48:35,987 --> 00:48:39,610
Из-за того что в Котлин все является
объектами и при создании нового

1089
00:48:39,610 --> 00:48:42,920
двух объектов ссылки на них будут разными
не смотря на то что они равны

1090
00:48:42,920 --> 00:48:46,840
Для того чтобы сравнить по ссылкам
будем использовать "==="

1091
00:48:46,840 --> 00:48:49,280
чтобы проверить

1092
00:48:49,280 --> 00:48:51,080
равны ли ссылки на объект A

1093
00:48:52,055 --> 00:48:54,100
и объект B

1094
00:48:55,020 --> 00:48:55,960
то мы получим результат true

1095
00:48:57,362 --> 00:48:59,870
И этот результат будет странным
для тек кто понимает суть ссылок и памяти

1096
00:48:59,870 --> 00:49:01,760
но в Котлине есть фишка -

1097
00:49:01,760 --> 00:49:04,360
числа, символы и boolean

1098
00:49:04,360 --> 00:49:07,770
в Котлине реализованны

1099
00:49:07,770 --> 00:49:12,770
с помощью примитивных

1100
00:49:12,930 --> 00:49:14,550
типов данных

1101
00:49:14,550 --> 00:49:17,330
когда программа запущена

1102
00:49:17,330 --> 00:49:19,940
Но для пользователей кажется
что это объекты

1103
00:49:19,940 --> 00:49:23,680
И для примитивных типов тройное
равно работает

1104
00:49:23,680 --> 00:49:28,590
точно так же как двойное

1105
00:49:28,590 --> 00:49:31,680
Давайте избавимся от примитивных типов

1106
00:49:31,680 --> 00:49:33,110
И создадим наш

1107
00:49:33,110 --> 00:49:34,370
первый класс

1108
00:49:34,370 --> 00:49:37,385
Это будет очень простой класс,
он будет описывать пользователя

1109
00:49:37,385 --> 00:49:40,350
у которого есть имя

1110
00:49:40,350 --> 00:49:43,746
И поменяем переменные на этот класс

1111
00:49:43,746 --> 00:49:44,630
Первый будет с имене Дон

1112
00:49:44,630 --> 00:49:48,090
И второй пусть будет с именем Дон

1113
00:49:48,090 --> 00:49:51,600
И теперь мы проверим их

1114
00:49:51,600 --> 00:49:53,470
на равенство по ссылке

1115
00:49:55,266 --> 00:49:57,730
запустим программу, чтобы проверить

1116
00:49:57,730 --> 00:50:00,510
и увидим false результат

1117
00:50:00,510 --> 00:50:04,220
это значит что ссылка объекта A
и ссылка объекта B отличаются

1118
00:50:04,220 --> 00:50:06,610
И это не один и тот же объект,
а два разных

1119
00:50:06,610 --> 00:50:09,210
Не смотря на одинаковые имена

1120
00:50:09,210 --> 00:50:11,600
Можно еще проверить неравенство
по ссылке

1121
00:50:11,600 --> 00:50:15,596
и написать "!=="

1122
00:50:15,596 --> 00:50:16,890
и написать "!=="

1123
00:50:16,890 --> 00:50:21,460
мы говорим что ссылка объекта
A не равна ссылке объекта B

1124
00:50:21,460 --> 00:50:24,140
И эти ссылки указывают на разные объекты
в паяти программы

1125
00:50:24,140 --> 00:50:26,240
Запустим и увидим

1126
00:50:27,531 --> 00:50:28,364
результат true

1127
00:50:28,364 --> 00:50:29,980
Еще раз, так происходит потому
что объект A и объект B

1128
00:50:31,002 --> 00:50:31,890
два абсолютно разных объекта

1129
00:50:31,890 --> 00:50:34,810
они хранятся в разных местах в памяти.

1130
00:50:34,810 --> 00:50:38,100
Для сравнения по ссылке
мы используем "==="

1131
00:50:38,100 --> 00:50:40,730
...

1132
00:50:40,730 --> 00:50:43,880
И для неравенства ссылок

1133
00:50:43,880 --> 00:50:45,620
используем "!=="

1134
00:50:47,991 --> 00:50:48,824
Одна из главных задач  Котлина

1135
00:50:48,824 --> 00:50:51,400
это избавиться от ссылок на null.

1136
00:50:51,400 --> 00:50:54,090
Если вы, например, возьмете эту
переменную name

1137
00:50:54,090 --> 00:50:56,450
и попытаетесь сделать ее null

1138
00:50:56,450 --> 00:50:58,440
то компилятор вам не позволит.

1139
00:50:58,440 --> 00:51:00,570
И причина в том что тип этой
переменной явно говорит, что

1140
00:51:00,570 --> 00:51:02,480
эта переменная не моет ссылаться на null.

1141
00:51:02,480 --> 00:51:04,640
Если вы хотите создать переменную,
которая может ссылаться на null
a nullable reference,

1142
00:51:04,640 --> 00:51:05,830
вы все так же должны объявить тип

1143
00:51:05,830 --> 00:51:08,820
но в конце вы должны
добавить знак вопроса.

1144
00:51:08,820 --> 00:51:13,820
Это позволит присваивать null
этой переменной

1145
00:51:14,020 --> 00:51:17,820
Это одинаковое правило для всех
типов в Котлин

1146
00:51:17,820 --> 00:51:21,050
Мы можем написать, что это Int
который равен 32.

1147
00:51:21,050 --> 00:51:24,410
Но если мы попытаемся присвоить null

1148
00:51:25,281 --> 00:51:26,420
У нас это не получится

1149
00:51:26,420 --> 00:51:29,330
Поэтому каждый раз, когда мы захотим

1150
00:51:29,330 --> 00:51:32,344
присвоить возрасту или
любому другому типу null

1151
00:51:32,344 --> 00:51:35,050
нам нужно добавлять к типу "?"
чтобы дать понять компилятору

1152
00:51:35,050 --> 00:51:38,120
что это nullable тип.

1153
00:51:38,120 --> 00:51:42,540
Тоже самое работает с нашими
самописными классами

1154
00:51:44,550 --> 00:51:49,550
Мы можем спокойно написать
person = Person

1155
00:51:50,470 --> 00:51:54,130
но если мы попытаемся присвоить
person нуль ссылку

1156
00:51:54,130 --> 00:51:56,710
компилятор будет ругаться,
потому что типом без вопросительного

1157
00:51:56,710 --> 00:51:59,080
знака мы гарантируем что значение
не будет null

1158
00:51:59,080 --> 00:52:01,500
Опять же, если мы хотим ссылаться на

1159
00:52:01,500 --> 00:52:04,460
null, мы должны

1160
00:52:04,460 --> 00:52:06,390
явно указать что тип может
ссылаться на null

1161
00:52:06,390 --> 00:52:09,300
и теперь мы можем сказать что

1162
00:52:09,300 --> 00:52:12,430
personTwo равняется null

1163
00:52:12,430 --> 00:52:14,670
Когда мы работаем с типами
которые не могут равняться null

1164
00:52:14,670 --> 00:52:16,880
как например с переменной name

1165
00:52:16,880 --> 00:52:19,790
Если мы захотим посчитать длинну имени

1166
00:52:19,790 --> 00:52:21,740
мы можем вызвать метода name.length

1167
00:52:22,680 --> 00:52:24,330
и получим длину в результате

1168
00:52:24,330 --> 00:52:26,300
тут нам не нужно проверять
ссылается ли эта переменная на null

1169
00:52:26,300 --> 00:52:28,300
потому что мы используем
не null тип

1170
00:52:28,300 --> 00:52:30,980
и Котлин гарантирует нам безопасный
вызов метода

1171
00:52:30,980 --> 00:52:32,700
Когда мы работаем с типом
который может равняться

1172
00:52:32,700 --> 00:52:34,080
null и пытаемся сделать точно
такую же операцию

1173
00:52:34,080 --> 00:52:37,000
то есть вызвать lastName.length

1174
00:52:37,000 --> 00:52:39,080
вы можете заметить небольшую
красную линию.

1175
00:52:39,080 --> 00:52:40,420
Представляю вам метод

1176
00:52:40,420 --> 00:52:42,560
который называется "безопасный вызов"

1177
00:52:42,560 --> 00:52:46,370
Фактически это значит, что если
lastName ссылается на null

1178
00:52:46,370 --> 00:52:48,050
то результат этой операции будет null

1179
00:52:48,050 --> 00:52:49,780
иначе - вернется длина фамилии

1180
00:52:49,780 --> 00:52:53,160
Как итог эта переменная может
быть либо null

1181
00:52:53,160 --> 00:52:55,550
либо числом шесть

1182
00:52:55,550 --> 00:52:58,510
потому что в фамилии шесть символов.

1183
00:52:59,510 --> 00:53:02,830
А если фамилия по какой-то причине
ссылается на null

1184
00:53:02,830 --> 00:53:05,120
то результат будет null.

1185
00:53:05,120 --> 00:53:08,010
Тоже самое можно сделать
с помощью "if" проверки

1186
00:53:08,010 --> 00:53:09,190
в одну линию

1187
00:53:09,190 --> 00:53:12,000
Если lastName != null

1188
00:53:12,000 --> 00:53:17,000
то можно безопасно вызвать
lastName.length иначе, например "0"

1189
00:53:17,550 --> 00:53:19,310
Проверям lastName на

1190
00:53:19,310 --> 00:53:21,320
null, если не null
то результат

1191
00:53:21,320 --> 00:53:22,230
будет длинной фамилии.

1192
00:53:22,230 --> 00:53:26,150
Заметьте, что здест нет красного
подчеркивания.

1193
00:53:26,150 --> 00:53:29,070
Это все потому что котлин достаточно
умный и после проверки на null

1194
00:53:29,070 --> 00:53:31,330
он неявно приводит тип переменной
к String

1195
00:53:31,330 --> 00:53:34,180
И нам уже не нужно ничего

1196
00:53:34,180 --> 00:53:37,120
проверять дополнительно

1197
00:53:37,120 --> 00:53:39,190
А если lastName ссылается на null

1198
00:53:39,190 --> 00:53:41,080
то результатом будет "0"

1199
00:53:41,080 --> 00:53:44,050
В любом случае, после этой проверки

1200
00:53:44,050 --> 00:53:46,220
ответ будет либо 6, либо 0

1201
00:53:46,220 --> 00:53:49,110
Конечно можно поменять это на null

1202
00:53:49,110 --> 00:53:51,530
Но концептуально это будет
то же самое, что написано

1203
00:53:51,530 --> 00:53:54,250
сверху, а вы скорее всего

1204
00:53:54,250 --> 00:53:56,320
хотите избавиться от лишних проверок

1205
00:53:56,320 --> 00:53:58,630
и это можно сделать одним if

1206
00:53:58,630 --> 00:54:00,600
Вы можете вызывать эти проверки
по цепочке

1207
00:54:00,600 --> 00:54:04,230
например мы хотим получить
первые две буквы фамилии

1208
00:54:04,230 --> 00:54:08,790
и потом получить длину

1209
00:54:08,790 --> 00:54:10,840
фамилии

1210
00:54:10,840 --> 00:54:12,090
Заметьте как мы будем это получать

1211
00:54:13,200 --> 00:54:16,360
результат. мы вызовем две функции

1212
00:54:16,360 --> 00:54:20,470
и после каждой функции
нам нужно сделать безопасный

1213
00:54:20,470 --> 00:54:21,303
вызов другой функции

1214
00:54:21,303 --> 00:54:22,760
Фактически это значит

1215
00:54:22,760 --> 00:54:26,330
что если lastName ссылается на null
то мы пропускаем остальные операции и

1216
00:54:26,330 --> 00:54:27,970
возвращаем null,
если lastName не null

1217
00:54:27,970 --> 00:54:29,950
то идем дальге и берем подстроку
от фамилии

1218
00:54:29,950 --> 00:54:32,210
берем первые два символа

1219
00:54:32,210 --> 00:54:34,240
И если по какойто причине они null

1220
00:54:34,240 --> 00:54:35,910
То возвращаем null,

1221
00:54:35,910 --> 00:54:37,610
а иначе возвращаем их длину.

1222
00:54:37,610 --> 00:54:39,370
Возможно вы видели что-то подобное

1223
00:54:39,370 --> 00:54:40,410
в других языках

1224
00:54:40,410 --> 00:54:45,350
Если lastName не равно null
и lastName.length больше

1225
00:54:47,440 --> 00:54:52,440
чем единица, то мы можем рподолжить

1226
00:54:53,037 --> 00:54:57,690
дальше нам нужно будет проверить

1227
00:54:57,690 --> 00:55:01,750
что длина не null

1228
00:55:01,750 --> 00:55:05,180
это очень типично для языка Java
ошибки которого пытается исправить Котлин

1229
00:55:05,180 --> 00:55:08,660
Можно все эти запросы связать

1230
00:55:08,660 --> 00:55:10,900
и можно вызвать

1231
00:55:10,900 --> 00:55:13,520
lastName.substring от нуля до пяти

1232
00:55:13,520 --> 00:55:15,840
и получить пят ьсимволов

1233
00:55:15,840 --> 00:55:17,230
А потом можно, например,

1234
00:55:17,230 --> 00:55:20,740
удалить последние два символа

1235
00:55:20,740 --> 00:55:22,869
Потом можно сделать еще один

1236
00:55:22,869 --> 00:55:26,480
substring и допустим от 2 до 3

1237
00:55:26,480 --> 00:55:29,760
и потом уже узнать длину

1238
00:55:29,760 --> 00:55:33,330
И теперь еще вот так

1239
00:55:33,330 --> 00:55:36,170
Вся эта цепочка может
оборваться в любой момент

1240
00:55:36,170 --> 00:55:38,200
и нам нужно использовать
безопасные вызовы

1241
00:55:38,200 --> 00:55:40,510
И каждый раз на протяжении

1242
00:55:40,510 --> 00:55:42,930
всей цепочки нужно использовать
безопасные вызовы

1243
00:55:42,930 --> 00:55:46,180
потому что люой метод цепочки, в теории
может вернуть null.

1244
00:55:46,180 --> 00:55:48,190
Вы часто будете работать с типами
которые могут содержать null,

1245
00:55:48,190 --> 00:55:52,010
но непонятно как дальше быть, поэтому
хочется вместо null подставлять какое-то значение

1246
00:55:52,010 --> 00:55:54,510
Допустим мы хотим узнать
длину имени нашей

1247
00:55:54,510 --> 00:55:55,860
строковой переменной

1248
00:55:55,860 --> 00:55:57,330
мы сделаем это через
безопасный вызов

1249
00:55:57,330 --> 00:56:00,090
безопасный вызов, чтобы

1250
00:56:00,090 --> 00:56:01,600
не возникло ошибки.

1251
00:56:01,600 --> 00:56:04,310
Но это ставит нас в положение

1252
00:56:04,310 --> 00:56:06,070
что результат этого вызова будет
либо null

1253
00:56:06,070 --> 00:56:09,110
либо конкретное число,
в нашем случае шесть

1254
00:56:09,110 --> 00:56:10,630
и мы можем получить любое из них.

1255
00:56:10,630 --> 00:56:13,660
Давайте представим, что мы
не хотим дальше работать

1256
00:56:13,660 --> 00:56:16,197
с null типом.

1257
00:56:16,197 --> 00:56:17,980
В этом случаем ммы получим ошибку

1258
00:56:17,980 --> 00:56:21,500
потому что name.length
потенциально возвращает null.

1259
00:56:21,500 --> 00:56:23,370
Как это исправить?

1260
00:56:23,370 --> 00:56:25,150
Можно по старинке - с помощью
условного блока if

1261
00:56:25,150 --> 00:56:28,050
Просто проверяем

1262
00:56:28,050 --> 00:56:31,360
равняется ли имя null

1263
00:56:31,360 --> 00:56:34,000
если да - возвращаем ноль,
если нет - длину имени

1264
00:56:34,839 --> 00:56:36,090
И можно убрать безопасный вызов тут
потому что проверка уже была и

1265
00:56:36,090 --> 00:56:39,770
компилятор понимает что имя
уже не будет null

1266
00:56:40,670 --> 00:56:44,790
Так мы получаем не null тип
результатом которого будет

1267
00:56:44,790 --> 00:56:47,330
ноль или длина имени

1268
00:56:47,330 --> 00:56:48,163
ноль или длина имени

1269
00:56:49,599 --> 00:56:52,150
У Котлина есть "синтаксический сахар"
для такого случая

1270
00:56:52,150 --> 00:56:56,516
Добавим переменную "длинна2"
и выражение которое мы напишем

1271
00:56:56,516 --> 00:56:59,240
в Котлине называется
оператором Элвиса

1272
00:56:59,240 --> 00:57:02,120
Элвис оператор пишется как

1273
00:57:02,120 --> 00:57:03,850
двоеточие со знаком вопроса

1274
00:57:03,850 --> 00:57:07,317
И читается это следующим образом:

1275
00:57:07,317 --> 00:57:10,400
"Если значение выражения

1276
00:57:10,400 --> 00:57:12,530
в левой части равно null, то мы подставляем
то что в правой части"

1277
00:57:12,530 --> 00:57:15,480
Если lastName null, тогда возвращаем
выражение справа

1278
00:57:15,480 --> 00:57:16,840
Можно выражение слева усложнить

1279
00:57:16,840 --> 00:57:19,050
и сделать цепочкой вызовов

1280
00:57:19,050 --> 00:57:24,050
Напишем substring от 0 до 2
и у нас будет несколько

1281
00:57:24,390 --> 00:57:26,698
безопасных вызовов подряд.

1282
00:57:26,698 --> 00:57:29,540
Если lastName null или подстрока null

1283
00:57:29,540 --> 00:57:32,920
то возвращаем ноль, а иначе
результат выражения слева

1284
00:57:32,920 --> 00:57:35,770
И такой подход в результате тоже даст
не нулевой тип

1285
00:57:35,770 --> 00:57:37,600
Если вас интересует, почему этот
оператор называется

1286
00:57:37,600 --> 00:57:38,670
оператором Элвиса

1287
00:57:40,000 --> 00:57:41,810
Ответ прост, если повернуть его на
90 градусов и приблизить

1288
00:57:41,810 --> 00:57:44,390
то будет казаться

1289
00:57:44,390 --> 00:57:46,520
будто это прическа Элвиса Пресли)

1290
00:57:46,520 --> 00:57:48,920
Поэтому и назвали оператором Элвиса)

1291
00:57:48,920 --> 00:57:51,620
Чтобы в Котлине создать функцию

1292
00:57:52,888 --> 00:57:55,080
можно использовать ключевое слово
fun, а потом написать ия функции

1293
00:57:55,080 --> 00:57:57,760
Мы напишем простую функцию helloWorld

1294
00:57:57,760 --> 00:57:59,980
и вконце нужно поставить скобочки

1295
00:57:59,980 --> 00:58:01,470
и потом фигурные скобки
в которых будет код

1296
00:58:01,470 --> 00:58:04,440
так вы получите функцию, которую
позже сможете переиспользовать.

1297
00:58:04,440 --> 00:58:07,420
Теперь, если мы хотим где-нибудь
вызвать helloWorld

1298
00:58:07,420 --> 00:58:10,450
Наша main функция вызывается,
когда мы нажимаем на

1299
00:58:10,450 --> 00:58:12,987
зеленую стрелочку

1300
00:58:12,987 --> 00:58:16,800
Если мы хотим вызвать то что находится
в функции helloWorld

1301
00:58:16,800 --> 00:58:18,630
мы должны вызвать

1302
00:58:18,630 --> 00:58:21,200
эту функцию где-нибудь

1303
00:58:21,200 --> 00:58:24,700
И сделаем мы это из нашей main
функции.

1304
00:58:24,700 --> 00:58:26,170
вызовем нашу функцию и допишем
две скобки, открывающую и

1305
00:58:26,170 --> 00:58:27,850
закрывающую.

1306
00:58:27,850 --> 00:58:29,570
Если сейчас запустим программу,

1307
00:58:29,570 --> 00:58:31,250
то в выводе мы ничего не увидим,
потому что по своей сути

1308
00:58:31,250 --> 00:58:33,713
helloWorld - ничего не делает,
а main вызывает функию, которая

1309
00:58:33,713 --> 00:58:35,800
ничего не делает.

1310
00:58:35,800 --> 00:58:38,510
Поэтому мы просто увидим
что функция завершилась.

1311
00:58:38,510 --> 00:58:39,780
Если мы что-то хотим сделать внутри

1312
00:58:39,780 --> 00:58:42,430
например вывести что-то в консоль

1313
00:58:42,430 --> 00:58:46,580
и текст "Hello World"

1314
00:58:46,580 --> 00:58:51,580
И теперь при запуске мы

1315
00:58:51,630 --> 00:58:54,520
увидим что Котлин вывел в

1316
00:58:54,520 --> 00:58:57,330
консоль "Hello World"

1317
00:58:57,330 --> 00:59:00,070
Теперь поменяем название
функции на какое-нибудь другое.

1318
00:59:00,070 --> 00:59:05,070
Например, пусть это будет функция
с милым названием purpleCow

1319
00:59:05,190 --> 00:59:08,050
Теперь у нас тут фиолетовая корова
и я просто

1320
00:59:08,050 --> 00:59:10,480
скопирую новое название
метода сюда

1321
00:59:10,480 --> 00:59:13,400
Ничего не изменилось, кроме имени метода
и результат останется таким же

1322
00:59:13,400 --> 00:59:15,660
Перепроверим это

1323
00:59:15,660 --> 00:59:17,940
Мы видим что вывод точно такой же

1324
00:59:17,940 --> 00:59:20,080
Полезное свойство функций это

1325
00:59:20,080 --> 00:59:21,380
их переиспользуемость.

1326
00:59:21,380 --> 00:59:22,213
Я скопирую функцию и

1327
00:59:22,213 --> 00:59:25,400
И вставлю ее на следующую строчку
и еще несколько раз

1328
00:59:25,400 --> 00:59:26,830
Если вам интересно, каков будет эффект
то все довольно просто

1329
00:59:26,830 --> 00:59:29,860
Котлин поддерживает процедурную парадигму

1330
00:59:29,860 --> 00:59:32,000
и он вызовет одну и ту же функцию
несколько раз.

1331
00:59:32,000 --> 00:59:35,070
Это значит что котлин построчно будет
выполнять main функцию

1332
00:59:35,070 --> 00:59:37,300
и зайдет в purpleCow функцию,

1333
00:59:37,300 --> 00:59:39,568
И потом зайдет в следующую

1334
00:59:39,568 --> 00:59:41,360
и каждый раз когда в main будет
вызов purpleCow

1335
00:59:41,360 --> 00:59:42,193
он будет проходить по коду этой функции

1336
00:59:42,193 --> 00:59:44,130
Фактически функция purpleCow
вызовется

1337
00:59:44,130 --> 00:59:46,150
раз, два, три, четыре раза.

1338
00:59:46,150 --> 00:59:49,810
И в консоли мы должны увидеть
четыре строчки с

1339
00:59:49,810 --> 00:59:53,100
текстом "Hello world"

1340
00:59:53,100 --> 00:59:54,290
И.. мы их видим

1341
00:59:54,290 --> 00:59:56,560
Еще одна крутая вещь -
это то что поведение функции может

1342
00:59:56,560 --> 00:59:59,007
меняться, каждый раз

1343
00:59:59,007 --> 01:00:00,870
когда вы ее вызываете.

1344
01:00:00,870 --> 01:00:03,440
Допустим, я осознал, что
мое приложение вызывает purpleCow

1345
01:00:03,440 --> 01:00:05,910
четыре раза, и я хочу чтобы
текст немного изменился

1346
01:00:05,910 --> 01:00:08,040
например, чтобы выводилось

1347
01:00:08,040 --> 01:00:09,730
"hello purple cow."

1348
01:00:09,730 --> 01:00:10,900
Я могу поменять это прямо в функции
purpleCow

1349
01:00:10,900 --> 01:00:13,400
Если запущу, мы увидим результат

1350
01:00:13,400 --> 01:00:15,960
"hello purple cow" четыре раза

1351
01:00:15,960 --> 01:00:17,860
И мы видим "hello purple cow"

1352
01:00:17,860 --> 01:00:20,120
Да, ровно четыре раза

1353
01:00:20,120 --> 01:00:22,460
То же самое можно сделать немного по другому

1354
01:00:22,460 --> 01:00:25,170
Функция это просто место куда можно
сложить код для выполнения

1355
01:00:25,170 --> 01:00:27,680
чтобы переиспользовать
ее несколько раз

1356
01:00:27,680 --> 01:00:30,920
Получается что-то вроде куска

1357
01:00:30,920 --> 01:00:31,753
переиспользуемого кода

1358
01:00:31,753 --> 01:00:33,250
Если я захочу сделать что-то дургое

1359
01:00:33,250 --> 01:00:36,450
Я могу написать еще один
вывод в консоль "hello there"

1360
01:00:36,450 --> 01:00:38,480
И теперь мы увидим

1361
01:00:38,480 --> 01:00:41,065
обе строки в консоли

1362
01:00:41,065 --> 01:00:41,898
написанные четыре раза

1363
01:00:41,898 --> 01:00:44,040
Запустим программу

1364
01:00:44,040 --> 01:00:47,500
и видим результат

1365
01:00:47,500 --> 01:00:49,010
добавления еще одного вывода

1366
01:00:49,010 --> 01:00:51,670
Теперь, каждый раз когда зовется
функция, все что в ней

1367
01:00:51,670 --> 01:00:54,790
написано вызывается,

1368
01:00:54,790 --> 01:00:57,730
то есть обе наши команды вывода.

1369
01:00:57,730 --> 01:00:59,930
Функции могут вызывать другие функции

1370
01:00:59,930 --> 01:01:02,554
Это как бы уже понятно,

1371
01:01:02,554 --> 01:01:04,740
потому что наша main функция

1372
01:01:04,740 --> 01:01:07,010
вызывает purpleCow функцию

1373
01:01:07,010 --> 01:01:10,760
в purpleCow мы тоже можем вызвать функцию

1374
01:01:10,760 --> 01:01:12,540
пусть это будет функция moo.

1375
01:01:12,540 --> 01:01:14,630
И пусть эта функция просто выводит "Муу"

1376
01:01:14,630 --> 01:01:16,800
и вызовем ее.

1377
01:01:16,800 --> 01:01:20,140
И внутри функции напишем метод вывода и текст.

1378
01:01:21,260 --> 01:01:24,160
Теперь, когда мы вызовем purpleCow

1379
01:01:24,160 --> 01:01:27,450
мы увидим две строки вывода из

1380
01:01:27,450 --> 01:01:29,520
purpleCow,

1381
01:01:29,520 --> 01:01:31,079
purpleCow,

1382
01:01:31,079 --> 01:01:32,350
В консоли будет "hello purple cow"
"hello there"

1383
01:01:32,350 --> 01:01:35,140
и потом функция purpleCow
вызовет функцию moo

1384
01:01:35,140 --> 01:01:37,783
и функция moo выведет текст "moo"

1385
01:01:37,783 --> 01:01:40,270
Запустим и посмотрим

1386
01:01:42,630 --> 01:01:44,200
на результат

1387
01:01:44,200 --> 01:01:45,660
Получили "hello purple cow"

1388
01:01:45,660 --> 01:01:46,600
"hello there" и "moo"

1389
01:01:46,600 --> 01:01:48,630
"hello purple cow", "hello there", "moo"

1390
01:01:48,630 --> 01:01:51,540
И еще немного изменим,
допустим я хочу сказать:

1391
01:01:51,540 --> 01:01:55,830
"А теперь я хочу поднять функцию повыше

1392
01:01:55,830 --> 01:02:00,330
и хочу, чтобы этот вывод писал
"hello pink cow""

1393
01:02:01,860 --> 01:02:02,900
А лучше "hello blue cow"

1394
01:02:02,900 --> 01:02:06,230
давайте сделаем синюю и вызовем
moo еще разок

1395
01:02:06,230 --> 01:02:08,793
Если запустим теперь

1396
01:02:08,793 --> 01:02:09,626
то что мы получим?

1397
01:02:09,626 --> 01:02:12,480
мы увидим фиолетовую корову, потом "муу",
потому синюю корову, потому снова "муу"

1398
01:02:12,480 --> 01:02:14,500
И теперь мы будем видеть строчку "Муу"
между каждой коровой

1399
01:02:14,500 --> 01:02:16,570
потому что так расположены наши
функции

1400
01:02:16,570 --> 01:02:18,150
И можем еще немного накрутить

1401
01:02:18,150 --> 01:02:21,000
Конечно мы допишем "Moo moo buckaroo"

1402
01:02:22,480 --> 01:02:24,350
И если запустим

1403
01:02:24,350 --> 01:02:26,700
то увидим уже жуткую мешанину, но все

1404
01:02:26,700 --> 01:02:27,910
проходит в том порядке, в котором должно

1405
01:02:27,910 --> 01:02:30,260
"Hello purple cow, moo, moo moo Buckaroo."

1406
01:02:30,260 --> 01:02:32,946
"Hello, blue cow, moo, moo moo Buckaroo."

1407
01:02:32,946 --> 01:02:35,090
Попробуйте произнести это быстро
десять раз, сломаете язык

1408
01:02:35,090 --> 01:02:37,580
Так пишутся самы простые функции,

1409
01:02:37,580 --> 01:02:39,480
которые позволяют вам
переиспользовать код.

1410
01:02:39,480 --> 01:02:41,504
Допустим мы теперь решили, что

1411
01:02:41,504 --> 01:02:43,870
мы хтим писать "Moo" тут,

1412
01:02:43,870 --> 01:02:45,820
но не очень хотим тут

1413
01:02:45,820 --> 01:02:48,900
То есть мы можем вставлять эти куски
где угодно

1414
01:02:48,900 --> 01:02:51,140
И в таком случае мы один раз позовем
фиолетовую корову, потом moo

1415
01:02:51,140 --> 01:02:53,150
потом опять коровы

1416
01:02:53,150 --> 01:02:54,350
до самого конца

1417
01:02:54,350 --> 01:02:56,790
Как я уже сказал, эти функции позволяют нам

1418
01:02:56,790 --> 01:02:58,730
создать переиспользуемые куски кода

1419
01:02:58,730 --> 01:03:01,260
Мы начинаем с приветствия

1420
01:03:01,260 --> 01:03:02,950
потом мычим, а потом

1421
01:03:02,950 --> 01:03:06,080
вызываем фиолетовую корову

1422
01:03:06,080 --> 01:03:07,380
три раза.

1423
01:03:07,380 --> 01:03:09,760
Это пример самых простых функций.

1424
01:03:09,760 --> 01:03:12,670
У этих функций нет

1425
01:03:12,670 --> 01:03:14,810
никакого возвращаемого типа

1426
01:03:14,810 --> 01:03:17,290
потому что мы только делаем вывод и
возвращать нам нечего

1427
01:03:17,290 --> 01:03:19,570
на самом деле тут неявно возвращается
объект типа Unit

1428
01:03:19,570 --> 01:03:20,810
Мы поговорим об этом через секунду

1429
01:03:20,810 --> 01:03:23,480
Но если мы не будем указывать

1430
01:03:23,480 --> 01:03:27,140
явно возвращаемый тип функции, то она
по дефолту будет

1431
01:03:27,140 --> 01:03:28,000
возвращать Unit.

1432
01:03:28,000 --> 01:03:30,100
Мы рассмотрим это через секунду

1433
01:03:30,100 --> 01:03:32,360
По дефолту все фукции в Котлине

1434
01:03:32,360 --> 01:03:33,840
возвращают тип Unit.

1435
01:03:33,840 --> 01:03:36,410
Если мы создадим функцию с
названием sayHi

1436
01:03:36,410 --> 01:03:40,390
которая просто будет
выводить какой-то текст в консоль,

1437
01:03:40,390 --> 01:03:44,640
например "Hello world"
и вызовем ее тут

1438
01:03:47,030 --> 01:03:49,030
У этой функции не будет возвращаемого типа

1439
01:03:49,030 --> 01:03:52,370
Чтобы его явно указать

1440
01:03:52,370 --> 01:03:55,280
нужно добавить двоеточие
после скобочек

1441
01:03:55,280 --> 01:03:58,690
и написать тип, который

1442
01:03:58,690 --> 01:03:59,523
функция будет возвращать.

1443
01:03:59,523 --> 01:04:00,830
Если функция что-то возвращает
мы можем написать

1444
01:04:00,830 --> 01:04:02,260
тип Unit

1445
01:04:02,260 --> 01:04:03,660
И вы можете заметить что внутри функции

1446
01:04:03,660 --> 01:04:06,060
нет ключевого слова return

1447
01:04:06,060 --> 01:04:07,650
с типом Unit или чего-то подобного.

1448
01:04:08,540 --> 01:04:11,050
Я просто могу написать так и
все будет работать.

1449
01:04:11,050 --> 01:04:13,680
Еще раз, по дефолту все функции

1450
01:04:13,680 --> 01:04:15,120
без явно указанного возвращаемого
типа возвращают Unit,

1451
01:04:15,120 --> 01:04:17,810
о чем дополнительно аодсказывает
IDE и предлагает

1452
01:04:17,810 --> 01:04:21,120
нам убрать возвращаемый тип

1453
01:04:21,120 --> 01:04:23,790
Мы можем нажать на лампочку

1454
01:04:23,790 --> 01:04:26,260
и кликнуть опцию "убрать лишнее объявление типа"

1455
01:04:26,260 --> 01:04:30,700
Я сделал такую запись, чтобы
доказать, что эта функия возвращает Unit

1456
01:04:30,700 --> 01:04:32,800
Еще я могу создать переменную

1457
01:04:32,800 --> 01:04:36,210
И вывести ее в консоль.

1458
01:04:36,210 --> 01:04:39,780
Функция всегад что-то возвращает
и эта переменная X будет

1459
01:04:39,780 --> 01:04:41,030
обладать типом,

1460
01:04:41,030 --> 01:04:44,600
который возвращает функция,
а тип этот будет

1461
01:04:44,600 --> 01:04:48,400
нашим Unit, который функции
возвращают по дефолту.

1462
01:04:48,400 --> 01:04:51,210
Удалим явное объявление

1463
01:04:51,210 --> 01:04:52,670
И так как функция что-то возвращает,

1464
01:04:52,670 --> 01:04:53,980
в переменную что-то запишется

1465
01:04:53,980 --> 01:04:57,580
Функцию можно вызывать без
присваивания переменной,

1466
01:04:57,580 --> 01:04:58,810
если мы просто хотим ее запустить.

1467
01:04:58,810 --> 01:05:00,570
Я могу ничего не делать с
возвращаемым типом,

1468
01:05:00,570 --> 01:05:03,680
но если я все таки хочу работать
дальше с типом,

1469
01:05:03,680 --> 01:05:05,930
я могу записать его в переменную

1470
01:05:05,930 --> 01:05:08,940
как например в нашу "X"
и вывести результат в консоль

1471
01:05:08,940 --> 01:05:11,910
Когда я запущу программу

1472
01:05:11,910 --> 01:05:13,870
мы увидим в выводе тип переменной

1473
01:05:13,870 --> 01:05:17,090
потому что x теперь

1474
01:05:17,090 --> 01:05:21,048
имеет тип kotlin.Unit

1475
01:05:21,048 --> 01:05:23,280
имеет тип kotlin.Unit

1476
01:05:23,280 --> 01:05:26,110
Повторюсь, что тип я могу
указать явно,

1477
01:05:26,110 --> 01:05:29,650
но это совсем не обязательно,
потому что все функции по дефолту

1478
01:05:29,650 --> 01:05:30,640
возвращают Unit.

1479
01:05:30,640 --> 01:05:34,440
И мы видим результат в консоли.

1480
01:05:34,440 --> 01:05:36,220
Давайте допустим, что мы хотим

1481
01:05:36,220 --> 01:05:38,390
возвращать какую-нибудь строку.

1482
01:05:38,390 --> 01:05:39,840
И вы заметите, что как только
я явно укажу тип String

1483
01:05:39,840 --> 01:05:41,010
снизу появится красная полоска.

1484
01:05:41,010 --> 01:05:42,620
Она подсказывает, что мы
не возвращаем строку,

1485
01:05:42,620 --> 01:05:43,453
но функия должна это делать.

1486
01:05:43,453 --> 01:05:45,550
Я хочу вернуть какую-то строку

1487
01:05:45,550 --> 01:05:49,410
допустим "Hello World"
я должен написать ключевое слово "return"

1488
01:05:49,410 --> 01:05:51,830
И вместо вывода в консоль, после
return я напишу эту строку

1489
01:05:53,465 --> 01:05:55,726
И теперь функция возвращает строку

1490
01:05:55,726 --> 01:05:57,150
которую мы будем выводить в консоль
из main() функции

1491
01:05:58,830 --> 01:06:00,200
которую мы будем выводить в консоль
из main() функции

1492
01:06:00,200 --> 01:06:02,790
И получим наш вывод.

1493
01:06:02,790 --> 01:06:05,770
функция sayHi теперь сама ничего не
выводит в консоль,

1494
01:06:05,770 --> 01:06:08,120
она отдает строку функции,
которая вызвала ее.

1495
01:06:08,120 --> 01:06:11,230
Мы записываем эту строку в переменную

1496
01:06:11,230 --> 01:06:13,620
и выводим значение
переменной в консоль

1497
01:06:13,620 --> 01:06:15,360
с помощью println.

1498
01:06:15,360 --> 01:06:17,170
Интересное знамечание -

1499
01:06:17,170 --> 01:06:18,800
Вы можете подумать, что будет
если мы несколько раз

1500
01:06:18,800 --> 01:06:22,050
вызовем функцию sayHi

1501
01:06:22,050 --> 01:06:24,510
И если вы запустите программу, то

1502
01:06:24,510 --> 01:06:28,040
ничего не изменится и вывод в
консоли будет только один

1503
01:06:28,040 --> 01:06:30,775
И причиной этому является то, что
сама по себе функция

1504
01:06:30,775 --> 01:06:32,660
sayHi больше не выводит ниего в консоль
она просто отдает результат

1505
01:06:32,660 --> 01:06:36,820
вызывающей ее функции

1506
01:06:36,820 --> 01:06:38,260
А внутри ничего не происходит

1507
01:06:38,260 --> 01:06:40,080
кроме созданя строки

1508
01:06:40,080 --> 01:06:42,400
и возвращения ее.

1509
01:06:42,400 --> 01:06:44,500
И вы можете делать с этим выводом
все что захотите уже вне функции.

1510
01:06:44,500 --> 01:06:47,184
В нашем случае мы записываем
строку в переменную

1511
01:06:47,184 --> 01:06:48,700
и выводим на экран.

1512
01:06:48,700 --> 01:06:51,190
Следующие три функции возвращают
строку "Hello World",

1513
01:06:51,190 --> 01:06:53,580
но мы ничего не

1514
01:06:53,580 --> 01:06:55,200
делаем с результатом

1515
01:06:55,200 --> 01:07:00,200
Если я напишу переменные "X" и "Y"

1516
01:07:01,418 --> 01:07:03,060
"X" уже используется, пусть будет "Z"

1517
01:07:03,060 --> 01:07:08,060
и переменную "A", то в них запишется

1518
01:07:09,180 --> 01:07:12,650
результат.
И давайте выведем их в консоль

1519
01:07:12,650 --> 01:07:17,620
Заменю вывод на "y" "z" и "a"

1520
01:07:21,300 --> 01:07:23,320
и если запустим программу

1521
01:07:23,320 --> 01:07:28,320
мы увидим, что эти строки вывелись
в нашу консоль

1522
01:07:28,580 --> 01:07:30,910
получилось много "Hello World"-ов

1523
01:07:30,910 --> 01:07:32,340
потому что теперь мы действительно

1524
01:07:32,340 --> 01:07:33,300
что-то делаем в возвращаемым значением.

1525
01:07:33,300 --> 01:07:34,630
И если я сейчас удалю переменные

1526
01:07:34,630 --> 01:07:37,530
мы получим ошибку, потому что
переменные, которые мы пытаемся вывести

1527
01:07:37,530 --> 01:07:40,220
не были объявлены в коде.

1528
01:07:40,220 --> 01:07:42,580
Поэтому программа просто напросто
не скомпилируется.

1529
01:07:42,580 --> 01:07:44,180
Итак, это функция с возвращаемым типом

1530
01:07:44,180 --> 01:07:46,040
и я поменяю его на что-нибудь другое.

1531
01:07:46,040 --> 01:07:48,280
Допустим на Int, теперь будем возвращать Int

1532
01:07:48,280 --> 01:07:50,030
И все снова сломается, компилятор говорит

1533
01:07:51,095 --> 01:07:51,928
Что возвращаемый тип

1534
01:07:51,928 --> 01:07:54,650
функции и то что мы возвращаем - разного типа.
Заменим строку на число, например 32

1535
01:07:54,650 --> 01:07:58,120
И если теперь запустим,
то все сработает.

1536
01:07:58,120 --> 01:07:59,550
В этой функции мы можем делать
что угодно помимо return

1537
01:07:59,550 --> 01:08:01,880
например мы можем записать
условное выражение if

1538
01:08:01,880 --> 01:08:04,570
мы даже можем вернуть тип на String

1539
01:08:04,570 --> 01:08:06,750
и наше число

1540
01:08:06,750 --> 01:08:08,340
32 привести к типу

1541
01:08:08,340 --> 01:08:12,540
String. для этого напишем 32.toSting()

1542
01:08:12,540 --> 01:08:14,630
и это переведет Int в String.

1543
01:08:14,630 --> 01:08:16,797
Возвращаемый тип может быть

1544
01:08:16,797 --> 01:08:18,020
строенным или нашим собственным

1545
01:08:18,020 --> 01:08:20,160
строенным или нашим собственным

1546
01:08:20,160 --> 01:08:23,340
То есть это может быть Boolean,
может быть Long

1547
01:08:23,340 --> 01:08:26,138
Double, Float

1548
01:08:26,138 --> 01:08:27,753
зависит от того что делает
ваша функция

1549
01:08:27,753 --> 01:08:29,340
вы можете вернуть любой тип

1550
01:08:30,181 --> 01:08:31,820
Я напишу return true

1551
01:08:31,820 --> 01:08:33,190
и функция будет теперь возвращать

1552
01:08:33,190 --> 01:08:35,050
это значение.

1553
01:08:35,050 --> 01:08:39,060
И конечно, как вы уже знаете,
мы можем не указывать тип

1554
01:08:39,060 --> 01:08:41,410
и тогда будет возвращаться
тип Unit.

1555
01:08:41,410 --> 01:08:44,350
в случае, когда функия ничего
не возвращает,

1556
01:08:44,350 --> 01:08:46,830
возвращается тип Unit

1557
01:08:46,830 --> 01:08:48,780
который мы можем вывести в консоль.

1558
01:08:50,360 --> 01:08:52,450
В котлине функции это "объекты
первого порядка"

1559
01:08:52,450 --> 01:08:56,480
Объяснение через секунду.
Если у нас есть функция sayHi

1560
01:08:56,480 --> 01:08:59,230
которая будет выводить текст

1561
01:08:59,230 --> 01:09:01,080
допустим "Hello"

1562
01:09:02,171 --> 01:09:03,004
и вызовем эту функцию из main()

1563
01:09:03,004 --> 01:09:04,740
функции

1564
01:09:04,740 --> 01:09:08,030
в результате она просто выведет текст
в консоль.

1565
01:09:08,030 --> 01:09:10,320
Но функции это объекты первого порядка

1566
01:09:10,320 --> 01:09:12,667
и технически функция в
Котлине это тоже объект

1567
01:09:12,667 --> 01:09:14,410
поэтому внутри одной

1568
01:09:14,410 --> 01:09:16,930
функции вы можете объявить

1569
01:09:16,930 --> 01:09:18,300
другую, новую, функцию

1570
01:09:18,300 --> 01:09:23,030
Например функцию sayBye,
которая будет выглядеть вот так

1571
01:09:23,030 --> 01:09:26,630
И так мы создаем функцию внутри
другой функции

1572
01:09:26,630 --> 01:09:29,280
И тут тоже выведем текст.

1573
01:09:29,280 --> 01:09:31,220
И теперь, если я захочу вызвать
эту функцию

1574
01:09:32,816 --> 01:09:35,001
из метода main и запуши ее вызов тут

1575
01:09:35,001 --> 01:09:36,234
вы увидете, что функция подсвечена красным

1576
01:09:36,234 --> 01:09:37,780
потому что main функция ее не видит

1577
01:09:37,780 --> 01:09:41,510
это происходит из-за того что
область видимости внутренней функции
ограничена

1578
01:09:41,510 --> 01:09:44,480
И единственное место, где я могу вызвать

1579
01:09:44,480 --> 01:09:47,420
функцию sayBye это функция
sayHi, где наша внутренняя функция

1580
01:09:47,420 --> 01:09:50,940
создается.

1581
01:09:50,940 --> 01:09:52,970
Но если я вызову фнкцию тут,
то она опять бует красной

1582
01:09:52,970 --> 01:09:54,920
а значит не найдена.

1583
01:09:55,818 --> 01:09:58,040
И причина в том, что функция,
которую я пытаюсь вызвать

1584
01:09:58,040 --> 01:09:59,060
еще не создана.

1585
01:09:59,060 --> 01:10:01,410
Когда код будет выполняться и мы будем в этой
строчке, то компилятор понятия не имеет

1586
01:10:01,410 --> 01:10:03,420
что за функция такая sayBye

1587
01:10:03,420 --> 01:10:05,380
потому что она объявлена на следующей строчке.

1588
01:10:05,380 --> 01:10:08,190
Если мы вызовем функцию после ее создания

1589
01:10:08,190 --> 01:10:11,320
И запустим программу

1590
01:10:11,320 --> 01:10:13,990
то увидим "Hi" и "Bye" текст

1591
01:10:15,472 --> 01:10:17,690
Запустим..
И да, результат такой, какой мы ожидали.

1592
01:10:17,690 --> 01:10:20,080
Теперь мы конечно должны переименовать
нашу функцию на sayHiAndBye

1593
01:10:20,080 --> 01:10:23,030
чтобы она подходила по смыслу.

1594
01:10:23,030 --> 01:10:25,781
Я использовал шорткат для переименования

1595
01:10:25,781 --> 01:10:27,300
который вы можете посмотреть

1596
01:10:27,300 --> 01:10:30,090
нажав правой кнопкой мыши
и выбрав пункт Refactor->Rename

1597
01:10:30,090 --> 01:10:32,280
Я использовал хоткей shift+F6 на своем маке

1598
01:10:32,280 --> 01:10:34,870
И этот хоткей подсвечивает нам функию
и меняет ее имя везде в коде

1599
01:10:34,870 --> 01:10:36,980
Итак при вызове sayHiAndBye

1600
01:10:36,980 --> 01:10:39,290
нам будут выводится все наши строки

1601
01:10:41,490 --> 01:10:43,850
Потому что одна функция создает
и вызывает внутри себя другую

1602
01:10:43,850 --> 01:10:45,220
Мы так же можем создать еще

1603
01:10:45,220 --> 01:10:46,900
одну функцию внутри bye

1604
01:10:47,752 --> 01:10:50,520
например функцию moo которая

1605
01:10:50,520 --> 01:10:52,250
будет мычать в консоль

1606
01:10:53,330 --> 01:10:56,450
И нам обязательно нужно не забыть
вызвать эту функцию, потому что

1607
01:10:56,450 --> 01:10:59,280
создание функции не означает
что она вызовется

1608
01:10:59,280 --> 01:11:02,260
И так по цепочке
у нас будут

1609
01:11:02,260 --> 01:11:04,650
создаваться и вызываться

1610
01:11:04,650 --> 01:11:07,220
функции одна за другой.

1611
01:11:07,220 --> 01:11:09,260
В самом конце вызовется функция moo
которая заверщит вывод в консоль.

1612
01:11:09,260 --> 01:11:11,100
В небольшом куске кода происходит очень
много действий

1613
01:11:11,100 --> 01:11:12,430
Мы идем сюда, сюда и сюда

1614
01:11:12,430 --> 01:11:14,600
и прыгаем по разным частям кода.

1615
01:11:14,600 --> 01:11:16,450
И если запустим

1616
01:11:16,450 --> 01:11:20,070
то в консоли будет "hello", "bye" и "moo"

1617
01:11:20,070 --> 01:11:21,560
то в консоли будет "hello", "bye" и "moo"

1618
01:11:21,560 --> 01:11:24,530
на самом деле создание и вызов
функиц внутри других функций

1619
01:11:24,530 --> 01:11:28,090
это довольно редкая практика
и не стоит ей злоупотреблять,

1620
01:11:28,090 --> 01:11:29,390
потому что код становится
неразборчивой кашей из вызовов

1621
01:11:29,390 --> 01:11:32,540
Используйте такой подход

1622
01:11:32,540 --> 01:11:34,730
только когда это действительно

1623
01:11:34,730 --> 01:11:36,570
необходимо или иначе сделать нельзя,

1624
01:11:36,570 --> 01:11:38,840
потому что читать такой код
очень турдно.

1625
01:11:38,840 --> 01:11:41,290
Итак, используйте создание функций
в других функция

1626
01:11:41,290 --> 01:11:43,460
только когда на это действительно
есть веская причина

1627
01:11:43,460 --> 01:11:46,170
и когда вы понимаете зачем это нужно.

1628
01:11:46,170 --> 01:11:48,220
но сейчас можно обойтись
просто созданием отдельных функций

1629
01:11:48,220 --> 01:11:50,220
кейсы создания функций в функиях
это тема не для этого курса.

1630
01:11:51,890 --> 01:11:56,090
Функции в Котлине
обычно выглядят так,

1631
01:11:56,090 --> 01:11:59,570
как наша функция sayHi

1632
01:11:59,570 --> 01:12:04,360
которая здоровается с нами
в консоли при запуске

1633
01:12:04,360 --> 01:12:07,230
И если мы выззовем ее из

1634
01:12:07,230 --> 01:12:09,580
функции main, то в выводе

1635
01:12:09,580 --> 01:12:11,800
мы увидим нашу строчку текста.

1636
01:12:13,499 --> 01:12:15,650
И если посмотреть на все объявление

1637
01:12:15,650 --> 01:12:17,910
метода то можно заметить, что
фигурные скобки

1638
01:12:17,910 --> 01:12:19,310
прилично увеличивают функцию
в объеме.

1639
01:12:20,503 --> 01:12:21,790
Конечно, сама по себе функция
могла бы содержать

1640
01:12:21,790 --> 01:12:23,860
гораздо больше действий, но
давайте представим, что она

1641
01:12:23,860 --> 01:12:25,490
делает одну единственную
вещь.

1642
01:12:25,490 --> 01:12:27,190
И для этого у котлина есть подход
который называется

1643
01:12:27,190 --> 01:12:29,640
"функция единственного выражения".

1644
01:12:29,640 --> 01:12:32,610
И мы можем написать название функции
потом знак "равно" и действие,

1645
01:12:32,610 --> 01:12:34,280
которое делали до этого.

1646
01:12:34,280 --> 01:12:37,820
Это значит, что у нас есть функция
с названием sayHi и пустым набором

1647
01:12:37,820 --> 01:12:39,580
параметров (пустые круглые скобки)

1648
01:12:39,580 --> 01:12:42,070
И тело этой функции равно тому
действию, которое

1649
01:12:42,997 --> 01:12:45,455
находится по правую сторону

1650
01:12:45,455 --> 01:12:46,530
от знака равно.

1651
01:12:46,530 --> 01:12:47,790
И так у нас получается, что тело
функции это просто

1652
01:12:47,790 --> 01:12:49,140
вызов метода println.

1653
01:12:49,140 --> 01:12:52,130
Если мы запустим программу,
то увидим все тот же вывод

1654
01:12:52,130 --> 01:12:53,870
Программа с нами здоровается.

1655
01:12:53,870 --> 01:12:57,020
Мы помним, что Котлин поддерживает
создание функций внутри других функций

1656
01:12:57,020 --> 01:12:59,756
потому что функции это тоже объекты,

1657
01:12:59,756 --> 01:13:01,980
объявим функцию

1658
01:13:01,980 --> 01:13:04,310
внутри нашей функции main

1659
01:13:04,310 --> 01:13:07,120
назовем ее напрмер doWork.

1660
01:13:07,120 --> 01:13:10,780
И создадим переменную age с
числом 32.

1661
01:13:10,780 --> 01:13:13,680
И теперь напишем тело функции -
если возраст меньше 32,

1662
01:13:13,680 --> 01:13:17,230
ой, извините, меньше 21, мы
выведем, что возраст пользователя

1663
01:13:17,230 --> 01:13:22,230
меньше чем 21

1664
01:13:24,770 --> 01:13:29,770
или иначе, пользователь подходит
для чего-то, неважно

1665
01:13:31,580 --> 01:13:34,030
возможно есть какое-то
возрстное ограничение.

1666
01:13:35,600 --> 01:13:38,470
И если мы вызовем функцию doWork

1667
01:13:38,470 --> 01:13:40,830
не тут конечно, потому что doWork
в этой строчке кода еще не создан

1668
01:13:40,830 --> 01:13:44,800
вызовем этотм метод после его создания.

1669
01:13:44,800 --> 01:13:47,270
И если запустим то увидим
приветствие

1670
01:13:47,270 --> 01:13:51,070
а потом увидим, что пользователь
проходит возрастное ограничение

1671
01:13:51,070 --> 01:13:53,880
Давайте поменяем на 12 и запустим.

1672
01:13:53,880 --> 01:13:58,130
Теперь увидим предупреждение.

1673
01:13:58,130 --> 01:14:00,760
И весь наш код написан

1674
01:14:00,760 --> 01:14:01,950
в несколько строк.

1675
01:14:01,950 --> 01:14:05,530
Но мы уже знаем, что короткие "if"
условия можно переписать в одну строку,

1676
01:14:05,530 --> 01:14:08,010
а функцию переписать как функцию
единственного выражения.

1677
01:14:08,010 --> 01:14:10,080
Для этого я просто поубираю все

1678
01:14:10,080 --> 01:14:13,380
ненужные фигурные скобки

1679
01:14:14,990 --> 01:14:18,190
из нашей функции

1680
01:14:19,080 --> 01:14:22,580
и перетащу все действия в одну строку.

1681
01:14:22,580 --> 01:14:25,850
И условие все тоже самое,
если возраст меньше 21

1682
01:14:25,850 --> 01:14:29,160
выведем эту строку, а если больше
то другую из "else".

1683
01:14:29,160 --> 01:14:32,430
Если запущу то увидим все тот же результат,

1684
01:14:32,430 --> 01:14:36,580
и по традиции поставим значение
побольше

1685
01:14:36,580 --> 01:14:39,470
и получим, что пользователь
проходит по возрасту,

1686
01:14:39,470 --> 01:14:41,950
а это как раз условие после "else".

1687
01:14:41,950 --> 01:14:43,900
И так вы можете убрать кучу лишнего
кода и читать его будет гораздо

1688
01:14:43,900 --> 01:14:45,510
легче в одну строку.

1689
01:14:45,510 --> 01:14:48,710
И опять же - главное правило
по стилю написания кода.

1690
01:14:48,710 --> 01:14:52,380
Закроем это окно и вы заметите

1691
01:14:52,380 --> 01:14:55,220
вертикальную линию

1692
01:14:55,220 --> 01:14:58,380
Если ваш код доходит до нее.

1693
01:14:58,380 --> 01:15:01,980
Давайте для примера несколько

1694
01:15:01,980 --> 01:15:04,180
раз продублируем текст

1695
01:15:04,180 --> 01:15:06,208
чтобы он был больше.

1696
01:15:06,208 --> 01:15:07,650
И теперь код выходит за эту границу

1697
01:15:07,650 --> 01:15:11,180
Главный совет по код стайлу -
если ваш код доходит до этой границы

1698
01:15:11,180 --> 01:15:15,180
то лучше использовать условный блок
if в несколько строк с фигурными скобками

1699
01:15:15,180 --> 01:15:16,830
так он будет читабельнее.

1700
01:15:16,830 --> 01:15:19,070
И нам нужно вернуть

1701
01:15:19,070 --> 01:15:20,410
фигурные скобки

1702
01:15:20,410 --> 01:15:22,810
и вернуть их везде и в функции
и в "if" условии

1703
01:15:24,080 --> 01:15:28,560
И перенесем все на отдельные линии.

1704
01:15:29,420 --> 01:15:32,800
Упс, через секунду поправлю.

1705
01:15:32,800 --> 01:15:37,800
Опять же, если возраст меньше
21 то выведем эту строку,

1706
01:15:37,979 --> 01:15:39,960
если больше, то вот эту

1707
01:15:39,960 --> 01:15:41,290
если больше, то вот эту

1708
01:15:41,290 --> 01:15:43,840
И причина этому - стандарты написания

1709
01:15:43,840 --> 01:15:46,020
кода, которые привычны
всем разработчикам.

1710
01:15:46,020 --> 01:15:48,770
Если ваш код превышает какое-то
колличество символов в длинну,

1711
01:15:48,770 --> 01:15:51,410
то вам нужно найти способ,
как разнести его на несколько строк.

1712
01:15:51,410 --> 01:15:53,610
И если вы используете
однострочную функцию

1713
01:15:53,610 --> 01:15:55,850
и доходите до индикатора,
то это верный знак, что ваша

1714
01:15:55,850 --> 01:15:57,500
функция слишком сложная и ее

1715
01:15:57,500 --> 01:15:59,300
нужно разбить на несколько строк.

1716
01:16:00,370 --> 01:16:03,130
Функции без параметров

1717
01:16:03,130 --> 01:16:04,710
выглядят именно так -

1718
01:16:04,710 --> 01:16:06,240
название функции и две скобки.

1719
01:16:06,240 --> 01:16:07,850
Если мы хотим передать в функцию
параметры

1720
01:16:07,850 --> 01:16:09,760
то мы запишем их между двумя скобками.

1721
01:16:09,760 --> 01:16:11,050
сейчас у нас нет параметров.

1722
01:16:11,050 --> 01:16:13,270
Если мы вызовем doWork,

1723
01:16:13,270 --> 01:16:14,930
то ничего не произойдет.

1724
01:16:14,930 --> 01:16:18,690
Мы можем дописать вывод
и текст "Work is happening"

1725
01:16:19,670 --> 01:16:23,040
И если сейчас запустим, то
в консоль выведется текст.

1726
01:16:23,040 --> 01:16:24,121
Параметр функции это нечто,
что мы можем передать

1727
01:16:24,121 --> 01:16:26,220
в функцию и функция

1728
01:16:26,220 --> 01:16:27,730
сможет использовать, чтобы
работать как-то иначе.

1729
01:16:27,730 --> 01:16:29,500
Мы можем передать какое-то значение
в функцию.

1730
01:16:29,500 --> 01:16:31,290
Напрмер я хочу передать

1731
01:16:31,290 --> 01:16:34,166
какое-нибудь значение в функцию.

1732
01:16:34,166 --> 01:16:36,360
Пусть это будет целое число 32.

1733
01:16:36,360 --> 01:16:38,230
И я как бы говорю функции:
"Сделай свою работу и вот тебе

1734
01:16:38,230 --> 01:16:42,170
дополнительно число 32, можешь его
использовать"

1735
01:16:42,170 --> 01:16:44,700
Но для того чтобы это работало,
необходимо, чтобы функция

1736
01:16:44,700 --> 01:16:46,450
ожидала что-то на вход в своих аргументах.

1737
01:16:47,497 --> 01:16:49,340
И для этого между скобками
я напишу "age" и его тип -

1738
01:16:49,340 --> 01:16:50,420
целочисленный Int.

1739
01:16:50,420 --> 01:16:55,320
Теперь тут возраст это целое число
и мы видим что при вызове функции

1740
01:16:55,320 --> 01:16:56,750
оно будет равно 32.

1741
01:16:56,750 --> 01:17:01,060
Теперь я могу использовать возраст
в функции и написать "Age is $age"

1742
01:17:01,060 --> 01:17:03,170
я использую интерполяцию строк,
чтобы возраст можно было

1743
01:17:03,170 --> 01:17:06,440
запихнуть сразу в строку

1744
01:17:08,053 --> 01:17:08,970
и код выглядел лучше.

1745
01:17:08,970 --> 01:17:11,510
Давайте лучше напишем "You are $age"

1746
01:17:11,510 --> 01:17:13,840
И давайте напишем что вам,
например 32 года.

1747
01:17:13,840 --> 01:17:18,430
Если запустим то в выводе
увидим

1748
01:17:18,430 --> 01:17:20,790
что вам 32, отлично.

1749
01:17:20,790 --> 01:17:23,720
Если я теперь вызову эту функцию
с другим значением

1750
01:17:23,720 --> 01:17:26,400
допустим 12, мы увидим два разных
фисла в строках консоли

1751
01:17:26,400 --> 01:17:28,770
один с 32, а другой с 12

1752
01:17:28,770 --> 01:17:31,660
Параметры в функциях помогают передать

1753
01:17:31,660 --> 01:17:34,630
разные значения в вашу
функцию

1754
01:17:34,630 --> 01:17:38,420
Так например происходит со
значением 32.

1755
01:17:38,420 --> 01:17:41,370
Таким же образом вы можете передать
дополнительные значения,

1756
01:17:41,370 --> 01:17:43,740
например имя с типом String

1757
01:17:43,740 --> 01:17:47,350
вам нужно написать аргумент в функции.

1758
01:17:47,350 --> 01:17:49,980
И его тип String

1759
01:17:49,980 --> 01:17:53,900
И у нас получится, возраст с
типом Int, потом запятая

1760
01:17:53,900 --> 01:17:55,870
а потом имя с

1761
01:17:55,870 --> 01:17:57,080
типом String.

1762
01:17:57,080 --> 01:17:58,980
Теперь мы омжем заметить
красное подчеркивание

1763
01:17:58,980 --> 01:18:00,770
Идея говорит нам:

1764
01:18:00,770 --> 01:18:03,650
"Вы потеряли передаваемое значение"

1765
01:18:03,650 --> 01:18:06,960
И я напечатаю сюда "Donn"
и в строке заменю

1766
01:18:08,478 --> 01:18:11,750
с помощью интерполяции
добавлю имя в начало

1767
01:18:14,247 --> 01:18:16,697
и расставлю еще знаки препинания

1768
01:18:17,900 --> 01:18:20,560
Если я сейчас запущу, то
в консоли будет

1769
01:18:20,560 --> 01:18:23,850
мое имя и сколько мне лет.

1770
01:18:23,850 --> 01:18:27,950
Я могу поменять аргументы
и вызвать функцию с другими аргументами,

1771
01:18:27,950 --> 01:18:32,710
например Jonas и 12 лет;

1772
01:18:32,710 --> 01:18:35,660
И Jonas будет у на 12-ти летним парнем

1773
01:18:36,818 --> 01:18:39,820
И в консоль теперь будет выдаваться
моя новая строка.

1774
01:18:39,820 --> 01:18:42,230
И крутая штука аргументов функции

1775
01:18:42,230 --> 01:18:44,570
это то что я теперь могу работать
с ними внутри функции

1776
01:18:44,570 --> 01:18:46,720
и делать дополнительные проверки.

1777
01:18:46,720 --> 01:18:48,870
Допустим мы хотим проверить возраст
и в зависимости от результата написать строку

1778
01:18:48,870 --> 01:18:51,780
Я напишу if который будет
говорить, что пользователь

1779
01:18:51,780 --> 01:18:54,060
недостаточно взрослый, если

1780
01:18:54,060 --> 01:18:58,500
аргумент age который пришел
в функцию

1781
01:18:58,500 --> 01:19:03,220
меньше чем 21.

1782
01:19:03,220 --> 01:19:05,410
Представим, что у нас есть какая-то логика

1783
01:19:05,410 --> 01:19:08,150
которая должна выполняться
только для пользователей

1784
01:19:08,150 --> 01:19:11,180
которые старше 21-ого

1785
01:19:11,180 --> 01:19:14,336
Допишем строку, что они недостаточно

1786
01:19:14,336 --> 01:19:17,094
взрослые и им "столько-то" лет.

1787
01:19:17,094 --> 01:19:22,094
И я напишу для else, что пользователь

1788
01:19:28,080 --> 01:19:30,310
слишком старый и ему столько-то лет

1789
01:19:30,310 --> 01:19:32,860
и если я сейчас запущу это
то в консоль выведутся разные значения

1790
01:19:32,860 --> 01:19:34,120
для пользователей с разным возрастом.

1791
01:19:34,120 --> 01:19:36,190
Мы видим сначала результат для "Donn"

1792
01:19:36,190 --> 01:19:37,040
а потом результат для "Jonah"

1793
01:19:37,040 --> 01:19:40,270
Донн у нас слишком старый и ему 32,

1794
01:19:40,270 --> 01:19:43,100
а Jonas слишком моложой и ему 12

1795
01:19:43,100 --> 01:19:44,980
И я могу переиспользовать эту функцию
сколько угодно раз

1796
01:19:44,980 --> 01:19:47,910
Я вызову ее еще раз

1797
01:19:47,910 --> 01:19:51,370
И например для возраста 71

1798
01:19:51,370 --> 01:19:55,100
напишу имя "Evelyn"
пусть она тоже пользуется приложением

1799
01:19:55,100 --> 01:19:57,520
И запустим

1800
01:19:57,520 --> 01:19:59,700
Мы увидим, что под Evelyn тоже
появилась запись

1801
01:19:59,700 --> 01:20:02,820
И Evelyn тоже старая и ей 71.

1802
01:20:02,820 --> 01:20:04,910
Прости Эвелин, если это не так)

1803
01:20:05,800 --> 01:20:08,610
И теперь мы можем пихать какие угодно
имена и возраста в эту функцию

1804
01:20:08,610 --> 01:20:10,730
да и добавлять новые типы аргументов.

1805
01:20:10,730 --> 01:20:13,050
Мы можем добавить Boolean

1806
01:20:13,050 --> 01:20:16,850
Добавим аргумент isHappy
и укажем тип

1807
01:20:16,850 --> 01:20:17,890
Boolean для аргумента.

1808
01:20:19,583 --> 01:20:21,703
И конечно же все у нас счастливые

1809
01:20:21,703 --> 01:20:22,800
поэтому везде передадим true.

1810
01:20:23,680 --> 01:20:25,900
И из-за того что у нас везде true
Идея подсказывает нам, для какого

1811
01:20:25,900 --> 01:20:29,880
аргумента мы добавляем значение true

1812
01:20:29,880 --> 01:20:31,900
Это не я писал, а идея сама содержит
такие подсказки,

1813
01:20:31,900 --> 01:20:33,670
чтобы не приходилось ходить в метод

1814
01:20:33,670 --> 01:20:36,400
и смотреть как называются его аргументы
и какой у них порядок.

1815
01:20:36,400 --> 01:20:38,500
И осталось добавить true для Эвелин,

1816
01:20:38,500 --> 01:20:40,450
теперь все счастливы.

1817
01:20:40,450 --> 01:20:42,210
Теперь можем запустить

1818
01:20:42,210 --> 01:20:43,810
И все будет работать.

1819
01:20:43,810 --> 01:20:45,970
Появится вывод про возраст.

1820
01:20:45,970 --> 01:20:49,190
Вы уже заметили, что мы ничего с
новым значением не делали,

1821
01:20:49,190 --> 01:20:51,920
но потенциально мы можем придумать
что-нибудь с ним

1822
01:20:51,920 --> 01:20:55,110
например вывести строку "You are happy? "

1823
01:20:56,890 --> 01:20:58,630
И как ответ вывести

1824
01:20:58,630 --> 01:21:01,300
аргумент, который мы передали в функцию.

1825
01:21:02,240 --> 01:21:06,910
Запустим программу.

1826
01:21:08,053 --> 01:21:10,170
И теперь мы эту дополнительную
строку увидим для каждого человека

1827
01:21:10,170 --> 01:21:12,050
Для всех трех выведется что они счастливы

1828
01:21:12,050 --> 01:21:13,500
Дон счастлив, эвелин счастлива.

1829
01:21:13,500 --> 01:21:16,420
По какой-то причине я сегодня не счастлив,

1830
01:21:16,420 --> 01:21:19,700
может мизинцем саданулся, запустим заново

1831
01:21:19,700 --> 01:21:22,780
И увидим, что Дон не счастлив,

1832
01:21:22,780 --> 01:21:24,310
потому что мизинец пошел в разнос.

1833
01:21:24,310 --> 01:21:27,200
Джонас и Эвелин все равно счастливы
их аргументы не менялись.

1834
01:21:27,200 --> 01:21:28,790
Мы можем добавлять сколько угодно

1835
01:21:28,790 --> 01:21:30,650
параметров и использовать их
внути функции.

1836
01:21:30,650 --> 01:21:33,320
Если вам нужен ваш параметр, просто
напишите его название после запятой

1837
01:21:33,320 --> 01:21:35,260
и укажите его тип, можете
попробовать сами, это просто.

1838
01:21:35,260 --> 01:21:38,520
Напишем еще один, пусть будет foo с типом Long

1839
01:21:38,520 --> 01:21:40,630
просто для примера.

1840
01:21:40,630 --> 01:21:41,920
Как всегда Идея подсветит наши вызовы

1841
01:21:41,920 --> 01:21:43,890
функций и скажет, что в них не достает

1842
01:21:43,890 --> 01:21:45,710
параметров.

1843
01:21:45,710 --> 01:21:48,800
И вот так мы передаем аргументы в функции.

1844
01:21:48,800 --> 01:21:51,900
Давайте представим, что у нас есть
функция с названием printUserInfo

1845
01:21:51,900 --> 01:21:55,053
в нее передается куча параметров,
например имя

1846
01:21:55,053 --> 01:21:57,580
фамилия, возраст, сгорали ли они на солнце

1847
01:21:57,580 --> 01:22:00,120
любят ли кино
и попкорн

1848
01:22:00,120 --> 01:22:02,590
И если я захочу эти аргументы
использовать и, например,

1849
01:22:02,590 --> 01:22:04,780
вывести информацию как-то в консоль

1850
01:22:04,780 --> 01:22:07,850
мы можем написать функцию

1851
01:22:07,850 --> 01:22:09,950
вывода с помощью литералов

1852
01:22:09,950 --> 01:22:11,000
звучит логично.

1853
01:22:11,000 --> 01:22:13,970
Если мы захотим теперь вызвать ее

1854
01:22:13,970 --> 01:22:15,150
мы должны предоставить ей все аргументы

1855
01:22:15,150 --> 01:22:18,190
Я начну передавать информацию в функцию

1856
01:22:18,190 --> 01:22:22,580
имя - Дон, фамилия - Фэлкер,
передам возраст

1857
01:22:22,580 --> 01:22:25,270
Сгорал ли я на на солнце,

1858
01:22:25,270 --> 01:22:26,430
напишу что нет

1859
01:22:26,430 --> 01:22:28,880
люблю кино

1860
01:22:28,880 --> 01:22:31,300
и конечно люблю попкорн!

1861
01:22:32,190 --> 01:22:34,920
Было довольно просто

1862
01:22:34,920 --> 01:22:37,690
и у нас есть подсказки от Идеи
и мы видим названия аргументов,

1863
01:22:37,690 --> 01:22:41,880
которые мы пердали

1864
01:22:41,880 --> 01:22:42,720
И все это работает чудесно

1865
01:22:42,720 --> 01:22:45,300
пока мы находимся в Идее,
но эти подсказки не будут работать

1866
01:22:45,300 --> 01:22:48,730
вне Идеи, потому

1867
01:22:48,730 --> 01:22:51,940
что это именно ее встроенная функциональность

1868
01:22:51,940 --> 01:22:53,470
Если мы перенесем этот код
куда-то онлайн или в другую IDE

1869
01:22:53,470 --> 01:22:54,710
то они могут не поддерживать эту фичу

1870
01:22:54,710 --> 01:22:56,640
Давайте перейдем в другую IDE.

1871
01:22:56,640 --> 01:22:58,710
Окей, теперь мы в Visual Studio Code

1872
01:22:58,710 --> 01:23:00,290
Я вставлю наш написанный код и вы увидите

1873
01:23:00,290 --> 01:23:02,330
что подсказки

1874
01:23:02,330 --> 01:23:03,430
у функции пропали.

1875
01:23:05,152 --> 01:23:07,657
Тут мы видим имя, фамилию и т.д.

1876
01:23:07,657 --> 01:23:09,038
Если вернемся в Visual Studio

1877
01:23:09,038 --> 01:23:11,480
у нас этих подсказок нет

1878
01:23:11,480 --> 01:23:13,610
Это фича для котлина в Intellij IDEA

1879
01:23:13,610 --> 01:23:15,930
И теперь когда мы читаем этот код

1880
01:23:15,930 --> 01:23:18,980
и это частый кейс, если вы работаете
с Git и делаете например мердж реквест

1881
01:23:18,980 --> 01:23:22,250
Или смотрите код где-то на стэковерфлоу

1882
01:23:22,250 --> 01:23:24,470
вы не будете понимать что значат эти
false/true/true

1883
01:23:24,470 --> 01:23:26,599
особенно, если вы писали код пару
месяцев назад

1884
01:23:26,599 --> 01:23:27,910
Вы точно не поймете что значит true

1885
01:23:27,910 --> 01:23:30,880
Эта true, у нас нет никакого понимания
что передается в printUserInfo.

1886
01:23:30,880 --> 01:23:33,840
И конечно нужно понимать,
что эта функция не будет

1887
01:23:33,840 --> 01:23:36,470
сидеть рядом с местом,
где она вызывается

1888
01:23:36,470 --> 01:23:38,620
а будет спрятана где-то среди тысячи
других файлов с кодом

1889
01:23:39,719 --> 01:23:40,552
И от этого понимание функции
становится сложнее

1890
01:23:40,552 --> 01:23:42,810
Нам нужно будет переключатся чтобы понять,
что в нее передается.

1891
01:23:45,805 --> 01:23:47,680
Хорошая новость, что мы можем
это поправить средствами языка

1892
01:23:47,680 --> 01:23:48,530
Котлин.

1893
01:23:49,457 --> 01:23:50,750
Вернемся в Идею, и штука которую

1894
01:23:50,750 --> 01:23:52,810
мы можем дописать называется
"именованные аргументы"

1895
01:23:52,810 --> 01:23:55,270
Я явно напишу firstName и равно

1896
01:23:55,270 --> 01:23:57,340
это называется именованным аргументом

1897
01:23:57,340 --> 01:24:01,450
я дописываю названия в месте вызова

1898
01:24:01,450 --> 01:24:03,270
и справа от равно будет значение
которое я передаю аргументу

1899
01:24:03,270 --> 01:24:06,980
isSunburned = false

1900
01:24:06,980 --> 01:24:09,640
и тоже самое для кино

1901
01:24:09,640 --> 01:24:12,720
и попкорна.

1902
01:24:12,720 --> 01:24:14,660
Я скопирую этот вызов

1903
01:24:14,660 --> 01:24:17,040
вернусь в VisualStudio

1904
01:24:17,040 --> 01:24:18,880
удалю старый и вставлю новый.

1905
01:24:18,880 --> 01:24:22,590
и теперь эти параметры явно указаны

1906
01:24:22,590 --> 01:24:25,080
По дефолту, Котлин сможет
скомпилировать код в таком виде

1907
01:24:25,080 --> 01:24:27,800
Вернемся в Идею, все будет работать

1908
01:24:27,800 --> 01:24:28,850
просто у аргументов в месте вызове будут
явные наименования.

1909
01:24:29,824 --> 01:24:34,470
Запущу и увидим

1910
01:24:34,470 --> 01:24:36,650
32 года, не сгорел на солнце,
любит кино и попкорн

1911
01:24:36,650 --> 01:24:38,080
все верно.

1912
01:24:38,080 --> 01:24:40,450
Все работает по прежнему.

1913
01:24:40,450 --> 01:24:42,910
Еще одна хорошая фича именнованых
аргументов

1914
01:24:42,910 --> 01:24:44,690
это их позиционированние

1915
01:24:44,690 --> 01:24:46,600
Удалим именование у последнего аргумента

1916
01:24:46,600 --> 01:24:48,595
и вы увидите то о чем я говорю

1917
01:24:48,595 --> 01:24:49,640
Идея теперь подсвечивает его
и говорит,

1918
01:24:49,640 --> 01:24:52,470
что смешивание обычных и

1919
01:24:52,470 --> 01:24:53,960
именованных аргументов запрещено

1920
01:24:53,960 --> 01:24:56,220
Это к разговору о позиционированнии

1921
01:24:56,220 --> 01:24:57,670
Последний аргумент должен быть
именнованным, если перед ним есть

1922
01:24:57,670 --> 01:25:01,740
именнованные аргументы.

1923
01:25:01,740 --> 01:25:02,990
я верну как было

1924
01:25:02,990 --> 01:25:05,380
И, например удалим именование у возраста

1925
01:25:05,380 --> 01:25:06,870
и получим ту же проблему

1926
01:25:06,870 --> 01:25:11,520
из-за того что перед ним есть
именнованные аргументы

1927
01:25:11,520 --> 01:25:13,180
Котлин не понимает, что мы
пытаемся сделать

1928
01:25:13,180 --> 01:25:15,280
Мы пытаемся использовать именнованные аргументы

1929
01:25:15,280 --> 01:25:17,800
и обычные, смешивая их

1930
01:25:17,800 --> 01:25:19,070
Это не скомпилируется

1931
01:25:19,070 --> 01:25:20,620
Если вы собираетесь использовать имя
хотя бы для одного аргумента

1932
01:25:20,620 --> 01:25:22,470
вам придется писать имена для
всех аргументов функции

1933
01:25:22,470 --> 01:25:24,170
и так читаемость повысится и
компилятор не сойдет с ума

1934
01:25:24,170 --> 01:25:26,300
И такое именование позволяет менять

1935
01:25:26,300 --> 01:25:29,360
аргументы местами, Котлин
сам поставит их на свои места.

1936
01:25:29,360 --> 01:25:33,010
Метод printUserInfo принимает  имя

1937
01:25:33,010 --> 01:25:35,520
фамилию, возраст.

1938
01:25:35,520 --> 01:25:38,050
В традиционных языках

1939
01:25:38,050 --> 01:25:41,970
вам придется передавать аргументы
в том порядке,

1940
01:25:41,970 --> 01:25:43,340
который объявляет функция.

1941
01:25:43,340 --> 01:25:45,320
Но не в Котлине, если вы используете
именованные аргументы,

1942
01:25:45,320 --> 01:25:48,150
Мы ставим возраст на первое место,
а котлин увидит именование

1943
01:25:48,150 --> 01:25:52,840
и сам подставит его на третье место
в функцию.

1944
01:25:52,840 --> 01:25:54,480
Если мы хотим переместить этот Boolean

1945
01:25:54,480 --> 01:25:56,540
куда-нибудь в другое место

1946
01:25:56,540 --> 01:25:59,020
где это несет больше смысла

1947
01:25:59,020 --> 01:26:01,150
И Котлин сам перенесет
и подставит это значение

1948
01:26:01,150 --> 01:26:03,460
в нужное место под капотом.

1949
01:26:04,344 --> 01:26:06,050
в нашем случае, на четвертую позицию

1950
01:26:06,050 --> 01:26:08,560
потому что у этого Boolean

1951
01:26:08,560 --> 01:26:11,190
есть явное название аргумента.

1952
01:26:11,190 --> 01:26:14,560
Вот так вы можете использовать именованые
аргументы в Котлин.

1953
01:26:14,560 --> 01:26:17,940
В Котлин есть концепт, который
называется "дефолтные агрументы"

1954
01:26:17,940 --> 01:26:20,390
Каждый раз, когда я вызываю
printUserFunction

1955
01:26:20,390 --> 01:26:22,910
Допустим я несколько раз ее вызываю

1956
01:26:22,910 --> 01:26:26,310
Я буду менять аргументы для

1957
01:26:26,310 --> 01:26:28,850
некоторых типор, потому что они меняются

1958
01:26:28,850 --> 01:26:32,970
например возраст 31, 37 и 12

1959
01:26:32,970 --> 01:26:34,110
и вообще почти все можно заменить

1960
01:26:34,110 --> 01:26:37,100
Пользователь сгорел на солнце и так далее

1961
01:26:37,100 --> 01:26:39,030
Но допустим, что в большинстве

1962
01:26:39,030 --> 01:26:40,880
случаев я знаю, что пользователь
не сгорел на солнце

1963
01:26:40,880 --> 01:26:43,130
И например они точно любят попкорн

1964
01:26:43,130 --> 01:26:45,720
и кино

1965
01:26:45,720 --> 01:26:48,310
Записывать эти вещи из раза в раз
превраается в рутину.

1966
01:26:48,310 --> 01:26:52,040
Для того, чтобы этого избежать мы можем использовать
дефолтные параметры.

1967
01:26:52,040 --> 01:26:55,070
И для этого мы напишем дефолтной значение
для аргумента функции

1968
01:26:55,070 --> 01:26:57,870
Например "lovesPopcorn: Boolean = true"

1969
01:26:57,870 --> 01:26:59,300
Выставим true gj ltajkne

1970
01:26:59,300 --> 01:27:01,570
Теперь у нас нет необходимости

1971
01:27:02,468 --> 01:27:03,990
писать это значение при вызове функции

1972
01:27:03,990 --> 01:27:05,640
оно по дефолту будет равно true

1973
01:27:06,813 --> 01:27:08,450
Уберу этот аргумент у всех вызовов.

1974
01:27:08,450 --> 01:27:13,450
Я могу сделать тоже самое для
переменной "любит кино"

1975
01:27:13,760 --> 01:27:14,790
и по дефолту тоже true

1976
01:27:14,790 --> 01:27:17,240
потому что все любят кино, верно?

1977
01:27:17,240 --> 01:27:19,790
И уберы эти аргументы из вызова.

1978
01:27:19,790 --> 01:27:22,710
И теперь, если мы явно не передаем
аргумент при вызове функции

1979
01:27:22,710 --> 01:27:25,470
то внутри функции будет
дефолтное значение true

1980
01:27:25,470 --> 01:27:29,513
И конечно для переменной "сгорел на солнце"

1981
01:27:29,513 --> 01:27:32,010
я поставлю false, потому что
все редко сгорают на солнце.

1982
01:27:32,010 --> 01:27:34,610
И эт отак же просто, я просто говорю что
этот аргумент по дефолту false

1983
01:27:34,610 --> 01:27:37,248
и убираю это из вызова функций.

1984
01:27:37,248 --> 01:27:38,081
И теперь наши вызовы выглядят гораздо проще

1985
01:27:38,081 --> 01:27:39,880
чем раньше.

1986
01:27:39,880 --> 01:27:42,860
Мы теперь видим только важную

1987
01:27:42,860 --> 01:27:46,180
информацию, которая часто меняется для функции

1988
01:27:46,180 --> 01:27:48,130
И если запустим

1989
01:27:48,130 --> 01:27:50,081
увидим три записи

1990
01:27:50,081 --> 01:27:51,310
с нашими дефолтными значениями

1991
01:27:51,310 --> 01:27:52,620
с нашими дефолтными значениями

1992
01:27:52,620 --> 01:27:56,032
И теперь, если я вдруг понимаю

1993
01:27:56,032 --> 01:27:58,420
что я съел много попкорна

1994
01:27:58,420 --> 01:27:59,980
и не очень сильно его переношу,

1995
01:27:59,980 --> 01:28:01,590
Я могу явно передать аргумент
и сделать его false.

1996
01:28:01,590 --> 01:28:05,320
И допусти Боб на этой неделе сгорел

1997
01:28:05,320 --> 01:28:07,981
потому что заснул на пляже

1998
01:28:07,981 --> 01:28:09,090
на берегу залива

1999
01:28:10,165 --> 01:28:12,309
И Сара не любит кино, а чаще

2000
01:28:12,309 --> 01:28:15,170
смотрит сериалы, вставлю false

2001
01:28:15,170 --> 01:28:17,220
Боб сгорел,

2002
01:28:17,220 --> 01:28:18,610
нужно поставить trueю

2003
01:28:18,610 --> 01:28:21,030
Теперь что происходит?
Когда мы вызовем функцию

2004
01:28:21,030 --> 01:28:23,320
значения которые мы указали
будет приоритетней дефолтных.

2005
01:28:23,320 --> 01:28:26,550
И дефолтные значения для аргументов,
которые были явно указаны,

2006
01:28:26,550 --> 01:28:29,990
будет проигнорировано.

2007
01:28:29,990 --> 01:28:32,640
Для следующего вызова функции

2008
01:28:32,640 --> 01:28:34,690
будет срабатывать
дефолтный параметр

2009
01:28:34,690 --> 01:28:36,570
потому что мы не передали свой.

2010
01:28:36,570 --> 01:28:38,440
Но мы передали сгорел ли пользователь

2011
01:28:38,440 --> 01:28:40,600
И в аргумент попадет наше
значение, а дефолтное

2012
01:28:40,600 --> 01:28:42,720
будет проигнорированно.

2013
01:28:42,720 --> 01:28:45,070
И в последнем вызове функции

2014
01:28:45,070 --> 01:28:47,060
для Сары

2015
01:28:47,060 --> 01:28:48,860
указано, что он не любит кино

2016
01:28:48,860 --> 01:28:50,550
и это перезапишет дефолтный параметр

2017
01:28:50,550 --> 01:28:51,750
и передаст false в функцию

2018
01:28:51,750 --> 01:28:54,060
И если мы запустим наши функции

2019
01:28:54,060 --> 01:28:56,150
То увидим что вывод соответствует
тому что мы только что описали.

2020
01:28:56,150 --> 01:28:58,720
Дон не любит попкорн

2021
01:28:59,825 --> 01:29:03,360
Боб сгорел на солнце true

2022
01:29:03,360 --> 01:29:06,840
и Сара не любит кино.

2023
01:29:06,840 --> 01:29:10,870
И это дефолтные значениея которые вы можете
использовать для любых аргументов

2024
01:29:10,870 --> 01:29:12,160
в Котлине

2025
01:29:12,160 --> 01:29:15,140
Если например, наш тип String

2026
01:29:15,140 --> 01:29:18,000
давайте добавим еще один аргумент
строковый в конце

2027
01:29:18,000 --> 01:29:22,220
например для любимого цвета.

2028
01:29:23,710 --> 01:29:25,680
И это будет

2029
01:29:25,680 --> 01:29:26,880
синий цвет по дефолту.

2030
01:29:28,438 --> 01:29:31,500
И если вы теперь укажете цвет в
месте вызова функции

2031
01:29:31,500 --> 01:29:35,210
вы можете изменить и установить
недефолтное значение

2032
01:29:35,210 --> 01:29:36,910
И вы можете так делать абсолютно для
любых типов

2033
01:29:37,971 --> 01:29:39,680
Для встроенных типов и
для ваших собственных.

2034
01:29:39,680 --> 01:29:42,880
Для встроенных типов и
для ваших собственных.

2035
01:29:42,880 --> 01:29:45,870
Чаще всего аргументы с дефолтными

2036
01:29:45,870 --> 01:29:48,700
значениями записываются
в аргументы в конце

2037
01:29:48,700 --> 01:29:50,920
Но это правило не железнобетонное

2038
01:29:50,920 --> 01:29:52,950
Вы можете вставлять их в середину
и в начало

2039
01:29:52,950 --> 01:29:54,800
например, если вы хотите
для фамилии указать

2040
01:29:54,800 --> 01:29:57,650
дефолтное значение
напрмер "Smith"

2041
01:29:57,650 --> 01:29:59,590
потому что мы, напрмер,
работаем с семьей

2042
01:29:59,590 --> 01:30:03,340
и удалим нае текущее значение.

2043
01:30:03,340 --> 01:30:04,850
и удалим нае текущее значение.


2044
01:30:04,850 --> 01:30:07,060
Если теперь запустим увидим,

2045
01:30:07,060 --> 01:30:11,190
что у Сары сменилась фамили на дефолтную

2046
01:30:11,190 --> 01:30:15,650
И это пример, когда дефолтное значение

2047
01:30:15,650 --> 01:30:18,400
у нас прямо посереине метода

2048
01:30:18,400 --> 01:30:20,910
Между недефолтными значениями.

2049
01:30:20,910 --> 01:30:22,710
У нас не указан возраст

2050
01:30:22,710 --> 01:30:24,120
и нужно его дописать

2051
01:30:24,120 --> 01:30:28,072
если мы не напишем, то получим ошибку
потому что у него нет дефолтного значения

2052
01:30:28,072 --> 01:30:30,310
и age просто не передается в метод

2053
01:30:30,310 --> 01:30:32,450
И из-за того что мы используем
именованные аргументы

2054
01:30:32,450 --> 01:30:35,290
мы можем добавить его в конце.

2055
01:30:35,290 --> 01:30:37,080
И из-за того что аргументы именнованные

2056
01:30:37,080 --> 01:30:39,140
я вообще могу их писать в любом порядке.

2057
01:30:39,140 --> 01:30:42,610
И так используются дефолтные
аргументы

2058
01:30:42,610 --> 01:30:43,970
в языке Котлин.

2059
01:30:43,970 --> 01:30:47,530
Один из подходов который мы убсуждали
эт опереносить строки кода на новую линию

2060
01:30:47,530 --> 01:30:50,040
если ваш код достиг вертикального

2061
01:30:50,040 --> 01:30:51,800
серого индитакора справа

2062
01:30:51,800 --> 01:30:54,720
Обычная практика - переносить
каждый аргумент функции на

2063
01:30:54,720 --> 01:30:58,730
новую строку, чтобы их
было легче читать

2064
01:30:58,730 --> 01:31:01,540
И это довольно рутинная работа,
если делать ее вручную -

2065
01:31:01,540 --> 01:31:04,200
очень долго и можно допустить ошибку.

2066
01:31:04,200 --> 01:31:06,890
Хорошие новости - в IDE для Котлина

2067
01:31:06,890 --> 01:31:09,130
например в IntelliJ IDEA и в Android Studio
есть шоркаты, которые сделают это

2068
01:31:09,130 --> 01:31:10,760
за вас.

2069
01:31:10,760 --> 01:31:12,580
Вам нужно только поставить курсор

2070
01:31:12,580 --> 01:31:15,430
перед открывающей скобкой
и нажать Alt+Enter

2071
01:31:15,430 --> 01:31:18,260
и выбрать пункт "Put arguments on separate lines"

2072
01:31:18,260 --> 01:31:20,990
И Идея сама раскидает аргументы
на разные строки

2073
01:31:20,990 --> 01:31:22,800
и экономит ваше время

2074
01:31:22,800 --> 01:31:24,520
Это шорткат, который

2075
01:31:24,520 --> 01:31:26,570
вам необходимо запомнить.

2076
01:31:26,570 --> 01:31:29,360
Теперь Идея подсвечивает нам

2077
01:31:29,360 --> 01:31:30,760
имена наших аргументов

2078
01:31:30,760 --> 01:31:32,700
Это фича исключительно IDE

2079
01:31:32,700 --> 01:31:34,990
и если мы скопируем код в другую IDE

2080
01:31:34,990 --> 01:31:39,080
например Visual Srudio,
то эти подсказки пропадут.

2081
01:31:39,080 --> 01:31:42,380
Как нам добавить все эти

2082
01:31:42,380 --> 01:31:43,430
имена аргументов?

2083
01:31:45,124 --> 01:31:48,360
Мы вернемся в нашу IDE
и конечно самый банальный способ

2084
01:31:48,360 --> 01:31:49,520
добавлять их вручную

2085
01:31:49,520 --> 01:31:51,760
И опять, это займет дикую кучу
времени, писать

2086
01:31:51,760 --> 01:31:52,740
каждый аргумент снова и снова

2087
01:31:52,740 --> 01:31:55,120
Опять же Идея, предоставляет отличный
шорткат - поставьте указатель

2088
01:31:55,120 --> 01:31:57,600
перед скобкой, нажмите Alt+Enter
и выберите пункт "Add names to

2089
01:31:57,600 --> 01:31:59,310
call arguments" и вуаля,

2090
01:32:00,443 --> 01:32:02,160
теперь все наименования добавились к
вашему коду

2091
01:32:02,160 --> 01:32:04,210
оба этих подхода -
перенос аргументов

2092
01:32:04,210 --> 01:32:05,610
на разнае строки

2093
01:32:05,610 --> 01:32:08,010
и добавление имен к аргументам

2094
01:32:08,010 --> 01:32:09,300
делают ваш код

2095
01:32:09,300 --> 01:32:11,030
гораздо читабельнее

2096
01:32:11,030 --> 01:32:13,790
и сохраняют кучу времени вашим коллегам
и вам в будущем.

2097
01:32:13,790 --> 01:32:16,250
Допустим у нас есть функция
которая выводит информацию о книге

2098
01:32:16,250 --> 01:32:18,590
она выводит название
и автора книги

2099
01:32:18,590 --> 01:32:20,830
Тут мы функцию вызываем с названием
и автором, если запустим

2100
01:32:20,830 --> 01:32:23,000
увидим что в консоль

2101
01:32:23,000 --> 01:32:25,190
все правильно выведется.

2102
01:32:25,190 --> 01:32:28,180
Но теперь, если нам понадобится
сделать книгу у которой

2103
01:32:28,180 --> 01:32:30,510
будет несколько авторов,
напрмер есть соавторы у книги

2104
01:32:30,510 --> 01:32:32,850
потому что так иногда бывает,
люди редко пишут книги самостоятельно,

2105
01:32:32,850 --> 01:32:36,830
Для этого мы могли бы переопределить
эту функцию но с двумя авторами

2106
01:32:36,830 --> 01:32:38,940
и написать, что это второй автор.

2107
01:32:38,940 --> 01:32:40,420
Это первый, а это второй автор

2108
01:32:40,420 --> 01:32:43,350
И изменить вывод нашей функции

2109
01:32:43,350 --> 01:32:44,510
чтобы он выводил

2110
01:32:44,510 --> 01:32:46,940
сразу несколько авторов.

2111
01:32:46,940 --> 01:32:48,230
Это будет работать для двух авторов.

2112
01:32:48,230 --> 01:32:50,774
Если у мниги будет три автора

2113
01:32:50,774 --> 01:32:51,740
то придется создавать еще
одну функцию

2114
01:32:51,740 --> 01:32:55,040
и придется дублировать для
четерех, пяти, шести второв

2115
01:32:55,040 --> 01:32:58,600
В языке Котлин есть специальное
ключевое слово для таких случаев

2116
01:32:58,600 --> 01:33:00,250
чтобы не писать дополнительный код

2117
01:33:00,250 --> 01:33:02,070
Мы можем взять наш последний параметр

2118
01:33:02,070 --> 01:33:03,790
и превратить его в "vararg"

2119
01:33:03,790 --> 01:33:07,010
И переводится это как переменный
аргумент функции

2120
01:33:07,010 --> 01:33:08,960
И поменяем его название
на "авторы"

2121
01:33:08,960 --> 01:33:12,300
Это значит, что теперь этот аргумент
может принимать от нуля до бесконечного

2122
01:33:12,300 --> 01:33:14,410
числа авторов.

2123
01:33:14,410 --> 01:33:16,830
И под капотом это превратится в массив

2124
01:33:16,830 --> 01:33:18,740
если мы попытаемся его вывести в таком
виде, давайте еще

2125
01:33:18,740 --> 01:33:20,260
добавим автора.

2126
01:33:20,260 --> 01:33:23,460
Добавим еще одного гипотетического

2127
01:33:23,460 --> 01:33:24,710
соавтора книги.

2128
01:33:25,759 --> 01:33:28,090
Если мы теперь это запустим

2129
01:33:28,090 --> 01:33:31,260
в консоль выведется квадратная
скобка и какая-то информация

2130
01:33:31,260 --> 01:33:32,350
так выводится в консоль массив
в Котлине.

2131
01:33:32,350 --> 01:33:34,800
И это вывод информации про массив,
из полезного - он пишет какой тип он содержит.

2132
01:33:34,800 --> 01:33:36,640
Если мы захотим вывести сам
контент массива

2133
01:33:36,640 --> 01:33:37,820
нам нужно погрузится в немного

2134
01:33:37,820 --> 01:33:41,130
продвинутые средства языка

2135
01:33:41,130 --> 01:33:44,840
а именно в лямбда выражения
и вывести все в консоль

2136
01:33:44,840 --> 01:33:47,590
И "it" это ключевое слово, которое
собержит одного автора.

2137
01:33:48,485 --> 01:33:50,485
Если мы запустим то увидим

2138
01:33:51,350 --> 01:33:54,000
информацию о массиве, которую можно удаалить

2139
01:33:55,329 --> 01:33:57,762
И перезапустим снова

2140
01:33:57,762 --> 01:33:58,800
Теперь мы видим название книги

2141
01:33:58,800 --> 01:34:01,980
и авторов, которых мы передали

2142
01:34:01,980 --> 01:34:04,480
в функцию

2143
01:34:04,480 --> 01:34:06,190
теперь все выводится.

2144
01:34:06,190 --> 01:34:07,990
Можем добавить еще одного

2145
01:34:07,990 --> 01:34:11,490
например Jane Doe

2146
01:34:11,490 --> 01:34:13,330
и можем еще сколько угодно,

2147
01:34:13,330 --> 01:34:15,300
на самом деле добавить.

2148
01:34:15,300 --> 01:34:16,570
Самое классное, что у книги

2149
01:34:16,570 --> 01:34:19,720
может вообще не быть автора

2150
01:34:19,720 --> 01:34:22,800
возсожно это какая-то анонимная нига

2151
01:34:22,800 --> 01:34:24,420
Мы можем все так же запустить

2152
01:34:24,420 --> 01:34:26,940
И просто увидим, что ничего не вывелось.

2153
01:34:26,940 --> 01:34:30,520
Если у вас будут кейсы,
когда функция должна принимать

2154
01:34:30,520 --> 01:34:33,050
несколько аргументов определенного типа

2155
01:34:33,050 --> 01:34:34,750
вы можете использовать vararg

2156
01:34:34,750 --> 01:34:37,130
в последнем аргументе функции.

2157
01:34:37,130 --> 01:34:40,350
к аргугменту просто добавляется "vararg"

2158
01:34:40,350 --> 01:34:43,170
и теперь можно передавать
сколько угодно переменных этого типа

2159
01:34:43,170 --> 01:34:47,100
Например у нас есть разные буквы

2160
01:34:47,100 --> 01:34:49,190
и все они могут влезть в этот массив

2161
01:34:49,190 --> 01:34:52,893
И потом в функции вы можете пройти
по массиву с помощью лябды

2162
01:34:52,893 --> 01:34:55,990
или сделать любую другую операцию.

2163
01:34:58,040 --> 01:35:00,890
Давайте допустим что у нас есть
функция, которая выводит инфу о пользователе

2164
01:35:00,890 --> 01:35:02,380
и сейчас просто выводит имя

2165
01:35:02,380 --> 01:35:04,750
Очень простая, мы просто передаем
имя и оно выводится

2166
01:35:04,750 --> 01:35:07,050
В консоль вывелось имя

2167
01:35:07,050 --> 01:35:08,560
Допустим, по какой-то причине

2168
01:35:08,560 --> 01:35:10,760
мне иногда нужно

2169
01:35:10,760 --> 01:35:12,210
выводить только имя

2170
01:35:12,210 --> 01:35:14,840
а иногда только возраст

2171
01:35:14,840 --> 01:35:16,800
И тут напрашивается еще одна

2172
01:35:16,800 --> 01:35:18,600
функция для вывода информации о пользователе.

2173
01:35:19,530 --> 01:35:20,990
И она должна принимать возраст и выводить его

2174
01:35:20,990 --> 01:35:22,330
тип укажем Int.

2175
01:35:22,330 --> 01:35:25,057
И теперь я могу продублировать

2176
01:35:25,057 --> 01:35:25,940
пользователя и дать ему новое
имя и возраст

2177
01:35:25,940 --> 01:35:27,550
Это наш новый пользователь

2178
01:35:27,550 --> 01:35:29,560
Назовем "Jane Doe"

2179
01:35:29,560 --> 01:35:32,030
И путь будет 37 лет

2180
01:35:32,910 --> 01:35:34,920
И теперь, если мы пойдем в определение
функции (cmd+B на маке)

2181
01:35:34,920 --> 01:35:36,210
Провалимся в определение первого вызова

2182
01:35:36,210 --> 01:35:37,560
И попадем в эту функцию

2183
01:35:37,560 --> 01:35:39,380
А во втором в эту функцию

2184
01:35:39,380 --> 01:35:41,060
Это называется перегрузкой функций

2185
01:35:41,060 --> 01:35:44,450
Мы перегружаем функию printUserInfo

2186
01:35:44,450 --> 01:35:47,120
и теперь она в двух вариациях, одна
принмает имя, а вторая имя и возраст

2187
01:35:47,120 --> 01:35:48,770
Функция называется перегруженной, только тогда
когда у ее вариаций отличаются аргументы;

2188
01:35:48,770 --> 01:35:51,180
Если мы уберем этот аргумент

2189
01:35:51,180 --> 01:35:52,290
мы увидим сообщение об ошибке

2190
01:35:52,290 --> 01:35:55,100
потому что аргументы совпадают
и это конфликт в определении функции

2191
01:35:55,100 --> 01:35:58,380
И первая и вторая
функции это одно и то же,

2192
01:35:58,380 --> 01:36:00,950
поэтому компилятор не сможет понять
какую именно функцию вы будете

2193
01:36:00,950 --> 01:36:02,330
вызвать, так как их две одинаковые.

2194
01:36:02,330 --> 01:36:07,010
Из-за того что аргументы функции разные

2195
01:36:07,010 --> 01:36:09,490
Котлин начинает считать, что это одна
и таже функция, но вызывать ее

2196
01:36:09,490 --> 01:36:11,490
можно с разными входными данными.
Поэтому Котлин не видит конфликтов

2197
01:36:11,490 --> 01:36:14,604
так как названия функций
и их возращщаемы тип

2198
01:36:14,604 --> 01:36:15,810
одинаковый, а аргументы на входе
разные.

2199
01:36:17,034 --> 01:36:19,263
И опять мы можем сказать, что
теперь мы хотим

2200
01:36:19,263 --> 01:36:20,700
передавать и выводить
любимый цвет пользователя

2201
01:36:20,700 --> 01:36:23,550
Допишем favoriteColor

2202
01:36:23,550 --> 01:36:26,450
И пусть это будет строкой
для простоты

2203
01:36:26,450 --> 01:36:27,960
Теперь одна функция у нас
перегружена тремя вариациями аргументов

2204
01:36:27,960 --> 01:36:31,080
И теперь я могу вызвать
printUserInfo

2205
01:36:31,080 --> 01:36:33,231
и в подсказке мы увидим 3
возможных варианта вызова.

2206
01:36:33,231 --> 01:36:35,030
Одна берет имя, другая имя и возраст

2207
01:36:35,030 --> 01:36:36,120
с типами Sting и Int

2208
01:36:36,120 --> 01:36:39,030
А третья Sting Int и еще String
c любимым цветом,

2209
01:36:39,030 --> 01:36:42,080
И конечно, нам нужно
изменить вывод

2210
01:36:42,080 --> 01:36:44,230
и вывести любимый цвет.

2211
01:36:44,230 --> 01:36:47,500
Как всегда, с помощью интерполяции,

2212
01:36:47,500 --> 01:36:48,980
выводим любимый цвет

2213
01:36:48,980 --> 01:36:51,530
Теперь я могу вывести информацию

2214
01:36:51,530 --> 01:36:54,513
например, про Фрэнка,

2215
01:36:57,220 --> 01:37:00,850
скажем что ему 22

2216
01:37:00,850 --> 01:37:03,100
и его любимый цвет фиолетовый.

2217
01:37:04,050 --> 01:37:05,970
Если запустим то увидим

2218
01:37:05,970 --> 01:37:09,890
три разных вывода

2219
01:37:09,890 --> 01:37:11,440
Первый быдет из этой функции

2220
01:37:11,440 --> 01:37:13,050
Второй из этой,

2221
01:37:13,050 --> 01:37:15,680
а третий из этой функции

2222
01:37:15,680 --> 01:37:18,718
Теперь, когда вы уже знакомы
понятием именованных аргументов

2223
01:37:18,718 --> 01:37:22,130
и дефолтных аргументов

2224
01:37:22,130 --> 01:37:24,813
Вы уже можете заметить,
что наш когд можно

2225
01:37:24,813 --> 01:37:26,940
почистить и сделать удобнее

2226
01:37:26,940 --> 01:37:29,715
Удалим все лишнее

2227
01:37:29,715 --> 01:37:31,030
и напишем что

2228
01:37:32,016 --> 01:37:33,390
возраст у нас будет типа Int

2229
01:37:34,273 --> 01:37:36,070
и если его не укажут в месте
вызова функции то дефолтным будет 0

2230
01:37:37,093 --> 01:37:39,870
цвет будет строкой

2231
01:37:39,870 --> 01:37:43,030
и дефолтное значение будет
фиолетовым цветом

2232
01:37:43,030 --> 01:37:44,270
И теперь...

2233
01:37:44,270 --> 01:37:46,260
Стоп, цвет можно сделать пустым
по дефолту, так будет удобнее

2234
01:37:46,260 --> 01:37:47,910
добавим пустую строку по дефолту

2235
01:37:49,236 --> 01:37:51,210
и теперь нам можно

2236
01:37:51,210 --> 01:37:52,700
удалить все перегрузки

2237
01:37:52,700 --> 01:37:54,640
Потому что теперь Котлин ругается

2238
01:37:54,640 --> 01:37:57,850
что у нас конфликт и две
функции принимают одинаковые аргументы

2239
01:37:57,850 --> 01:38:00,710
Если вс удалим, то все будет

2240
01:38:00,710 --> 01:38:03,160
работать потому что у нас
есть дефолтные параметры.

2241
01:38:03,160 --> 01:38:06,030
Нужно конечно все добавить в вывод

2242
01:38:06,030 --> 01:38:10,810
чтобы у нас эта информация

2243
01:38:10,810 --> 01:38:11,643
отображалась в консоли

2244
01:38:11,643 --> 01:38:14,030
Если я не указыаю любимый цвет,
то по дефолту он будет пустым

2245
01:38:14,030 --> 01:38:16,570
если не добавляю возраст,
то он будет ноль

2246
01:38:16,570 --> 01:38:18,120
и при этом мы избавились от
перегруженных функций

2247
01:38:19,029 --> 01:38:21,309
И в подсказке у нас теперь будут
отображаться дефолтные ззначения

2248
01:38:21,309 --> 01:38:23,020
которые мы можем заполнить,
а можем проигнорировать.

2249
01:38:23,020 --> 01:38:24,740
...

2250
01:38:24,740 --> 01:38:26,440
...

2251
01:38:27,540 --> 01:38:30,400
И так вы вожете перегрузать функции
в языке Котлин.

2252
01:38:30,400 --> 01:38:34,690
In Kotlin, you can create a
class by using the class keyword

2253
01:38:34,690 --> 01:38:36,930
and give it a name such as user

2254
01:38:36,930 --> 01:38:39,420
we'll do open and close parentheses.

2255
01:38:39,420 --> 01:38:41,620
Now, if you're not familiar
with what a class is,

2256
01:38:41,620 --> 01:38:44,283
a class is a reusable templates.

2257
01:38:44,283 --> 01:38:45,880
So we could actually have
various different variables here.

2258
01:38:45,880 --> 01:38:49,180
So I say variable user equals user,

2259
01:38:49,180 --> 01:38:50,400
and then I could have another one.

2260
01:38:50,400 --> 01:38:54,910
So var friend equals user,

2261
01:38:56,032 --> 01:38:58,305
and there's another own
different instances.

2262
01:38:58,305 --> 01:39:02,730
So friend is a user and
this user object is a user.

2263
01:39:02,730 --> 01:39:06,010
They're two different
instances stored in memory.

2264
01:39:06,010 --> 01:39:10,010
Now this class, this template
per se is not doing anything,

2265
01:39:10,010 --> 01:39:12,190
it doesn't do anything for us right now.

2266
01:39:12,190 --> 01:39:14,640
So what we can do is actually define

2267
01:39:14,640 --> 01:39:15,610
a couple of fields here.

2268
01:39:15,610 --> 01:39:17,700
So we'll say a couple properties.

2269
01:39:17,700 --> 01:39:20,930
We'll say field, call this one first name

2270
01:39:20,930 --> 01:39:22,740
and this one's gonna be a
string, we'll just initialize it

2271
01:39:22,740 --> 01:39:25,550
to an empty string, var last name.

2272
01:39:26,860 --> 01:39:29,509
And we'll go ahead and
initialize this one as well

2273
01:39:29,509 --> 01:39:32,880
to empty string, and now we
have first name and last name.

2274
01:39:32,880 --> 01:39:35,606
So if on the user I
would like to set that,

2275
01:39:35,606 --> 01:39:37,750
I can say user dot and that
will allow me to access

2276
01:39:37,750 --> 01:39:39,930
the two properties last
name and first name.

2277
01:39:39,930 --> 01:39:44,370
So I'll set the first name
to Donn and user.last name

2278
01:39:44,370 --> 01:39:45,203
to Felker.

2279
01:39:47,077 --> 01:39:47,910
Now let's say we have another user.

2280
01:39:47,910 --> 01:39:49,660
Let's say it's friend, of course,

2281
01:39:50,846 --> 01:39:52,290
this one also has a first and last name.

2282
01:39:52,290 --> 01:39:54,140
We'll set the first name here to Jane

2283
01:39:55,242 --> 01:39:58,960
and the friend.last name equal to Doe.

2284
01:39:58,960 --> 01:40:00,430
So we have two different instances.

2285
01:40:00,430 --> 01:40:02,440
Just because I've set
the last name Doe here

2286
01:40:02,440 --> 01:40:03,570
does not mean it overwrites here.

2287
01:40:03,570 --> 01:40:05,750
These are two different things in memory.

2288
01:40:05,750 --> 01:40:08,802
Now class again, it's kind of a template.

2289
01:40:08,802 --> 01:40:11,100
So you can actually, it can
provide functionality as well.

2290
01:40:11,100 --> 01:40:12,870
So we can actually put functions
inside of this user class

2291
01:40:12,870 --> 01:40:16,150
that are scoped to the user class.

2292
01:40:16,150 --> 01:40:19,010
So what I might wanna
say is print full name,

2293
01:40:19,888 --> 01:40:22,060
and then we'll just be a regular function

2294
01:40:22,060 --> 01:40:25,900
and it's not gonna do anything,
but it will print line

2295
01:40:25,900 --> 01:40:28,830
to the screen and or to the output,

2296
01:40:28,830 --> 01:40:32,590
which would be the first
name and the last name.

2297
01:40:32,590 --> 01:40:35,040
We can have another one in here that says

2298
01:40:35,040 --> 01:40:39,400
print with a prefix, which
then would maybe taken a prefix

2299
01:40:39,400 --> 01:40:40,530
of some sort.

2300
01:40:40,530 --> 01:40:41,860
And we could just call that prefix

2301
01:40:41,860 --> 01:40:43,785
and that would be a string.

2302
01:40:43,785 --> 01:40:45,710
And then when we call this function,

2303
01:40:45,710 --> 01:40:47,460
we can do the same thing here.

2304
01:40:47,460 --> 01:40:50,120
We could just say prefix

2305
01:40:50,120 --> 01:40:52,170
and then you have perhaps a last name.

2306
01:40:53,020 --> 01:40:56,130
Now, the way we would use this is up here.

2307
01:40:56,130 --> 01:40:58,990
We might just call user.print full name.

2308
01:41:00,360 --> 01:41:02,520
And if we go down here and do
the same thing with friend,

2309
01:41:03,831 --> 01:41:05,540
friend.print full name,

2310
01:41:05,540 --> 01:41:08,340
we'll actually see two
different pieces of output.

2311
01:41:08,340 --> 01:41:10,457
So let's run this real quick
and what's gonna happen

2312
01:41:10,457 --> 01:41:12,120
is we'll have two things
printed to the screen.

2313
01:41:12,120 --> 01:41:15,810
One is Donn Felker and that's
called by the print full name

2314
01:41:15,810 --> 01:41:17,060
function here.

2315
01:41:17,060 --> 01:41:19,260
The next one is Jane Doe and that's called

2316
01:41:19,260 --> 01:41:21,480
from the print full name
function as well here.

2317
01:41:21,480 --> 01:41:24,340
Again, there are two different instances.

2318
01:41:24,340 --> 01:41:26,860
The contents of the objects,
which are basically instances

2319
01:41:26,860 --> 01:41:29,620
of the class are being
printed to the screen

2320
01:41:29,620 --> 01:41:30,950
with the print line function.

2321
01:41:30,950 --> 01:41:33,800
Now we do have the prefix, so
we'll get to that in a second,

2322
01:41:33,800 --> 01:41:36,090
but let's also do
something different here.

2323
01:41:36,090 --> 01:41:40,940
So let's say we have a
function called update name

2324
01:41:40,940 --> 01:41:45,120
and this update name takes in
a new name and it's a string.

2325
01:41:45,120 --> 01:41:47,470
And what this is going
to do is actually update

2326
01:41:47,470 --> 01:41:48,720
their first name.

2327
01:41:48,720 --> 01:41:52,710
And so we'll say first name
and we're set to new name.

2328
01:41:52,710 --> 01:41:55,210
And then what we'll have here
is a way to update their name.

2329
01:41:55,210 --> 01:41:57,030
So let's come back up here and say,

2330
01:41:57,030 --> 01:41:59,550
you know what, maybe I messed
up when I update their name

2331
01:41:59,550 --> 01:42:02,300
and this is hypothetical and
what I call this one, Bob.

2332
01:42:03,569 --> 01:42:06,790
And then at the same time, I'd
like to user.print full name.

2333
01:42:06,790 --> 01:42:07,730
And so if we run this again,

2334
01:42:07,730 --> 01:42:11,400
what we'll see here is that the
first object is Donn Felker,

2335
01:42:11,400 --> 01:42:15,170
then we update the called
the update name function,

2336
01:42:15,170 --> 01:42:18,280
which goes down here, sets
the name to the new name.

2337
01:42:19,220 --> 01:42:22,080
And then we call print full
name again that says Bob Belker.

2338
01:42:22,080 --> 01:42:24,350
And then we go into the next user

2339
01:42:24,350 --> 01:42:27,310
and this following the line,
sequentially procedurally,

2340
01:42:28,350 --> 01:42:30,450
we see Jane Doe here.

2341
01:42:30,450 --> 01:42:34,510
Now the same thing we can do
say user.print with prefix.

2342
01:42:34,510 --> 01:42:36,520
And maybe I'll say Mr.

2343
01:42:36,520 --> 01:42:38,200
And then in this one, I might actually say

2344
01:42:38,200 --> 01:42:41,850
friend.print with prefix,
and this one might be Ms.

2345
01:42:42,990 --> 01:42:45,510
And if we were to run this
now, what we're going to see

2346
01:42:45,510 --> 01:42:47,200
is of course, Donn Felker, Bob Felker,

2347
01:42:47,200 --> 01:42:51,270
and it will say Mr. Felker,
and then we'll see Jane Doe

2348
01:42:51,270 --> 01:42:54,990
in Ms. Doe here, because
we're actually just printing

2349
01:42:54,990 --> 01:42:55,860
with the values in here.

2350
01:42:55,860 --> 01:43:00,280
So now this class is basically
a template that we can use

2351
01:43:00,280 --> 01:43:01,150
inside of our application.

2352
01:43:01,150 --> 01:43:04,330
Now everything is stored
inside the same file here.

2353
01:43:04,330 --> 01:43:06,490
Now, what you can do is
you don't have to have this

2354
01:43:06,490 --> 01:43:07,560
in the same file at all.

2355
01:43:07,560 --> 01:43:09,480
So what we can do is I'm
gonna open up the project,

2356
01:43:09,480 --> 01:43:12,210
went over here and you see
we just have our main file.

2357
01:43:12,210 --> 01:43:14,900
What we can actually do
is create a file manually,

2358
01:43:16,280 --> 01:43:20,090
like say new Kotlin
and I can say, user.kt.

2359
01:43:22,498 --> 01:43:23,540
And then what I can do
is I can go over here

2360
01:43:23,540 --> 01:43:27,940
and I can cut and paste
this code into user.kt.

2361
01:43:30,154 --> 01:43:31,570
If we go back to the
main, you're gonna see

2362
01:43:31,570 --> 01:43:32,750
that everything still works

2363
01:43:32,750 --> 01:43:34,890
because we're in the same package.

2364
01:43:34,890 --> 01:43:38,210
So it knows that it's going
to look in the same package

2365
01:43:38,210 --> 01:43:39,480
and it found the user class.

2366
01:43:39,480 --> 01:43:42,270
Now this allows us to start
cleaning up the code a lot

2367
01:43:42,270 --> 01:43:46,040
because basically have a template
called the user class here

2368
01:43:46,040 --> 01:43:47,480
in a different file to do that for me.

2369
01:43:47,480 --> 01:43:50,010
Now, what I'm gonna do,
actually, I'm gonna undo this.

2370
01:43:50,010 --> 01:43:54,290
I'm gonna go back to main here,
I'm gonna undo this as well

2371
01:43:54,290 --> 01:43:58,150
and come here and get
rid of that Kotlin class.

2372
01:43:58,150 --> 01:43:59,820
So we're gonna go back
to how we were before.

2373
01:43:59,820 --> 01:44:02,660
There's actually a
shortcut that you can use.

2374
01:44:02,660 --> 01:44:06,079
When you put your cursor over
class, the class name here,

2375
01:44:06,079 --> 01:44:07,180
you'll see this little bulb.

2376
01:44:07,180 --> 01:44:09,600
You can click on it and
you can say, create test,

2377
01:44:09,600 --> 01:44:12,850
rename the file or you say
move user to a separate file.

2378
01:44:12,850 --> 01:44:14,300
Say, yeah, I'd like to do that.

2379
01:44:15,617 --> 01:44:17,260
So right out of the box,
by default, we were given

2380
01:44:17,260 --> 01:44:20,507
this nice little thing that
allows us to create a file.

2381
01:44:20,507 --> 01:44:22,400
And what that did is it
created the file force

2382
01:44:22,400 --> 01:44:24,570
and moved all the contents
of that user class

2383
01:44:24,570 --> 01:44:25,470
over there for us.

2384
01:44:27,280 --> 01:44:28,113
So let's go a little bit further here

2385
01:44:28,113 --> 01:44:29,710
and make one more method.

2386
01:44:29,710 --> 01:44:33,070
And this method might print
the length of the first names.

2387
01:44:33,070 --> 01:44:36,470
We say, function, first name length.

2388
01:44:38,140 --> 01:44:40,637
And what we'll do is we're
gonna print something

2389
01:44:40,637 --> 01:44:42,610
to the screen and then
what we're gonna do here

2390
01:44:42,610 --> 01:44:46,780
is just take the first name
as the first name.length.

2391
01:44:50,428 --> 01:44:51,330
And that's gonna print the
length of the first name.

2392
01:44:51,330 --> 01:44:54,522
So if we, again, this is
kind of like a template.

2393
01:44:54,522 --> 01:44:55,355
It's a class.

2394
01:44:55,355 --> 01:44:57,010
Go back to main Katie and
let's print the length

2395
01:44:57,010 --> 01:44:59,605
of the friend's first name.

2396
01:44:59,605 --> 01:45:04,605
Friend.print, excuse me,
length, first name length.

2397
01:45:04,990 --> 01:45:06,483
There we go.

2398
01:45:06,483 --> 01:45:09,890
And if we run this now,
Kotlin will find a user class

2399
01:45:09,890 --> 01:45:13,320
included here for so we're
running what that user class,

2400
01:45:13,320 --> 01:45:16,017
run the existing code,
which we've seen already,

2401
01:45:16,017 --> 01:45:17,140
Mr. Felker, Bob Felker, et cetera.

2402
01:45:18,292 --> 01:45:19,890
And then we're gonna call the
friend up first name length,

2403
01:45:19,890 --> 01:45:23,170
and it's going to return four
because that's the number

2404
01:45:23,170 --> 01:45:26,145
of characters in the
first name, which is Jane.

2405
01:45:26,145 --> 01:45:27,170
So this is a very simple class,

2406
01:45:27,170 --> 01:45:30,300
but this is how you can
create a class here in Kotlin.

2407
01:45:31,340 --> 01:45:33,440
Допустим у нас есть класс который
называется User

2408
01:45:33,440 --> 01:45:35,910
с именем, фамилией и парочкой

2409
01:45:35,910 --> 01:45:36,840
функций внутри.

2410
01:45:36,840 --> 01:45:38,360
Если я хочу создать конструктор,

2411
01:45:38,360 --> 01:45:42,190
я могу использовать
ключевое слово constructor

2412
01:45:42,190 --> 01:45:44,350
И передать эти параметры пользователя

2413
01:45:44,350 --> 01:45:45,590
через конструктор.

2414
01:45:45,590 --> 01:45:48,860
Теперь я могу убрать эти поля

2415
01:45:48,860 --> 01:45:53,860
и перенести их в конструктор.
Имя с типом String

2416
01:45:54,410 --> 01:45:55,260
и фамилию с типом String.

2417
01:45:57,164 --> 01:45:59,350
Часто вы будете делать их
неизменяемыми, поэтому сменим все на "val"

2418
01:45:59,350 --> 01:46:01,570
это позволит вам запретить их
изменение и избежать ошибок

2419
01:46:01,570 --> 01:46:03,710
в будующем, чтобы никто не мог
сменить имя вашего пользователя.

2420
01:46:03,710 --> 01:46:05,350
После того как мы это сделаем,

2421
01:46:05,350 --> 01:46:08,175
мы заметим ошибку вот тут.

2422
01:46:08,175 --> 01:46:10,372
У нас есть метод updateName

2423
01:46:10,372 --> 01:46:11,870
который должен присваивать новое имя

2424
01:46:11,870 --> 01:46:13,986
Но из-за того что имя у нас неизменяемая
переменная, мы не можем этого сделать

2425
01:46:13,986 --> 01:46:15,209
Вернем var, чтобы все работало

2426
01:46:15,209 --> 01:46:16,990
и наши поля были изменяемыми

2427
01:46:16,990 --> 01:46:18,480
и наши поля были изменяемыми

2428
01:46:18,480 --> 01:46:21,720
Теперь у нас есть конструктор для
нашего класса

2429
01:46:21,720 --> 01:46:23,140
он принимает имя и фамилию

2430
01:46:23,140 --> 01:46:25,920
И если мы вернемся в наш main
файл мы сможем его использовать.

2431
01:46:25,920 --> 01:46:27,980
Тут вы сразу заметите нессколько вещей

2432
01:46:27,980 --> 01:46:31,370
Первое различие будет в классе User

2433
01:46:31,370 --> 01:46:33,630
Теперь, когда мы печатаем тип и

2434
01:46:33,630 --> 01:46:35,740
скобочки

2435
01:46:35,740 --> 01:46:39,630
мы должны указать имя
и фамилию прямо в них

2436
01:46:39,630 --> 01:46:42,900
Я запишу "Donn" и "Felker".

2437
01:46:45,133 --> 01:46:45,966
Теперь я хочу немного поменять наш
старый код

2438
01:46:45,966 --> 01:46:47,880
На строчках 6 и 7

2439
01:46:47,880 --> 01:46:50,730
я изменю строки

2440
01:46:50,730 --> 01:46:55,450
пусть это будет Jason Smith

2441
01:46:55,450 --> 01:46:58,320
Я могу менять имя и фамилию пользователя
после его создания

2442
01:46:58,320 --> 01:46:59,460
но сейчас я просто удалю эти строчки

2443
01:46:59,460 --> 01:47:01,000
потому что болье они нам не нужны.

2444
01:47:01,000 --> 01:47:06,000
И тут я впишу имя и фамилию
прямо в конструктов

2445
01:47:08,816 --> 01:47:09,660
и уберу явное присвоения полям
имени и фамилии.

2446
01:47:09,660 --> 01:47:11,420
И если я запущу этот код

2447
01:47:11,420 --> 01:47:14,586
то результат будет точно такой же

2448
01:47:14,586 --> 01:47:19,586
но тут мы использовали
конструктор для создания пользователя

2449
01:47:21,090 --> 01:47:21,923
и поля у нас теперь в конструкторе.

2450
01:47:21,923 --> 01:47:24,030
И эти поля в конструкторе
вы все так же можете использовать

2451
01:47:24,939 --> 01:47:26,870
во все вашем классе.

2452
01:47:26,870 --> 01:47:28,370
Как, например, вот тут.

2453
01:47:29,995 --> 01:47:31,730
Вы наверное уже догадались,

2454
01:47:31,730 --> 01:47:34,859
что вы можете навести курсор сюда

2455
01:47:34,859 --> 01:47:35,692
и сделать конструктор с именнованными
параметрами

2456
01:47:35,692 --> 01:47:37,740
Чтобы явно видеть, что это у нас имя,

2457
01:47:37,740 --> 01:47:39,820
а это фамилия.

2458
01:47:39,820 --> 01:47:41,410
И так будет легче

2459
01:47:41,410 --> 01:47:43,080
читать ваш код.

2460
01:47:43,080 --> 01:47:46,700
К тому же, если в конструкторе

2461
01:47:46,700 --> 01:47:49,280
класса нет никаких
модификаторов доступа,

2462
01:47:50,393 --> 01:47:53,093
как например ключевое слово internal,
о котором мы поговорим позже.

2463
01:47:54,140 --> 01:47:55,900
Так вот, если у вас нет никаких ключевых

2464
01:47:55,900 --> 01:47:59,980
слов перед конструктором,

2465
01:47:59,980 --> 01:48:02,535
то вы можете не писать слово
"constructor"

2466
01:48:02,535 --> 01:48:03,368
и это будет нашим основным конструктором.

2467
01:48:03,368 --> 01:48:05,630
И наш код теперь стал почище

2468
01:48:05,630 --> 01:48:06,500
У нас есть класс User

2469
01:48:06,500 --> 01:48:08,830
который принимает имя и
фамилию в конструкторе

2470
01:48:09,890 --> 01:48:12,340
И мы можем обращаться

2471
01:48:12,340 --> 01:48:13,680
к полям.

2472
01:48:13,680 --> 01:48:16,590
Нам не нужно писать ключевое слово
construcor

2473
01:48:16,590 --> 01:48:17,950
вы все равно можете писать
его, если хотите)

2474
01:48:17,950 --> 01:48:20,890
но обычно его не пишут, потому

2475
01:48:20,890 --> 01:48:24,170
что эффект тот же самый,
а кода меньше.

2476
01:48:24,170 --> 01:48:26,540
Теперь, если вы зохотите поставить

2477
01:48:26,540 --> 01:48:29,720
какое-то ключевое слово, напрмер internal
и убрать constructor

2478
01:48:29,720 --> 01:48:32,389
то у васс не получится

2479
01:48:32,389 --> 01:48:34,030
и котлин покажет вам ошибку.

2480
01:48:34,030 --> 01:48:36,120
вам нужно использовать, "constructor",
если перед ним

2481
01:48:36,120 --> 01:48:37,250
есть ключевые слова.

2482
01:48:37,250 --> 01:48:39,460
Если мы закрываем доступ к конструктору

2483
01:48:39,460 --> 01:48:43,610
то мы явно должны писать ключевое слово
"construcor"

2484
01:48:43,610 --> 01:48:45,255
Но тут мы не будем этого делать.

2485
01:48:45,255 --> 01:48:47,500
Это стандартный класс
с реализацией основного конструктора.

2486
01:48:47,500 --> 01:48:48,940
Еще одна вещь, которую вы можете сделать

2487
01:48:48,940 --> 01:48:51,280
вместо конструктора мы можете выставить
дефолтные значения

2488
01:48:51,280 --> 01:48:54,610
То есть эту строку мы можем сделать пустой

2489
01:48:54,610 --> 01:48:56,370
И, допустим, мы знаем, что мы
создаем пользователей для

2490
01:48:56,370 --> 01:48:58,130
семейства с фамилией "Smith"

2491
01:48:58,130 --> 01:48:59,920
мы выставид дефолтное Smith на фамилии.

2492
01:48:59,920 --> 01:49:02,790
Вернемся в main

2493
01:49:02,790 --> 01:49:04,410
и теперь можем не писать фамилию.

2494
01:49:04,410 --> 01:49:06,320
И если я не хочу дефолтное
значение тут, а хочу чтобы

2495
01:49:06,320 --> 01:49:07,310
фамилия была "Doe",
я могу явно ее написать.

2496
01:49:07,310 --> 01:49:10,760
И теперь наш вывод сменится
и будут выводится дефолтные

2497
01:49:10,760 --> 01:49:12,810
значения так, где мы
не передали свои

2498
01:49:12,810 --> 01:49:15,180
получился Donn Smith

2499
01:49:15,180 --> 01:49:18,020
и Jane Doe.

2500
01:49:18,020 --> 01:49:20,500
У классов может быть несколько конструкторов.

2501
01:49:20,500 --> 01:49:22,900
Основной будет навершу после названия класса.

2502
01:49:22,900 --> 01:49:24,650
Второстепенные мы можем создать сами.

2503
01:49:24,650 --> 01:49:25,950
Чтобы создать второстепенный конструктор

2504
01:49:25,950 --> 01:49:27,980
мы будем использовать ключевое
слово constructor

2505
01:49:27,980 --> 01:49:30,752
и в него передадим наши
дополнительные аргументы

2506
01:49:30,752 --> 01:49:31,585
Но давайте сначала опишем ситуацию.

2507
01:49:31,585 --> 01:49:35,240
Допустим пользователь
у нас обладает особым свойством

2508
01:49:35,240 --> 01:49:39,860
добавим поле isPlatinum

2509
01:49:39,860 --> 01:49:41,620
оно используется для каких-то

2510
01:49:41,620 --> 01:49:44,960
финансовых кейсов в нашей
программе.

2511
01:49:44,960 --> 01:49:48,120
И теперь создадим второстепенный
конструктор.

2512
01:49:48,120 --> 01:49:49,830
Иногда мы хотим добавлять только

2513
01:49:49,830 --> 01:49:53,060
имя и фамилию

2514
01:49:53,060 --> 01:49:54,740
и нам уже известно, что такие
пользователи не будут платиновыми.

2515
01:49:54,740 --> 01:49:58,900
И теперь нам нужно использовать
ключевое слово "this"

2516
01:49:58,900 --> 01:50:02,930
и передать ему все параметры
основного конструктора.

2517
01:50:02,930 --> 01:50:03,770
это неявный вызов основного конструктора
из второстепенного, чтобы

2518
01:50:03,770 --> 01:50:06,200
проинициализировать
все поля класса.

2519
01:50:06,200 --> 01:50:08,926
Мы передадим имя,
фамилию

2520
01:50:08,926 --> 01:50:11,199
и значение isPlatinum, которое

2521
01:50:11,199 --> 01:50:12,920
будет равно false при

2522
01:50:12,920 --> 01:50:14,640
вызове второстепенного конструктора.

2523
01:50:14,640 --> 01:50:16,590
И теперь у нас нет

2524
01:50:16,590 --> 01:50:17,423
никаких подсвечнных ошибок в коде.

2525
01:50:17,423 --> 01:50:20,310
Это значит, что теперь второстепенный
конструктор можно использовать

2526
01:50:20,310 --> 01:50:23,390
Не обязательно у второстепенного
конструктора явно писать тело функции

2527
01:50:23,390 --> 01:50:25,360
Но если мне что-то еще нужно
сделать при вызове конструктора,

2528
01:50:25,360 --> 01:50:26,590
я могу это сделать здесь.

2529
01:50:26,590 --> 01:50:30,120
Например вывести в консоль, что

2530
01:50:32,270 --> 01:50:33,870
пользователь не платиновый по дефолту.

2531
01:50:34,951 --> 01:50:36,890
И если теперь я создаю пользователя
с помощью этого конструктора

2532
01:50:36,890 --> 01:50:38,040
эта строчка кода выполнится при создании.

2533
01:50:38,040 --> 01:50:39,998
Вернемся к нашему примеру

2534
01:50:39,998 --> 01:50:42,560
и поменяем логику.

2535
01:50:42,560 --> 01:50:45,960
По дефолту оба этих создания
пользователя будут вызывать

2536
01:50:45,960 --> 01:50:48,210
второстепенный конструктор.

2537
01:50:48,210 --> 01:50:50,130
И тут нужно поправить
и добавить фамилию пользователю

2538
01:50:50,130 --> 01:50:51,780
Напишем фамилию,

2539
01:50:53,193 --> 01:50:54,660
пусть будет моей - Felker.

2540
01:50:54,660 --> 01:50:57,160
и допишем значение isPlatinum,
пусть будет истиной.

2541
01:50:57,160 --> 01:50:59,290
Теперь я платиновый пользователь
а пользователь ниже

2542
01:50:59,290 --> 01:51:00,160
не платиновый.

2543
01:51:00,160 --> 01:51:04,300
Если запустим, то увидим
строчку вывода, которая написана

2544
01:51:04,300 --> 01:51:09,300
в теле второстепенного конструктора

2545
01:51:09,590 --> 01:51:11,250
Если мы залезем в

2546
01:51:12,314 --> 01:51:13,147
реализацию этого конструктора

2547
01:51:13,147 --> 01:51:14,890
то мы попадем в второстепенный конструктор.

2548
01:51:14,890 --> 01:51:17,451
Можем пойти еще дальше

2549
01:51:17,451 --> 01:51:18,284
и сделать еще один
второстепенный конструктор

2550
01:51:18,284 --> 01:51:20,180
Все второстепенные конструкторы
будут внутри класса.

2551
01:51:20,180 --> 01:51:21,480
И я могу внести в него имя

2552
01:51:22,845 --> 01:51:23,678
и потом сразу обратиться к какому-нибудь

2553
01:51:23,678 --> 01:51:25,941
другому конструктору и передать

2554
01:51:25,941 --> 01:51:26,774
ему имя,

2555
01:51:26,774 --> 01:51:29,430
А фамилию, мы, например,

2556
01:51:29,430 --> 01:51:31,920
не знаем и напишем "unknown".

2557
01:51:31,920 --> 01:51:36,160
Платиновость пользователя тоже не
будем указывать.

2558
01:51:36,160 --> 01:51:39,068
Просто для примера мы опять напишем
тело конструктора и выведем

2559
01:51:39,068 --> 01:51:41,450
скрочку, чтобы понять, что
он вызвался.

2560
01:51:42,460 --> 01:51:46,244
И вернумся в метсо создания пользователя

2561
01:51:46,244 --> 01:51:49,220
и создадим еще одного
например какого-то кузена,

2562
01:51:49,220 --> 01:51:53,060
И вызовем наш конструктор
и назовоме пользователя Ник.

2563
01:51:55,840 --> 01:51:58,060
И больше мы ничего не будем писать

2564
01:51:58,060 --> 01:52:00,140
давайте перейдем к реализации конструктора

2565
01:52:00,140 --> 01:52:02,140
Мы попадем в третий конструктор
(второй второстепенный)

2566
01:52:02,140 --> 01:52:04,830
который выпонится и выведет
строчку текста,

2567
01:52:04,830 --> 01:52:07,880
но сомтрите что случится дальше.

2568
01:52:07,880 --> 01:52:11,730
дальше, конструктор через "this"
вызовет другой конструктор

2569
01:52:11,730 --> 01:52:13,740
И передаст ему имя

2570
01:52:13,740 --> 01:52:15,130
и строчку Unknown.
А что еще у нас принимает такие аргументы?

2571
01:52:15,130 --> 01:52:18,150
Правильно, другой наш конмтруктор,
и в него передастся

2572
01:52:18,150 --> 01:52:20,960
имя и фамилия

2573
01:52:20,960 --> 01:52:23,480
через ключевое слово "this"
мы вызваем другой конструктор

2574
01:52:24,790 --> 01:52:27,540
который примет имя и фамилию

2575
01:52:27,540 --> 01:52:30,080
И выведет свою строку текста в консоль

2576
01:52:30,080 --> 01:52:31,340
Давайте посмотрим на это все в действии

2577
01:52:31,340 --> 01:52:34,120
Збыл сказать, что конечно в итоге
все значения

2578
01:52:34,120 --> 01:52:35,670
передаются в основной конструктор

2579
01:52:37,402 --> 01:52:38,534
и все поля заполняются данными.

2580
01:52:38,534 --> 01:52:39,840
Если запустим вы заметите,

2581
01:52:39,840 --> 01:52:42,290
что произойдет кое что интересное

2582
01:52:43,320 --> 01:52:45,336
Очень много всего вывелось в консоль

2583
01:52:45,336 --> 01:52:46,169
Давайте посмотрим по подробнее

2584
01:52:46,169 --> 01:52:47,925
Для начала давайте уберем

2585
01:52:47,925 --> 01:52:48,758
все что мешает.

2586
01:52:48,758 --> 01:52:51,070
Оставим только вещи, которые
выводятся при вызове конструкторов.

2587
01:52:51,070 --> 01:52:54,500
Нас интересуют только эти

2588
01:52:54,500 --> 01:52:59,060
строчки и ничего больше.

2589
01:52:59,060 --> 01:53:01,990
Запустили и видим, появилось сообщение
от кунструктора с двумя значениями,

2590
01:53:01,990 --> 01:53:03,230
где платиновость будет false
по дефолту

2591
01:53:03,230 --> 01:53:04,350
И потом снова видим эту строчку,

2592
01:53:04,350 --> 01:53:06,280
а потом видим строчку из третьего
конструктора.

2593
01:53:06,280 --> 01:53:08,490
Если зайдем в первое создание пользователя

2594
01:53:08,490 --> 01:53:10,800
то увидим, что оно вызвает
основной конструктор.

2595
01:53:10,800 --> 01:53:12,680
Тут ничего не происходит,
мы просто создаем объект

2596
01:53:12,680 --> 01:53:14,040
и на этом все заканчивается.

2597
01:53:14,040 --> 01:53:17,710
Второе создание использует
первый второстепенный конструктор

2598
01:53:17,710 --> 01:53:19,150
Второе создание использует
первый второстепенный конструктор

2599
01:53:19,150 --> 01:53:21,400
который выводит строчку

2600
01:53:22,243 --> 01:53:24,440
и выставляет платиновось в false.

2601
01:53:24,440 --> 01:53:27,091
Третее создание пользователя
использует третий конструктор

2602
01:53:27,091 --> 01:53:28,650
Выставляет имя Nick

2603
01:53:28,650 --> 01:53:31,660
и по цепочке вызывает остальные конструкторы

2604
01:53:31,660 --> 01:53:34,440
Тут передается имя Ник и фамилия uniknown

2605
01:53:34,440 --> 01:53:36,680
и этот конструктор вызывает

2606
01:53:36,680 --> 01:53:38,120
основной конструктор.

2607
01:53:38,120 --> 01:53:41,870
В итоге - сначала вызывается
этот конструктор

2608
01:53:41,870 --> 01:53:43,720
потом этот

2609
01:53:43,720 --> 01:53:46,900
а он уже вызовет основной конструктор.

2610
01:53:46,900 --> 01:53:51,170
После того как основной конструктор

2611
01:53:51,170 --> 01:53:54,130
ыполнился и пользователь создан

2612
01:53:54,130 --> 01:53:56,580
мы вызываем строку с выводом
из второстепенного конструктора

2613
01:53:56,580 --> 01:53:59,950
И после того как строка вывелась

2614
01:53:59,950 --> 01:54:03,780
мы вызываем следующий блок вывода.

2615
01:54:03,780 --> 01:54:07,520
Тут нужно запомнить цепь вызовов
сначала зовется этот конструктор

2616
01:54:07,520 --> 01:54:11,240
потом через this зовется
второй, а потом основной конструктор

2617
01:54:11,240 --> 01:54:14,070
в основном конструкторе ничего не происходит
и он просто выполняется

2618
01:54:14,070 --> 01:54:17,040
потом, задо наперед, выполняется тело
предыдущего конструктора

2619
01:54:17,920 --> 01:54:19,170
это вот этот вызов

2620
01:54:19,170 --> 01:54:20,420
Потом это выполнилось

2621
01:54:20,420 --> 01:54:23,060
и мы можем вернуться в самый первый
конструктор и вызвать его тело

2622
01:54:23,060 --> 01:54:23,893
И именно в ткой последовательности
выполняется цепочка

2623
01:54:23,893 --> 01:54:26,190
Давайте еще немного упростим

2624
01:54:26,190 --> 01:54:31,190
явно в тексте пометим что это третий,
чтобы это было очевидно

2625
01:54:31,340 --> 01:54:32,910
а этот второй.

2626
01:54:34,047 --> 01:54:35,950
Я вернусь в место вызова и удалю второго
пользователя

2627
01:54:35,950 --> 01:54:37,400
чтобы логи были чище.

2628
01:54:37,400 --> 01:54:40,575
И теперь мы в консоли явно увидим

2629
01:54:40,575 --> 01:54:41,980
последовательность вызова ТЕЛА
конструктора

2630
01:54:41,980 --> 01:54:43,750
Первое что вывелось -
текст из второго конструктора

2631
01:54:43,750 --> 01:54:45,230
потому что по нашей цепочки
в обратном направлении мы сначала попадаем

2632
01:54:45,230 --> 01:54:47,790
в его тело

2633
01:54:47,790 --> 01:54:48,850
а потом выводится тело третьего

2634
01:54:48,850 --> 01:54:50,110
И мы можем немного эту цепочку поменять

2635
01:54:50,110 --> 01:54:53,155
и при выызове третьего конструктора
укажем значение isPlatinum

2636
01:54:53,155 --> 01:54:55,220
пусть будет false.

2637
01:54:55,220 --> 01:54:57,434
хотя можем написать true, но
поставим false, это ни на что не влияет

2638
01:54:57,434 --> 01:54:59,460
поэтому не так важно что мы передаем

2639
01:54:59,460 --> 01:55:00,750
нет, давайте поставим true.

2640
01:55:00,750 --> 01:55:03,070
Если мы вызовем третий конструктор
и передадим имя фамилию

2641
01:55:03,070 --> 01:55:05,590
и платиновый статус, то мы сразу
пойдем в основной конструктор.

2642
01:55:05,590 --> 01:55:08,470
И, если запустим, в консоли
увидим только

2643
01:55:08,470 --> 01:55:10,640
вывод третьего конструктора

2644
01:55:10,640 --> 01:55:13,370
потому что теперь нам

2645
01:55:13,370 --> 01:55:16,270
нет нужны идти во второй конструктор

2646
01:55:16,270 --> 01:55:18,939
потому что мы предоставили достаточно

2647
01:55:18,939 --> 01:55:20,070
данных, чтобы вызвать
основной конструктор.

2648
01:55:20,070 --> 01:55:21,780
И тут слово this будет ссылаться
на основной конструктор

2649
01:55:21,780 --> 01:55:24,120
потому что тут три аргумента.

2650
01:55:24,120 --> 01:55:27,040
Если мы уберем последний аргумент

2651
01:55:27,040 --> 01:55:28,990
то вызовется второй конструктор.

2652
01:55:28,990 --> 01:55:32,270
Если представить, что его не существует

2653
01:55:32,270 --> 01:55:33,370
программа не скомпилируется.

2654
01:55:33,370 --> 01:55:35,320
Все потому что у нас теперь нет

2655
01:55:35,320 --> 01:55:37,100
конструктора, который бы подходил
по сигнатуре вызова

2656
01:55:37,100 --> 01:55:40,610
а именно два строковых аргумента.

2657
01:55:40,610 --> 01:55:43,390
У нас есть конструктор с
двумя строковыми аргументами и Boolean.

2658
01:55:43,390 --> 01:55:47,786
Поэтому нас нужны разные
версии конструкторов.

2659
01:55:47,786 --> 01:55:50,230
И если мы вернем конструктор
и снова запустим

2660
01:55:50,230 --> 01:55:52,540
мы опять увидим вызов второго
и третьего конструктора

2661
01:55:53,950 --> 01:55:56,720
У вас может быть какое угодно
кол-во конструкторов

2662
01:55:56,720 --> 01:55:57,553
внутри класса.

2663
01:55:57,553 --> 01:56:01,280
И вы можете продолжать создавать
разные их версии

2664
01:56:01,280 --> 01:56:03,820
добавлять платиновый статус и тому
подобное.

2665
01:56:03,820 --> 01:56:06,210
Но, конечно, это

2666
01:56:06,210 --> 01:56:07,043
не обязательно.

2667
01:56:07,043 --> 01:56:08,980
Мы например можем вообще удалить

2668
01:56:08,980 --> 01:56:11,270
все наши второстепенные конструкторы
и использовать дефолтные параметры.

2669
01:56:11,270 --> 01:56:12,810
Если фамилия не известна

2670
01:56:12,810 --> 01:56:15,730
по дефолту будет "Unknown"

2671
01:56:15,730 --> 01:56:19,440
и платиновость будет false.

2672
01:56:20,376 --> 01:56:21,209
И если вернемся в код

2673
01:56:21,209 --> 01:56:22,980
то увидим что все работает.

2674
01:56:22,980 --> 01:56:25,660
Оба создания пользователей
будут работать

2675
01:56:25,660 --> 01:56:27,570
потому что есть дефолтные значения

2676
01:56:28,450 --> 01:56:31,819
при создании объекта.

2677
01:56:31,819 --> 01:56:34,460
и именованные аргументы
помогаю нам это проще читать.

2678
01:56:34,460 --> 01:56:37,150
Каждый объект создастся

2679
01:56:37,150 --> 01:56:39,130
с полным набором параметров.

2680
01:56:39,985 --> 01:56:42,180
И весь код у нас будет в одну строчку

2681
01:56:42,180 --> 01:56:43,920
и с одним конструктором.

2682
01:56:43,920 --> 01:56:45,900
Но если по какой-то причине вам понадобятся

2683
01:56:45,900 --> 01:56:47,360
дополнительные конструкторы,
или вам нужно сделать еще какие-то

2684
01:56:47,360 --> 01:56:49,450
дополнительные манипуляции

2685
01:56:49,450 --> 01:56:51,710
вы можете использовать тело конструктора
и делать в них все что захотите.

2686
01:56:51,710 --> 01:56:54,240
можете считать дополнительные вещи
или вызывать функции

2687
01:56:54,240 --> 01:56:56,650
можете считать дополнительные вещи
или вызывать функции

2688
01:56:56,650 --> 01:56:57,820
просто создавайте конструктор
через ключевое слово

2689
01:56:57,820 --> 01:56:59,810
и делайте все что

2690
01:56:59,810 --> 01:57:01,290
вам необходимо.

2691
01:57:01,290 --> 01:57:03,870
Еще одна вещь - доступ к конструкторам

2692
01:57:03,870 --> 01:57:08,070
можно закрывать ключевыми словами

2693
01:57:08,070 --> 01:57:13,040
protected, internal, private и так далее.

2694
01:57:13,040 --> 01:57:14,670
Так вы сможете сузить круг лиц,
которые смогус создавать ваш

2695
01:57:14,670 --> 01:57:17,560
объект в зависимости от модификатора,
который вы укажете.

2696
01:57:19,940 --> 01:57:22,400
У нас есть класс Юзера
и внутри класса пользователя вы

2697
01:57:22,400 --> 01:57:26,388
можете объявить так называемый
блок инициализации.

2698
01:57:26,388 --> 01:57:28,517
Блоки инициализации создаются
с помощью ключевого слова "init"

2699
01:57:28,517 --> 01:57:31,090
и двух фигурных скобок.

2700
01:57:31,090 --> 01:57:34,690
И в этом месте вы можете
выполнять подготовительные

2701
01:57:34,690 --> 01:57:38,160
действия перед тем как ваш
класс начнут использовать.

2702
01:57:38,160 --> 01:57:41,570
блики инициализации вызываются после

2703
01:57:41,570 --> 01:57:42,403
выполнения основного конструктора.

2704
01:57:42,403 --> 01:57:45,250
Итак, шаг назад -
это наш основной конструктор.

2705
01:57:45,250 --> 01:57:47,260
Когда он вызовется и сделает
все свои дела,

2706
01:57:47,260 --> 01:57:49,460
вызовется блик инициализации.

2707
01:57:49,460 --> 01:57:51,870
Интересная вещь -

2708
01:57:51,870 --> 01:57:55,340
мы можем вернуться в наш основной файл

2709
01:57:56,274 --> 01:57:58,310
и создадим нового юзера.

2710
01:57:58,310 --> 01:58:01,460
В качестве имени и фамилии

2711
01:58:01,460 --> 01:58:02,930
укажем "Donn Felker"
и запустим

2712
01:58:02,930 --> 01:58:04,690
Мы ничего не выводим дополнительно

2713
01:58:04,690 --> 01:58:07,870
но вы можете заметить, что текст из
нашего блока инициализации

2714
01:58:07,870 --> 01:58:09,400
вывелся на экран.

2715
01:58:09,400 --> 01:58:11,910
Теперь после инициализации
объекта срабатывает

2716
01:58:11,910 --> 01:58:15,060
блок инициализации
и выводится текст.

2717
01:58:16,190 --> 01:58:17,990
Еще одна интересная штука, которую

2718
01:58:17,990 --> 01:58:19,150
можно сделать с блоком
инициализации -

2719
01:58:19,150 --> 01:58:21,805
их может быть несколько

2720
01:58:21,805 --> 01:58:25,400
и блоки инициализации
будут запускаться

2721
01:58:25,400 --> 01:58:28,150
в том порядке в каком они описаны
в классе - сверху вниз.

2722
01:58:28,150 --> 01:58:31,040
В начале у нас выполнится
основной конструктор

2723
01:58:31,040 --> 01:58:33,880
потом блок инициализации с
первым текстом,

2724
01:58:33,880 --> 01:58:37,070
а потом со вторым.

2725
01:58:37,070 --> 01:58:39,720
Если перезапустим

2726
01:58:39,720 --> 01:58:41,230
то вместо одного текста

2727
01:58:41,230 --> 01:58:44,320
увидим "Hello 1" и "Hello 2"

2728
01:58:45,290 --> 01:58:48,120
Зайдем в класс пользователя

2729
01:58:48,120 --> 01:58:53,120
и поменяем init блоки местами

2730
01:58:53,370 --> 01:58:55,840
теперь текст с "Hello 2"
будет появляться

2731
01:58:55,840 --> 01:58:57,010
равньше "Hello 1".

2732
01:58:58,070 --> 01:59:00,530
Еще один способ проверить
что блоки инициализации

2733
01:59:00,530 --> 01:59:04,170
запускаются после конструктора

2734
01:59:04,170 --> 01:59:06,370
запускаются после конструктора -

2735
01:59:06,370 --> 01:59:08,530
давайте создадим еще один конструктор

2736
01:59:08,530 --> 01:59:11,620
в который, например, передается
только имя

2737
01:59:11,620 --> 01:59:15,840
и фамилию мы передадим

2738
01:59:15,840 --> 01:59:16,740
какую-нибудь дефолтную.

2739
01:59:16,740 --> 01:59:19,710
Вызовем this и передадим имя

2740
01:59:19,710 --> 01:59:22,490
а фамилия будет по дефолту "Felker"

2741
01:59:23,762 --> 01:59:25,630
И вернемся в основной файл

2742
01:59:25,630 --> 01:59:28,100
и удалим фамилию, чтобы
вызывать второстепенный

2743
01:59:28,100 --> 01:59:29,600
конструктор.

2744
01:59:29,600 --> 01:59:32,160
И теперь мы добавим тело в
конструктор, чтобы сделать что-то

2745
01:59:32,160 --> 01:59:34,370
после того

2746
01:59:34,370 --> 01:59:35,640
как этот конструктор вызовется.

2747
01:59:35,640 --> 01:59:37,610
Давайте просто выведем простой текст

2748
01:59:39,160 --> 01:59:42,720
например напишем что вызвался второй конструктор

2749
01:59:42,720 --> 01:59:44,870
И ожидаем мы примерно такое поведение

2750
01:59:44,870 --> 01:59:48,110
создается наш класс через
второстепенный конструктор

2751
01:59:48,110 --> 01:59:51,130
потом мы вызываем основной конструктор.

2752
01:59:51,130 --> 01:59:54,670
потом выполняем тело

2753
01:59:54,670 --> 01:59:57,850
второстепенного конструктора
и вызываем init блоки.

2754
01:59:57,850 --> 02:00:00,219
примерно такой порядок

2755
02:00:00,219 --> 02:00:02,360
Но это в корне не так

2756
02:00:02,360 --> 02:00:03,250
и вывод будет другим.

2757
02:00:03,250 --> 02:00:05,260
вы можете заметить что порядок немного перепутан

2758
02:00:05,260 --> 02:00:06,890
у нас есть вызовы init блоков

2759
02:00:06,890 --> 02:00:09,110
а только потом вызов тела

2760
02:00:09,110 --> 02:00:10,520
второстепенного конструктора.

2761
02:00:10,520 --> 02:00:14,330
Надо просто запомнить,

2762
02:00:15,360 --> 02:00:17,290
что блоки init вызываются

2763
02:00:17,290 --> 02:00:19,000
сразу после вызова основного конструктора

2764
02:00:19,000 --> 02:00:20,710
не смотря ни на что

2765
02:00:20,710 --> 02:00:22,740
не смотря ни на что

2766
02:00:22,740 --> 02:00:25,210
Еще раз - вызывается основной конструктор,

2767
02:00:25,210 --> 02:00:27,220
вызываются блоки init,
а потом все остальное.

2768
02:00:27,220 --> 02:00:30,640
После инит блоков мы пройдемся по

2769
02:00:30,640 --> 02:00:34,340
телам всех конструкторов,
которые участвовали в цепочке,

2770
02:00:34,340 --> 02:00:37,470
в нашем случае это второй конструктор

2771
02:00:37,470 --> 02:00:40,500
и выполнится эта строчка
и вы увидите "Hello 1"

2772
02:00:40,500 --> 02:00:44,470
"Hello 2" и в конце концов
строку из тела второго конструктора.

2773
02:00:44,470 --> 02:00:46,690
Теперь вы знаете о init блоках

2774
02:00:46,690 --> 02:00:49,369
и можете делать действия необходимые
для работы с

2775
02:00:49,369 --> 02:00:50,930
вашим классом после

2776
02:00:50,930 --> 02:00:54,260
его инициализации.

2777
02:00:54,260 --> 02:00:55,860
его инициализации.

2778
02:00:58,220 --> 02:01:01,240
В классах так же можно
создавать поля.

2779
02:01:01,240 --> 02:01:03,970
Я создам поле "полное имя"

2780
02:01:03,970 --> 02:01:07,090
и сразу проинициализирую
его значениями

2781
02:01:07,090 --> 02:01:09,800
которые мы передали в конструктор.

2782
02:01:09,800 --> 02:01:11,580
Используем firstName

2783
02:01:11,580 --> 02:01:14,040
и lastName

2784
02:01:14,040 --> 02:01:15,770
чтобы создать полное имя.

2785
02:01:15,770 --> 02:01:17,430
Вернемся в main функцию

2786
02:01:17,430 --> 02:01:19,100
и выведем наше новое поле

2787
02:01:19,100 --> 02:01:22,710
в консоль, напишем println(user.fullName),

2788
02:01:22,710 --> 02:01:24,380
и у нас есть доступ к этому полю

2789
02:01:24,380 --> 02:01:27,810
потому что мы находимся в том же
пакете что и класс пользователя.

2790
02:01:27,810 --> 02:01:30,090
Если я запущу программу

2791
02:01:30,090 --> 02:01:31,600
то увижу наше полное имя.

2792
02:01:32,803 --> 02:01:34,900
И еще в консоль выводится

2793
02:01:34,900 --> 02:01:37,430
текст, который мы написали в
init блоке.

2794
02:01:37,430 --> 02:01:38,500
init блок еще тут, не будем
забывать про это.

2795
02:01:38,500 --> 02:01:41,410
И еще одна крутая штука

2796
02:01:41,410 --> 02:01:43,210
если вернемся в main функцию

2797
02:01:44,164 --> 02:01:44,997
то мы можем поменять это значение

2798
02:01:44,997 --> 02:01:47,280
Поля класса изменяемые.

2799
02:01:47,280 --> 02:01:49,585
И это потому что поле у нас

2800
02:01:49,585 --> 02:01:50,490
объявлено с помощью "var".

2801
02:01:50,490 --> 02:01:53,270
Я могу написать user.fullName

2802
02:01:53,270 --> 02:01:56,760
и присвоить ему новое значение
например "Hello world".

2803
02:01:56,760 --> 02:01:59,570
И это полностью заменит наше
исходное значение.

2804
02:01:59,570 --> 02:02:03,110
Теперь, чтоыбы проверить
я сделаю еще один вывод

2805
02:02:03,110 --> 02:02:06,170
и снова выведу fullName.

2806
02:02:06,170 --> 02:02:07,420
Запустим по новой,

2807
02:02:07,420 --> 02:02:09,620
видим вывод init блока,

2808
02:02:09,620 --> 02:02:11,020
потом видим исходное
полное имя

2809
02:02:12,312 --> 02:02:13,780
и потом видим новое значение.

2810
02:02:13,780 --> 02:02:16,920
Вернемся в класс пользователя

2811
02:02:16,920 --> 02:02:18,410
тут у нас есть еще одна фишка,

2812
02:02:18,410 --> 02:02:22,640
Внутри init блока я могу получить
доступ к этому полю.

2813
02:02:22,640 --> 02:02:25,070
Например, если мы что-то
хотим вывести

2814
02:02:25,070 --> 02:02:26,210
в init блоке

2815
02:02:26,210 --> 02:02:28,480
связанное с полным именем,

2816
02:02:28,480 --> 02:02:33,480
можем написать такую строчку
и вывести полное имя.

2817
02:02:35,915 --> 02:02:37,710
Вы заметите что компилятору
что-то не нравится

2818
02:02:37,710 --> 02:02:39,160
и он сигнализирует нам красной линией

2819
02:02:39,160 --> 02:02:42,680
и говорит, что полное имя еще
не проинициализировалось

2820
02:02:42,680 --> 02:02:45,820
что мы можем в этом случае сделать?

2821
02:02:45,820 --> 02:02:48,260
нужно просто перенести инициализацию
поля и поставить его

2822
02:02:48,260 --> 02:02:49,093
над блоком init.

2823
02:02:49,093 --> 02:02:51,360
Порядок инициализации зависит
от порядка кода

2824
02:02:51,360 --> 02:02:52,860
в классе

2825
02:02:52,860 --> 02:02:56,280
теперь init блок видит наше поле.

2826
02:02:56,280 --> 02:02:58,290
Пойдем обратно и запустим код,

2827
02:02:58,290 --> 02:02:59,790
видим что init блок запустился

2828
02:02:59,790 --> 02:03:03,120
вывел свою первую строку

2829
02:03:04,389 --> 02:03:06,556
и нашу строку с полным именем.

2830
02:03:06,556 --> 02:03:07,389
Сделал опечатку в тексте

2831
02:03:07,389 --> 02:03:11,640
Перепишем как надо

2832
02:03:11,640 --> 02:03:14,360
И конечно запустим заново,
нам не нужны очепятки в консоли.

2833
02:03:14,360 --> 02:03:16,910
Мы видим исправленный текст.

2834
02:03:16,910 --> 02:03:19,310
и наше полное имя, которое

2835
02:03:19,310 --> 02:03:20,180
мы рпосто выводим через поле

2836
02:03:20,180 --> 02:03:23,610
Дальше мы видим измененное полное имя.

2837
02:03:23,610 --> 02:03:26,710
Вы можете сделать сколько угодно

2838
02:03:26,710 --> 02:03:28,156
полей в классе.

2839
02:03:28,156 --> 02:03:29,050
И не обязательно их сразу
инициализировать

2840
02:03:29,050 --> 02:03:33,270
для каждого класса.

2841
02:03:33,270 --> 02:03:35,870
Мы можем написать примерно так -
пусть есть какой-то возраст,

2842
02:03:35,870 --> 02:03:37,210
но пока он равен нулю.

2843
02:03:37,210 --> 02:03:40,110
Так можно делать с любым типом.

2844
02:03:40,110 --> 02:03:44,260
И потом, когда код будет выполняться,
мы можем изменить возраст

2845
02:03:44,260 --> 02:03:48,980
например 22 года, мне конечно не
22, но почему бы и нет

2846
02:03:48,980 --> 02:03:51,360
И теперь я могу его вывести

2847
02:03:51,360 --> 02:03:52,430
или делать с ним что-то другое.

2848
02:03:52,430 --> 02:03:56,250
Теперь вы знаете как получать
и изменять

2849
02:03:56,250 --> 02:03:59,710
поля классов в Котлине.

2850
02:04:00,760 --> 02:04:02,880
Вы можете запрещать изменение полей

2851
02:04:02,880 --> 02:04:04,450
и делать их доступными только
для чтения.

2852
02:04:04,450 --> 02:04:06,700
Например вам нужно узнать
длину полного имени

2853
02:04:07,624 --> 02:04:10,180
и сохранить это как число в вашем классе.

2854
02:04:10,180 --> 02:04:12,570
проинициализируем наше новое поле

2855
02:04:12,570 --> 02:04:16,960
с помощью fullName.length
из-за "val" это поле больше нельзя менять

2856
02:04:16,960 --> 02:04:20,710
но мы можем его читать
из main функции

2857
02:04:20,710 --> 02:04:23,750
Напишем user.fullNameLength

2858
02:04:23,750 --> 02:04:25,580
и у нас будет к нему доступ,
никаких ошибок.

2859
02:04:25,580 --> 02:04:27,600
Выведем его на экран

2860
02:04:27,600 --> 02:04:32,370
А если попробуем изменить его на 12

2861
02:04:32,370 --> 02:04:34,200
нам выпадет ошибка, которая будет
пояснять что это поле val

2862
02:04:34,200 --> 02:04:35,830
и недоступно для изменения.

2863
02:04:35,830 --> 02:04:38,670
Это поле создается с помощью

2864
02:04:38,670 --> 02:04:40,230
другого поля

2865
02:04:40,230 --> 02:04:43,520
Мы так же тожем создать его с
помощью

2866
02:04:43,520 --> 02:04:45,730
аргумента конструктора.

2867
02:04:45,730 --> 02:04:49,820
Вы можете сами сразу
дать ему значение

2868
02:04:49,820 --> 02:04:51,300
Вы можете сами сразу
дать ему значение

2869
02:04:51,300 --> 02:04:53,600
Можно дописать тип.

2870
02:04:54,570 --> 02:04:56,390
Давайте допустим, что каждый раз

2871
02:04:56,390 --> 02:05:00,100
когда кто-то хочет прочитать

2872
02:05:00,100 --> 02:05:01,430
поле полного имени,

2873
02:05:01,430 --> 02:05:04,260
вы должны отдать полное имя
с префиксом "name"

2874
02:05:04,260 --> 02:05:08,730
В Котлине это легко сделать,
для этого нужно переопределить

2875
02:05:08,730 --> 02:05:13,190
функцию чтения get()

2876
02:05:13,190 --> 02:05:15,070
В ней мы можем отдавать новою строку

2877
02:05:15,070 --> 02:05:17,000
в которой будет префикс

2878
02:05:17,000 --> 02:05:18,090
и ключевое слово field

2879
02:05:18,090 --> 02:05:20,780
filed это не что иное, как

2880
02:05:20,780 --> 02:05:23,200
ссылка на текущее значение поля,

2881
02:05:23,200 --> 02:05:25,150
мы будем использовать его.

2882
02:05:25,150 --> 02:05:30,150
И теперь кажный раз, когда кто-то читает
это поле, в коде обычно

2883
02:05:30,428 --> 02:05:32,582
чтение пишется через точку,

2884
02:05:32,582 --> 02:05:33,450
вызов подменяется на то что мы
написали в get блоке

2885
02:05:34,782 --> 02:05:35,920
в нашем случае вернется "Name: полное имя"

2886
02:05:36,967 --> 02:05:39,095
Теперь если мы

2887
02:05:39,095 --> 02:05:39,928
запустим то увидим не полное имя,

2888
02:05:39,928 --> 02:05:42,540
а полное имя с новым префиксом.

2889
02:05:42,540 --> 02:05:46,130
Если мы закомментируем этот get

2890
02:05:46,130 --> 02:05:47,690
и перезапустим,

2891
02:05:47,690 --> 02:05:50,310
то увидим что префикс пропал

2892
02:05:50,310 --> 02:05:52,530
и чтение поля теперь

2893
02:05:52,530 --> 02:05:56,380
идет прямиком из поля

2894
02:05:57,320 --> 02:05:58,770
у которого значение имя + фамилия.

2895
02:05:59,964 --> 02:06:02,990
С помощью get мы переопределяем

2896
02:06:02,990 --> 02:06:05,780
функцию чтения из поля

2897
02:06:05,780 --> 02:06:09,140
и к нашему имени и фамилии

2898
02:06:09,140 --> 02:06:13,320
добавляется префикс.

2899
02:06:13,320 --> 02:06:15,930
Так, нужно поменять префикс,

2900
02:06:15,930 --> 02:06:18,550
чтобы он отражал действительность.

2901
02:06:18,550 --> 02:06:21,350
И теперь, после запуска мы видим
Full name и наше полное имя.

2902
02:06:22,520 --> 02:06:25,260
Важная вещь на которой
нужно заострить внимание -

2903
02:06:25,260 --> 02:06:28,740
ключевое слово field это
вспомогательное поле для поля fullName

2904
02:06:28,740 --> 02:06:31,040
это значит что оно
содержит контент

2905
02:06:31,040 --> 02:06:32,530
поля fullName.

2906
02:06:32,530 --> 02:06:34,430
поля fullName.

2907
02:06:35,590 --> 02:06:37,750
Таким же образом мы можем
переопределить метод записи в поле

2908
02:06:37,750 --> 02:06:38,720
метод записи в поле.

2909
02:06:38,720 --> 02:06:39,640
Делаем это с помощью функции set()

2910
02:06:40,833 --> 02:06:43,560
И по дефолту, значение, которое я

2911
02:06:43,560 --> 02:06:46,060
хочу записать будет в ключевом
слове value

2912
02:06:46,060 --> 02:06:50,770
Если я хочу записать в поле
строку "John"

2913
02:06:50,770 --> 02:06:54,850
давайте сделаем рпосто "Jon"

2914
02:06:54,850 --> 02:06:59,610
без буквы "h", в общем
эта строка

2915
02:07:00,607 --> 02:07:02,739
должна стать полным именем

2916
02:07:02,739 --> 02:07:03,990
и вызовется этот участок кода

2917
02:07:03,990 --> 02:07:07,980
и внутри нашего value

2918
02:07:09,191 --> 02:07:11,400
будет наша строка "Jon".

2919
02:07:11,400 --> 02:07:12,630
теперь я могу сделать с ней что-то

2920
02:07:12,630 --> 02:07:13,860
что я захочу

2921
02:07:13,860 --> 02:07:17,540
Напрмер, если value
у нас начинается

2922
02:07:17,540 --> 02:07:19,040
с какой-то последовательности символов

2923
02:07:19,040 --> 02:07:21,730
Пусть ээта последовательность
тоже будет "Jon"

2924
02:07:21,730 --> 02:07:25,220
то я хочу ее видо изменить

2925
02:07:25,220 --> 02:07:29,810
и дописать "Doe"

2926
02:07:30,910 --> 02:07:33,150
И если теперь кто-то передает
нам полное имя, которе начинается

2927
02:07:33,150 --> 02:07:36,390
с "Jon", то мы меняем

2928
02:07:36,390 --> 02:07:40,650
его на "Jon Doe"

2929
02:07:40,650 --> 02:07:42,860
Если запустим сейчас

2930
02:07:42,860 --> 02:07:44,720
то увидим "John Franks", потому что

2931
02:07:45,610 --> 02:07:47,520
это наш старыей вывод.

2932
02:07:47,520 --> 02:07:50,251
Потом мы меняем полное имя на "Jon"

2933
02:07:50,251 --> 02:07:51,084
но мы при записи переходим
в мутатор (set функция)

2934
02:07:51,084 --> 02:07:53,120
И видим нашу

2935
02:07:54,135 --> 02:07:56,500
нехитрую проверку, если начинается
с "Jon"

2936
02:07:56,500 --> 02:07:59,030
то мы меняем значение
и записываем его

2937
02:07:59,030 --> 02:08:01,020
в вспомогательное поле.
Кейс странный, но

2938
02:08:01,020 --> 02:08:03,300
допустим, что это какая-то наша
бизнес логика,

2939
02:08:03,300 --> 02:08:05,514
которая от нас требует такой замены.

2940
02:08:05,514 --> 02:08:06,410
И уже теперь, когда мы выводим

2941
02:08:06,410 --> 02:08:08,500
наше новое полное имя

2942
02:08:08,500 --> 02:08:10,480
мы выводим его с помощью переопределенно

2943
02:08:10,480 --> 02:08:12,330
функции чтения и видим новый результат.

2944
02:08:13,500 --> 02:08:15,820
Тут у нас конечно появляется
небольшая проблема

2945
02:08:15,820 --> 02:08:18,500
Если мы попробуем изменить полное имя

2946
02:08:18,500 --> 02:08:23,390
на что-то без "Jon"
напрмер "Jane Sparks".

2947
02:08:23,390 --> 02:08:26,410
и попытаемся вывести это в консоль

2948
02:08:26,410 --> 02:08:28,510
мы увидим странный и неожиданный результат

2949
02:08:28,510 --> 02:08:30,860
fullName тоже будет

2950
02:08:30,860 --> 02:08:34,370
равен "Jon Doe"

2951
02:08:34,370 --> 02:08:36,760
Но мы же задавали "Jane Sparks"
и эта строка не начаниется на "Jon"

2952
02:08:36,760 --> 02:08:38,080
почему это работает не так?

2953
02:08:38,080 --> 02:08:41,300
Все на самом деле очень просто,
мы переопределили функцию

2954
02:08:41,300 --> 02:08:44,340
записи в поле

2955
02:08:44,340 --> 02:08:49,010
и проверяем на наше условие,

2956
02:08:49,010 --> 02:08:51,090
Если новое значение начинается на "jon"
то меняем значение

2957
02:08:51,090 --> 02:08:53,090
что мы не учли

2958
02:08:53,960 --> 02:08:54,890
в этой проверке?

2959
02:08:54,890 --> 02:08:56,850
Нам нужно else условие

2960
02:08:56,850 --> 02:08:58,970
Если начинается с Jon

2961
02:08:58,970 --> 02:09:01,635
то записываем Jon Doe,

2962
02:09:01,635 --> 02:09:02,800
а иначе просто делаем field = value

2963
02:09:02,800 --> 02:09:04,180
и пропускаем новое значение без изменений.

2964
02:09:04,180 --> 02:09:07,190
Вернемся обратно и проверим.

2965
02:09:07,190 --> 02:09:09,340
Теперь последний вывод у нас

2966
02:09:09,340 --> 02:09:12,040
это нормально полное имя.

2967
02:09:12,040 --> 02:09:14,660
При переопределении методов
записи стоит

2968
02:09:14,660 --> 02:09:17,050
учитывать подобные кейсы, чтобы
не потерять значения.

2969
02:09:17,050 --> 02:09:19,490
Этот сценарий вполне может

2970
02:09:19,490 --> 02:09:20,620
случиться в вашем приложении.

2971
02:09:20,620 --> 02:09:24,450
Возможно у вас будут ситуации,
когда вам нужно

2972
02:09:24,450 --> 02:09:28,760
будет перезаписывать некоторые

2973
02:09:28,760 --> 02:09:31,580
поля исключительно в каких-нибудь
ситуациях.

2974
02:09:31,580 --> 02:09:34,002
И если у вас будут условные выражения

2975
02:09:34,002 --> 02:09:35,980
не забывайте присваивать
вашим полям

2976
02:09:35,980 --> 02:09:37,590
значения, которые

2977
02:09:38,579 --> 02:09:41,179
будут их менять, если это нужно
будет делать.

2978
02:09:42,310 --> 02:09:44,540
Давайте допустим, что у нас есть
несколько полей

2979
02:09:44,540 --> 02:09:46,980
и вы без проблем можете их дописть

2980
02:09:46,980 --> 02:09:49,480
у нас конечно есть поля, которые
объявлены в конструкторе,

2981
02:09:49,480 --> 02:09:52,380
но давайте допустим что нам нужно

2982
02:09:52,380 --> 02:09:56,160
еще поле, которое будет
показывать возраст, и по дефолту

2983
02:09:56,160 --> 02:09:59,330
пусть будет ноль, и, напрмер,
поле любимого цвета пользователя

2984
02:10:00,580 --> 02:10:03,980
пусть будет строкой, и по дефолту - синий.

2985
02:10:05,009 --> 02:10:07,730
И их может быть очень много
в вашем классе

2986
02:10:07,730 --> 02:10:10,900
и ко всем ним будет доступ
ферез функции

2987
02:10:13,710 --> 02:10:18,210
чтения и записи

2988
02:10:18,210 --> 02:10:19,070
из вне вашего класса.

2989
02:10:19,070 --> 02:10:23,043
Напишем что возраст равен 30

2990
02:10:25,650 --> 02:10:28,590
И новый любимый цвет

2991
02:10:28,590 --> 02:10:30,770
будет равен зеоеному.

2992
02:10:30,770 --> 02:10:32,240
И это все доступные действия.

2993
02:10:32,240 --> 02:10:35,540
У вас может быть сколько
угодно таких полей

2994
02:10:35,540 --> 02:10:38,060
внутри класса, прямо как с функциями

2995
02:10:38,060 --> 02:10:41,960
МОжно написать еще функию sayHi

2996
02:10:41,960 --> 02:10:45,820
которая просто выводит в консоль

2997
02:10:45,820 --> 02:10:48,520
текст и говорит "привет."

2998
02:10:48,520 --> 02:10:53,520
и конечно мы теперь можем вызывать
эти методы у пользователя и написать user.sayHi

2999
02:10:54,268 --> 02:10:55,101
и в консоль бросится строка.

3000
02:10:55,101 --> 02:10:56,900
Я могу пойти в метод
и поменять вывод,

3001
02:10:56,900 --> 02:11:00,170
на "Првет" потом полное имя и

3002
02:11:00,170 --> 02:11:02,710
вывод будет "Hi, Donn Felker"
в этом случае.

3003
02:11:02,710 --> 02:11:05,190
Таким образом вы можете
создавать много полей в классе,

3004
02:11:05,190 --> 02:11:07,330
нужно еще какое-то поле,
можем создать его тут

3005
02:11:07,330 --> 02:11:09,080
и так далее, и тому подобное,

3006
02:11:09,080 --> 02:11:10,880
сколько вам необходимо.

3007
02:11:11,960 --> 02:11:14,650
Мы можем добавлять функции
специфичные для нашего класса

3008
02:11:14,650 --> 02:11:17,640
идем внутрь класса

3009
02:11:17,640 --> 02:11:19,070
и пишем название функции.

3010
02:11:19,070 --> 02:11:20,940
Создадим функцию, которую назовем
fullName и которая

3011
02:11:20,940 --> 02:11:22,960
будет возвращать строку.

3012
02:11:22,960 --> 02:11:24,500
И внутри нее мы будем использовать

3013
02:11:24,500 --> 02:11:28,150
интерполяцию строк,
напишем иммя и фамилию

3014
02:11:28,150 --> 02:11:30,560
для интерполяции нужно использовать
знак доллара, чтобы Котлин

3015
02:11:30,560 --> 02:11:32,910
мог отличить строку от переменной или поля

3016
02:11:32,910 --> 02:11:34,340
эта функция будет возвращать нам
полное имя пользователя.

3017
02:11:35,517 --> 02:11:37,440
Вы уже могли заметить,
что я не использую скобки

3018
02:11:37,440 --> 02:11:38,440
в интерполяции.

3019
02:11:38,440 --> 02:11:42,540
Они нужны только если наше
значение для вывода

3020
02:11:42,540 --> 02:11:45,214
сложнее и для него нужен вызов
поля или функции.

3021
02:11:45,214 --> 02:11:47,425
Например, если нам нужна длина

3022
02:11:47,425 --> 02:11:48,723
IDE самостоятельно добавляет
нам скобки.

3023
02:11:48,723 --> 02:11:53,723
Каждый раз, когда у меня будет
какое-то составное

3024
02:11:54,700 --> 02:11:57,020
выражение, мне будут
нужны фигурные скобки.

3025
02:11:57,020 --> 02:11:59,080
Если я уберу вызов метода,
я все равно могу оставить скобки

3026
02:11:59,080 --> 02:12:00,400
И это будет работать,

3027
02:12:00,400 --> 02:12:02,270
но мы можем заметить
белесое подчеркивание,

3028
02:12:02,270 --> 02:12:03,800
которое довольно турдно разглядеть

3029
02:12:03,800 --> 02:12:06,092
Если наведем на него,
то увидим попап с лампочкой

3030
02:12:06,092 --> 02:12:08,180
можно на него нажать мышкой
или использовать alt+enter

3031
02:12:08,180 --> 02:12:09,760
и мы увидим подсказку, что фигурные скобки
можно убрать.

3032
02:12:09,760 --> 02:12:11,820
И если согласимся
то IDE сама почистит код

3033
02:12:11,820 --> 02:12:13,630
потому что это излишки,
без которых все будет работать

3034
02:12:13,630 --> 02:12:15,200
Дальше наш код можно почистить

3035
02:12:15,200 --> 02:12:16,440
еще больше.

3036
02:12:16,440 --> 02:12:19,060
Мы можем превратить эту функцию
в функцию единственного выражения

3037
02:12:19,060 --> 02:12:22,230
для этого удалим фигурные
скобки вокруг

3038
02:12:22,230 --> 02:12:25,530
и теперь функция равна выражению.

3039
02:12:25,530 --> 02:12:28,810
Теперь это очень маленькая
и удобная функция

3040
02:12:28,810 --> 02:12:33,073
чтобы ее вызвать нам нужно
вернуться в main функцию

3041
02:12:33,073 --> 02:12:34,373
и теперь мы можем написать user.fullName()

3042
02:12:35,699 --> 02:12:37,340
И мы даже видим эту функцию в подсказке

3043
02:12:37,340 --> 02:12:39,367
И если запустим, то в консоли будет результат

3044
02:12:39,367 --> 02:12:42,110
мы увидим комбинацию имени и фамилии,

3045
02:12:42,110 --> 02:12:45,000
имя John, фамилия Franks,
полное имя - John Franks.

3046
02:12:45,000 --> 02:12:47,220
Если нам нужно что-то другое

3047
02:12:47,220 --> 02:12:49,500
например длина фамилии

3048
02:12:49,500 --> 02:12:52,004
И по какой-то причине нам нужна
комбинация имени и длины

3049
02:12:52,004 --> 02:12:53,950
фамилии пользователя

3050
02:12:53,950 --> 02:12:56,430
то в консоль выведется уже такой
вывод

3051
02:12:56,430 --> 02:13:00,542
"John 6" потому что теперь вместо фамилии
выводится ее длина

3052
02:13:00,542 --> 02:13:03,020
И теперь мы можем добавлять

3053
02:13:03,020 --> 02:13:04,130
самые разные функции для пользователя

3054
02:13:04,130 --> 02:13:06,150
Напрмер тут можно делать функцию

3055
02:13:06,150 --> 02:13:09,470
которая выводит длинуу полного
имени пользователя

3056
02:13:09,470 --> 02:13:12,200
И эта функция будет возвращать Int

3057
02:13:12,200 --> 02:13:14,990
мы так же можетм сделать ее
однострочной

3058
02:13:14,990 --> 02:13:17,230
или на несколько строк,
как мы делаем тут.

3059
02:13:17,230 --> 02:13:19,030
И теперь мы можем переиспользовать
функцию, которая возвращает полное

3060
02:13:19,030 --> 02:13:20,940
имя и вызвать

3061
02:13:20,940 --> 02:13:22,990
на ней метод length.

3062
02:13:24,204 --> 02:13:27,020
И теперь тоже можем вывести
результат в консоль

3063
02:13:27,020 --> 02:13:30,590
напишем user.fullNameLength

3064
02:13:31,664 --> 02:13:33,300
И теперь мы увидим

3065
02:13:33,300 --> 02:13:36,240
строчку "John 6" потому что так
у нас реализуется fullName

3066
02:13:36,240 --> 02:13:38,390
давайте быстро это поправим

3067
02:13:38,390 --> 02:13:40,860
потому что эта цифра нам не нужна

3068
02:13:40,860 --> 02:13:44,530
Мы хотим выводить настоящее полное имя

3069
02:13:44,530 --> 02:13:47,960
И дальше мы хотим увидеть длину полного имени.

3070
02:13:47,960 --> 02:13:49,410
И делаем мы это тут.

3071
02:13:50,252 --> 02:13:52,140
Мы выводим "John Franks"
и длина 11.

3072
02:13:52,140 --> 02:13:54,940
Итак, у нас есть одна функция,
которая вызывает другую функцию.

3073
02:13:54,940 --> 02:13:56,650
Но это делать необязательно.

3074
02:13:56,650 --> 02:14:00,390
Я мог бы просто продублировать
функциональность

3075
02:14:00,390 --> 02:14:03,205
закомментирую наше текущее решение

3076
02:14:03,205 --> 02:14:06,778
И теперь ан этой строчке я могу вызвать
length метод

3077
02:14:06,778 --> 02:14:07,611
и результат будет таким же.

3078
02:14:07,611 --> 02:14:09,790
Но теперь у нас появились повторения когда

3079
02:14:09,790 --> 02:14:11,190
и часто это не самая хорошая штука

3080
02:14:11,190 --> 02:14:14,100
потому что, если в какой-то момент
я решу что в полном имени

3081
02:14:14,100 --> 02:14:16,320
нам нужен дефис,

3082
02:14:16,320 --> 02:14:20,180
то, во первых, длина увеличится из-за этого,
а во вторых мне придется

3083
02:14:20,180 --> 02:14:21,060
добавлять это изменение в двух
местах сразу

3084
02:14:21,060 --> 02:14:23,040
Это зависит в основном от того
приложения, которое вы делаете

3085
02:14:23,040 --> 02:14:25,220
и если у вас будут подобные кейсы.

3086
02:14:25,220 --> 02:14:27,960
И обычно я рекомендую переиспользовать

3087
02:14:27,960 --> 02:14:30,010
функции, которые отдают вам какие-то
значения, потому что, если логика поменяется,

3088
02:14:30,010 --> 02:14:31,860
то все остальные функции получат
актуальное значение.

3089
02:14:31,860 --> 02:14:34,402
Такое изменение добавит нам

3090
02:14:34,402 --> 02:14:35,235
два дополнительных символа
в полное имя

3091
02:14:35,235 --> 02:14:38,480
а именно пробел и тире,

3092
02:14:38,480 --> 02:14:42,500
поэтому вместо 11 у нас теперь
будет число 13

3093
02:14:43,340 --> 02:14:44,550
все верно.

3094
02:14:44,550 --> 02:14:47,770
И таким образом вы можете добавлять
простейшие функции

3095
02:14:47,770 --> 02:14:49,823
в ваши собственные классы.

3096
02:14:49,823 --> 02:14:52,200
И добавлять их можно сколько угодно

3097
02:14:52,200 --> 02:14:53,280
в теле класса.

3098
02:14:53,280 --> 02:14:54,730
Они могут использовать различные
поля объекта

3099
02:14:54,730 --> 02:14:57,230
делать самые разные операции

3100
02:14:57,230 --> 02:14:59,230
и могу даже как-то влиять на состояние
класса и менять значение полей.

3101
02:14:59,230 --> 02:15:01,420
Напирмер, если мы
хотим это продемонстрировать

3102
02:15:02,970 --> 02:15:07,970
можем создать функцию, которая
добавляет в имя суффикс.

3103
02:15:08,680 --> 02:15:11,100
И мы можем этот суффикс передавать
в саму функцию

3104
02:15:11,100 --> 02:15:13,600
путсь это будет какая-то строка,

3105
02:15:14,520 --> 02:15:15,880
добавить суффикс можно так

3106
02:15:15,880 --> 02:15:19,490
к имени прбавляем суффикс

3107
02:15:20,730 --> 02:15:22,380
и присваиваем это значение
имени пользователя.

3108
02:15:23,920 --> 02:15:26,020
И теперь мы можем вернуться

3109
02:15:26,020 --> 02:15:29,260
в main функцию.

3110
02:15:29,260 --> 02:15:32,640
И теперь мы обновим наше имя
и добавим в него суффикс

3111
02:15:32,640 --> 02:15:34,650
Например "Mr"

3112
02:15:34,650 --> 02:15:38,590
Когда это выведется, мы должны увидеть
"Mr. John"

3113
02:15:38,590 --> 02:15:41,800
что звучит немного странно, но
так это будет выглядеть.

3114
02:15:41,800 --> 02:15:45,360
И да, мы видим правильный
вывод в консоли

3115
02:15:45,360 --> 02:15:47,980
и так вы можете добавлять

3116
02:15:47,980 --> 02:15:50,080
различные функции в вашем классе.

3117
02:15:51,280 --> 02:15:53,490
Чтобы создать объект-компаньон

3118
02:15:53,490 --> 02:15:56,060
вам нужно использовать ключевое слово
"companion object" в вашем классе,

3119
02:15:57,382 --> 02:15:58,530
и дальше вы можете писать
ваши функции.

3120
02:15:58,530 --> 02:16:01,030
В нашем случае это функция
для создания пользователя,

3121
02:16:01,030 --> 02:16:02,640
которая будет возвращать нового
пользователя.

3122
02:16:03,630 --> 02:16:05,440
для нее нам нужны

3123
02:16:05,440 --> 02:16:06,273
имя и фамилия.

3124
02:16:06,273 --> 02:16:07,960
И надо создать для этого аргументы

3125
02:16:09,080 --> 02:16:10,950
нам понадобится имя

3126
02:16:10,950 --> 02:16:12,450
и вот тут фамилия.

3127
02:16:13,671 --> 02:16:15,958
И внутри функции мы создадим
пользователя

3128
02:16:15,958 --> 02:16:16,791
и вернем его.

3129
02:16:16,791 --> 02:16:19,260
И для этого мы вызовем конструктор

3130
02:16:19,260 --> 02:16:21,160
и передадим имя и фамилию.

3131
02:16:23,440 --> 02:16:26,130
Объект компаньон содержит
набор методов и полей,

3132
02:16:26,130 --> 02:16:28,170
которые будут привязаны к
всему классу,

3133
02:16:28,170 --> 02:16:30,310
а не отдельным экземплярам

3134
02:16:30,310 --> 02:16:33,000
Это тоже самое, что статический метод
или статическое поле

3135
02:16:33,000 --> 02:16:35,490
которые есть, напрмер
в языке Java

3136
02:16:35,490 --> 02:16:37,390
И объект компаньон это синглтон

3137
02:16:37,390 --> 02:16:39,810
это значит, что он единственный
и прявязан ко всему классу

3138
02:16:39,810 --> 02:16:40,780
Что это все значит?

3139
02:16:40,780 --> 02:16:44,033
Давайте посмотрим на конкретные
примеры.

3140
02:16:44,033 --> 02:16:46,610
В main функции я смогу вызвать User.createUser

3141
02:16:46,610 --> 02:16:49,670
с агрументами "foo" и "bar"
и присвоим это к переменной.

3142
02:16:52,316 --> 02:16:53,820
И дальше просто выведем в консоль

3143
02:16:53,820 --> 02:16:55,670
с помощью println.

3144
02:16:56,651 --> 02:16:58,953
И тут мы вызвали статический метод

3145
02:16:58,953 --> 02:17:00,120
который привязан к классу User,

3146
02:17:00,120 --> 02:17:02,310
а он уже внутри создал нам пользователя.

3147
02:17:02,310 --> 02:17:04,830
Вы можете заметить важную деталь,
что мне не пришлось создавать пользователя

3148
02:17:04,830 --> 02:17:08,870
Я просто вызвал метод, который
напрямую связан с классом пользователя,

3149
02:17:08,870 --> 02:17:11,620
и он уже создал пользователя под капотом.

3150
02:17:11,620 --> 02:17:15,010
И теперь мы можем использовать
метод createUser как паттерн фабрика

3151
02:17:15,010 --> 02:17:16,200
и он будет создавать для нас пользователей

3152
02:17:16,200 --> 02:17:19,270
Давайте немного усложним пример

3153
02:17:19,270 --> 02:17:22,870
например нам нужно создавать

3154
02:17:22,870 --> 02:17:25,132
сразу несколько пользователей,
я могу сделать метод createUsers

3155
02:17:25,132 --> 02:17:28,500
И как аргумент мы будем передавать
кол-во пользователей,

3156
02:17:28,500 --> 02:17:30,400
которое нужно создать

3157
02:17:30,400 --> 02:17:32,535
и передадим его

3158
02:17:32,535 --> 02:17:35,970
Возвращать из этой функции мы
будем список пользователей.

3159
02:17:37,010 --> 02:17:38,870
Для этого нам для назала нужно

3160
02:17:38,870 --> 02:17:41,510
создать переменную синглтон в
объекте компаньоне.

3161
02:17:41,510 --> 02:17:46,133
Создадим неизменяемую переменную
которая будет содержать готовых пользователей

3162
02:17:47,250 --> 02:17:50,080
Теперь у нас есть доступ к ней через
вызов класса.

3163
02:17:50,080 --> 02:17:55,080
И теперь мы создадим цикл
от нуля до нашего значения аргумента

3164
02:17:57,020 --> 02:17:59,440
Этот оборот значит что наш цикл

3165
02:17:59,440 --> 02:18:00,980
будет менять параметр i от 0 до count.

3166
02:18:00,980 --> 02:18:04,480
И дальше в список пользователей мы добавим

3167
02:18:04,480 --> 02:18:06,060
нового пользователя

3168
02:18:06,060 --> 02:18:09,320
у которого будет одинаковое имя и фамилия

3169
02:18:09,320 --> 02:18:11,910
но к нему будет добавляться значение

3170
02:18:11,910 --> 02:18:14,220
нашего счетчика.

3171
02:18:14,220 --> 02:18:17,280
И для фамилии тоже

3172
02:18:17,280 --> 02:18:19,850
будем добавлять

3173
02:18:19,850 --> 02:18:21,180
этот индекс,

3174
02:18:22,423 --> 02:18:23,256
IDE подсказывает, что мы можем убрать
фигурные скобки

3175
02:18:23,256 --> 02:18:24,830
тут и тут

3176
02:18:24,830 --> 02:18:28,520
потому что выражения у нас простые.

3177
02:18:28,520 --> 02:18:31,690
И в конце мы вернем всех пользователей,
которых надобавляли

3178
02:18:31,690 --> 02:18:34,040
И в конце мы вернем всех пользователей,
которых надобавляли

3179
02:18:34,040 --> 02:18:35,970
Давайте посмотрим, как это все можно запустить

3180
02:18:35,970 --> 02:18:38,800
и напишем переменную "пользователи"

3181
02:18:40,240 --> 02:18:42,470
и вызовем User.createUsers

3182
02:18:43,565 --> 02:18:45,954
Таким образом вы можете создавать

3183
02:18:45,954 --> 02:18:47,800
пользователей, а можете создавать
какие-то другие объекты.

3184
02:18:47,800 --> 02:18:50,360
И потом мы выведем их, чтобы
посмотреть в консоли

3185
02:18:50,360 --> 02:18:51,740
всех созданных пользователей.

3186
02:18:51,740 --> 02:18:53,430
И, в консоли они все будут

3187
02:18:53,430 --> 02:18:56,670
в одну строчку

3188
02:18:56,670 --> 02:18:59,240
Это стандартный вывод Котлина

3189
02:18:59,240 --> 02:19:02,690
для списков

3190
02:19:06,265 --> 02:19:07,160
В начале у нас будут квадратный скобки,
а в конце списка закрывающие скобки

3191
02:19:07,160 --> 02:19:09,300
вот тут, открывающие и закрывающие

3192
02:19:09,300 --> 02:19:12,170
И это первый элемент нашего списка

3193
02:19:12,170 --> 02:19:16,140
Итерация ноль, один, два, три, четыре, пять

3194
02:19:16,140 --> 02:19:18,840
Если мы хотим, чтобы это было

3195
02:19:18,840 --> 02:19:21,500
удобнее читать, мы можем использовать
вспомогательный метод forEach

3196
02:19:21,500 --> 02:19:23,780
для классов коллекций (таких как List)

3197
02:19:23,780 --> 02:19:26,385
И он будет проходить по каждому элементу

3198
02:19:26,385 --> 02:19:28,280
И внутри этого метода мы
можем вывести элемент коллекции

3199
02:19:28,280 --> 02:19:31,340
он будет называться "it" по дефолту

3200
02:19:31,340 --> 02:19:33,870
И если запустим, то увидим,

3201
02:19:33,870 --> 02:19:36,230
что каждый пользователь теперь на новой строке.

3202
02:19:36,230 --> 02:19:38,330
Нужно подметить, что мы хотели

3203
02:19:38,330 --> 02:19:42,730
создать пять пользователей,
а у нас их [считает] шесть.

3204
02:19:43,593 --> 02:19:44,426
Причина почему у нас шесть

3205
02:19:44,426 --> 02:19:46,840
это потому что наш цикл создания
начинается с нуля

3206
02:19:46,840 --> 02:19:50,743
Мы можем поменять верхнюю границу
на count - 1

3207
02:19:50,743 --> 02:19:51,640
или мы можем начать в единицы

3208
02:19:51,640 --> 02:19:53,260
и до кол-ва пользователей,
которое нам нужно.

3209
02:19:53,260 --> 02:19:55,990
Если перезапустим, то теперь

3210
02:19:55,990 --> 02:19:57,300
у нас будет [считает] пять пользователей.

3211
02:19:57,300 --> 02:20:00,800
Можем теперь создать 15

3212
02:20:00,800 --> 02:20:03,350
разных пользователей.

3213
02:20:03,350 --> 02:20:04,710
И это теперь сделать супер просто.

3214
02:20:04,710 --> 02:20:06,760
Еще одна интересная вещь,

3215
02:20:07,667 --> 02:20:08,840
давайте закоментируем эти строки,

3216
02:20:08,840 --> 02:20:11,630
теперь мы не выводим пользователей
а просто создаем их

3217
02:20:11,630 --> 02:20:14,620
но мы все равно можем в любой

3218
02:20:14,620 --> 02:20:17,470
момент обрптиться к значению
User.users

3219
02:20:17,470 --> 02:20:21,000
Если вы помните, то это синглтон

3220
02:20:21,000 --> 02:20:23,110
привязанный к классу пользователя.

3221
02:20:23,110 --> 02:20:28,110
И метод createUsers при вызове
модифичирует этот список

3222
02:20:29,320 --> 02:20:30,660
добавляя в него новых пользователей

3223
02:20:30,660 --> 02:20:32,550
И вот тут, в начале, мы ничего
не делаем с нашими пользователями

3224
02:20:32,550 --> 02:20:35,631
мы просто создаем их и оставляем
в подвешенном состоянии

3225
02:20:35,631 --> 02:20:36,993
и можно даже не сохранять
их в переменную

3226
02:20:36,993 --> 02:20:38,750
И из-за того что они привязаны
к классу и хранятся как синглтон

3227
02:20:38,750 --> 02:20:40,350
я могу в любой момент взять
и, например, вывести их на экран

3228
02:20:42,030 --> 02:20:43,770
Давайте, чтобы было проще просто
скопируем и

3229
02:20:43,770 --> 02:20:46,980
поменяем значение на users2

3230
02:20:48,190 --> 02:20:49,320
users у нас больше нет,
поэтому показывает ошибку

3231
02:20:49,320 --> 02:20:50,870
И выводим их в консоль

3232
02:20:50,870 --> 02:20:53,210
И при запуске мы видим, что пользователи

3233
02:20:53,210 --> 02:20:55,920
создались при вызове

3234
02:20:55,920 --> 02:20:57,620
createUsers метода.

3235
02:20:57,620 --> 02:21:00,780
И если мы поменяем цифру на ноль

3236
02:21:01,670 --> 02:21:03,330
то пользователи не будут создаваться

3237
02:21:03,330 --> 02:21:05,020
и мы увидим пустой список.

3238
02:21:05,020 --> 02:21:07,730
Мы видим только foo - bar.

3239
02:21:07,730 --> 02:21:09,980
Это старая строчка в самом верху,

3240
02:21:11,689 --> 02:21:12,522
если уберем ее то будет пусто.

3241
02:21:12,522 --> 02:21:13,650
У нас нет пользователей, чтобы их

3242
02:21:14,513 --> 02:21:16,820
вывести, поэтому в консоли пусто.

3243
02:21:16,820 --> 02:21:19,750
И так мы создаем объекты компаньоны

3244
02:21:19,750 --> 02:21:21,340
внутри Котлин классов.

3245
02:21:22,324 --> 02:21:24,433
Мы используем ключевое слово
companion object

3246
02:21:24,433 --> 02:21:25,400
пишем фигурные скобки,

3247
02:21:25,400 --> 02:21:27,680
и объявляем переменные и функции,

3248
02:21:27,680 --> 02:21:30,520
которые будут синглтонами
и доступны по названию класса.

3249
02:21:31,980 --> 02:21:33,480
Давайте допустим, что нам нужно
сохранять

3250
02:21:33,480 --> 02:21:35,270
любимое блюдо пользователя

3251
02:21:36,600 --> 02:21:38,760
или просто любимое
блюдо в вашем приложении

3252
02:21:38,760 --> 02:21:41,510
Представим, что у него
есть какие-то ингридиенты

3253
02:21:43,030 --> 02:21:46,930
И эти ингридиенты можем представить
как список строк.

3254
02:21:46,930 --> 02:21:50,950
И у любимого блюда

3255
02:21:50,950 --> 02:21:52,890
есть название,

3256
02:21:52,890 --> 02:21:56,690
и оно должно быть изменяемым

3257
02:21:56,690 --> 02:21:59,050
пусть тип будет String

3258
02:21:59,050 --> 02:22:02,170
и по дефолту будет "unknown",

3259
02:22:02,170 --> 02:22:03,830
мы изменим это значение позже.

3260
02:22:03,830 --> 02:22:07,080
Если мы хотим, чтобы у нас существовал
единственный экзепляр объекта

3261
02:22:07,080 --> 02:22:12,080
то нам нужно использовать
паттерн синглтон.

3262
02:22:12,360 --> 02:22:14,850
И если у меня есть любимое блюдо,
оно может быть только одно

3263
02:22:14,850 --> 02:22:16,480
технически конечно их может
быть несколько

3264
02:22:16,480 --> 02:22:18,730
Давайте представим, что
мои любимые блюда, это

3265
02:22:18,730 --> 02:22:20,590
абстрактные блюда X, Y и Z

3266
02:22:20,590 --> 02:22:22,770
И мне нужно чтобы существовало
только одно любимое блюдо

3267
02:22:22,770 --> 02:22:26,030
Но сейчас, с помощью этого класса

3268
02:22:26,030 --> 02:22:27,600
Я могу создать любимое блюдо X

3269
02:22:27,600 --> 02:22:31,650
любимое блюдо Y

3270
02:22:31,650 --> 02:22:34,270
И теперь получается так

3271
02:22:34,270 --> 02:22:37,090
что у нас естьвозможность
создавать несколько

3272
02:22:37,090 --> 02:22:40,410
разных экземпляров,
но мне нужно разрешить

3273
02:22:40,410 --> 02:22:43,750
создание любимого блюда только
один раз

3274
02:22:43,750 --> 02:22:45,030
Как это сделать?

3275
02:22:45,030 --> 02:22:46,650
В других языках программирования

3276
02:22:46,650 --> 02:22:49,200
вам бы пришлось запрещать использование
конструктора с помощью

3277
02:22:49,200 --> 02:22:50,730
модификатора доступа "private".

3278
02:22:50,730 --> 02:22:52,550
Но если мы так сделаем то
вообще не сможем

3279
02:22:52,550 --> 02:22:53,383
создавать пользователей.

3280
02:22:53,383 --> 02:22:55,870
И нам понадобится объект компаньон,
который будет

3281
02:22:55,870 --> 02:22:56,703
создавать нам пользователя.

3282
02:22:56,703 --> 02:23:00,050
И в объекте компаньоне, напрмер,

3283
02:23:00,050 --> 02:23:04,660
будет метод "instance".

3284
02:23:04,660 --> 02:23:08,140
И этот метод будет создавать

3285
02:23:08,140 --> 02:23:13,140
пользователя

3286
02:23:13,690 --> 02:23:16,290
и возвращать его нам.

3287
02:23:16,290 --> 02:23:19,475
но теперь, опять же
при вызове instance мы будем

3288
02:23:19,475 --> 02:23:20,308
получать нового пользователя.

3289
02:23:20,308 --> 02:23:23,047
Если мы вызываем instance

3290
02:23:23,047 --> 02:23:24,570
тут, мы создаем новое любимое блюдо

3291
02:23:25,410 --> 02:23:28,190
и у нас в итоге будет много разных

3292
02:23:28,190 --> 02:23:29,160
любимых блюд.

3293
02:23:29,160 --> 02:23:30,580
Чтобы это исправить, нам нужно

3294
02:23:30,580 --> 02:23:32,851
немного усложнить код

3295
02:23:32,851 --> 02:23:34,946
и сказать что метод возвращает
тип FavoriteFood.

3296
02:23:34,946 --> 02:23:38,420
И внутри нашего клласса нам нужен
будет val поле

3297
02:23:38,420 --> 02:23:43,413
в котором мы будем хранить
наш единственный экзепляр.

3298
02:23:49,820 --> 02:23:52,080
И теперь нам нужно будет
написать очень много

3299
02:23:52,080 --> 02:23:53,100
кода чтобы все это разрулить.

3300
02:23:53,100 --> 02:23:54,900
Вы уже наверное начали замечать,

3301
02:23:54,900 --> 02:23:58,320
что ситуация выходит из под контроля
и, поверьте, это только начало работы -

3302
02:23:58,320 --> 02:24:01,070
нужно создать хранилище
для синглтона и так далее.

3303
02:24:01,070 --> 02:24:03,240
Хорошая новость, что в котлине
это все делается гораздо проще.

3304
02:24:03,240 --> 02:24:04,410
На не нужно делать
ничего из вышеперечисленного

3305
02:24:04,410 --> 02:24:06,510
Котлин уже все умеет делать за нас.

3306
02:24:06,510 --> 02:24:09,200
И создать синглтон в Котлине

3307
02:24:09,200 --> 02:24:10,250
очень просто.

3308
02:24:10,250 --> 02:24:11,950
Удалим привантый конструктор.

3309
02:24:11,950 --> 02:24:14,890
И единственное что нужно сделать -
заменить ключевое слово с class на object.

3310
02:24:15,760 --> 02:24:19,250
и теперь у нас будет
единственный экземпляр любимой еду

3311
02:24:19,250 --> 02:24:20,360
в любой момент времени.

3312
02:24:20,360 --> 02:24:22,000
И теперь я просто могу написать
FavoriteFood

3313
02:24:25,408 --> 02:24:26,630
дай мне название блюда

3314
02:24:29,723 --> 02:24:32,920
прошу прощения, я напишу printl,
чтобы вывести это в консоль

3315
02:24:32,920 --> 02:24:35,280
FavoriteFood.name и мы увидим
в консоли "unknown".

3316
02:24:35,280 --> 02:24:37,940
Если запущу программу, увидим "unknown"

3317
02:24:37,940 --> 02:24:39,130
И результат верный.

3318
02:24:39,130 --> 02:24:40,340
Если я хочу поменять название,

3319
02:24:40,340 --> 02:24:45,340
я могу присвоить новое значение
через поле name

3320
02:24:46,070 --> 02:24:47,650
Я, например, люблю арбузы.

3321
02:24:48,795 --> 02:24:51,570
Я запишу арбуз и снова запущу

3322
02:24:51,570 --> 02:24:54,940
мы снова увидим "unknown",
потому что мы вывели его только до

3323
02:24:54,940 --> 02:24:56,140
изменения названия.

3324
02:24:57,090 --> 02:24:59,320
Если я сейчас выведу, то мы увидим арбуз

3325
02:24:59,320 --> 02:25:02,710
И у нас будет только один экземпляр

3326
02:25:02,710 --> 02:25:05,590
Создадим функцию,

3327
02:25:05,590 --> 02:25:09,250
напрмер "doStuff"

3328
02:25:09,250 --> 02:25:11,000
и она будет что-то делать.

3329
02:25:11,000 --> 02:25:13,370
И в ней я снова поменяю значение

3330
02:25:16,162 --> 02:25:17,462
пусть будет курица.

3331
02:25:18,400 --> 02:25:20,010
Теперь нужно эту функцию вызвать

3332
02:25:20,010 --> 02:25:21,210
просто напишем "doStuff"

3333
02:25:21,210 --> 02:25:22,043
ой

3334
02:25:24,920 --> 02:25:25,860
напишем doStuff

3335
02:25:27,390 --> 02:25:30,290
И нам нужно объявить ее до того
как мы ее вызовем

3336
02:25:30,290 --> 02:25:32,390
Я возьму все это и вынесу
за нашу функцию.

3337
02:25:32,390 --> 02:25:35,470
Я возьму все это и вынесу
за нашу функцию.

3338
02:25:37,370 --> 02:25:39,890
Ура, наконец-то

3339
02:25:39,890 --> 02:25:42,460
Я вызову doStuff
и потом снова

3340
02:25:44,072 --> 02:25:46,650
вызову вывод в консоль и опять
выведу имя любимого блюда.

3341
02:25:46,650 --> 02:25:48,890
И теперь мы увидим сначла "unknown"

3342
02:25:48,890 --> 02:25:51,004
потом увидим арбуз

3343
02:25:51,004 --> 02:25:52,350
И теперь, когда мы дойдем
сюда, должны увидеть курицу

3344
02:25:52,350 --> 02:25:54,930
Не смотря на то что мы вызываем
изменение блюда в другом методе

3345
02:25:54,930 --> 02:25:57,930
мы просто меняем наш синглтон
из другого контекста.

3346
02:25:57,930 --> 02:25:59,470
Мы теперь не в контексте функции main,
а в контексте

3347
02:25:59,470 --> 02:26:01,860
функции doStuff,

3348
02:26:01,860 --> 02:26:04,120
мы все равно увидим, что наше
любимое блюдо это синглтон

3349
02:26:04,120 --> 02:26:06,180
и в программе есть
только один экземпляр

3350
02:26:06,180 --> 02:26:07,013
на все приложение.

3351
02:26:07,013 --> 02:26:09,640
И когда запустим, увидим "unknown",

3352
02:26:09,640 --> 02:26:11,790
"watermelon" и "chiken" в конце.

3353
02:26:11,790 --> 02:26:14,180
Та же самая логика будет

3354
02:26:14,180 --> 02:26:18,060
распространятся на ингридиенты

3355
02:26:18,060 --> 02:26:22,250
например тут мы добавим соль,

3356
02:26:25,540 --> 02:26:26,570
какое блюдо без соли.

3357
02:26:28,247 --> 02:26:30,730
и я выведу ингридиенты тут.

3358
02:26:30,730 --> 02:26:33,340
И выведем ингридиенты

3359
02:26:33,340 --> 02:26:34,700
Я просто выведу первый ингридиент
с помощью специального метода

3360
02:26:34,700 --> 02:26:36,820
FavoriteFood.ingredients.first()

3361
02:26:37,890 --> 02:26:40,940
этот метод выведет первый элемент
в нашем списке ингридиентов

3362
02:26:41,795 --> 02:26:43,430
и давайте запустим и проверим,

3363
02:26:43,430 --> 02:26:44,870
как это все выглядит.

3364
02:26:44,870 --> 02:26:47,530
И правда видим, соль первым ингридиентом
в нашем любимом блюде

3365
02:26:47,530 --> 02:26:48,363
вот тут.

3366
02:26:48,363 --> 02:26:51,500
Давайте снова что-нибудь изменим
внутри функции doStuff

3367
02:26:51,500 --> 02:26:54,150
напрмер просто очистим список ингридиентов
с помощью функции clear().

3368
02:26:54,150 --> 02:26:56,300
Она просто удаляет все элементы из списка

3369
02:26:56,300 --> 02:26:57,890
И снова выведем первый элемент

3370
02:26:57,890 --> 02:27:01,180
немного разделим код, чтобы было понятнее

3371
02:27:01,180 --> 02:27:05,970
Вот так уже лучше.

3372
02:27:05,970 --> 02:27:08,530
И если запустим, то увидим

3373
02:27:08,530 --> 02:27:09,960
что список ингридиентов очистился

3374
02:27:09,960 --> 02:27:12,680
и увидим что соли больше нет.

3375
02:27:12,680 --> 02:27:16,810
И нам выпадает исключение на строчке 14,

3376
02:27:16,810 --> 02:27:18,030
потому что я вызываю метод first,
но первого элемента нет.

3377
02:27:18,030 --> 02:27:19,480
Давайте немного изменим, чтобы не было
исключения

3378
02:27:19,480 --> 02:27:22,030
например вызовем метод
firstOrNull, который, если список

3379
02:27:22,030 --> 02:27:25,670
пустой, вернет нам null

3380
02:27:25,670 --> 02:27:27,040
Окей, теперь возвращается null.

3381
02:27:28,320 --> 02:27:31,090
И теперь наш список пуст.

3382
02:27:31,090 --> 02:27:35,010
Мы рассмотрели самый лучший и
легкий способ

3383
02:27:35,010 --> 02:27:36,240
создавать синглтоны в котлине.

3384
02:27:36,240 --> 02:27:39,630
Просто поменяйте "class"

3385
02:27:39,630 --> 02:27:41,090
на "object".

3386
02:27:41,090 --> 02:27:43,230
И конечно внутрь синглтона вы можете

3387
02:27:43,230 --> 02:27:44,220
добавлять любые функции.

3388
02:27:44,220 --> 02:27:48,670
Напишем функцию, которая будет

3389
02:27:50,070 --> 02:27:51,910
возвращать кол-во ингридиентов

3390
02:27:52,758 --> 02:27:57,580
просто вернем размер списка
ingredients.

3391
02:27:57,580 --> 02:28:00,400
И теперь можем это вызывать тут

3392
02:28:00,400 --> 02:28:03,600
и выведем число в консоль

3393
02:28:03,600 --> 02:28:06,300
FavoriteFood.numberOfIngredients

3394
02:28:07,150 --> 02:28:09,600
И если запустим, должны увидеть
ноль в конце вывода.

3395
02:28:11,180 --> 02:28:13,080
Упс, нас просят указать возвращаемый тип,

3396
02:28:13,999 --> 02:28:15,430
который мы забыли, напишем Int

3397
02:28:16,780 --> 02:28:19,190
Запустим и увидим ноль.

3398
02:28:19,190 --> 02:28:23,290
Вернемся в самый верх,
где мы добавляли  ингридиенты

3399
02:28:23,290 --> 02:28:28,040
сразу после того как добавили соль.

3400
02:28:28,040 --> 02:28:31,340
Увидим цифру один, потом курицу,
потом все очищается

3401
02:28:31,340 --> 02:28:34,320
из-за doStuff функции.

3402
02:28:34,320 --> 02:28:37,530
И потом мы выводи ноль.

3403
02:28:37,530 --> 02:28:40,258
В объекте синглтоне
у нас могут быть различные поля

3404
02:28:40,258 --> 02:28:42,000
Можно вообще использовать что угодно,
как с обычными классани

3405
02:28:42,000 --> 02:28:42,860
Может быть больше функций

3406
02:28:42,860 --> 02:28:44,520
но у этого класса будет только один
уникальный экземпляр.

3407
02:28:44,520 --> 02:28:46,820
И я не могу создать
второй такой вообще никак

3408
02:28:46,820 --> 02:28:49,600
И если я выведу их сравнение

3409
02:28:49,600 --> 02:28:53,960
сделаем FavoriteFood == FavoriteFood

3410
02:28:53,960 --> 02:28:55,710
что тут должно быть результатом?

3411
02:28:57,090 --> 02:28:59,730
будет ли оно равно само себе,
будет это один и тот же экземпляр?

3412
02:28:59,730 --> 02:29:01,660
И в результате внизу в консоли
мы увидим "true",

3413
02:29:01,660 --> 02:29:02,670
они равны

3414
02:29:04,516 --> 02:29:06,230
но не просто равны, это один и тот же

3415
02:29:06,230 --> 02:29:07,063
объект в памяти программы

3416
02:29:07,063 --> 02:29:09,740
На этом завершим разговор
про синглтоны.

3417
02:29:09,740 --> 02:29:11,870
Есть несколько способов
создать константное

3418
02:29:11,870 --> 02:29:13,530
значение в котлин

3419
02:29:13,530 --> 02:29:16,180
Первый это создать локальную константу

3420
02:29:16,180 --> 02:29:18,610
Стоит заранее сказать, что
в Котлине есть ключевое слово

3421
02:29:18,610 --> 02:29:19,950
const чтобы создать константу

3422
02:29:19,950 --> 02:29:23,020
Но если вы попробуете сделать это
в классе, вы увидите, что его можно

3423
02:29:23,020 --> 02:29:25,050
исопльзовать только на верхних уровнях
мы обсудим это позже

3424
02:29:25,050 --> 02:29:27,190
Подсказка говорит,
что нельзя объявить

3425
02:29:27,190 --> 02:29:28,860
поле класса как константу

3426
02:29:28,860 --> 02:29:30,680
поле класса как константу

3427
02:29:30,680 --> 02:29:32,680
Удалим ключевое слово

3428
02:29:32,680 --> 02:29:36,170
Константы можно без проблем создавать
с помощью "val" и обычно

3429
02:29:36,170 --> 02:29:38,030
их пошут большими буквами и слова
разделяют нижними подчеркиваниями

3430
02:29:38,030 --> 02:29:40,030
это просто стандарт код стайла,
который быстро дает понять

3431
02:29:40,030 --> 02:29:42,490
что вы работаете с константой.

3432
02:29:42,490 --> 02:29:44,680
Давайте допустим, что у нас есть

3433
02:29:44,680 --> 02:29:46,620
константа максимального возраста,
пусть будет 18

3434
02:29:46,620 --> 02:29:50,260
допустим что это детское приложение

3435
02:29:50,260 --> 02:29:53,400
и у нас есть максимальный возраст пользователя

3436
02:29:53,400 --> 02:29:55,480
Теперь я могу использовать
константу в функциях

3437
02:29:55,480 --> 02:29:58,690
я могу ее получить

3438
02:29:59,530 --> 02:30:00,800
и что-то с ней сделать

3439
02:30:00,800 --> 02:30:04,090
Она объявлена через "val"
и ее никто не поменяет

3440
02:30:04,090 --> 02:30:06,540
Если вернемся в main

3441
02:30:06,540 --> 02:30:08,090
то мы можем так же ее вызвать

3442
02:30:08,090 --> 02:30:09,290
с помощью нашего
созданного пользователя.

3443
02:30:10,365 --> 02:30:11,900
Если я захочу, чтобы ее
можно было использовать

3444
02:30:11,900 --> 02:30:14,670
внутри класса, но запретить
доступ к нему

3445
02:30:14,670 --> 02:30:17,890
со стороны

3446
02:30:17,890 --> 02:30:19,730
я могу использовать модификатор

3447
02:30:19,730 --> 02:30:22,160
видимости, или иначе модификатор
доступа "private".

3448
02:30:22,160 --> 02:30:23,940
Это сужает видимость этой константы

3449
02:30:23,940 --> 02:30:27,530
и доступна она будет только в
классе где объявлена.

3450
02:30:27,530 --> 02:30:29,770
В main функции вы увидите ошибку
потому что main теперь не видит константу

3451
02:30:29,770 --> 02:30:34,166
но она все еще доступна внутри
класса пользователя.

3452
02:30:34,166 --> 02:30:35,720
Это первый способ создания констант.

3453
02:30:35,720 --> 02:30:39,060
Есть только одна проблема,
чтобы пользоваться

3454
02:30:39,060 --> 02:30:41,040
константой, нам обязательно нужно

3455
02:30:41,040 --> 02:30:44,390
создать экзепляр класса,

3456
02:30:44,390 --> 02:30:46,370
и вызвать user.MAX_AGE

3457
02:30:46,370 --> 02:30:51,370
Но константы бывают априори,
напрмер кол-во океанов,

3458
02:30:53,776 --> 02:30:54,609
И не хотелось бы что-то для этого создавать.

3459
02:30:54,609 --> 02:30:58,690
Для того чтобы константа
была независима от создания объектов

3460
02:30:58,690 --> 02:31:01,170
то мы можем применить уже
известный нам метод -

3461
02:31:01,170 --> 02:31:03,550
создать companion object

3462
02:31:03,550 --> 02:31:05,350
и объявить ее внутри.

3463
02:31:05,350 --> 02:31:10,350
Теперь мы можем использовать "const"
и напишем что возраст так же равен 18

3464
02:31:10,980 --> 02:31:14,410
Теперь мы можем получить доступ к
константе гораздо проще

3465
02:31:14,410 --> 02:31:17,180
и без создания экземпляра класса

3466
02:31:17,180 --> 02:31:19,927
И она еще и локальная для нашего
класса, поэтому нужно только название

3467
02:31:19,927 --> 02:31:23,370
Но если теперь мы напишем user.MAX_AGE

3468
02:31:23,370 --> 02:31:25,600
увидим, что больше она
не привязана к конкретному пользователю.

3469
02:31:25,600 --> 02:31:29,630
Но мы можем получить к ней доступ
через название класса

3470
02:31:29,630 --> 02:31:33,540
и теперь это синглтон

3471
02:31:33,540 --> 02:31:37,100
для класса пользователя

3472
02:31:37,100 --> 02:31:39,960
можем вызвать ее через User.MAX_AGE

3473
02:31:39,960 --> 02:31:42,180
можем вызвать ее через User.MAX_AGE

3474
02:31:42,180 --> 02:31:45,040
Теперь мы можем использовать ее

3475
02:31:45,040 --> 02:31:47,700
где угодно, не создавая при этом

3476
02:31:47,700 --> 02:31:49,560
объект пользователя

3477
02:31:49,560 --> 02:31:51,700
И класс User это что-то вроде
нэймспейса

3478
02:31:51,700 --> 02:31:54,100
для нашей константы

3479
02:31:54,100 --> 02:31:56,920
можно рассуждать так.

3480
02:31:56,920 --> 02:31:58,900
У нас есть есть константа

3481
02:31:58,900 --> 02:32:00,110
которая объявлена в
объекте компаньоне.

3482
02:32:01,456 --> 02:32:03,610
В ходе вашего обучения вы заметите

3483
02:32:03,610 --> 02:32:08,030
что люди обычно создают

3484
02:32:08,030 --> 02:32:11,570
отдельный файл для констант

3485
02:32:11,570 --> 02:32:12,403
допустим constants.kt

3486
02:32:14,399 --> 02:32:16,150
И в нем мы создадим object

3487
02:32:16,150 --> 02:32:17,650
который назовем "константы"

3488
02:32:18,798 --> 02:32:20,915
И вы помните, что object

3489
02:32:20,915 --> 02:32:21,748
это для создания синглтон класса

3490
02:32:21,748 --> 02:32:25,030
И внутри него мы уже можем

3491
02:32:25,030 --> 02:32:29,350
объявить нашу константу
MAX_AGE = 18

3492
02:32:29,350 --> 02:32:33,110
и еще одну, например

3493
02:32:33,110 --> 02:32:35,200
минимальный возраст - 5 лет

3494
02:32:35,200 --> 02:32:36,530
по какой-то причине.

3495
02:32:36,530 --> 02:32:38,970
и внутри main функции

3496
02:32:38,970 --> 02:32:42,140
мы можем вызвать

3497
02:32:42,140 --> 02:32:47,120
наши максимальные и минимальный
возраст, через объект Constants

3498
02:32:47,120 --> 02:32:49,240
который нам доступен в любой момент.

3499
02:32:49,240 --> 02:32:52,240
В Котлине на самом деле не нужно
указывать константы внутри object класса

3500
02:32:52,240 --> 02:32:55,230
можно просто объявлять вершнеуровневые
константы в файле

3501
02:32:55,230 --> 02:32:57,340
они просто будут находиться в файле
и не будут привязаны

3502
02:32:57,340 --> 02:32:58,900
к конкретным названиям

3503
02:32:58,900 --> 02:33:03,320
Напирмер нам нужна такая константа

3504
02:33:03,320 --> 02:33:08,140
Например MAX_AGE = 18

3505
02:33:08,140 --> 02:33:10,899
Теперь мы можем использовать эту
константу тут

3506
02:33:10,899 --> 02:33:11,880
потому что константа находится в корне
нашего файла

3507
02:33:11,880 --> 02:33:13,630
И я так же могу использовать ее
в классе пользователя

3508
02:33:14,944 --> 02:33:18,520
и могу вызвать ее

3509
02:33:18,520 --> 02:33:20,260
Если мы перейдем к определению
константы

3510
02:33:20,260 --> 02:33:23,328
нас выкинет в файл main.kt

3511
02:33:23,328 --> 02:33:25,450
Какие константы лучше использовать?

3512
02:33:25,450 --> 02:33:29,650
Я предпочитаю хранить константы
связанные с классом

3513
02:33:29,650 --> 02:33:32,250
в объекте компаньоне класса

3514
02:33:32,250 --> 02:33:35,030
Это кажется логичным

3515
02:33:35,030 --> 02:33:37,630
И в случае с пользователем
мы можем добавить MAX_AGE сюда

3516
02:33:37,630 --> 02:33:39,580
если это константа только для пользователя.

3517
02:33:40,442 --> 02:33:42,090
Если мне нужна константа, которая будет

3518
02:33:42,090 --> 02:33:44,660
использоваться в разных частях
нашего приложения

3519
02:33:44,660 --> 02:33:47,230
то я предпочитаю создавать
класс синглтон и класть

3520
02:33:47,230 --> 02:33:49,720
в него константы.
сделаем вот такой объект

3521
02:33:49,720 --> 02:33:52,730
и сюда пишем const val и так далее

3522
02:33:52,730 --> 02:33:54,600
"ABC", какое то значени

3523
02:33:54,600 --> 02:33:57,420
и это например какая-то еда

3524
02:33:57,420 --> 02:33:59,050
И теперь у меня есть доступ к этой

3525
02:33:59,050 --> 02:34:02,660
константе из любого места в
приложении, константы в данном случае

3526
02:34:03,940 --> 02:34:07,300
это какие-то дефолтные данные нашего
приложения.

3527
02:34:07,300 --> 02:34:09,330
И скорее всего вы тоже будете так делать

3528
02:34:09,330 --> 02:34:12,290
Если нужны константы то лучше сначала
попытаться привязать их к какому-нибудь

3529
02:34:12,290 --> 02:34:13,690
классу в приложении

3530
02:34:14,891 --> 02:34:17,410
Если вам например не нужно чтобы другие
классы ее видели

3531
02:34:17,410 --> 02:34:20,210
и не могли использовать

3532
02:34:20,210 --> 02:34:22,120
вы можете закрыть их с помощью private

3533
02:34:22,120 --> 02:34:24,390
или если вам вообще нужно значение
для экземпляра вашего классо

3534
02:34:24,390 --> 02:34:27,510
то можете писать константу в поле

3535
02:34:27,510 --> 02:34:31,900
и тоже пометить ее как private

3536
02:34:32,890 --> 02:34:35,460
Если вам константа не нужна
в экземплярах и вы не хотите создавать

3537
02:34:35,460 --> 02:34:38,300
объекты, чтобы ее использовать

3538
02:34:38,300 --> 02:34:39,420
объекты, чтобы ее использовать

3539
02:34:39,420 --> 02:34:41,530
Вы можете использовать

3540
02:34:41,530 --> 02:34:44,020
объект компаньон и повесить

3541
02:34:44,020 --> 02:34:45,620
модификатор доступа private

3542
02:34:46,533 --> 02:34:47,366
внутри объекта компаньона на константу.

3543
02:34:47,366 --> 02:34:49,860
Эта константа все еще будет видима
внутри вашего класса.

3544
02:34:49,860 --> 02:34:51,830
Напишем MAX_AGE тут, все хорошо

3545
02:34:51,830 --> 02:34:55,050
если вернемся в main.kt,
и создадим пользователя

3546
02:34:56,252 --> 02:34:57,540
и создадим пользователя

3547
02:34:59,857 --> 02:35:02,350
и я попытаюсь вызвать MAX_AGE

3548
02:35:02,350 --> 02:35:05,520
то увидим, что константа недоступна
потому что она помечена как private.

3549
02:35:05,520 --> 02:35:08,850
Если я уберу модификатор "private"

3550
02:35:08,850 --> 02:35:13,170
то мы получим доступ к user.MAX_AGE

3551
02:35:14,494 --> 02:35:18,517
Вернем private

3552
02:35:19,500 --> 02:35:20,910
У нас нет доступа к константе

3553
02:35:20,910 --> 02:35:25,140
даже когда это константа класса

3554
02:35:25,140 --> 02:35:26,890
и находится она в объекте компаньоне

3555
02:35:26,890 --> 02:35:29,320
вот на что способен модификатор private

3556
02:35:29,320 --> 02:35:34,270
Небольшой рекап всего
что мы сейчас делали

3557
02:35:34,270 --> 02:35:36,670
Если вам нужны константы,
постарайтесь отнести их к какому-то

3558
02:35:36,670 --> 02:35:37,503
класу, который подходит по смыслу

3559
02:35:37,503 --> 02:35:39,800
Если константа нужна в нескольких местах

3560
02:35:39,800 --> 02:35:41,850
и будет использоваться
нескольким классам

3561
02:35:42,770 --> 02:35:45,080
то я обычно выделяю для этого
какой-то объект

3562
02:35:45,080 --> 02:35:48,080
Я редко выношу константы на верхний
уровень класса

3563
02:35:48,080 --> 02:35:51,910
как вот эту константу foo

3564
02:35:51,910 --> 02:35:54,640
Мое личное мнение, что

3565
02:35:54,640 --> 02:35:57,040
константы в таком виде ни к чему не
прявязаны и рандомно подвешены

3566
02:35:57,040 --> 02:36:00,560
в неисветных местах в коде

3567
02:36:00,560 --> 02:36:02,550
очень легко запутаться и забыть про них.

3568
02:36:02,550 --> 02:36:04,580
В моих приложениях вещи строго организованы

3569
02:36:04,580 --> 02:36:06,200
Но все зависит от вашего приложения
и кейсов использования констант,

3570
02:36:06,200 --> 02:36:08,960
но вот такими разными способами
вы можете созжавать константы в Котлин.

3571
02:36:08,960 --> 02:36:12,360
Давайте представим что нам нужен

3572
02:36:12,360 --> 02:36:13,330
новый пользователь

3573
02:36:13,330 --> 02:36:17,750
и у него нужно указать
любимый город

3574
02:36:17,750 --> 02:36:19,560
в изменяемй переменной

3575
02:36:20,460 --> 02:36:22,290
и мы можем допустить что это строка

3576
02:36:23,210 --> 02:36:26,530
По дефолту мы должны
проинициализировать это поле

3577
02:36:26,530 --> 02:36:29,208
иначе у нас будет ошибка о том

3578
02:36:29,208 --> 02:36:30,041
что переменная непроинициализированна.

3579
02:36:30,041 --> 02:36:32,840
И мы можем указать пустую строку
чтобы это работало.

3580
02:36:32,840 --> 02:36:36,830
И теперь в функции "toString"

3581
02:36:36,830 --> 02:36:38,310
мы можем вывести

3582
02:36:38,310 --> 02:36:41,783
что любимый город нашего

3583
02:36:43,330 --> 02:36:47,536
пользователя такой-то.

3584
02:36:47,536 --> 02:36:48,501
Давайте теперь выведем на экран.

3585
02:36:48,501 --> 02:36:51,900
вернемся в main функцию

3586
02:36:51,900 --> 02:36:55,580
И внутри можем создать пользователя

3587
02:36:55,580 --> 02:36:58,161
и вывести его через println

3588
02:36:58,161 --> 02:36:59,266
в консоль.

3589
02:36:59,266 --> 02:37:01,080
И в консоли мы видим что

3590
02:37:01,080 --> 02:37:03,930
любимый город пустой,
не очень полезная информация.

3591
02:37:03,930 --> 02:37:06,330
В Котлине есть способ сказать компилятору

3592
02:37:06,330 --> 02:37:10,210
что мы не будем инициализировать
переменную сразу

3593
02:37:10,210 --> 02:37:12,160
но к моменту вызова она точно будет
проинициализированна

3594
02:37:12,160 --> 02:37:15,380
и поэтому в момент объявления мы ничего

3595
02:37:15,380 --> 02:37:17,870
в нее не запшем, но дадим компилятору

3596
02:37:17,870 --> 02:37:20,120
понять, что мы точно проинициализируем

3597
02:37:20,120 --> 02:37:22,890
переменную как можно быстрее.

3598
02:37:22,890 --> 02:37:24,410
И получается, что нашу переменную
мы объявили,

3599
02:37:24,410 --> 02:37:29,087
но не можем ее использовать
сразу

3600
02:37:30,470 --> 02:37:31,830
но мы говорим компилятору, что это нормально

3601
02:37:31,830 --> 02:37:35,280
и мы ее обязательно проинициализируем
перед использованием.

3602
02:37:35,280 --> 02:37:38,490
Допустим, что по какой-то причине мы забыли
проинициализировать переменную

3603
02:37:38,490 --> 02:37:39,790
и во время выполнения программы,

3604
02:37:39,790 --> 02:37:42,100
когда мы вызовем метод toString,

3605
02:37:42,100 --> 02:37:43,330
давайте вернемся в main файл

3606
02:37:43,330 --> 02:37:47,130
Мы не сказали какой будет любимый город

3607
02:37:47,130 --> 02:37:49,920
ПОэтому, если запустим

3608
02:37:49,920 --> 02:37:52,100
то Котлин выдаст ошибку

3609
02:37:52,100 --> 02:37:55,330
что lateinit поле должно

3610
02:37:55,330 --> 02:37:58,325
быть проинициализированно
перед использованием

3611
02:37:58,325 --> 02:37:59,940
а сейчас в нем ничего нет

3612
02:37:59,940 --> 02:38:01,620
И Котлин как бы говорит:
"Вы обежали, что что-то будет

3613
02:38:01,620 --> 02:38:04,890
в этом поле к моменту использования,
но вы так ничего и не

3614
02:38:04,890 --> 02:38:07,220
положили, я так работать не могу"

3615
02:38:07,220 --> 02:38:12,220
Потому что к моменту вызова на строке 8

3616
02:38:12,380 --> 02:38:13,790
вот тут

3617
02:38:13,790 --> 02:38:16,190
мы использовали функцию с вызовом
lateinit поля,

3618
02:38:17,280 --> 02:38:19,860
которое не было проинициализированно,
в таких случаях программа навернется,

3619
02:38:19,860 --> 02:38:21,660
и Котлин выбросит

3620
02:38:22,534 --> 02:38:23,367
исключение.

3621
02:38:23,367 --> 02:38:26,450
Это можно легко поправить

3622
02:38:26,450 --> 02:38:29,840
А сама ошибка дает понять

3623
02:38:30,731 --> 02:38:32,030
что мое приложение работает неправильно

3624
02:38:32,030 --> 02:38:34,090
и мне нужно проинициализировать
поле для нормальной работы

3625
02:38:34,090 --> 02:38:36,170
и нужно это поле проинициализировать

3626
02:38:36,170 --> 02:38:39,093
иначе все взорвется

3627
02:38:39,093 --> 02:38:40,220
Давайте перед выводом

3628
02:38:40,220 --> 02:38:42,780
присвоим пользователю любимый город

3629
02:38:42,780 --> 02:38:46,820
например "Newark"
и запустим

3630
02:38:49,489 --> 02:38:50,322
Это конечно не мой любимый город,
но пусть будет для примера,

3631
02:38:50,322 --> 02:38:53,960
и теперь в выводе будет полное
имя пользователя и любимый город

3632
02:38:53,960 --> 02:38:55,290
И никаких больше ошибок.

3633
02:38:55,290 --> 02:38:57,600
В принципе можно указать и пустую строку

3634
02:38:57,600 --> 02:38:58,750
и все по прежнему будет работать

3635
02:38:58,750 --> 02:39:00,830
Главное проинициализировать хоть чем-то.

3636
02:39:00,830 --> 02:39:04,210
Я могу записать "Минеаполис"

3637
02:39:05,260 --> 02:39:07,870
это один из моих любимых городов

3638
02:39:07,870 --> 02:39:11,320
и мы увидим, что выводится Минеаполис.

3639
02:39:11,320 --> 02:39:14,780
Так мы используем ключевое слово
lateinit и откладываем

3640
02:39:14,780 --> 02:39:16,580
инициализацию полей в приложении.

3641
02:39:17,575 --> 02:39:18,420
Тип может быть разный, это может
быть строка или какой-то объект

3642
02:39:18,420 --> 02:39:19,990
И вообще любой тип

3643
02:39:19,990 --> 02:39:23,880
Мы просто говоорим компилятору,
что у нас есть

3644
02:39:23,880 --> 02:39:27,790
какая-то переменная и
к моменту использования

3645
02:39:27,790 --> 02:39:30,159
мы что-то туда положим,
не буспокойся.

3646
02:39:30,159 --> 02:39:31,780
И я пока ничего в него не кладу
а просто пишу lateinit

3647
02:39:31,780 --> 02:39:35,552
что означает - "поздняя инициализация"

3648
02:39:35,552 --> 02:39:37,040
что означает - "поздняя инициализация"

3649
02:39:37,950 --> 02:39:40,110
Если вы забудете проинициализировать,
то приложение сломается.

3650
02:39:40,110 --> 02:39:41,330
Еще одна важная вещь.

3651
02:39:41,330 --> 02:39:43,430
Если мы захотим, чтобы lateinit

3652
02:39:43,430 --> 02:39:44,920
поле было неизменяемым

3653
02:39:44,920 --> 02:39:46,620
и попробуем написать val

3654
02:39:46,620 --> 02:39:49,996
то у нас ничего не выйдет

3655
02:39:49,996 --> 02:39:50,829
потому что при использовании lateinit
переменная должна быть var.

3656
02:39:50,829 --> 02:39:52,620
А почему так?
Если подумать, то нам

3657
02:39:52,620 --> 02:39:57,620
придется изменить ее
в момент, когда мы

3658
02:39:57,690 --> 02:39:59,538
сделаем инициализацию

3659
02:39:59,538 --> 02:40:00,800
Поэтому нужно использовать var

3660
02:40:00,800 --> 02:40:03,240
иначе мы ничего не сможем в нее записать.

3661
02:40:03,240 --> 02:40:07,210
val можем использовать, но тогда
нам нужно сразу записать

3662
02:40:07,210 --> 02:40:08,480
значение и удалить ключевое слово lateinit

3663
02:40:08,480 --> 02:40:11,750
и теперь можем записать "NYC"

3664
02:40:11,750 --> 02:40:13,410
и это будет работать.

3665
02:40:13,410 --> 02:40:18,410
Но если хотим lateinit, то нужно ставить var

3666
02:40:18,780 --> 02:40:20,840
И так вы можете откладывать инициализацию

3667
02:40:20,840 --> 02:40:21,890
переменных в Котлин.

3668
02:40:23,150 --> 02:40:25,720
В Котлине, как и во многих других
объектно ориентированных языках

3669
02:40:25,720 --> 02:40:28,980
Классы могут содержать другие классы.

3670
02:40:28,980 --> 02:40:32,020
Допустим у нас есть класс "Машина"

3671
02:40:32,020 --> 02:40:35,350
и у машины есть брэнд

3672
02:40:35,350 --> 02:40:36,790
пусть брэнд будет строкой

3673
02:40:36,790 --> 02:40:39,870
и по дефолту всегда будет "unknown"

3674
02:40:39,870 --> 02:40:42,250
И, допустим, что у машины будет

3675
02:40:42,250 --> 02:40:44,690
класс руля внутри.

3676
02:40:44,690 --> 02:40:46,740
Теперь у нас есть класс руля, который

3677
02:40:46,740 --> 02:40:51,220
находится внутри класса машины

3678
02:40:51,220 --> 02:40:55,290
И допустим у руля ест название

3679
02:40:55,290 --> 02:40:58,370
давайте сделаем его var

3680
02:40:58,370 --> 02:41:03,277
и даже какая-то функция

3681
02:41:05,597 --> 02:41:07,980
которая что-то будет делать

3682
02:41:07,980 --> 02:41:11,080
Путь это будет функция info,

3683
02:41:11,080 --> 02:41:14,030
которая просто выводит информацию
о руле

3684
02:41:15,200 --> 02:41:17,870
напишем println(name)

3685
02:41:17,870 --> 02:41:19,750
Если мы хотим обращаться к этому классу

3686
02:41:19,750 --> 02:41:23,150
то нам нужно создать
экземпляр класса руля

3687
02:41:23,150 --> 02:41:25,979
сделаем переменную sw

3688
02:41:25,979 --> 02:41:29,610
и через класс машины, обратимся
к классу руля и вызовем конструктор

3689
02:41:29,610 --> 02:41:32,220
и теперь у переменной sw сможем
вызвать функцию info

3690
02:41:32,220 --> 02:41:34,820
Если запустим то увидим

3691
02:41:34,820 --> 02:41:37,280
что нам вывелась информация о руле

3692
02:41:37,280 --> 02:41:39,910
И мы не ограниченны в создании
классов внутри классов

3693
02:41:39,910 --> 02:41:42,990
Можем создавать их сколько угодно

3694
02:41:42,990 --> 02:41:46,470
Давайте сделаем еще один
и назовем его

3695
02:41:46,470 --> 02:41:47,560
"коробка передач".

3696
02:41:48,830 --> 02:41:50,600
Представим что мы делаем

3697
02:41:50,600 --> 02:41:52,750
какую-то программу для автомобилей

3698
02:41:52,750 --> 02:41:56,520
и внутри объявим var переменную

3699
02:41:56,520 --> 02:41:58,970
с типом коробки передач
и пусть она будет автоматическая

3700
02:42:00,360 --> 02:42:03,180
И тут же мы можем определить функцию

3701
02:42:03,180 --> 02:42:07,360
которая будет переключать передачи

3702
02:42:07,360 --> 02:42:10,430
на деле просто будет выводить текст

3703
02:42:12,031 --> 02:42:13,480
и текст будет "передача изменилась"

3704
02:42:17,250 --> 02:42:19,120
И теперь нам нужно

3705
02:42:20,170 --> 02:42:22,420
у нас уже есть экземпляр руля,
но нет экземпляра коробки передач

3706
02:42:22,420 --> 02:42:27,090
мы можем так же его объявить обратившись

3707
02:42:28,150 --> 02:42:30,510
через Vehicle

3708
02:42:32,170 --> 02:42:34,320
И теперь мы можем вызвать функцию shift()

3709
02:42:35,620 --> 02:42:37,220
И после запуска мы увидим

3710
02:42:37,220 --> 02:42:39,030
информацию о руле

3711
02:42:39,030 --> 02:42:40,660
а потом сообщение о переключении
передачи;

3712
02:42:40,660 --> 02:42:44,701
Если мы продублируем вызов метода

3713
02:42:44,701 --> 02:42:47,080
мы увидим сообщение о переключении
дважды

3714
02:42:47,080 --> 02:42:50,170
И так мы можем объявлять классы
внутри других классов

3715
02:42:50,170 --> 02:42:51,930
Заметьте, что мы ничего не
делали с брэндом машины

3716
02:42:51,930 --> 02:42:54,100
можем добавить функцию, которая тоже
выводит информацию о брэнде

3717
02:42:54,100 --> 02:42:59,100
допустим, она просто

3718
02:42:59,810 --> 02:43:02,760
выводит ее в консоль.

3719
02:43:03,620 --> 02:43:07,152
выводит ее в консоль.

3720
02:43:07,152 --> 02:43:09,282
И брэнд сделаем var, потому что
скорее всего он можжет измениться

3721
02:43:09,282 --> 02:43:10,115
скорее всего он можжет измениться

3722
02:43:10,115 --> 02:43:15,070
И теперь создадим экземпляо

3723
02:43:16,250 --> 02:43:20,300
И сразу заменим

3724
02:43:20,300 --> 02:43:25,037
брэнд на "Fiat" и выведем
название в консоль

3725
02:43:27,354 --> 02:43:29,280
И мы должны увидеть сначала брэнд

3726
02:43:29,280 --> 02:43:30,900
потом информацию о руле

3727
02:43:30,900 --> 02:43:34,050
и дважды переключение передачи

3728
02:43:34,050 --> 02:43:37,210
таким образом мы создаем вложенные
классы в Котлине.

3729
02:43:37,210 --> 02:43:40,580
Такой подход полезен, когда
классы связаны друг с другом

3730
02:43:40,580 --> 02:43:43,400
и легче держать иерархию
классов в одном месте

3731
02:43:43,400 --> 02:43:44,540
Например у нас есть машина

3732
02:43:44,540 --> 02:43:46,430
а которой есть руль

3733
02:43:46,430 --> 02:43:49,297
И при создании руля мы уже видим
что это руль машины

3734
02:43:49,297 --> 02:43:50,130
по названиям

3735
02:43:50,130 --> 02:43:52,030
И в программировани очень

3736
02:43:52,030 --> 02:43:54,010
много подобной связи в объектах.

3737
02:43:55,094 --> 02:43:56,960
И с помощью вложенных классов
можно устроить эту организацию

3738
02:43:57,970 --> 02:44:00,310
В котлине очень просто
создавать вложенные классы

3739
02:44:00,310 --> 02:44:02,760
В своем классе вы можете напрямую создать
вложенный класс

3740
02:44:02,760 --> 02:44:04,850
и создавать иерархию зависимостей типов

3741
02:44:04,850 --> 02:44:07,550
Но иногда вам понадобится из
вложенного класса получить

3742
02:44:08,470 --> 02:44:10,870
поступ к полям внешнего класса

3743
02:44:10,870 --> 02:44:12,890
поступ к полям внешнего класса

3744
02:44:12,890 --> 02:44:14,910
давайте допустим, что класс
руля в информации должен

3745
02:44:14,910 --> 02:44:16,430
писать название брэнда машины

3746
02:44:16,430 --> 02:44:21,430
перепишем немного наш

3747
02:44:23,100 --> 02:44:27,990
вывод в консоль

3748
02:44:30,614 --> 02:44:32,687
Сменим название руля на "кожаный"

3749
02:44:35,750 --> 02:44:39,400
теперь это руль из кожи.

3750
02:44:41,200 --> 02:44:43,930
И заметим что у нас появилась ошибка,
брэнд недоступен в классе руля

3751
02:44:43,930 --> 02:44:47,660
Причина этому - вложенные

3752
02:44:47,660 --> 02:44:50,890
классы не получают доступа к полям

3753
02:44:50,890 --> 02:44:52,820
класса где они объявлены

3754
02:44:52,820 --> 02:44:54,830
Если мы хотим иметь доступ к полям
внешего класса

3755
02:44:54,830 --> 02:44:58,330
нам нужно использовать ключевое слово
"inner"

3756
02:44:58,330 --> 02:45:00,880
И теперь у нашины есть "внутренний"
класс руля

3757
02:45:00,880 --> 02:45:02,700
который имеет доступ к полям машины

3758
02:45:02,700 --> 02:45:05,310
мы видим, что ошибка в выводе
пропала

3759
02:45:05,310 --> 02:45:07,640
Давайте удалим этот код

3760
02:45:08,790 --> 02:45:11,750
Оставим изменение брэнда на "Fiat"
и вывод информации

3761
02:45:11,750 --> 02:45:16,110
Теперь вы можете заметить, что
поломался вызов конструктора

3762
02:45:16,110 --> 02:45:18,620
для руля. Теперь этот конструктор
может вызывать

3763
02:45:18,620 --> 02:45:19,900
только экземпляр машины.

3764
02:45:20,760 --> 02:45:23,240
Это значит, что из-за того что
руль имеет доступ к полям машины

3765
02:45:23,240 --> 02:45:25,680
это значит что нам нужен созданный
объект машины, чтобы создать руль

3766
02:45:26,929 --> 02:45:29,900
и руль теперь всегда будет держать
ссылку на объект машины к которой он привязан

3767
02:45:29,900 --> 02:45:33,660
И мы не можем использовать название
класса для создания руля

3768
02:45:33,660 --> 02:45:35,240
нам нужно позвать

3769
02:45:35,240 --> 02:45:37,450
экземпляр нашей машины

3770
02:45:37,450 --> 02:45:40,400
У нас уже есть готовый экземпляр

3771
02:45:40,400 --> 02:45:41,950
И нам нужно заменить вызов

3772
02:45:41,950 --> 02:45:44,130
класса на вызов экземпляра

3773
02:45:44,130 --> 02:45:46,050
просто поменять "V" с большой
на маленькую

3774
02:45:46,050 --> 02:45:49,730
давайте просто переименум
и назовем машину "myCar"

3775
02:45:49,730 --> 02:45:52,190
теперь лучше.

3776
02:45:52,190 --> 02:45:54,840
и теперь я могу вызвать конструктор

3777
02:45:54,840 --> 02:45:57,040
руля с помощью myCar

3778
02:45:57,040 --> 02:45:58,350
и руль будет хранить ссылку на myCar
и знать о ее брэнде.

3779
02:45:58,350 --> 02:46:01,370
давайте выведем информацию о руле

3780
02:46:01,370 --> 02:46:02,970
запустим и выведем

3781
02:46:02,970 --> 02:46:05,950
все в консоль.

3782
02:46:05,950 --> 02:46:09,590
И теперь мы видим информацию
он нашей машины - это Фиат

3783
02:46:09,590 --> 02:46:12,440
и вывод от нашего руля, который
выводит ту же марку машины

3784
02:46:12,440 --> 02:46:16,230
Из-за того что коробка передач
это все еще вложенный класс

3785
02:46:16,230 --> 02:46:19,800
мы не можем вызвать myCar.Transmission()

3786
02:46:20,840 --> 02:46:23,170
потому что это вложенный класс и
экземпляр машины не межет его создать

3787
02:46:23,170 --> 02:46:25,870
И нам все еще нужно вызывать

3788
02:46:25,870 --> 02:46:30,230
создание через названия классов

3789
02:46:31,370 --> 02:46:34,590
Если мы хотим сделать
коробку внутренним классом

3790
02:46:34,590 --> 02:46:36,674
нам нужно просто пришпандорить
ключевое слово inner

3791
02:46:36,674 --> 02:46:37,520
У нас, конечно сломается
наше создание экземпляра

3792
02:46:37,520 --> 02:46:40,250
и нам нужно использовать готовый
экземпляр машины, чтобы создать

3793
02:46:40,250 --> 02:46:42,440
коробку передач. Теперь коробка
будет держать ссылку на машину.

3794
02:46:42,440 --> 02:46:45,630
И теперь, когда мы создаем экземпляр
коробки передач

3795
02:46:46,922 --> 02:46:50,230
она будет держать ссылку на нашу машину
и знать про все ее поля

3796
02:46:51,450 --> 02:46:53,150
И так вы можеме создавать внутренние классы

3797
02:46:53,150 --> 02:46:56,110
которы держат ссылку на
свои внешние классы

3798
02:46:56,110 --> 02:46:58,150
Often during development,
you'll need to create

3799
02:46:58,150 --> 02:47:01,930
some type of construct that shows you

3800
02:47:01,930 --> 02:47:04,750
what different types
you have to work with.

3801
02:47:04,750 --> 02:47:07,080
And for example, we might
wanna have something

3802
02:47:07,080 --> 02:47:08,120
different account types.

3803
02:47:08,120 --> 02:47:12,630
Maybe we have various different
users who have account types

3804
02:47:12,630 --> 02:47:15,340
and they look something like this.

3805
02:47:15,340 --> 02:47:19,210
So we have one that's
a bronze account type,

3806
02:47:19,210 --> 02:47:21,070
we have a silver account type.

3807
02:47:21,070 --> 02:47:23,650
There's a gold and there's a platinum.

3808
02:47:25,726 --> 02:47:28,540
Very often you'll see these,
for example, the credit cards

3809
02:47:28,540 --> 02:47:30,740
or different types of gym memberships

3810
02:47:30,740 --> 02:47:32,370
or something like that.

3811
02:47:32,370 --> 02:47:34,290
And if you're modeling
something like this,

3812
02:47:34,290 --> 02:47:36,766
you'll wanna create a user defined type.

3813
02:47:36,766 --> 02:47:38,912
And that's typically done with an enum.

3814
02:47:38,912 --> 02:47:41,760
And to define an enum, you will
use the keywords enum class.

3815
02:47:41,760 --> 02:47:44,840
And then for example, I'm gonna
call this one account type.

3816
02:47:44,840 --> 02:47:46,920
And then by default, inside of enums,

3817
02:47:46,920 --> 02:47:49,180
if you give the names of the types,

3818
02:47:49,180 --> 02:47:51,570
which is your user defined
type, you uppercase them.

3819
02:47:51,570 --> 02:47:56,440
So we'll say bronze, and then
they're separated by commas.

3820
02:47:56,440 --> 02:48:00,420
So silver, gold, platinum.

3821
02:48:01,940 --> 02:48:02,800
And then if I wanna use the account types,

3822
02:48:02,800 --> 02:48:04,820
which we'll get rid of this now,

3823
02:48:04,820 --> 02:48:09,100
I can just say account type.gold.

3824
02:48:10,060 --> 02:48:11,840
And now I have an instance of gold,

3825
02:48:11,840 --> 02:48:13,540
so I can start representing
something like that.

3826
02:48:13,540 --> 02:48:16,090
So if I were to just to print line this,

3827
02:48:17,320 --> 02:48:20,290
and these are very useful
inside of various different

3828
02:48:20,290 --> 02:48:22,950
if statements and conditional
clauses and so forth,

3829
02:48:22,950 --> 02:48:24,350
so we can see gold there.

3830
02:48:24,350 --> 02:48:27,450
Now, this is something in Kotlin.

3831
02:48:27,450 --> 02:48:29,190
Anytime you're interacting
with an application,

3832
02:48:29,190 --> 02:48:34,190
a lot of times you'll be
talking to API and perhaps

3833
02:48:34,280 --> 02:48:37,820
you'll get a value down a that's
gold like that from an API.

3834
02:48:37,820 --> 02:48:39,750
And so you need to create
an account type off of that.

3835
02:48:39,750 --> 02:48:44,170
And to do that, you can use
the account type that value of,

3836
02:48:44,170 --> 02:48:46,110
and then perhaps you would say,

3837
02:48:46,110 --> 02:48:48,860
so let's say we had a
string that was given to us

3838
02:48:48,860 --> 02:48:51,230
from an input somewhere, maybe an API,

3839
02:48:52,150 --> 02:48:57,130
and we'll call this account type from API.

3840
02:48:59,161 --> 02:49:00,540
And then we'll just call it gold.

3841
02:49:00,540 --> 02:49:03,580
And if we wanna in turn
this gold right here

3842
02:49:03,580 --> 02:49:08,580
into an actual account type,
then we'll say account type,

3843
02:49:08,760 --> 02:49:12,550
we'll see value of, and we'll
say account type from API.

3844
02:49:12,550 --> 02:49:16,180
Now, if we've run this,
we're gonna run this here

3845
02:49:16,180 --> 02:49:18,330
and we'll see that well, that didn't work.

3846
02:49:18,330 --> 02:49:21,580
There's no enum constant by
the name of account.gold,

3847
02:49:21,580 --> 02:49:23,430
but we do see one here.

3848
02:49:23,430 --> 02:49:25,084
So what's going on here?

3849
02:49:25,084 --> 02:49:26,930
Well, the reason is, is because
this is an uppercase value.

3850
02:49:26,930 --> 02:49:30,460
So we can just say here to uppercase.

3851
02:49:30,460 --> 02:49:32,970
And if we run this again,
we'll see that it runs

3852
02:49:32,970 --> 02:49:34,230
a compile is just fine.

3853
02:49:34,230 --> 02:49:35,540
That gives us our account types.

3854
02:49:35,540 --> 02:49:37,790
So now we can actually say print line

3855
02:49:38,640 --> 02:49:41,230
and we're gonna actually say account type,

3856
02:49:41,230 --> 02:49:44,230
and it'll say gold as we see here.

3857
02:49:44,230 --> 02:49:46,940
So now we actually have an
instance of gold, which is nice.

3858
02:49:46,940 --> 02:49:48,050
So we can actually account type,

3859
02:49:48,050 --> 02:49:50,660
does this actually equal
and account type of gold?

3860
02:49:51,740 --> 02:49:53,640
So this should return
true, which we get running

3861
02:49:53,640 --> 02:49:55,010
and say, it's true.

3862
02:49:55,010 --> 02:49:57,160
So now we can actually enter work with

3863
02:49:57,160 --> 02:49:58,870
these different types of enums.

3864
02:49:58,870 --> 02:50:01,350
Now, a lot of times this is very useful

3865
02:50:01,350 --> 02:50:03,370
inside of conditionals and different types

3866
02:50:03,370 --> 02:50:04,203
of things like that.

3867
02:50:04,203 --> 02:50:06,650
So you might have your user class,

3868
02:50:06,650 --> 02:50:09,120
which if we go back over here
to our typical user class

3869
02:50:09,120 --> 02:50:12,070
that we have, we might have
a user that's associated

3870
02:50:12,070 --> 02:50:12,903
with account type.

3871
02:50:12,903 --> 02:50:16,560
So we might have a var account type,

3872
02:50:16,560 --> 02:50:20,180
and that would be an
account type of whatever,

3873
02:50:23,620 --> 02:50:26,280
and we might wanna default
it to account type.bronze.

3874
02:50:26,280 --> 02:50:28,540
Maybe that's what it defaults to,

3875
02:50:28,540 --> 02:50:32,020
or instead of doing it here,
we could actually just do it,

3876
02:50:32,020 --> 02:50:34,170
put this all up inside of the constructor

3877
02:50:34,170 --> 02:50:36,480
and have it use a default value.

3878
02:50:36,480 --> 02:50:39,220
So account type, and we don't need that

3879
02:50:39,220 --> 02:50:41,010
and say account type
equals, but we do need that.

3880
02:50:41,010 --> 02:50:43,280
Excuse me, account type
people's the bronze.

3881
02:50:43,280 --> 02:50:45,130
And then if we decide to override it,

3882
02:50:45,981 --> 02:50:49,650
for example, we could
say val user equals user,

3883
02:50:52,392 --> 02:50:54,247
and then we don't wanna say Donn Felker.

3884
02:50:55,900 --> 02:50:58,697
And then I don't have it
provide an account type.

3885
02:50:58,697 --> 02:50:59,830
But if I would, if I'd like to, I can say,

3886
02:50:59,830 --> 02:51:02,210
well, he's actually going
to be a platinum account,

3887
02:51:02,210 --> 02:51:03,043
for whatever reason,

3888
02:51:03,043 --> 02:51:05,240
he's a good customer
or something like that.

3889
02:51:06,500 --> 02:51:08,610
And now I can actually
start working with this.

3890
02:51:08,610 --> 02:51:13,610
And then in my application,
I can say user.account type,

3891
02:51:13,840 --> 02:51:16,500
I can then do some
different types of things

3892
02:51:16,500 --> 02:51:19,136
with conditionals inside of that

3893
02:51:19,136 --> 02:51:19,969
and then start working with it.

3894
02:51:19,969 --> 02:51:21,590
And it gives us some user-defined types

3895
02:51:21,590 --> 02:51:23,300
that are basically strongly typed.

3896
02:51:24,321 --> 02:51:26,180
We're not working with strings
doing string comparisons,

3897
02:51:26,180 --> 02:51:28,100
and we can work with them accordingly.

3898
02:51:29,280 --> 02:51:33,560
That's how you can create and
work with very basic enums

3899
02:51:33,560 --> 02:51:35,220
and define them in Kotlin.

3900
02:51:36,340 --> 02:51:38,280
Иногда бывает полезным вместе
с enum передавать какое-то

3901
02:51:38,280 --> 02:51:39,670
дополнительное значение

3902
02:51:40,752 --> 02:51:42,927
На примере нашего абонемента
в спортивный зал

3903
02:51:42,927 --> 02:51:46,590
давайте представим, что
бронзовый абонемент

3904
02:51:46,590 --> 02:51:50,490
дает вам 10% скидку.

3905
02:51:50,490 --> 02:51:53,840
Серебряный - 15%

3906
02:51:53,840 --> 02:51:56,320
Золотой 20%

3907
02:51:56,320 --> 02:51:59,620
а платиновый целых 25%

3908
02:51:59,620 --> 02:52:03,360
например бронзовый абонемент
на месяц

3909
02:52:03,360 --> 02:52:04,830
и с увеличением кол-ва месяцев

3910
02:52:04,830 --> 02:52:07,500
у вас появляется все больше

3911
02:52:07,500 --> 02:52:09,090
и больше скидок.

3912
02:52:09,090 --> 02:52:10,250
Как нам загнать эти значения в enum?

3913
02:52:10,250 --> 02:52:12,330
Проще простого, у enum

3914
02:52:12,330 --> 02:52:13,770
нужно объявить конструктор

3915
02:52:13,770 --> 02:52:17,680
И заведем поле val с велечиной скидки

3916
02:52:17,680 --> 02:52:19,730
и сожно указать тип

3917
02:52:19,730 --> 02:52:22,510
для простоты сделаем Int,
но можно Float, или ваш собственный тип

3918
02:52:22,510 --> 02:52:24,210
Теперь мы видим кучу ошибок

3919
02:52:24,210 --> 02:52:27,300
потому что у enum теперь нет
дефолтного конструктора

3920
02:52:27,300 --> 02:52:29,170
мы можем сделать

3921
02:52:30,217 --> 02:52:31,820
дефолтное значение

3922
02:52:31,820 --> 02:52:33,240
например это будет 10%

3923
02:52:33,240 --> 02:52:35,160
Теперь все энамы под капотом
будут содержать значение 10

3924
02:52:35,160 --> 02:52:37,029
но давайте не будем так
все оставлять

3925
02:52:37,029 --> 02:52:40,160
И укажем для каждого

3926
02:52:40,160 --> 02:52:43,040
абонемента конкретное

3927
02:52:43,040 --> 02:52:46,240
значение скидки.

3928
02:52:46,240 --> 02:52:50,670
Укажем 10,
для сребряного 15

3929
02:52:50,670 --> 02:52:54,720
золотому - 20
и платиновому 25

3930
02:52:55,600 --> 02:52:57,230
И все, все так просто

3931
02:52:57,230 --> 02:52:59,710
Мы теперь можем почистить
все комментарии

3932
02:53:00,840 --> 02:53:02,910
И если мы теперь выведем

3933
02:53:02,910 --> 02:53:06,180
в консоль какой-нибудь энам

3934
02:53:06,180 --> 02:53:09,500
то мы все еще увидим его название.

3935
02:53:09,500 --> 02:53:12,217
Но теперь мы можем вывести поле
discountPercent у энама

3936
02:53:12,217 --> 02:53:13,530
и это выведет наше новое число.

3937
02:53:13,530 --> 02:53:15,030
И если запустим увидим

3938
02:53:15,030 --> 02:53:17,210
энам GOLD и скидку 20%

3939
02:53:17,210 --> 02:53:22,046
Но и это не предел,

3940
02:53:22,046 --> 02:53:23,840
мы можем добавить какой-нибудь
другой параметр

3941
02:53:23,840 --> 02:53:28,840
напишем val и например
кол-во месяцев

3942
02:53:29,270 --> 02:53:30,690
пусть это тоже будет Int

3943
02:53:30,690 --> 02:53:32,650
и опять видим проблему с энамами

3944
02:53:32,650 --> 02:53:36,370
И для бронзы это будет
один месяц

3945
02:53:36,370 --> 02:53:39,360
для серебряного пять

3946
02:53:39,360 --> 02:53:41,610
для золота - 10

3947
02:53:41,610 --> 02:53:44,330
и для платинового 15 месяцев.

3948
02:53:44,330 --> 02:53:45,830
И это минимальное число для
каждого абонемента.

3949
02:53:45,830 --> 02:53:48,100
И так я могу легко заводить

3950
02:53:48,100 --> 02:53:49,300
новые типы абонементов работая

3951
02:53:49,300 --> 02:53:51,690
с енамом как с небольшой иерархией объектов

3952
02:53:51,690 --> 02:53:53,970
у которых есть процент скидки

3953
02:53:53,970 --> 02:53:55,910
и кол-во месяцев.

3954
02:53:55,910 --> 02:53:57,580
И конечно название

3955
02:53:57,580 --> 02:54:01,810
нового типа абонемента

3956
02:54:01,810 --> 02:54:05,230
И у нас будут разные абонементы: бронзовый
серебряный, золотой и так далее

3957
02:54:06,069 --> 02:54:08,120
И у них у всех будут определены

3958
02:54:09,450 --> 02:54:10,730
скидки и кол-во месяцев

3959
02:54:10,730 --> 02:54:12,860
как обязательные параметры.

3960
02:54:12,860 --> 02:54:15,732
И это все будут строго

3961
02:54:15,732 --> 02:54:16,565
типизированные переменные в коде.

3962
02:54:16,565 --> 02:54:19,090
И например, я знаю

3963
02:54:19,090 --> 02:54:21,530
что у меня бэкенд присылает

3964
02:54:21,530 --> 02:54:24,240
тип абонемента и я могу

3965
02:54:24,240 --> 02:54:27,950
использовать функцию valueOf
в нее передать строку

3966
02:54:27,950 --> 02:54:30,500
и сделать у нее все буквы заглавными

3967
02:54:30,500 --> 02:54:33,080
и сделать у нее все буквы заглавными

3968
02:54:33,080 --> 02:54:36,850
И давайте, чтобы не повторяться

3969
02:54:36,850 --> 02:54:38,600
с выводами цифр

3970
02:54:40,370 --> 02:54:43,170
создадим платиновый абонемент

3971
02:54:44,590 --> 02:54:46,950
И если запустим, увидим, что создался

3972
02:54:46,950 --> 02:54:49,150
платиновый enum.

3973
02:54:49,150 --> 02:54:52,875
И теперь мы можем вывести..

3974
02:54:52,875 --> 02:54:56,700
Давайте просто скопируем дважды
и выведем скидку

3975
02:54:56,700 --> 02:54:58,290
и кол-во месяцев

3976
02:54:59,490 --> 02:55:00,330
И что мы сделали тут -

3977
02:55:00,330 --> 02:55:01,750
опираясь на строку мы создали из нее

3978
02:55:01,750 --> 02:55:04,840
enum, который подходил по названию

3979
02:55:05,863 --> 02:55:06,920
и смогли вывести все значения этого энама.

3980
02:55:06,920 --> 02:55:09,870
И это реальный кейс, когда вам
будет приходить значение из базы данных

3981
02:55:09,870 --> 02:55:11,980
и вы будете трансформировать его

3982
02:55:11,980 --> 02:55:14,690
в кокой-то энам во время
выполнения программы.

3983
02:55:14,690 --> 02:55:16,980
И в консоль вывелся платиновый

3984
02:55:16,980 --> 02:55:19,250
абонемент с 25% скидки

3985
02:55:19,250 --> 02:55:21,830
и минимальным кол-вом месяцев 15

3986
02:55:21,830 --> 02:55:24,210
И таким образом вы можете
передавать в энамы

3987
02:55:24,210 --> 02:55:25,780
дополнительные параметры.

3988
02:55:27,170 --> 02:55:29,320
Давайте разберем еще одну вещь
на нашем примере абонементов

3989
02:55:29,320 --> 02:55:32,240
давайте допустим, что скидка
неизвестна сразу

3990
02:55:32,240 --> 02:55:34,970
и должна быть рассчитана индивидуально

3991
02:55:34,970 --> 02:55:36,840
во время выполнения программы.

3992
02:55:36,840 --> 02:55:38,210
В таком случае вы можете написать

3993
02:55:38,210 --> 02:55:43,210
абстрактную функцию

3994
02:55:44,510 --> 02:55:47,580
которая будет высчитывать процент

3995
02:55:47,580 --> 02:55:49,690
И будет она возвращать скидку

3996
02:55:49,690 --> 02:55:52,720
с типом Int

3997
02:55:52,720 --> 02:55:56,220
Я немного опечатался

3998
02:56:00,430 --> 02:56:01,800
Теперь когда мы все починили

3999
02:56:01,800 --> 02:56:03,990
мы видим кучу ошибок
здесь говорится, что класс BRONZE

4000
02:56:03,990 --> 02:56:07,360
абстрактный и не реализует
абстрактный метод

4001
02:56:07,360 --> 02:56:09,800
который опрдеделен в нашем enum

4002
02:56:09,800 --> 02:56:11,690
тоже самое для

4003
02:56:11,690 --> 02:56:13,430
остальных типов enum

4004
02:56:13,430 --> 02:56:16,780
Мы можем поставить
фигурные скобки

4005
02:56:16,780 --> 02:56:19,850
И реализовать абстрактный метод

4006
02:56:19,850 --> 02:56:22,478
появится метод с ключевым словом
override и мы можем

4007
02:56:22,478 --> 02:56:24,470
написать реализацию абстрактной
функции.

4008
02:56:24,470 --> 02:56:26,110
Можно сделать метод однострочным

4009
02:56:26,110 --> 02:56:27,400
или, если вы собираетесь

4010
02:56:27,400 --> 02:56:31,190
писать много логики, можно реализовать

4011
02:56:31,190 --> 02:56:34,110
как обычную функцию

4012
02:56:34,110 --> 02:56:38,380
и в конце возвратить какое-нибудь

4013
02:56:38,380 --> 02:56:40,560
значение, например пять

4014
02:56:40,560 --> 02:56:43,250
или, если подсчеты простые

4015
02:56:43,250 --> 02:56:44,200
можно сделать в одну строку.

4016
02:56:44,200 --> 02:56:46,480
Вот например написать пять тут.

4017
02:56:46,480 --> 02:56:48,110
Тоже самое будет происходить тут

4018
02:56:48,110 --> 02:56:51,150
нужно опять реализовать
абстрактную функцию

4019
02:56:51,150 --> 02:56:54,740
и вернуть наприер 10

4020
02:56:54,740 --> 02:56:56,650
Я просто скопирую все отсюда,

4021
02:56:56,650 --> 02:56:57,650
так будет проще.

4022
02:56:58,943 --> 02:57:02,150
Тут я верну 15

4023
02:57:03,074 --> 02:57:03,940
И, напомню, это просто те же

4024
02:57:03,940 --> 02:57:04,840
проценты скидки что были раньше.

4025
02:57:04,840 --> 02:57:09,130
Все цифры что и в предыдущем результате

4026
02:57:09,130 --> 02:57:11,040
Только через абстрактнцю функцию

4027
02:57:11,930 --> 02:57:15,370
И тут нужно добавить точку с запятой

4028
02:57:15,370 --> 02:57:17,530
потому что после значений энама
у нас есть функция.

4029
02:57:17,530 --> 02:57:21,060
Теперь попытаемся это все повызывать

4030
02:57:21,060 --> 02:57:23,450
И например наши данные приходят с

4031
02:57:23,450 --> 02:57:25,770
какого-то API в каком-то

4032
02:57:25,770 --> 02:57:27,450
плохом формате.

4033
02:57:27,450 --> 02:57:29,540
Мы сделаем переменную для типа аккаунта

4034
02:57:29,540 --> 02:57:33,140
и вызовем valueOf

4035
02:57:33,140 --> 02:57:35,270
и возьмем наше значение из API

4036
02:57:35,270 --> 02:57:37,860
переведем его в верхний регистр
и получим наш тип абонемента.

4037
02:57:37,860 --> 02:57:39,880
и теперь используем функцию

4038
02:57:39,880 --> 02:57:43,310
вычисления скидки для абонемента.

4039
02:57:43,310 --> 02:57:45,360
И это будет золотой абонемент
и если запустим

4040
02:57:45,360 --> 02:57:48,510
Увидим скидку 15 процентов.

4041
02:57:48,510 --> 02:57:52,990
Если изменим на платиновый

4042
02:57:52,990 --> 02:57:56,290
то получим 20

4043
02:57:56,290 --> 02:57:59,700
И так вы можете писать абстрактные

4044
02:57:59,700 --> 02:58:01,600
функции у энамов.

4045
02:58:01,600 --> 02:58:06,600
Это будет полезно, когда вы
не будете сразу понимать

4046
02:58:07,060 --> 02:58:08,590
что будет результатом вычислений

4047
02:58:09,759 --> 02:58:10,592
и у вас будет гораздо больше вычислений

4048
02:58:10,592 --> 02:58:13,220
И блок функции будет больше

4049
02:58:13,220 --> 02:58:16,740
Вы будете делать много работы

4050
02:58:16,740 --> 02:58:19,430
в функции и выводить результат.

4051
02:58:19,430 --> 02:58:23,590
Например у вас будет переменная
которая хранит процент

4052
02:58:24,970 --> 02:58:27,970
и вы начнете с нуля процентов

4053
02:58:27,970 --> 02:58:30,180
и вернете процент в конце.

4054
02:58:30,180 --> 02:58:33,740
И например ваши вычисления процента

4055
02:58:33,740 --> 02:58:36,456
будут зависеть от параметров

4056
02:58:36,456 --> 02:58:37,289
конструктора, которые вы будете

4057
02:58:37,289 --> 02:58:39,390
передавать в тип энам.
Сейчас этих параметров нет

4058
02:58:39,390 --> 02:58:44,390
но если бы были, вы бы могли
их использовать

4059
02:58:44,460 --> 02:58:47,700
Так и используются

4060
02:58:47,700 --> 02:58:49,200
абстрактные функции
в enam'ах Котлина.

4061
02:58:50,750 --> 02:58:53,150
По типам энама

4062
02:58:53,150 --> 02:58:56,150
можно итерироваться

4063
02:58:56,150 --> 02:58:59,860
вызвав AccountType.values()

4064
02:58:59,860 --> 02:59:01,320
Вы можете использовать это поле

4065
02:59:01,320 --> 02:59:02,620
оно встроено во все энамы.

4066
02:59:02,620 --> 02:59:04,460
и идет как

4067
02:59:04,460 --> 02:59:06,300
часть языка Котлин

4068
02:59:06,300 --> 02:59:09,570
С помощью ключевого слова for

4069
02:59:09,570 --> 02:59:13,400
мы можем написать цикл
слева напишем accountType

4070
02:59:13,400 --> 02:59:15,450
и внутри сделаем вывод

4071
02:59:15,450 --> 02:59:16,840
нашего типа аккаунта

4072
02:59:16,840 --> 02:59:19,700
И если запустим

4073
02:59:19,700 --> 02:59:22,080
мы увидим все типы аккаунтов

4074
02:59:22,080 --> 02:59:26,380
кажный на новой строке:
бронза, серебро, золото, платина

4075
02:59:26,380 --> 02:59:30,140
метод values возвращает массив

4076
02:59:30,140 --> 02:59:31,270
содержащий тип AccountType

4077
02:59:31,270 --> 02:59:33,930
И, из-за того что массив в
Котлине это коллекция

4078
02:59:33,930 --> 02:59:37,880
мы можем использовать удобные
функции расширения

4079
02:59:37,880 --> 02:59:41,160
для итерации по массиву,
например forEach

4080
02:59:41,160 --> 02:59:45,350
и я могу сделать все то же самое,
и в фигурных скобках сделаю

4081
02:59:45,350 --> 02:59:47,360
вывод в консоль.

4082
02:59:47,360 --> 02:59:49,770
И теперь мы делаем все наши операции

4083
02:59:49,770 --> 02:59:51,330
в одну троку, вместо трех

4084
02:59:51,330 --> 02:59:52,720
и в выводе ровно тот же результат

4085
02:59:52,720 --> 02:59:55,470
и в выводе ровно тот же результат

4086
02:59:55,470 --> 02:59:57,550
И таким образом можно итерироваться

4087
02:59:57,550 --> 03:00:02,510
по значениям энамов

4088
03:00:04,950 --> 03:00:06,690
Чтобы добавить статический
метод в энам

4089
03:00:06,690 --> 03:00:08,570
мы можем использовать
объект компаньон

4090
03:00:08,570 --> 03:00:11,530
Но сначала нам нужно
поставить точку с запятой

4091
03:00:11,530 --> 03:00:14,320
чтобы сказать Котлину, что мы закончили
объявлять энамы

4092
03:00:14,320 --> 03:00:16,860
и теперь мы можем написать companion object.

4093
03:00:16,860 --> 03:00:19,790
и тут мы можем создать
функцию, котоая

4094
03:00:19,790 --> 03:00:23,850
будет возвращать тип энама по имени

4095
03:00:23,850 --> 03:00:26,840
Мы будем принимать имя в виде строки

4096
03:00:26,840 --> 03:00:28,190
и внутри мы можем

4097
03:00:28,190 --> 03:00:31,610
использовать уже известный нам
метод valueOf и вызвать toUpperCase

4098
03:00:31,610 --> 03:00:33,070
Вы можете спросить, а зачем?

4099
03:00:33,070 --> 03:00:36,127
На самом деле это будет просто небольшой
синтаксический сахар

4100
03:00:36,127 --> 03:00:40,160
и вызывать создание

4101
03:00:40,160 --> 03:00:41,720
типа аккаунта будет легче

4102
03:00:41,720 --> 03:00:44,800
чем мы делали это раньше

4103
03:00:44,800 --> 03:00:47,980
И давайте выведем в консоль

4104
03:00:47,980 --> 03:00:49,240
и напишем нашу переменную.

4105
03:00:50,647 --> 03:00:51,480
Запустим и увидим

4106
03:00:51,480 --> 03:00:53,210
что в консоли будет золотой аккаунт

4107
03:00:53,210 --> 03:00:56,190
тут снизу экрана

4108
03:00:56,190 --> 03:01:01,190
Я могу поменять на платиновый абонемент

4109
03:01:01,570 --> 03:01:02,850
или любой другой.

4110
03:01:02,850 --> 03:01:05,521
А если я напишу

4111
03:01:05,521 --> 03:01:06,354
сюда какую-нибудь билиберду

4112
03:01:06,354 --> 03:01:10,980
то ничего не сработает и

4113
03:01:11,920 --> 03:01:13,120
приложение выдаст ошибку

4114
03:01:13,120 --> 03:01:15,630
потому что такого типа

4115
03:01:15,630 --> 03:01:18,030
энама у нас нет.

4116
03:01:18,030 --> 03:01:19,390
Одна важная концептуальная

4117
03:01:19,390 --> 03:01:22,170
особенность Котлина от Java это то
что в нем нет ключевого слова static

4118
03:01:22,170 --> 03:01:24,825
но по поведению companion object

4119
03:01:24,825 --> 03:01:26,725
делает именно это.

4120
03:01:27,660 --> 03:01:31,160
Так в энам можно сделать функции
в объекте компаньоне

4121
03:01:31,160 --> 03:01:33,520
который по сути и работает

4122
03:01:33,520 --> 03:01:37,040
как статический метод в Котлине

4123
03:01:38,320 --> 03:01:41,110
В котлине нет ключевого слова switch

4124
03:01:41,110 --> 03:01:43,840
В контлине у него есть аналог -
ключевое слово "when"

4125
03:01:43,840 --> 03:01:47,300
Давайте быстренько
создадим пользователя

4126
03:01:47,300 --> 03:01:49,880
С именем Donn

4127
03:01:49,880 --> 03:01:51,310
и фамилией Felker.

4128
03:01:52,150 --> 03:01:54,310
when - условие
выглядит так

4129
03:01:54,310 --> 03:01:56,280
вы пишите when ив скобчках
пишете объект, состояние

4130
03:01:56,280 --> 03:01:59,740
которого вы хотите проверить.

4131
03:01:59,740 --> 03:02:02,860
Мы будем проверять имя пользователя
имя это строковый объект

4132
03:02:02,860 --> 03:02:05,690
и в фигурных скобках будут

4133
03:02:05,690 --> 03:02:07,750
проверки, которые нас интересуют

4134
03:02:07,750 --> 03:02:11,340
И мы как бы говорим, проверим ия пользователя

4135
03:02:11,340 --> 03:02:14,600
и если оно соответствует условию,
будем делать какое-то действие

4136
03:02:14,600 --> 03:02:17,460
и условие и действие будут
внутри фигурных скобок

4137
03:02:17,460 --> 03:02:22,220
условие - если имя "Donn"
действие - вывести имя на экран.

4138
03:02:22,220 --> 03:02:24,100
и запустим

4139
03:02:24,100 --> 03:02:26,720
Теперь мы увидим

4140
03:02:26,720 --> 03:02:29,890
и в консоли увидим имя

4141
03:02:29,890 --> 03:02:33,890
представим, что имя пользователя
поменялось

4142
03:02:33,890 --> 03:02:36,860
теперь наша проверка не выполнится

4143
03:02:36,860 --> 03:02:38,580
и в консоли

4144
03:02:38,580 --> 03:02:40,058
ничего не будет.

4145
03:02:40,058 --> 03:02:41,640
так же мы можем сделать
действие по дефолту

4146
03:02:41,640 --> 03:02:44,870
для этого нам нужно написать "else"

4147
03:02:44,870 --> 03:02:47,360
и фигурные скобки

4148
03:02:47,360 --> 03:02:50,000
и напишем "Имя не DOnn"

4149
03:02:50,000 --> 03:02:53,420
Если запустим теперь

4150
03:02:53,420 --> 03:02:55,810
то мы увидим

4151
03:02:55,810 --> 03:02:57,210
наш второй вывод

4152
03:02:57,210 --> 03:03:00,600
а значит выполнился блок из
условия "else"

4153
03:03:00,600 --> 03:03:03,820
В блоках "действиях"

4154
03:03:03,820 --> 03:03:05,370
можно делать несколько вещей

4155
03:03:05,370 --> 03:03:07,930
например сделаем еще один вывод

4156
03:03:07,930 --> 03:03:10,110
или еще какую-нибудь логику, не важно

4157
03:03:10,110 --> 03:03:11,860
это тоже самое что и функции,
но их можно вызывать только тут

4158
03:03:11,860 --> 03:03:13,210
и делать в них любые действия.

4159
03:03:14,596 --> 03:03:15,940
Когда вы только начнете

4160
03:03:15,940 --> 03:03:18,719
разрабатывать на Kotlin
вам придется

4161
03:03:18,719 --> 03:03:19,552
адаптироватся к тому как

4162
03:03:19,552 --> 03:03:20,510
правильно писать when условия.

4163
03:03:20,510 --> 03:03:22,250
Так во всяком случае было у меня.

4164
03:03:22,250 --> 03:03:25,270
Но длагодаря IDE это
делать довольно легче

4165
03:03:25,270 --> 03:03:27,580
Вам уже знакомы "if" проверки

4166
03:03:27,580 --> 03:03:30,960
можно написать такую проверку

4167
03:03:30,960 --> 03:03:35,210
и вывести что-то на экран

4168
03:03:35,210 --> 03:03:36,600
и потом у вас будет else

4169
03:03:36,600 --> 03:03:39,570
и это нормальный подход для
"Си" подобных языков

4170
03:03:39,570 --> 03:03:42,660
и вы видели такой подход
ммного раз

4171
03:03:42,660 --> 03:03:47,660
если мы закоментируем эту часть

4172
03:03:48,830 --> 03:03:51,530
И запустим, то увидим что логика работает

4173
03:03:52,622 --> 03:03:54,130
и мы уходим в else блок

4174
03:03:54,130 --> 03:03:56,340
Если поменяем имя назад

4175
03:03:56,340 --> 03:04:00,070
и запустим, то попадем
в первое условие

4176
03:04:00,070 --> 03:04:02,620
И я например хочу

4177
03:04:02,620 --> 03:04:06,330
работать с такими условиями в
Котлин стиле

4178
03:04:06,330 --> 03:04:08,688
можно анвести курсор на "if"

4179
03:04:08,688 --> 03:04:10,220
и нажать на желтую лампочку

4180
03:04:10,220 --> 03:04:13,720
и нажать на опцию
"заменить if на when"

4181
03:04:13,720 --> 03:04:16,410
и IDE автоматически все заменит

4182
03:04:16,410 --> 03:04:18,340
на немного другой код

4183
03:04:18,340 --> 03:04:21,220
И этот when не очень похож на тот,
который мы написали ниже

4184
03:04:21,220 --> 03:04:23,240
но делает ровно ту же вещь

4185
03:04:24,770 --> 03:04:26,140
И что тут происходит?

4186
03:04:26,140 --> 03:04:29,060
мы просто заходим и спрашиваем
имя равно Donn?

4187
03:04:29,060 --> 03:04:32,830
и выводим строку в консоль

4188
03:04:32,830 --> 03:04:35,650
И тут у нас нет фигурных скобок
как снизу

4189
03:04:35,650 --> 03:04:38,190
Давайте вернем все к if

4190
03:04:38,190 --> 03:04:41,860
И допишем еще какое-то действие

4191
03:04:41,860 --> 03:04:43,280
в if-е

4192
03:04:43,280 --> 03:04:44,900
И снова заменим

4193
03:04:44,900 --> 03:04:46,450
if условие на when

4194
03:04:47,520 --> 03:04:50,170
IDE при форматировании подставит скобки

4195
03:04:50,170 --> 03:04:51,920
Если в if у нас одно действие

4196
03:04:53,146 --> 03:04:53,979
то при замене на

4197
03:04:53,979 --> 03:04:55,770
when условие

4198
03:04:55,770 --> 03:04:58,280
действие превратится в одностроковое
как это было с функциями

4199
03:04:58,280 --> 03:04:59,950
и читать его будет проще

4200
03:04:59,950 --> 03:05:02,690
и when еще немного оптимизирован
и мы не проверяем конкретный объект

4201
03:05:02,690 --> 03:05:05,980
а работаем с большими проверками

4202
03:05:05,980 --> 03:05:08,080
и тут мы можем делать дополнительные

4203
03:05:08,080 --> 03:05:12,140
проверки, например
мы можем проверить

4204
03:05:12,140 --> 03:05:14,700
равно ли имя пользователя

4205
03:05:14,700 --> 03:05:16,680
например, "Dan"

4206
03:05:16,680 --> 03:05:18,910
И если запустим, то увидим,

4207
03:05:18,910 --> 03:05:21,750
что сейчас имя Donn

4208
03:05:21,750 --> 03:05:25,200
заменим имя пользователя на Dan
в выводе увидим Dan

4209
03:05:27,260 --> 03:05:29,740
И теперь вставим "Dana"

4210
03:05:29,740 --> 03:05:31,260
и попадем в else блок.

4211
03:05:31,260 --> 03:05:33,450
На мой взгляд, если все проверки
касаются одного и того же объекта

4212
03:05:33,450 --> 03:05:34,940
то лучше написать это немного чище

4213
03:05:34,940 --> 03:05:38,150
и удалить вызов объекта
в каждом условии и добавить

4214
03:05:38,150 --> 03:05:40,530
в крглые скобки блока (when)

4215
03:05:40,530 --> 03:05:44,390
запишем сюда user.firstName

4216
03:05:45,520 --> 03:05:47,140
и теперь when будет лимитирован проверкой

4217
03:05:47,140 --> 03:05:50,151
нашего имени пользователя

4218
03:05:50,151 --> 03:05:53,520
Когда у нас имя равно

4219
03:05:54,588 --> 03:05:55,421
"Donn" мы выполняем это действие

4220
03:05:55,421 --> 03:05:57,130
Когда "Dan", то вот это

4221
03:05:57,130 --> 03:05:59,910
Когда не получится работать с
when на конкретном объекте?

4222
03:05:59,910 --> 03:06:00,860
Есть хороший пример

4223
03:06:00,860 --> 03:06:03,660
Вернем код и напишем

4224
03:06:03,660 --> 03:06:05,430
все как было

4225
03:06:05,430 --> 03:06:08,820
но если мы захотим проверить
кроме имени

4226
03:06:08,820 --> 03:06:13,820
должны еще проверить

4227
03:06:15,325 --> 03:06:19,470
фамилию, имя равно Donn и фамилия
равна Felker

4228
03:06:20,900 --> 03:06:22,910
И с таким условием
мы выведем "Donn"

4229
03:06:22,910 --> 03:06:24,452
иначе - что-то другое

4230
03:06:24,452 --> 03:06:26,530
Давайте вернемся сюда
и поменяем пользователя

4231
03:06:26,530 --> 03:06:30,860
на Donn Felker и запустим

4232
03:06:30,860 --> 03:06:33,760
И в выводе увидим
строку из первого условия

4233
03:06:33,760 --> 03:06:38,470
а что будет, если фамилия не совпадет

4234
03:06:39,399 --> 03:06:41,930
например у нас опечатка, и запустим

4235
03:06:41,930 --> 03:06:44,120
код из первого условия не выполнится

4236
03:06:44,120 --> 03:06:46,480
потому что условие проверяется полностью

4237
03:06:46,480 --> 03:06:49,140
все это слева проверяется

4238
03:06:49,140 --> 03:06:52,130
И опять, если эта строка очень большая

4239
03:06:52,130 --> 03:06:54,070
и становится плохо читаемым

4240
03:06:54,070 --> 03:06:56,830
то можно все действия
переносить на новую строку

4241
03:06:56,830 --> 03:06:58,580
И теперь вы проверяете много

4242
03:06:58,580 --> 03:07:00,260
разных значений в

4243
03:07:00,260 --> 03:07:02,680
when условии и если не попадаете

4244
03:07:02,680 --> 03:07:05,670
ни в одно из них, то выполняется
else блок в конце.

4245
03:07:05,670 --> 03:07:08,570
Вы можете миксовать блоки кода

4246
03:07:08,570 --> 03:07:12,190
и выражения написанные в одну строку

4247
03:07:12,190 --> 03:07:14,520
и действия справа

4248
03:07:14,520 --> 03:07:16,820
будут выполняться как и блоки кода

4249
03:07:16,820 --> 03:07:18,790
В одностроковых действиях
вы не можете делать несколько строк кода

4250
03:07:18,790 --> 03:07:20,330
если вы это сделаете

4251
03:07:20,330 --> 03:07:23,030
то вам придется добавлять фигурные скобки

4252
03:07:23,030 --> 03:07:24,340
Делается это просто, берем строку

4253
03:07:24,340 --> 03:07:28,240
пишем фигурные скобки

4254
03:07:28,240 --> 03:07:32,630
и на новой строке вставляем код обратно

4255
03:07:34,640 --> 03:07:38,550
И теперь можете писать
сколько угодно логики

4256
03:07:38,550 --> 03:07:41,620
что-то вроде этого, неважно.

4257
03:07:41,620 --> 03:07:43,150
И так мы познакомились

4258
03:07:43,150 --> 03:07:46,740
с when условиями и ключевым
словом "when" в котлин

4259
03:07:46,740 --> 03:07:47,990
И его можно использовать

4260
03:07:47,990 --> 03:07:51,660
с проверкой самых разных типов

4261
03:07:51,660 --> 03:07:54,740
от примитивов до ваших
собственных классов

4262
03:07:54,740 --> 03:07:57,370
"when" очень похож на if

4263
03:07:57,370 --> 03:08:00,037
И если у вас какие-то сложности с написанием

4264
03:08:00,037 --> 03:08:01,190
when условия, вы всегда можете написать

4265
03:08:01,190 --> 03:08:03,780
if - условия и с помощью

4266
03:08:03,780 --> 03:08:07,030
IDE конвертировать его в when

4267
03:08:07,030 --> 03:08:11,410
Это форматирование встроено
в Intellij IDEA и Android Studio

4268
03:08:11,410 --> 03:08:14,320
обе сделаны компанией JetBrains

4269
03:08:14,320 --> 03:08:16,430
Спокойно переводите if условия

4270
03:08:16,430 --> 03:08:17,690
в when условия.

4271
03:08:19,610 --> 03:08:21,340
Иногда бывают ситуайции, когда

4272
03:08:21,340 --> 03:08:23,150
when используется как функция выражения

4273
03:08:23,150 --> 03:08:24,700
и должна проверять все условия.

4274
03:08:30,120 --> 03:08:32,500
Это значит, что в  нем обязательно
должно быть else условие

4275
03:08:32,500 --> 03:08:34,800
Давайте предположим что у нас есть when

4276
03:08:36,386 --> 03:08:37,219
который проверяет тип аккаунта

4277
03:08:37,219 --> 03:08:39,410
давайте заведем тип аккаунта

4278
03:08:39,410 --> 03:08:44,410
пусть будет GOLD и сделаем на нем
when проверку

4279
03:08:45,250 --> 03:08:48,960
И когда тип аккаунта золотой

4280
03:08:50,850 --> 03:08:54,890
мы можем выполнить

4281
03:08:54,890 --> 03:08:56,620
какой-то код, мы, например,
вернем строку

4282
03:08:56,620 --> 03:09:01,030
"Gold member"

4283
03:09:01,030 --> 03:09:02,960
Допустим что мы хотим возвращать

4284
03:09:02,960 --> 03:09:05,400
строку в зависимости от
типа абонемента

4285
03:09:05,400 --> 03:09:07,380
И тут мы можем заметить ошибку

4286
03:09:07,380 --> 03:09:11,290
и она говорит, что мы возвращаем String

4287
03:09:11,290 --> 03:09:12,550
а должны возвращать Unit

4288
03:09:12,550 --> 03:09:15,790
На самом деле when может
возвращать значение

4289
03:09:15,790 --> 03:09:19,000
напишем переменную в которую
запишется результат

4290
03:09:19,000 --> 03:09:21,470
и теперь результат when формирует
нашу новую переменную

4291
03:09:21,470 --> 03:09:24,022
И теперь новая ошибка говорит,
что когда when используется

4292
03:09:24,022 --> 03:09:28,260
таким образом, when должен
покрывать все кейсы

4293
03:09:28,260 --> 03:09:29,290
и обязательно что-то возвращать.

4294
03:09:29,290 --> 03:09:33,180
И нам придется поддержать
все возможные сценарии

4295
03:09:33,180 --> 03:09:37,790
потому что переменная должна
в итоге получить значение

4296
03:09:37,790 --> 03:09:38,900
Что-то должно быть в результате

4297
03:09:38,900 --> 03:09:41,580
И компилятору извесно, что

4298
03:09:41,580 --> 03:09:44,383
у типа аккаунта есть несколько значений

4299
03:09:44,383 --> 03:09:45,590
Бронза, серебра, золото и платина

4300
03:09:45,590 --> 03:09:49,120
И если ваш тип аккаунта Платиновый

4301
03:09:49,120 --> 03:09:50,720
то when не знает как его обаботать.

4302
03:09:50,720 --> 03:09:53,480
И говорит нам, что

4303
03:09:53,480 --> 03:09:54,840
нужно обработать все варианты

4304
03:09:54,840 --> 03:09:56,160
И тут он пишет, что

4305
03:09:56,160 --> 03:09:58,130
мы можем либо предоставить

4306
03:09:58,130 --> 03:10:00,730
обработку всех недостающих абонементов

4307
03:10:00,730 --> 03:10:03,070
либо добавить else блок

4308
03:10:03,070 --> 03:10:07,390
Мы можем сделать как сейчас

4309
03:10:08,890 --> 03:10:13,420
и дописть блок else
и, например вернуть

4310
03:10:13,420 --> 03:10:18,420
какой-нибудь обычный текст

4311
03:10:20,930 --> 03:10:23,630
И тут какая-то ошибка

4312
03:10:23,630 --> 03:10:25,200
кажется нам не нужно слово return

4313
03:10:25,200 --> 03:10:26,730
потому что when используется как
функция выражение

4314
03:10:26,730 --> 03:10:27,940
и ничего явно возвращать не нужно

4315
03:10:27,940 --> 03:10:32,450
И теперь наконец-то мы можем
вывести наше сообщение в консоль

4316
03:10:33,770 --> 03:10:36,270
И в консоли увидим что

4317
03:10:36,270 --> 03:10:37,910
это сообщение для золотого абонемента.

4318
03:10:37,910 --> 03:10:40,260
Если заменим на платиновый

4319
03:10:43,820 --> 03:10:47,340
мы значем, что это не золотой
и попадем в else блок

4320
03:10:47,340 --> 03:10:49,230
потому что обрабатывается
только золотой

4321
03:10:49,230 --> 03:10:54,090
Давайте допустим, что мы хотим
что-то сделать, если

4322
03:10:55,380 --> 03:10:57,140
абонемент золотой.

4323
03:10:57,140 --> 03:10:58,790
Хотя нет, платиновый самый лучший

4324
03:10:58,790 --> 03:11:00,090
поэтому заменим на платиновый

4325
03:11:05,710 --> 03:11:06,740
Платиновый

4326
03:11:06,740 --> 03:11:09,392
И внутри else блока

4327
03:11:09,392 --> 03:11:14,392
мы напишем, что у остальных
нет доступа к

4328
03:11:15,730 --> 03:11:16,690
например к спортивному залу

4329
03:11:16,690 --> 03:11:18,900
И теперь в случае, когда абонемент

4330
03:11:18,900 --> 03:11:21,330
платиновый мы будем выводить

4331
03:11:21,330 --> 03:11:22,830
что он платиновый

4332
03:11:22,830 --> 03:11:26,670
а для всех других типов

4333
03:11:27,654 --> 03:11:29,640
будет текст, что у них нет доступа

4334
03:11:29,640 --> 03:11:32,201
в зал

4335
03:11:32,201 --> 03:11:33,540
Сейчас у нас результат для платинового

4336
03:11:33,540 --> 03:11:37,390
и давайте заменим текст, что у них
доступ к залу есть

4337
03:11:39,110 --> 03:11:40,664
и перезапустим

4338
03:11:40,664 --> 03:11:41,500
увидим новый текст

4339
03:11:41,500 --> 03:11:44,400
теперь заменим на серебряный

4340
03:11:44,400 --> 03:11:45,270
и снова перезапустим

4341
03:11:45,270 --> 03:11:48,530
И теперь доступа для такого аккаунта
у нас нет

4342
03:11:48,530 --> 03:11:50,070
И так мы можем обрабатывать
одним способом

4343
03:11:50,070 --> 03:11:52,800
Другой способ подразумевает,

4344
03:11:52,800 --> 03:11:56,770
что нам нужно обработать все типы
абонементов

4345
03:11:56,770 --> 03:11:59,650
Главное правило тут что

4346
03:11:59,650 --> 03:12:01,760
порядок не важен

4347
03:12:01,760 --> 03:12:05,830
Текст для бронзы заменим на правильный

4348
03:12:05,830 --> 03:12:07,360
что есть "бронзовый" доступ

4349
03:12:09,580 --> 03:12:12,090
А это поменяем на серебро

4350
03:12:13,280 --> 03:12:15,160
И заметьте что у нас до сих
пор есть это подчеркивание

4351
03:12:15,160 --> 03:12:17,520
компилятор жалуется, что мы не
обработали все варианты

4352
03:12:17,520 --> 03:12:20,730
И добавим последний - золотой

4353
03:12:22,289 --> 03:12:23,122
Как только я его написал

4354
03:12:23,122 --> 03:12:25,690
и мы обработали все варианты
ошибка пропала

4355
03:12:25,690 --> 03:12:27,070
заменим текст в золотом

4356
03:12:28,190 --> 03:12:31,000
Самая классная вещь во всем этом

4357
03:12:31,000 --> 03:12:33,040
это то что в будущем...

4358
03:12:33,040 --> 03:12:34,840
Так, компилятор говорит, что
мы можем упростить код

4359
03:12:34,840 --> 03:12:38,100
но мы этого делать не будем,

4360
03:12:38,100 --> 03:12:41,320
потому что мы подразумеваем что
это значение динамически меняется.

4361
03:12:41,320 --> 03:12:42,550
Так вот, самая класная штука -

4362
03:12:42,550 --> 03:12:45,480
когда мы запустим мы увидим правильный

4363
03:12:46,346 --> 03:12:49,650
вывод в консоли

4364
03:12:49,650 --> 03:12:51,660
простите, я все таки поменяю их

4365
03:12:51,660 --> 03:12:54,421
местами, чтобы было логичнее.

4366
03:12:54,421 --> 03:12:56,840
из-за того что мы работаем
с типом аккаунта

4367
03:12:56,840 --> 03:12:57,840
у нас будет фиксированый список

4368
03:12:57,840 --> 03:13:00,080
и если он в будущем поменяется

4369
03:13:01,410 --> 03:13:03,430
и мы решим, что у нас будет

4370
03:13:03,430 --> 03:13:06,800
добавлен новый тип Onyx

4371
03:13:07,750 --> 03:13:11,420
наше приложение не скомпилируется

4372
03:13:11,420 --> 03:13:12,710
Компилятор придет в when и увидит

4373
03:13:12,710 --> 03:13:14,940
что when не обработал все возможные
варианты

4374
03:13:14,940 --> 03:13:18,070
И если у нас тип аккаунта
используется где-то в другом

4375
03:13:18,070 --> 03:13:19,940
файле или приложении,

4376
03:13:19,940 --> 03:13:21,840
что тоже вероятно,

4377
03:13:22,761 --> 03:13:25,000
и мы добавим onyx потому что api
теперь может присылать такой вариант

4378
03:13:25,000 --> 03:13:28,360
То мы добавим этот тип и когда

4379
03:13:28,360 --> 03:13:30,120
попробуем скомпилировать приложение

4380
03:13:30,120 --> 03:13:32,550
компилятор Котлина остановит нас

4381
03:13:32,550 --> 03:13:34,950
и скажет, что он ничего не будет

4382
03:13:34,950 --> 03:13:37,400
компилировать, пока мы не
обработаем это значение везде

4383
03:13:37,400 --> 03:13:40,120
И конечно такой кейс можно
обойти, если

4384
03:13:40,120 --> 03:13:45,120
мы добавим else блок в конце

4385
03:13:45,710 --> 03:13:48,253
и вставим какой-нибудь

4386
03:13:48,253 --> 03:13:49,396
текст для неопределенных
абонементов

4387
03:13:49,396 --> 03:13:51,160
И если мы сейчас добавит еще

4388
03:13:51,160 --> 03:13:53,510
один тип, например "розовый"

4389
03:13:55,599 --> 03:13:56,600
абонемент

4390
03:13:56,600 --> 03:14:00,200
то его обработает блок else
или вы можете напистаь обработку сами

4391
03:14:00,200 --> 03:14:04,010
Опять же, порядок тут не важен

4392
03:14:04,010 --> 03:14:04,843
Если ваш тип будет бронзовый,

4393
03:14:04,843 --> 03:14:07,101
то мы выполним только блок у бронзового

4394
03:14:07,101 --> 03:14:09,960
и вернем сообщение

4395
03:14:09,960 --> 03:14:12,696
И так мы работаем с when выражениями,
которые используются

4396
03:14:12,696 --> 03:14:14,900
как функции выражений

4397
03:14:14,900 --> 03:14:17,020
Еще раз напомню что обычный when

4398
03:14:17,020 --> 03:14:20,860
просто делает проверку
и ничего не возвращает

4399
03:14:20,860 --> 03:14:24,434
Вот так будет выглядеть обычный when

4400
03:14:24,434 --> 03:14:26,580
И я могу обработать золотой абонемент

4401
03:14:28,150 --> 03:14:31,050
и вывести что-то на экран

4402
03:14:32,130 --> 03:14:34,290
"Это золотой абонемент"

4403
03:14:35,280 --> 03:14:36,880
это обычный when

4404
03:14:37,908 --> 03:14:39,890
и в нем даже не нужен else блок

4405
03:14:39,890 --> 03:14:41,390
А этот блок должен проинициализировть

4406
03:14:41,390 --> 03:14:42,700
переменную и вернуть значение

4407
03:14:42,700 --> 03:14:46,170
и нам нужно

4408
03:14:46,170 --> 03:14:47,650
обработать все варианты

4409
03:14:47,650 --> 03:14:50,000
то есть пройтись по всем типам

4410
03:14:50,000 --> 03:14:51,900
и использовать else для типов,
которые мы не обрабатываем

4411
03:14:51,900 --> 03:14:53,010
чтобы компилятор знал что сделать

4412
03:14:53,010 --> 03:14:55,695
Теперь снова жалуется, потому
что мы не написали

4413
03:14:55,695 --> 03:14:56,712
как обработать Onyx тип

4414
03:14:56,712 --> 03:15:01,692
И если удалим сам тип

4415
03:15:01,692 --> 03:15:04,480
то все будет хорошо

4416
03:15:04,480 --> 03:15:05,940
И на этом можно завершить

4417
03:15:05,940 --> 03:15:08,730
наш разговор про ключевое слово when

4418
03:15:10,800 --> 03:15:13,920
Часто в разработке у вас будут случаи

4419
03:15:13,920 --> 03:15:16,470
когда ваши классы будут
только хранить данные

4420
03:15:16,470 --> 03:15:20,890
Допустим у нас есть класс человека

4421
03:15:20,890 --> 03:15:24,170
с именем и фамилией

4422
03:15:25,479 --> 03:15:26,590
и допустим у него нет никаких функций

4423
03:15:26,590 --> 03:15:29,790
а поэтому тело класса писать не нужно

4424
03:15:29,790 --> 03:15:31,020
и никаких других конструкторов

4425
03:15:32,524 --> 03:15:35,850
Сделаем переменную

4426
03:15:35,850 --> 03:15:37,080
и проинициализируем ее человеком

4427
03:15:38,625 --> 03:15:39,660
пусть имя будет Donn

4428
03:15:39,660 --> 03:15:41,900
а фамилия Felker

4429
03:15:41,900 --> 03:15:45,740
и я сделаю еще одного пользователя
с такими же параметрами

4430
03:15:45,740 --> 03:15:47,370
И теперь, если я проверю хи на равенство

4431
03:15:47,370 --> 03:15:50,620
вам сначала может показаться

4432
03:15:50,620 --> 03:15:52,010
что они одинаковые

4433
03:15:52,010 --> 03:15:53,600
у них одинаковые имя и фамилия,

4434
03:15:53,600 --> 03:15:56,690
поэтому они должны быть одинаковыми

4435
03:15:56,690 --> 03:15:59,040
если запустим, то увидим,
что результат false

4436
03:15:59,950 --> 03:16:01,780
они не равны друг другу

4437
03:16:01,780 --> 03:16:06,780
А если вывести их на экран

4438
03:16:07,200 --> 03:16:12,200
то мы увдим странные кодироваки
и они будут разные для этих объектов

4439
03:16:12,260 --> 03:16:15,010
я позже объясню что они значат

4440
03:16:15,010 --> 03:16:17,777
и не смотря на то что
эти объекты очень похожи,

4441
03:16:17,777 --> 03:16:18,610
для программы они разные

4442
03:16:18,610 --> 03:16:20,910
программа на самом деле не проверяет

4443
03:16:20,910 --> 03:16:23,140
контент этих объектов

4444
03:16:23,140 --> 03:16:26,150
Благодаря прекрасным
разработчикам языка Котлин,

4445
03:16:26,150 --> 03:16:27,290
которые позаботились об этом
и подумали, что будут классы

4446
03:16:27,290 --> 03:16:30,580
которые будут просто хранить данные

4447
03:16:30,580 --> 03:16:33,730
и если нам нужен класс для
таких нужд

4448
03:16:33,730 --> 03:16:35,460
мы можем использовать дата классы,
ключевое слово "data class"

4449
03:16:35,460 --> 03:16:37,590
И если ваш класс именно такой

4450
03:16:37,590 --> 03:16:39,710
просто пришлепните слово data в начале
и ваши параметры в конструкторе

4451
03:16:39,710 --> 03:16:42,080
должны начинаться с

4452
03:16:42,080 --> 03:16:44,470
val и var

4453
03:16:44,470 --> 03:16:47,680
И как толко мы добавили
это ключевое слово

4454
03:16:47,680 --> 03:16:51,940
мы можем проверить на
равенство наши объекты

4455
03:16:53,451 --> 03:16:54,940
и если запустим увидим, что теперь

4456
03:16:54,940 --> 03:16:55,773
объекты равны.

4457
03:16:55,773 --> 03:16:57,480
Под капотом data говорит компилятору
что классы нужно проверять на равенство

4458
03:16:57,480 --> 03:17:00,960
по их контенту

4459
03:17:00,960 --> 03:17:03,000
И происходит это таким образом

4460
03:17:03,000 --> 03:17:06,060
Компилятор самостоятельно переопределяет

4461
03:17:06,060 --> 03:17:10,630
оператор сравнения для этого класса
и использует переменные из конструктора

4462
03:17:10,630 --> 03:17:13,900
для сравнения, а так же переопределяет
метод toString и добавляет еще несколько

4463
03:17:13,900 --> 03:17:15,460
функций, о них поговорим позже.

4464
03:17:15,460 --> 03:17:18,730
Давайте посмотрим основные методы
которые переопределяет компилятор

4465
03:17:18,730 --> 03:17:22,090
toString - метод для вывода объекта
в строковом виде

4466
03:17:22,090 --> 03:17:26,240
И когда мы вызываем println
на объекте, функция println

4467
03:17:26,240 --> 03:17:29,180
вызывает toString метод объекта

4468
03:17:29,180 --> 03:17:30,531
по дефолту

4469
03:17:30,531 --> 03:17:33,700
И мы можем вывести p1

4470
03:17:33,700 --> 03:17:35,500
Давайте для начала
уберем префикс data

4471
03:17:35,500 --> 03:17:37,460
и посмотрим что обудет

4472
03:17:38,422 --> 03:17:41,040
Если мы выведем это

4473
03:17:41,040 --> 03:17:43,410
как обычный класс

4474
03:17:43,410 --> 03:17:48,000
мы увидим тип класса и цифры,
пользы млаовато

4475
03:17:48,000 --> 03:17:52,400
но если вернем data, то
компилятор перепишет

4476
03:17:52,400 --> 03:17:55,540
метод toString

4477
03:17:55,540 --> 03:17:56,590
метод toString

4478
03:17:56,590 --> 03:17:58,760
и вывод будет в хорошем формате

4479
03:17:58,760 --> 03:18:01,381
вывелся тип и значения полей

4480
03:18:01,381 --> 03:18:03,528
И давайте еще добавим возраст

4481
03:18:03,528 --> 03:18:07,050
и добавим какой-то возраст

4482
03:18:07,050 --> 03:18:10,560
например 30. И для второго объекта тоже

4483
03:18:10,560 --> 03:18:12,020
перезапустим

4484
03:18:12,020 --> 03:18:14,570
Теперь в консоли

4485
03:18:14,570 --> 03:18:16,270
появится еще и возраст

4486
03:18:16,270 --> 03:18:18,670
И теперь выведутся все параметры

4487
03:18:18,670 --> 03:18:22,040
И теперь выведутся все параметры

4488
03:18:22,040 --> 03:18:23,420
И это все генерируется компилятором

4489
03:18:23,420 --> 03:18:25,900
методы equals, hashcode и toString

4490
03:18:25,900 --> 03:18:27,970
И так мы создаем

4491
03:18:27,970 --> 03:18:29,220
data классы в Котлине

4492
03:18:29,220 --> 03:18:31,600
На самом деле вы можете писать
функции в data классах

4493
03:18:31,600 --> 03:18:34,180
Например выводить полное имя

4494
03:18:34,180 --> 03:18:36,550
и это все будет как в наших

4495
03:18:36,550 --> 03:18:37,470
предыдущих примерах

4496
03:18:37,470 --> 03:18:38,870
метод будет возвращать строку

4497
03:18:40,180 --> 03:18:42,870
и в теле метода

4498
03:18:42,870 --> 03:18:47,870
вернем комбинацию имени и фамилии

4499
03:18:49,460 --> 03:18:52,640
И теперь мы можем вывести полное имя

4500
03:18:52,640 --> 03:18:56,600
запустим и увиди Donn Felker

4501
03:18:56,600 --> 03:18:59,350
И, конечно мы можем писать тут

4502
03:18:59,350 --> 03:19:00,650
любые методы, например метод

4503
03:19:02,128 --> 03:19:04,720
который выводит длинну полного

4504
03:19:04,720 --> 03:19:06,770
имени и возвращает число

4505
03:19:07,740 --> 03:19:09,340
И мы можем эту функцию теперь

4506
03:19:09,340 --> 03:19:12,570
заменим ввод с вывода полного имени

4507
03:19:12,570 --> 03:19:14,460
на вывод длины полного имени

4508
03:19:14,460 --> 03:19:17,570
И результат, с учетом пробела
будет одинадцать.

4509
03:19:17,570 --> 03:19:19,890
И так мы закончим тему про создание
дата классов -

4510
03:19:19,890 --> 03:19:23,410
простых классов, в которых уже

4511
03:19:23,410 --> 03:19:26,550
реализованые опирации сравнения
и вывода в строковом виде.

4512
03:19:28,060 --> 03:19:31,480
Если при сождании дата класса вам
понадобится ражные вариации

4513
03:19:31,480 --> 03:19:32,900
конструктора

4514
03:19:32,900 --> 03:19:35,900
то можно использовать дефолтные
значения в конструкторе

4515
03:19:35,900 --> 03:19:39,910
Например на имени дефолтное

4516
03:19:39,910 --> 03:19:42,750
значение будет, что имя неизвестно,
на фамилии -

4517
03:19:42,750 --> 03:19:44,160
фамилия неизвестна.

4518
03:19:44,160 --> 03:19:45,620
Эти значения взяты из головы

4519
03:19:45,620 --> 03:19:47,500
они могут быть любыми

4520
03:19:48,544 --> 03:19:50,140
возраст просто поставим ноль

4521
03:19:50,140 --> 03:19:52,038
И теперь конструктор

4522
03:19:52,038 --> 03:19:54,340
у нас довольно большой,
давайте перенесем строки.

4523
03:19:54,340 --> 03:19:56,913
И теперь у нас объявление класса

4524
03:19:56,913 --> 03:19:57,746
разбито на несколько строк.

4525
03:19:57,746 --> 03:19:59,720
И теперь можно создать пользователя
p3 в функции мэйн

4526
03:19:59,720 --> 03:20:02,960
Мы просто объявляем переменную
и вызываем конструктор

4527
03:20:02,960 --> 03:20:04,230
нам не нужно передавать никаких

4528
03:20:04,230 --> 03:20:05,810
значений - все они будут дефолтными

4529
03:20:05,810 --> 03:20:08,420
Теперь я могу конечно в
конструкторе добавить еще одно поле

4530
03:20:08,420 --> 03:20:11,080
пусть будет поле foo с типом
String

4531
03:20:11,080 --> 03:20:13,500
У нас сразу появится куча ошибок
потому что дефолтного значения

4532
03:20:13,500 --> 03:20:17,220
нет и это значение нужно указать явно
для каждого человека

4533
03:20:17,220 --> 03:20:19,170
давайте удалим

4534
03:20:19,170 --> 03:20:24,170
и выведем нашего нового человека

4535
03:20:25,500 --> 03:20:30,360
удалим все старые выводы

4536
03:20:30,360 --> 03:20:32,160
и увидим в консоли пользователя
с нашими дефолтными значениями

4537
03:20:32,160 --> 03:20:35,700
имя неизвестно, фамилия неизвестна
и возраст ноль лет

4538
03:20:35,700 --> 03:20:38,300
И так можно делать конструкторы

4539
03:20:38,300 --> 03:20:40,560
динамичнее, и не вводить все данные.

4540
03:20:40,560 --> 03:20:43,410
Дата классы в котлине
генерируют так называемые

4541
03:20:43,410 --> 03:20:45,490
методы компонент.

4542
03:20:45,490 --> 03:20:48,480
при вызове функции человека p1
мы видим функцию component1

4543
03:20:48,480 --> 03:20:49,880
которая возвращает строку

4544
03:20:49,880 --> 03:20:53,200
и на самом деле этот метод
просто вернет имя пользователя

4545
03:20:53,200 --> 03:20:58,200
второй компонент это второе
поле пользователя, а именно фамилия

4546
03:20:58,600 --> 03:21:00,490
и тоже строкового типа

4547
03:21:00,490 --> 03:21:03,210
компоненты хранят поля дата класса
в порядке их объявления

4548
03:21:03,210 --> 03:21:04,043
в конструкторе.

4549
03:21:04,043 --> 03:21:08,640
И этот компонент вернет имя,
а этот фамилию

4550
03:21:11,120 --> 03:21:12,602
И на этом все

4551
03:21:12,602 --> 03:21:13,435
вы можете заметить, что больше

4552
03:21:13,435 --> 03:21:15,950
компонентов нет, потому что в
конструкторе только два поля

4553
03:21:15,950 --> 03:21:18,970
для которых дополнительно сгенерируются
методы component1, component2.

4554
03:21:18,970 --> 03:21:21,800
Но если мы заведем еще одно поле

4555
03:21:21,800 --> 03:21:26,730
Напрмер возраст с типом Int
и в месте вызова напишем, например,

4556
03:21:28,453 --> 03:21:30,680
30.

4557
03:21:30,680 --> 03:21:33,360
Теперь, если мы введем p1.

4558
03:21:33,360 --> 03:21:35,438
то увидим новую компонент функцию

4559
03:21:35,438 --> 03:21:37,350
и она будет возвращать тип Int
потому что этот компонент

4560
03:21:37,350 --> 03:21:38,400
связан с полем возраста

4561
03:21:38,400 --> 03:21:39,820
связан с полем возраст

4562
03:21:40,775 --> 03:21:43,010
И это третий компонент
в списке параметров

4563
03:21:43,010 --> 03:21:46,990
и напишем val age равно
component3.

4564
03:21:46,990 --> 03:21:49,630
все эти методы генерируются под капотом

4565
03:21:49,630 --> 03:21:51,800
Котлин компилятором.

4566
03:21:51,800 --> 03:21:54,380
И если мы выведем все наши переменные

4567
03:21:54,380 --> 03:21:57,490
выведем имя

4568
03:21:59,540 --> 03:22:01,620
выведем фамилию

4569
03:22:02,540 --> 03:22:03,500
и возраст в конце

4570
03:22:04,935 --> 03:22:06,850
и если запустим, увидим
все данные нашего пользователя

4571
03:22:06,850 --> 03:22:08,340
выведенные каждая на
своей строке.

4572
03:22:08,340 --> 03:22:09,550
И вообще мы можем отказаться
отпромежуточных значений и заменить это

4573
03:22:09,550 --> 03:22:12,470
на p1.component1

4574
03:22:15,550 --> 03:22:19,520
это на p1.component2

4575
03:22:19,520 --> 03:22:22,190
Просто скопирую для экономии времени

4576
03:22:22,190 --> 03:22:23,810
и это будет третий компонент,
а лишние переменные

4577
03:22:23,810 --> 03:22:26,650
мы просто удалим.

4578
03:22:28,280 --> 03:22:29,660
Если перезапустим, то получим
точно такой же результат

4579
03:22:29,660 --> 03:22:32,280
Донн Фелкер, 30 лет

4580
03:22:32,280 --> 03:22:34,460
И это компонент 1,2 и 3

4581
03:22:34,460 --> 03:22:36,300
Если я теперь поменяю поля местами

4582
03:22:36,300 --> 03:22:40,690
я переставлю 30 на вторую
позицию, но сначала будет много

4583
03:22:40,690 --> 03:22:43,200
ошибок, быстро поправим

4584
03:22:43,200 --> 03:22:45,550
я поменяю поля в конструкторе
местами, чтобы не было ошибок

4585
03:22:47,590 --> 03:22:48,740
И все будет хорошо

4586
03:22:54,630 --> 03:22:56,620
Но теперь компоненты поменяли
свои значения

4587
03:22:56,620 --> 03:22:58,670
компонент один будет Donn
компонент два - будет 30

4588
03:22:58,670 --> 03:23:00,800
и компонент три будет Felker.

4589
03:23:00,800 --> 03:23:02,480
Давайте вернем все на свои места

4590
03:23:02,480 --> 03:23:03,840
и возраст поставим в конце.

4591
03:23:03,840 --> 03:23:06,730
Еще одна вещь

4592
03:23:06,730 --> 03:23:09,570
мы можем использовать
именованные аргументы

4593
03:23:09,570 --> 03:23:11,210
Давайте так и поступим.

4594
03:23:11,210 --> 03:23:16,210
напишем что возраст 30
фамилия Felker

4595
03:23:18,480 --> 03:23:22,810
и имя Donn

4596
03:23:23,800 --> 03:23:26,093
и еще поменяем местами эти два

4597
03:23:26,093 --> 03:23:27,490
Давайте поменяем.

4598
03:23:27,490 --> 03:23:29,750
Теперь порядок в месте вызова
у нас все вперемешку

4599
03:23:29,750 --> 03:23:32,410
но именнованые аргументы
связывают значения с порядком

4600
03:23:32,410 --> 03:23:35,420
в конструкторе и компилятор
сам поймет, как правильно реализовать

4601
03:23:35,420 --> 03:23:37,260
функции компоненты.
Порядок компонент определяется конструктором.

4602
03:23:37,260 --> 03:23:38,750
Именно в этом порядке будут

4603
03:23:38,750 --> 03:23:39,990
сгенерированы компоненты

4604
03:23:39,990 --> 03:23:42,070
Не в том порядке
где вызывается конструктор

4605
03:23:42,070 --> 03:23:44,710
а тос где он объявлен в дата классе

4606
03:23:44,710 --> 03:23:46,480
имя будет component1

4607
03:23:46,480 --> 03:23:49,510
фамилия - component2,
а возраст - component3.

4608
03:23:49,510 --> 03:23:52,490
И даже, если я вызываю конструктор
в другом порядке

4609
03:23:52,490 --> 03:23:55,150
Котлин сам разрулит эти моменты

4610
03:23:55,150 --> 03:23:57,660
и определит нужный порядок.

4611
03:23:57,660 --> 03:24:01,030
В нашем примере первый компонент
это Donn, Felker - второй

4612
03:24:01,030 --> 03:24:04,730
и третий компонент - 30

4613
03:24:04,730 --> 03:24:06,480
Вот так функции компоненты

4614
03:24:06,480 --> 03:24:09,380
генерируются для нас

4615
03:24:09,380 --> 03:24:11,190
И еще одна вешь, важное понятие -
"деструктуризация"

4616
03:24:11,190 --> 03:24:13,730
именно для него
используются функции компоненты

4617
03:24:15,980 --> 03:24:19,230
функции компоненты используются
языком чтобы

4618
03:24:19,230 --> 03:24:21,680
деструктурировать

4619
03:24:21,680 --> 03:24:24,180
дата классы

4620
03:24:24,180 --> 03:24:26,710
Тут у нас компонент1 ссылается на имя -

4621
03:24:26,710 --> 03:24:28,840
потому что он первый в
параметрах конструктора

4622
03:24:28,840 --> 03:24:30,270
в дата классе

4623
03:24:30,270 --> 03:24:32,610
компонент2 это второй параметр

4624
03:24:32,610 --> 03:24:34,760
а компонент3 - третий

4625
03:24:34,760 --> 03:24:36,420
вот пример деструктуризации

4626
03:24:36,420 --> 03:24:39,060
мы создадим переменную и в круглых
скобках напишем через запятую

4627
03:24:41,260 --> 03:24:44,070
имя, фамилия и возраст

4628
03:24:44,070 --> 03:24:45,550
и все это будет равно нашему человеку

4629
03:24:45,550 --> 03:24:48,190
мы человека объявили
во второй строке

4630
03:24:49,330 --> 03:24:50,590
и вот тут мы объявляем

4631
03:24:50,590 --> 03:24:53,170
три переменных и разбиваем (деструктурируем)

4632
03:24:53,170 --> 03:24:54,970
наш класс на три переменные.

4633
03:24:54,970 --> 03:24:57,550
И под капотом Котлин использует

4634
03:24:57,550 --> 03:24:59,860
функции компоненты

4635
03:24:59,860 --> 03:25:02,210
и с помощью них инициализирует
новые переменные

4636
03:25:02,210 --> 03:25:04,450
давайте все эти переменные выведем

4637
03:25:04,450 --> 03:25:06,602
и посмотрим, как они выглядят

4638
03:25:06,602 --> 03:25:10,020
напишем функции вывода и выведем

4639
03:25:10,020 --> 03:25:14,260
наши переменные

4640
03:25:14,260 --> 03:25:15,450
Теперь запустим

4641
03:25:16,620 --> 03:25:20,270
и в консоли будут значения нашего
человека

4642
03:25:20,270 --> 03:25:21,580
Отлично.

4643
03:25:21,580 --> 03:25:25,400
И имена переменных никак на это не влияют

4644
03:25:25,400 --> 03:25:26,780
можно поменять тут все местами

4645
03:25:26,780 --> 03:25:30,440
например имя, возраст, фамилия

4646
03:25:31,510 --> 03:25:32,343
Теперь смотрите.

4647
03:25:32,343 --> 03:25:34,720
И теперь в выводе будет другой порядок

4648
03:25:34,720 --> 03:25:36,750
и мы увидим

4649
03:25:36,750 --> 03:25:38,800
возраст, имя, а томто фамилию

4650
03:25:38,800 --> 03:25:41,500
это все потому что деструктуризация
основана на порядке переменных в скобках

4651
03:25:41,500 --> 03:25:42,810
то есть сюда запишется component1

4652
03:25:42,810 --> 03:25:44,900
и это будет имя

4653
03:25:44,900 --> 03:25:47,210
тут будет фамилия,
которую мы выводим тут

4654
03:25:47,210 --> 03:25:50,012
Это второе, Donn, все верно

4655
03:25:50,012 --> 03:25:51,280
потом будет имя

4656
03:25:51,280 --> 03:25:53,550
которая на самом деле будет содержать
component3 нашего пользователя

4657
03:25:53,550 --> 03:25:56,310
и у нас будет имя

4658
03:25:56,310 --> 03:25:58,060
в котором будет записан возраст

4659
03:25:58,060 --> 03:26:00,250
и он выведется тут и будет равен 30

4660
03:26:00,250 --> 03:26:01,440
И последний вывод это

4661
03:26:01,440 --> 03:26:04,210
переменная возраст в которрую

4662
03:26:04,210 --> 03:26:06,310
запишется значение из component2
функции и это на самом

4663
03:26:06,310 --> 03:26:07,380
деле будет фамилия

4664
03:26:07,380 --> 03:26:10,390
В общем, не важно какие названия
тут будут указаны

4665
03:26:10,390 --> 03:26:14,240
Можем даже переименовать

4666
03:26:14,240 --> 03:26:19,240
эти переменные и назвать их
компонентами

4667
03:26:21,790 --> 03:26:25,190
эти имена ни на что не влияют.

4668
03:26:25,190 --> 03:26:27,190
я бы никогда так не написао в
реальном приложении

4669
03:26:28,210 --> 03:26:30,940
это просто пример и доказательство
того, что тут все зависит от положения

4670
03:26:30,940 --> 03:26:33,390
а не названия

4671
03:26:33,390 --> 03:26:34,500
переменных.

4672
03:26:34,500 --> 03:26:36,500
Все равно результат будет тот же

4673
03:26:36,500 --> 03:26:39,060
Давайте все вернем на прежние позиции

4674
03:26:39,060 --> 03:26:40,150
компонент один, два и три

4675
03:26:40,150 --> 03:26:42,130
чтобы порядок снова был логичным

4676
03:26:42,130 --> 03:26:44,170
и у нас будет Donn Felker 30.

4677
03:26:44,170 --> 03:26:47,060
И снова, я бы просто мог назвать
эту переменную fName

4678
03:26:47,060 --> 03:26:50,940
эту переменную lName
I could call this name for last name.

4679
03:26:50,940 --> 03:26:52,890
случайно включил капслок

4680
03:26:53,940 --> 03:26:56,580
lName, и последнюю я могу

4681
03:26:58,550 --> 03:27:02,070
назвать personAge

4682
03:27:04,200 --> 03:27:07,480
Это все не имеет значения,
в них запишутся

4683
03:27:07,480 --> 03:27:09,540
значения функций компонент

4684
03:27:09,540 --> 03:27:11,190
значения функций компонент

4685
03:27:11,190 --> 03:27:14,680
и так вы можете разбирать
дата классы

4686
03:27:14,680 --> 03:27:17,780
на переменные в одну строку,

4687
03:27:17,780 --> 03:27:19,570
другой способ гораздо длиннее

4688
03:27:19,570 --> 03:27:21,350
вам нужно будет сделать такую цепочку

4689
03:27:21,350 --> 03:27:25,440
Создать переменную имени
и присвоить ей значение из дата класса

4690
03:27:26,370 --> 03:27:29,090
фамилию и ей тоже самое

4691
03:27:30,040 --> 03:27:31,630
и тут на самом деле нет ничего плохого

4692
03:27:31,630 --> 03:27:34,180
просто деструктуризация позволяет

4693
03:27:34,180 --> 03:27:39,180
это делать в одну строку

4694
03:27:39,180 --> 03:27:43,390
это делать в одну строку

4695
03:27:43,390 --> 03:27:48,005
На этом все про деструктуризацию
в языке Котлин

4696
03:27:48,005 --> 03:27:53,005
Очень часто в разработке вам нужно
будет создавать

4697
03:27:55,470 --> 03:27:56,950
копию какой-то информации

4698
03:27:56,950 --> 03:28:00,140
Например вам нужно сделать копию
нашего человека

4699
03:28:00,140 --> 03:28:02,560
И для этого создадим переменную

4700
03:28:02,560 --> 03:28:04,760
и теперь еще один приятный метод
дата класса

4701
03:28:04,760 --> 03:28:07,810
а именно - метод copy()

4702
03:28:07,810 --> 03:28:11,050
Метод copy создает копию

4703
03:28:11,050 --> 03:28:12,520
вашего объекта и всего его

4704
03:28:12,520 --> 03:28:13,590
содержимого.

4705
03:28:13,590 --> 03:28:17,650
И если мы выведем

4706
03:28:17,650 --> 03:28:20,430
сначала нашего человека

4707
03:28:20,430 --> 03:28:23,090
а потом его "родственника"

4708
03:28:23,090 --> 03:28:27,170
в консоли мы увидим два класса
с одними и теми же данными

4709
03:28:27,170 --> 03:28:28,890
Иногда может возникнуть ситуация
что при копировании

4710
03:28:28,890 --> 03:28:30,640
вам нужно заменить парочку параметров

4711
03:28:30,640 --> 03:28:32,500
вашего класса

4712
03:28:32,500 --> 03:28:35,240
И я могу, например

4713
03:28:35,240 --> 03:28:36,500
заменить имя на Sam

4714
03:28:36,500 --> 03:28:37,470
И если запустим теперь

4715
03:28:37,470 --> 03:28:39,780
то увидим что все данные совпадают,

4716
03:28:39,780 --> 03:28:41,720
но у второго человека имя Sam

4717
03:28:41,720 --> 03:28:44,470
И давайте например Sam
это родственник постарше

4718
03:28:44,470 --> 03:28:46,650
и ему 44 года

4719
03:28:47,490 --> 03:28:48,420
Перезапустим..

4720
03:28:48,420 --> 03:28:51,320
И увидим нашего Сэма, которому 44 года.

4721
03:28:51,320 --> 03:28:52,980
И это самый простой создавать и
измениять объекты при копировании

4722
03:28:52,980 --> 03:28:56,280
Это особенно полезно, когда
у вашего объекта очень много параметров

4723
03:28:56,280 --> 03:29:00,870
Например у вас есть человек, или лучше

4724
03:29:00,870 --> 03:29:03,470
у вас есть заказ

4725
03:29:03,470 --> 03:29:07,140
У заказа есть сумма

4726
03:29:07,140 --> 03:29:09,990
по идее сумма может меняться, но пусть

4727
03:29:09,990 --> 03:29:12,400
она будет val в этом примере

4728
03:29:12,400 --> 03:29:15,020
и заказ принадлежит какому-то человеку

4729
03:29:15,020 --> 03:29:16,150
пусть это будет customer (клиент)

4730
03:29:16,150 --> 03:29:18,620
и тип будет Person

4731
03:29:18,620 --> 03:29:22,570
В таком виде мы можем

4732
03:29:22,570 --> 03:29:24,560
создать наш заказ

4733
03:29:24,560 --> 03:29:25,700
напишем переменную order

4734
03:29:26,870 --> 03:29:30,420
И пусть сумма будет 100

4735
03:29:30,420 --> 03:29:35,420
и наш человек будет

4736
03:29:35,420 --> 03:29:36,520
родственником

4737
03:29:37,938 --> 03:29:41,860
простите, клиент будет родственником

4738
03:29:41,860 --> 03:29:44,140
и теперь мы выведем заказ

4739
03:29:44,140 --> 03:29:48,210
увидим что сумма заказа 100

4740
03:29:49,350 --> 03:29:50,310
и тут внутри мы увидим заказчика

4741
03:29:50,310 --> 03:29:53,330
это наш родственник

4742
03:29:53,330 --> 03:29:55,710
До пустим я хочу скопировать этот заказ

4743
03:29:55,710 --> 03:29:56,860
Я могу сделать новый заказ

4744
03:29:59,060 --> 03:30:00,970
и пусть заказчик будет тем же

4745
03:30:00,970 --> 03:30:02,720
я просто хочу сменить сумму.

4746
03:30:03,687 --> 03:30:06,750
Я введу сумму 200,

4747
03:30:06,750 --> 03:30:08,420
допустим они что-то еще набрали
в заказе

4748
03:30:08,420 --> 03:30:10,430
и заказчик остается тем же)

4749
03:30:10,430 --> 03:30:12,270
Я могу это без проблем сделать

4750
03:30:12,270 --> 03:30:13,103
Ой простите

4751
03:30:13,103 --> 03:30:15,060
Мы напишем order.copy()

4752
03:30:16,150 --> 03:30:18,400
и введем сумму 200

4753
03:30:20,110 --> 03:30:21,560
И после того как ввели,

4754
03:30:22,452 --> 03:30:24,690
можем вывести этот новый заказ в консоль.

4755
03:30:26,280 --> 03:30:27,950
и когда все запустится

4756
03:30:27,950 --> 03:30:29,660
мы увидим новый заказ

4757
03:30:29,660 --> 03:30:32,460
на сумму 200 с тем же
самым заказчиком

4758
03:30:32,460 --> 03:30:34,480
Мы так же можем

4759
03:30:34,480 --> 03:30:36,970
пойти по другому пути

4760
03:30:36,970 --> 03:30:41,800
давайте создадим еще один заказ

4761
03:30:41,800 --> 03:30:44,120
и теперь мы хотим

4762
03:30:44,120 --> 03:30:45,320
в заказе оставить прежнюю сумму

4763
03:30:45,320 --> 03:30:47,380
но поменять заказчика

4764
03:30:47,380 --> 03:30:50,790
и заказчиком должен стать person

4765
03:30:50,790 --> 03:30:52,510
Выведем это в консоль

4766
03:30:52,510 --> 03:30:54,130
посмотрим на результат.

4767
03:30:54,130 --> 03:30:56,890
вводим второй заказ
и запускаем

4768
03:30:56,890 --> 03:31:00,210
Видим в консоли что
сумма по прежнему 100

4769
03:31:00,210 --> 03:31:03,300
но сменился заказчик.

4770
03:31:03,300 --> 03:31:06,940
И так можно копировать дата классы
в Котлине

4771
03:31:06,940 --> 03:31:10,630
Важно понимать, что если
в вашем классе есть

4772
03:31:10,630 --> 03:31:12,110
списки, то при копировании
будет происходить поверхностное копирование

4773
03:31:12,110 --> 03:31:13,940
то есть будет копироваться ссылка на
список, а не контент списка.

4774
03:31:13,940 --> 03:31:15,970
Будьте осторожны при копировании
объектов со списками.

4775
03:31:17,940 --> 03:31:19,410
Вы можете делать свои собственные
data классы, но я хочу

4776
03:31:19,410 --> 03:31:21,890
показать вам парочку полезных

4777
03:31:21,890 --> 03:31:23,580
готовых data классов из библиотеки.

4778
03:31:23,580 --> 03:31:27,430
Один из них - класс Pair и
он просто хранит пару значений

4779
03:31:27,430 --> 03:31:32,430
В него например можно положить
строки "foo" и "bar",

4780
03:31:33,310 --> 03:31:35,310
и теперь это просто переменная
с парой значений, которые

4781
03:31:35,310 --> 03:31:38,610
можно получить через поля first
и second

4782
03:31:41,151 --> 03:31:41,984
И так можно передавать значения парами.

4783
03:31:41,984 --> 03:31:43,960
И вам не нужно создавать

4784
03:31:43,960 --> 03:31:46,240
собственный класс, если вам нужно
передавать пару значений

4785
03:31:46,240 --> 03:31:47,880
в программе, можно просто

4786
03:31:47,880 --> 03:31:49,480
сложить их в Pair.

4787
03:31:49,480 --> 03:31:53,010
и если вы выведете Pair

4788
03:31:53,010 --> 03:31:57,887
в консоль first и second значения

4789
03:31:59,500 --> 03:32:02,740
то сначала мы увидим foo,
а потом bar

4790
03:32:02,740 --> 03:32:05,850
Еще в Котлине для Pair
существует специальный

4791
03:32:05,850 --> 03:32:06,750
синтаксис для создания.

4792
03:32:06,750 --> 03:32:09,090
В подсказках можно увидеть опцию
"Конвертировать с 'to'"

4793
03:32:09,090 --> 03:32:11,550
И теперь у нас будет такой синтаксис

4794
03:32:11,550 --> 03:32:15,330
который читается "foo к bar"

4795
03:32:15,330 --> 03:32:16,163
и его результат дает нам Pair

4796
03:32:16,163 --> 03:32:19,060
Это просто еще один легче читаемый

4797
03:32:19,060 --> 03:32:22,410
способ создать пару в программе

4798
03:32:22,410 --> 03:32:26,350
И это уже встроено
в стандартные средства Котлина

4799
03:32:26,350 --> 03:32:28,588
Мы можем посмотреть реализацию

4800
03:32:28,588 --> 03:32:31,120
"Создает пару из переданных значений"

4801
03:32:31,120 --> 03:32:33,980
this и that это два наших
значения

4802
03:32:33,980 --> 03:32:35,580
но не сильно парьтесь по поводу реализации

4803
03:32:35,580 --> 03:32:38,370
самое главное что пару можно создавать так

4804
03:32:38,370 --> 03:32:40,640
или стандартным способом

4805
03:32:40,640 --> 03:32:43,880
через конструктор класса

4806
03:32:43,880 --> 03:32:46,910
И у нас тут небольшая ошибка

4807
03:32:46,910 --> 03:32:47,743
Еще один дата класс на случай

4808
03:32:47,743 --> 03:32:50,120
если у вас три значения,
называется Triple

4809
03:32:51,390 --> 03:32:53,150
и он очень похож на пару

4810
03:32:53,150 --> 03:32:58,150
И значения впишем foo, bar и что-то еще

4811
03:32:58,470 --> 03:32:59,860
и у нас будут три значения

4812
03:32:59,860 --> 03:33:00,850
И тут все работает так же

4813
03:33:00,850 --> 03:33:05,640
мы можем позвать triple.first,
triple.second, triple.third

4814
03:33:07,353 --> 03:33:08,210
и получить значения

4815
03:33:08,210 --> 03:33:09,540
Важно отметить, что тип не обязательно

4816
03:33:09,540 --> 03:33:10,640
должен совпадать

4817
03:33:10,640 --> 03:33:13,370
напрмер если мы хотим, чтобы третий
элемент был Int мы можем его заменить

4818
03:33:13,370 --> 03:33:16,190
можно заменить на Boolean

4819
03:33:16,190 --> 03:33:18,260
зависит от того что вам нужно

4820
03:33:18,260 --> 03:33:20,070
И теперь мы увидим

4821
03:33:20,070 --> 03:33:23,950
что triple.second возвращает Boolean

4822
03:33:23,950 --> 03:33:25,420
вот тут

4823
03:33:25,420 --> 03:33:27,760
А triple.third возвращает Int

4824
03:33:29,252 --> 03:33:30,260
И, конечно, это data класс
и мы можем копировтаь наш контейнер

4825
03:33:30,260 --> 03:33:31,510
потому что это заранее встроено

4826
03:33:31,510 --> 03:33:34,260
в функциональность

4827
03:33:34,260 --> 03:33:35,770
data классов

4828
03:33:35,770 --> 03:33:40,640
Это два готовых к использованию
встроенных data классов

4829
03:33:40,640 --> 03:33:42,830
в стандартной библиотеке Котлина

4830
03:33:42,830 --> 03:33:44,010
Конечно со временем появится что-то новое,

4831
03:33:44,010 --> 03:33:45,770
если вывдруг смотрите курс спустя
несколько лет,

4832
03:33:45,770 --> 03:33:48,720
но на данный момент эти два класса
есть в стандартной библиотеке.

4833
03:33:50,110 --> 03:33:54,670
К переменным класса можно
добавлять модификатор protected

4834
03:33:54,670 --> 03:33:57,910
Для этого в классе при объявлении

4835
03:33:57,910 --> 03:34:02,100
переменной вам нужно дописать
модификатор protected

4836
03:34:02,100 --> 03:34:03,630
в самом начале.

4837
03:34:03,630 --> 03:34:06,820
Тут я добавил protected
к переменной любимого блюда

4838
03:34:06,820 --> 03:34:08,260
Давайте теперь его уберем и

4839
03:34:08,260 --> 03:34:10,770
посмотрим на что он влияет

4840
03:34:10,770 --> 03:34:13,040
В main файле я создам

4841
03:34:13,040 --> 03:34:15,930
переменную с типом Person

4842
03:34:15,930 --> 03:34:17,860
у человека есть любимое блюдо

4843
03:34:17,860 --> 03:34:21,040
Допустим это арбуз

4844
03:34:21,040 --> 03:34:22,620
и все работает хорошо

4845
03:34:22,620 --> 03:34:24,930
у нас есть доступ на изменение и получение

4846
03:34:24,930 --> 03:34:27,140
и так мы уже работали с полями

4847
03:34:27,140 --> 03:34:30,810
но если я добавлю модификатор
protected

4848
03:34:30,810 --> 03:34:32,890
то он ограничит доступ к переменной

4849
03:34:32,890 --> 03:34:35,020
И область видимости этой переменной
сузится до этого класса

4850
03:34:35,020 --> 03:34:40,020
и классов, которые наследуются
от него

4851
03:34:40,040 --> 03:34:42,640
если вернемся в main  и увидим

4852
03:34:42,640 --> 03:34:45,160
что у нас больше нет доступа
и мы не можем менять или получать это поле

4853
03:34:45,160 --> 03:34:49,350
И если я попробую посмотреть
какие поля доступны

4854
03:34:49,350 --> 03:34:52,600
то IDEA перестанет показывать
наше поле

4855
03:34:52,600 --> 03:34:54,780
и причина тому модификатор
protected

4856
03:34:54,780 --> 03:34:58,380
и теперь доступ к полю есть только

4857
03:34:58,380 --> 03:34:59,880
у самого класса и его наследников

4858
03:34:59,880 --> 03:35:01,060
Давайте посмотрим на примере

4859
03:35:01,060 --> 03:35:03,930
Я уже сделал еще один класс Chef

4860
03:35:03,930 --> 03:35:06,260
И мне пришлось дописать модификатор
open, чтобы я мог

4861
03:35:06,260 --> 03:35:09,480
наследоваться от класса Person

4862
03:35:09,480 --> 03:35:11,682
и я отнаследовал Chef от Person

4863
03:35:11,682 --> 03:35:12,630
теперь Chef расширяет функциональность
класса Peron

4864
03:35:12,630 --> 03:35:16,410
И теперь, у меня есть класс Chef

4865
03:35:16,410 --> 03:35:18,590
и он тоже может иметь
любимое блюдо из-за наследования полей

4866
03:35:18,590 --> 03:35:22,350
и я могу передать это блюдо в конструктор
тип у него будет String

4867
03:35:22,350 --> 03:35:24,520
И теперь, когда я создаю Шефа

4868
03:35:24,520 --> 03:35:26,470
нужно передавать любимое блюдо

4869
03:35:26,470 --> 03:35:28,950
И нужно это как-то сохранить

4870
03:35:28,950 --> 03:35:30,930
Я создам блок инициализации

4871
03:35:30,930 --> 03:35:33,840
он будет вызываться при создании класса

4872
03:35:33,840 --> 03:35:35,340
и тут я могу написать
что любимое блюдо равно

4873
03:35:35,340 --> 03:35:36,690
тому блюду, что мы передали

4874
03:35:36,690 --> 03:35:38,580
И если я пойду посмотреть где объявлено
это поле, то IDE

4875
03:35:38,580 --> 03:35:41,400
перекинет меня на пятую строчку в Person

4876
03:35:41,400 --> 03:35:44,070
вернемся в блок и напишем, что
любимое блюдо

4877
03:35:44,070 --> 03:35:47,500
это блюдо, которое пришло в конструкторе

4878
03:35:47,500 --> 03:35:48,940
И это интересно

4879
03:35:48,940 --> 03:35:52,460
Не смотря на модификатор
я могу работать с эти полем в классе Chef.

4880
03:35:52,460 --> 03:35:54,860
Если по какой-то причине я хочу запретить

4881
03:35:54,860 --> 03:35:59,453
изменять поле

4882
03:36:01,050 --> 03:36:03,730
класса снаружи

4883
03:36:03,730 --> 03:36:05,970
И оставить эту возможность только
наследникам, то можно исопльзовать protected

4884
03:36:05,970 --> 03:36:08,620
и класс Person все еще может
использовать и менять его

4885
03:36:08,620 --> 03:36:10,920
вот тут я могу вызвать favoriteFood

4886
03:36:12,347 --> 03:36:13,180
и изменить его при желании

4887
03:36:13,180 --> 03:36:16,580
Но давать менять его снаружи

4888
03:36:16,580 --> 03:36:19,640
и получать его снаружи уже не получится.

4889
03:36:19,640 --> 03:36:21,470
Я не хочу чтобы у кого-то была возможность

4890
03:36:21,470 --> 03:36:25,840
вызвать favoriteFood через
экзепляр класса

4891
03:36:25,840 --> 03:36:28,950
И если я теперь создам
экзепляр класса Chef

4892
03:36:28,950 --> 03:36:32,660
Напрмер как-то так,

4893
03:36:33,610 --> 03:36:37,930
пусть будет Боб, 33 года
и он любит ребрышки.

4894
03:36:39,110 --> 03:36:41,860
И тут мы можем выбрать

4895
03:36:41,860 --> 03:36:42,810
любимое блюдо

4896
03:36:42,810 --> 03:36:44,860
потому что так объявлен конструктор

4897
03:36:44,860 --> 03:36:48,210
и это значение попадет в блок
инициализации

4898
03:36:48,210 --> 03:36:50,230
И давайте допустим, что
мы хотим позволить

4899
03:36:50,230 --> 03:36:51,090
менять блюдо у шефа

4900
03:36:51,090 --> 03:36:54,850
Для этого сооздадим функцию
setFavoriteFood

4901
03:36:54,850 --> 03:36:57,260
и передадим туда новое блюдо

4902
03:36:57,260 --> 03:37:01,090
и внутри функции мы выставим
любимое блюдо равно

4903
03:37:01,090 --> 03:37:01,970
новому блюду.

4904
03:37:03,810 --> 03:37:05,830
Тут есть интересная ошибка

4905
03:37:05,830 --> 03:37:06,740
метод подчеркнулся красным

4906
03:37:06,740 --> 03:37:08,650
и если наведем курсор

4907
03:37:08,650 --> 03:37:12,146
мы увидим сообщение о случайном
переопределении функции

4908
03:37:12,146 --> 03:37:14,170
Это потому что котлин под капотом

4909
03:37:14,170 --> 03:37:16,700
выполняет работу за нас и когда

4910
03:37:16,700 --> 03:37:19,500
мы объявляем поля, Котлин

4911
03:37:19,500 --> 03:37:21,020
создает для нас

4912
03:37:21,020 --> 03:37:25,170
функции на получение
и изменения этого поля

4913
03:37:25,170 --> 03:37:27,670
с названием getFavoriteFood и
setFavoriteFood

4914
03:37:27,670 --> 03:37:29,390
которые позволяют нам получить

4915
03:37:29,390 --> 03:37:30,610
или изсенить это поле

4916
03:37:30,610 --> 03:37:33,700
это наследие из Java

4917
03:37:33,700 --> 03:37:35,830
но в котлине эти методы вызываются неявно

4918
03:37:36,750 --> 03:37:39,100
при обращении к самому полю

4919
03:37:40,330 --> 03:37:44,690
В случае get** нам вернется строка

4920
03:37:44,690 --> 03:37:46,720
а вслучае set** нам вернется Unit,
но мы должны передать строку.

4921
03:37:46,720 --> 03:37:49,590
это нужно для поддержки работы
Котлина с Java

4922
03:37:49,590 --> 03:37:53,540
В Джаве, когда вы создаете поле

4923
03:37:53,540 --> 03:37:54,770
вам нужно создать геттер и сеттер

4924
03:37:54,770 --> 03:37:56,860
функции чтобы получать или изменять это поле

4925
03:37:56,860 --> 03:37:58,560
И обычно они называеются как само

4926
03:37:58,560 --> 03:38:02,400
поле, но прибавляется

4927
03:38:02,400 --> 03:38:06,660
префикс set и после него
идет название поля

4928
03:38:06,660 --> 03:38:09,910
конечно оно будет с большой буквы теперь

4929
03:38:09,910 --> 03:38:13,950
и для получения - функция с префиксом

4930
03:38:13,950 --> 03:38:16,410
get и названием поля

4931
03:38:16,410 --> 03:38:18,020
в таком же формате как и сеттер

4932
03:38:18,020 --> 03:38:20,310
в таком же формате как и сеттер

4933
03:38:20,310 --> 03:38:23,080
в котлине эти функции генерируются

4934
03:38:23,080 --> 03:38:24,080
под капотом

4935
03:38:24,080 --> 03:38:27,670
И котлин говорит, что не может
создать функцию

4936
03:38:28,630 --> 03:38:29,463
потому что он ее уже

4937
03:38:29,463 --> 03:38:32,530
сгенерировал, хоть ее нигде
не видно

4938
03:38:32,530 --> 03:38:34,690
Чтобы это исправить я просто
переименую в setMyfavoriteFood

4939
03:38:34,690 --> 03:38:36,270
просто для примера.

4940
03:38:36,270 --> 03:38:38,460
если вернемся в main файл

4941
03:38:38,460 --> 03:38:41,560
то теперь у класса Chef мы

4942
03:38:41,560 --> 03:38:43,032
можем поменять любимое блюдо

4943
03:38:43,032 --> 03:38:45,032
И я поменяю на "Сельдерей"

4944
03:38:46,240 --> 03:38:47,600
Я не очень люблю сельдерей

4945
03:38:47,600 --> 03:38:49,830
но это просто ради примера

4946
03:38:49,830 --> 03:38:52,560
И теперь любимое блюда этого шефа
сменится на сельдерей

4947
03:38:52,560 --> 03:38:56,410
Но если мы попытаемся поменять
любимое блюдо

4948
03:38:56,410 --> 03:38:59,690
у нашего человека, то Котлин эту функцию

4949
03:38:59,690 --> 03:39:01,230
не найдет.

4950
03:39:01,230 --> 03:39:02,580
И это очень интересно

4951
03:39:02,580 --> 03:39:05,310
Но мы можем сделать функцию

4952
03:39:06,240 --> 03:39:10,913
выводит в консоль любимое блюдо

4953
03:39:12,500 --> 03:39:13,350
А в теле функции

4954
03:39:13,350 --> 03:39:14,220
просто напишем println

4955
03:39:16,080 --> 03:39:17,430
и внутри него

4956
03:39:19,519 --> 03:39:20,520
выведем favoriteFood

4957
03:39:21,395 --> 03:39:22,228
проще простого

4958
03:39:22,228 --> 03:39:23,420
И теперь вызовем эту функцию у человека

4959
03:39:23,420 --> 03:39:26,620
напишем p.printMyFavoriteFood

4960
03:39:26,620 --> 03:39:28,080
все работает

4961
03:39:28,080 --> 03:39:28,920
И теперь, чуть ниже напишем

4962
03:39:28,920 --> 03:39:31,180
давайте напишем дважны, до и после изменения

4963
03:39:31,180 --> 03:39:34,540
тут и строчкой ниже

4964
03:39:34,540 --> 03:39:35,480
выводим

4965
03:39:35,480 --> 03:39:39,880
И класс Chef наследуется от Person,
поэтому все методы и поля класса

4966
03:39:41,860 --> 03:39:44,260
Person автоматом переносятся в Chef

4967
03:39:45,400 --> 03:39:48,900
и я в классе Chef могу звать любые
функции пользователя

4968
03:39:48,900 --> 03:39:51,250
если на них не стоит модификатор private

4969
03:39:51,250 --> 03:39:52,860
и я вызываю printMyFavoriteFood

4970
03:39:52,860 --> 03:39:54,070
Для класса Person

4971
03:39:54,070 --> 03:39:56,880
долен вывестись unknown, потому что
это дефолтное значение

4972
03:39:56,880 --> 03:39:59,180
и мы никак не можем выставить
любимое блюдо у человека

4973
03:40:00,220 --> 03:40:02,120
но можем его выставить,
если человек это Chef

4974
03:40:02,120 --> 03:40:04,230
Итак, сначала выведется unknown

4975
03:40:04,230 --> 03:40:08,100
а для шефа будет два вывода

4976
03:40:09,682 --> 03:40:10,515
в первый раз выведутся рюбра

4977
03:40:10,515 --> 03:40:12,456
а потом будет замена на сельдерей

4978
03:40:12,456 --> 03:40:15,150
и выведется сельдерей.

4979
03:40:15,150 --> 03:40:20,150
И так мы можем работать с
protected полями

4980
03:40:20,410 --> 03:40:22,310
Если вам нужно что-то скрыть
для внешнего вмешательство

4981
03:40:22,310 --> 03:40:25,970
но оставить открытым для класса

4982
03:40:25,970 --> 03:40:28,190
и его наследников

4983
03:40:28,190 --> 03:40:32,710
без проблем можно обозначить

4984
03:40:32,710 --> 03:40:35,730
поля и методы с помощью

4985
03:40:35,730 --> 03:40:36,563
ключевого слова protected.

4986
03:40:36,563 --> 03:40:39,460
и все это работает с любыми

4987
03:40:39,460 --> 03:40:40,360
типами.

4988
03:40:40,360 --> 03:40:42,250
Давайте запустим

4989
03:40:42,250 --> 03:40:43,450
и увидим выводы

4990
03:40:44,513 --> 03:40:46,460
первый "unknown" это блюдо человека

4991
03:40:46,460 --> 03:40:48,640
дальше ribs и celery

4992
03:40:48,640 --> 03:40:51,050
И так вы можете использовать
ключевое слово protected

4993
03:40:51,050 --> 03:40:51,883
в Котлине

4994
03:40:53,470 --> 03:40:57,260
protected можно выставлять у методов

4995
03:40:57,260 --> 03:40:59,870
давайте на этом же примере

4996
03:40:59,870 --> 03:41:02,830
рассмотрим новый способ.

4997
03:41:04,000 --> 03:41:07,100
например у нас есть метод,
который выводит любимое блюдо

4998
03:41:07,100 --> 03:41:09,500
который мы уже используем в
main функции

4999
03:41:09,500 --> 03:41:14,500
Вот тут используем у person

5000
03:41:16,338 --> 03:41:18,340
а тут у шефа

5001
03:41:20,260 --> 03:41:22,400
и нам веведется любимое блюдо

5002
03:41:22,400 --> 03:41:24,990
которое определено
в классе Person

5003
03:41:24,990 --> 03:41:27,470
Давайте рассмотрим пример
когда мы не хотим, чтобы

5004
03:41:27,470 --> 03:41:29,780
внутри нашего приложения
эта функция не была частью

5005
03:41:29,780 --> 03:41:32,297
публичного API

5006
03:41:32,297 --> 03:41:35,880
Под публичным API я подразумеваю
что эта функуия

5007
03:41:35,880 --> 03:41:39,340
может вызываться откуда угодно

5008
03:41:39,340 --> 03:41:40,870
потому что это публичный метод

5009
03:41:40,870 --> 03:41:43,170
и доступ к нему публичный

5010
03:41:43,170 --> 03:41:44,530
Например по какой-то причине вы

5011
03:41:44,530 --> 03:41:47,770
хотите чтобы доступ к этой
функции был только у экземпляров

5012
03:41:47,770 --> 03:41:50,170
класса Person или его наследников

5013
03:41:50,170 --> 03:41:51,480
например таких как Chef

5014
03:41:52,690 --> 03:41:54,040
Для этого вам всего лишь нужно

5015
03:41:54,040 --> 03:41:57,100
поставить ключевое слово protected.

5016
03:41:57,100 --> 03:42:00,060
И теперь этот модификатор работает

5017
03:42:00,060 --> 03:42:02,880
и мы не можем вызывать функции
в main файле

5018
03:42:02,880 --> 03:42:05,890
но можем звать внутри класса
тут и тут

5019
03:42:05,890 --> 03:42:07,950
Давайте вернемеся в main
файл и посмотрим

5020
03:42:07,950 --> 03:42:09,150
что поменялось.

5021
03:42:09,150 --> 03:42:13,040
Теперь мы видим что функция
myFavoriteFood protected.

5022
03:42:13,040 --> 03:42:13,930
Что это собственно значит?

5023
03:42:13,930 --> 03:42:16,570
Давайте посмотрим на авто заполнение

5024
03:42:17,470 --> 03:42:19,640
мы больше не видим нашу функцию

5025
03:42:19,640 --> 03:42:23,370
Но если мы перейдем
в метод info

5026
03:42:23,370 --> 03:42:25,150
мы можем вызвать эту функцию тут

5027
03:42:25,150 --> 03:42:27,940
И у нас есть доступ к ней из
класса Person.

5028
03:42:27,940 --> 03:42:29,630
И это дает нам много возможностей
не раскрывая метод всемо коду

5029
03:42:29,630 --> 03:42:33,660
И можно использовать в других
наследниках Person

5030
03:42:33,660 --> 03:42:35,340
например мы хотим выводить

5031
03:42:35,340 --> 03:42:38,370
любимое блюдо, когда оно изменилось

5032
03:42:38,370 --> 03:42:39,650
и можем вызывать эту функцию

5033
03:42:39,650 --> 03:42:41,180
из любого наследника Person.

5034
03:42:41,180 --> 03:42:43,710
Например мы хотим

5035
03:42:43,710 --> 03:42:46,680
выводить, когда у нас новое значение

5036
03:42:46,680 --> 03:42:47,513
любимого блюда

5037
03:42:47,513 --> 03:42:49,400
Можем написать println функцию

5038
03:42:49,400 --> 03:42:51,710
И когда вернемся в main...

5039
03:42:51,710 --> 03:42:55,190
И тут конечно мы уже не можем
вызывать эти функции

5040
03:42:55,190 --> 03:42:57,740
потому что они закрыты для

5041
03:42:57,740 --> 03:43:00,330
внешнего использования,
так может быть устроено ваше

5042
03:43:00,330 --> 03:43:02,620
приложение

5043
03:43:02,620 --> 03:43:04,490
но мы можем
установить новое значение

5044
03:43:04,490 --> 03:43:07,020
мы знаем, что раньше любимым
блюдом были ребрышки

5045
03:43:08,164 --> 03:43:10,030
но по какой-то причине
мы хотим поменять

5046
03:43:10,030 --> 03:43:12,890
и сделать картошку любимым блюдом

5047
03:43:15,810 --> 03:43:18,610
И если теперь запустим приложение

5048
03:43:18,610 --> 03:43:22,550
то увидим, что значение изменилось
на картошку

5049
03:43:22,550 --> 03:43:24,794
и в консоли тоже выведется картошка

5050
03:43:24,794 --> 03:43:26,510
Вот она наша картошка

5051
03:43:26,510 --> 03:43:28,660
А выводится это потому что
внутри set функции

5052
03:43:28,660 --> 03:43:30,320
мы зовем нашу protected функцию

5053
03:43:30,320 --> 03:43:32,911
любимое блюдо заменяется,
а потом выводится

5054
03:43:32,911 --> 03:43:34,000
на экран с помощью другой функции,

5055
03:43:34,000 --> 03:43:36,330
доступной только в этом классе

5056
03:43:36,330 --> 03:43:38,990
И вообще все можно сделать
немного по другому

5057
03:43:38,990 --> 03:43:39,900
Нам не обязательно хранить вывод
любимого блюда внутри Person

5058
03:43:39,900 --> 03:43:43,280
И наверное наш Person не должен ничего
знать о любимой еде

5059
03:43:43,280 --> 03:43:46,170
Таким образом Person станет шаблоном
который хранит имя и возраст

5060
03:43:46,170 --> 03:43:49,040
и понятия не имеет,

5061
03:43:49,040 --> 03:43:50,920
какую еду любит человек

5062
03:43:50,920 --> 03:43:53,540
Для этого нам нужно перенести
поле и метод

5063
03:43:53,540 --> 03:43:56,130
вниз в класс Chef

5064
03:43:57,980 --> 03:43:58,990
И внутри Chef будут
лежать поле и метод

5065
03:43:58,990 --> 03:44:00,430
Итак, у нас есть любимое блюдо, но

5066
03:44:00,430 --> 03:44:03,120
есть небольшая проблемка

5067
03:44:03,120 --> 03:44:05,230
Что говорит подсказка...

5068
03:44:05,230 --> 03:44:07,730
Переменная не можеть быть присвоена
до определения

5069
03:44:08,580 --> 03:44:10,000
Тут мы можем делаем следующее

5070
03:44:10,000 --> 03:44:12,510
в init методе пытаемся
выставить значение

5071
03:44:12,510 --> 03:44:13,810
но сама переменная объявлена ниже

5072
03:44:14,793 --> 03:44:15,626
Это можно поправить парой способов

5073
03:44:15,626 --> 03:44:16,500
для начала просто уберем это

5074
03:44:16,500 --> 03:44:17,920
и теперь можем убрать поле

5075
03:44:17,920 --> 03:44:20,950
и нам каждому Шефу нужно
любимое блюдо, поэтому

5076
03:44:20,950 --> 03:44:22,900
просто пойдем в конструктор

5077
03:44:22,900 --> 03:44:24,410
и добавим к переменной ключевое
слово var

5078
03:44:24,410 --> 03:44:26,380
Просто пришлепнем
ключевое слово var

5079
03:44:26,380 --> 03:44:28,740
и тепере мы можем вызывать
и менять это поле

5080
03:44:28,740 --> 03:44:31,390
И если вернемся в main файл

5081
03:44:32,630 --> 03:44:34,670
после того как мы почистили наши классы

5082
03:44:34,670 --> 03:44:36,530
у нас все еще может быть
экземпляр Person

5083
03:44:36,530 --> 03:44:38,730
и экзепляр Chef

5084
03:44:38,730 --> 03:44:40,460
и программа все еще будет запускаться

5085
03:44:40,460 --> 03:44:44,100
теперь наш Person это просто

5086
03:44:46,048 --> 03:44:46,881
какой-то базовый класс

5087
03:44:46,881 --> 03:44:48,808
и после запуска мы все еще увидим картошку

5088
03:44:48,808 --> 03:44:50,766
И Person теперь

5089
03:44:50,766 --> 03:44:51,777
это просто хранилище для
возраста и имени

5090
03:44:51,777 --> 03:44:53,800
а это самая базовая информация
которая подходит по смыслу

5091
03:44:53,800 --> 03:44:55,920
а все наследники только добавляют
новые свойства

5092
03:44:55,920 --> 03:44:57,720
Как, например, наш шеф,
который добавляет любимое блюдо

5093
03:44:57,720 --> 03:44:58,830
своим экземплярам.

5094
03:44:58,830 --> 03:45:00,620
И у шефа есть дополнительные

5095
03:45:00,620 --> 03:45:03,330
методы связанные с его полями,
например приготовить или

5096
03:45:03,330 --> 03:45:05,440
вывести блюдо в консоль.

5097
03:45:05,440 --> 03:45:07,730
И чем больше растет наше приложение

5098
03:45:07,730 --> 03:45:10,060
тем больше мы начнем разделять
обязанности классов

5099
03:45:10,060 --> 03:45:13,540
и беспокоиться за архитектуру

5100
03:45:14,800 --> 03:45:19,800
и области видимости, как мы

5101
03:45:20,740 --> 03:45:22,620
делали с классами Chef
и классом Person

5102
03:45:22,620 --> 03:45:24,920
So, which kind of brings up a good point

5103
03:45:24,920 --> 03:45:29,520
that if you had a chef class,
well, you could also have

5104
03:45:30,700 --> 03:45:33,000
a class, you have a sous chef class.

5105
03:45:34,020 --> 03:45:36,880
And this one would take in
taking the name and a string

5106
03:45:36,880 --> 03:45:41,880
and an age and int and
a favorite food perhaps.

5107
03:45:44,360 --> 03:45:46,390
And this one would inherit from chef.

5108
03:45:48,700 --> 03:45:50,700
And so we have name, age, favorite food.

5109
03:45:52,630 --> 03:45:53,630
There we go.

5110
03:45:56,030 --> 03:45:58,280
We just gonna renew this
to fave food or whatever,

5111
03:46:00,280 --> 03:46:01,780
we'll call this the fave food.

5112
03:46:02,680 --> 03:46:04,907
And then of course we
could have inside of here,

5113
03:46:04,907 --> 03:46:05,740
something else, we have some other classes

5114
03:46:05,740 --> 03:46:08,820
and stuff inside here,
or you can actually,

5115
03:46:08,820 --> 03:46:12,427
if you would like to, you can
say inside of your inner block

5116
03:46:14,600 --> 03:46:16,240
whatever reason you
wanted to print something

5117
03:46:16,240 --> 03:46:18,380
when it was created, you
could do that side of here.

5118
03:46:18,380 --> 03:46:21,600
And so for my favorite
food is not accessible

5119
03:46:21,600 --> 03:46:24,080
to the outside world,
it's not a public API.

5120
03:46:24,080 --> 03:46:29,080
So I can't call c.print my
favorite food, which is a chef.

5121
03:46:30,910 --> 03:46:33,700
I can't call it anywhere in
public because it's protected.

5122
03:46:33,700 --> 03:46:35,510
However, any of the children classes

5123
03:46:35,510 --> 03:46:36,580
can then still call this.

5124
03:46:36,580 --> 03:46:39,650
So here person is just giving us

5125
03:46:39,650 --> 03:46:42,120
some root level inheritance.

5126
03:46:42,120 --> 03:46:43,680
Now we're kind of created chef class

5127
03:46:43,680 --> 03:46:45,030
has some stuff around it.

5128
03:46:45,030 --> 03:46:46,260
And then we've got a sous chef class

5129
03:46:46,260 --> 03:46:47,750
that maybe has some other
things inside of here.

5130
03:46:47,750 --> 03:46:51,850
And you might wanna have
something like prep foods methods

5131
03:46:51,850 --> 03:46:54,800
and stuff like that or something
that a sous chef would do.

5132
03:46:55,910 --> 03:46:58,650
And that's how you can create a method,

5133
03:46:58,650 --> 03:47:01,350
which has a visibility
modifier of protected.

5134
03:47:03,470 --> 03:47:06,560
How do we use the internal
modifier on a class?

5135
03:47:07,800 --> 03:47:09,613
And what does it use for?

5136
03:47:09,613 --> 03:47:10,500
It's a great question.

5137
03:47:10,500 --> 03:47:13,260
So the vehicle class that we have here

5138
03:47:13,260 --> 03:47:17,500
is a very simple class that
just takes a color of a vehicle,

5139
03:47:17,500 --> 03:47:18,550
and then we can print it out.

5140
03:47:18,550 --> 03:47:21,470
Now, of course, this class would
have a lot more information

5141
03:47:21,470 --> 03:47:23,750
about a particular vehicle, et cetera.

5142
03:47:23,750 --> 03:47:27,700
However, let's go ahead and
assume that this vehicle

5143
03:47:27,700 --> 03:47:28,860
has some axles.

5144
03:47:28,860 --> 03:47:29,910
So we knew another class.

5145
03:47:29,910 --> 03:47:32,600
So we're gonna create a class called axle

5146
03:47:32,600 --> 03:47:34,050
and we're gonna have a count.

5147
03:47:34,920 --> 03:47:37,820
And this count is gonna be,
actually let's call it number.

5148
03:47:39,292 --> 03:47:40,125
And it's gonna be entered your value

5149
03:47:40,125 --> 03:47:42,295
and that's basically the number of wheels.

5150
03:47:42,295 --> 03:47:44,420
So we'll say number of wheels on the axle.

5151
03:47:45,470 --> 03:47:47,510
And then of course it would be
a whole bunch of other stuff

5152
03:47:47,510 --> 03:47:51,200
inside of this axle class
that would do things for us,

5153
03:47:51,200 --> 03:47:53,290
but we're gonna leave
that out for brevity here.

5154
03:47:53,290 --> 03:47:56,700
Now we know that the vehicle is gonna have

5155
03:47:56,700 --> 03:47:57,870
a number of axles.

5156
03:47:57,870 --> 03:48:00,599
So let's go and say axles,
and then we're gonna have it

5157
03:48:00,599 --> 03:48:02,670
as an array of axle.

5158
03:48:02,670 --> 03:48:04,300
Now, of course, we don't know what that is

5159
03:48:04,300 --> 03:48:05,480
given this period in time.

5160
03:48:05,480 --> 03:48:07,720
So we're gonna actually go
ahead and apply the late init

5161
03:48:07,720 --> 03:48:10,820
modifier saying, Kotlin, I
don't know what it is right now

5162
03:48:10,820 --> 03:48:11,700
at compile time.

5163
03:48:11,700 --> 03:48:12,890
I'm gonna initialize it later.

5164
03:48:12,890 --> 03:48:15,050
Don't worry about it,
I'll take care of it.

5165
03:48:15,050 --> 03:48:15,940
So this all makes sense.

5166
03:48:15,940 --> 03:48:18,240
We have a public class, we have axles,

5167
03:48:18,240 --> 03:48:20,270
and then we might even
have something else,

5168
03:48:20,270 --> 03:48:21,460
like another class.

5169
03:48:21,460 --> 03:48:25,130
And this one's gonna be a
truck because perhaps we know

5170
03:48:25,130 --> 03:48:27,430
that the truck is going to be,

5171
03:48:28,380 --> 03:48:30,360
of course, it's going to be a vehicle

5172
03:48:30,360 --> 03:48:32,860
and we need to parse it in the color.

5173
03:48:32,860 --> 03:48:36,080
And then for whatever reason,
we already know that a truck,

5174
03:48:36,080 --> 03:48:38,320
this truck that we're
building or all trucks

5175
03:48:38,320 --> 03:48:40,420
in our application are
gonna have some axles.

5176
03:48:40,420 --> 03:48:43,950
So we say axles equal, we'll say array of,

5177
03:48:45,080 --> 03:48:48,200
and allows us to create an
array and I could say axle.

5178
03:48:48,200 --> 03:48:50,230
And perhaps this first access to wheels,

5179
03:48:50,230 --> 03:48:54,030
and this next axle has four wheels,

5180
03:48:54,030 --> 03:48:55,270
basically, meaning we have two axles,

5181
03:48:55,270 --> 03:48:57,700
one with two wheels in the
front, four on the back.

5182
03:48:57,700 --> 03:48:59,710
So this all makes sense, this is great.

5183
03:48:59,710 --> 03:49:01,450
If we go back to our main class,

5184
03:49:01,450 --> 03:49:05,360
we can easily create a
vehicle as I've done here.

5185
03:49:05,360 --> 03:49:08,280
I can actually say vehicle that
axles, I can see the axles.

5186
03:49:08,280 --> 03:49:13,280
I can say, val truck equals
truck and I can parse in blue.

5187
03:49:14,110 --> 03:49:17,470
And the truck's gonna have
axles that can have access to,

5188
03:49:17,470 --> 03:49:20,710
but let's go ahead and
assume for whatever reason

5189
03:49:20,710 --> 03:49:25,530
that we do not want anybody
outside of our current module

5190
03:49:25,530 --> 03:49:27,720
to know about this axle class.

5191
03:49:27,720 --> 03:49:32,060
Maybe we only want to expose
things about vehicles,

5192
03:49:32,060 --> 03:49:35,110
but internally for
organizational purposes,

5193
03:49:35,110 --> 03:49:38,920
we want to be able to have a
class that represents an axle.

5194
03:49:38,920 --> 03:49:40,850
Maybe it has a bunch of utility methods

5195
03:49:40,850 --> 03:49:44,100
that just helps us do things
inside of our application,

5196
03:49:45,343 --> 03:49:47,270
but we don't want other people
to know about this class

5197
03:49:47,270 --> 03:49:48,460
or even be able to use it,

5198
03:49:48,460 --> 03:49:50,820
we just kind of wanna
keep it internal to us.

5199
03:49:50,820 --> 03:49:55,240
Like this is our class it's
for us to do work with.

5200
03:49:55,240 --> 03:49:56,810
We don't want anyone else using it.

5201
03:49:56,810 --> 03:49:59,409
There is a way to do
that and you can apply

5202
03:49:59,409 --> 03:50:01,500
the internal modifier to the class.

5203
03:50:01,500 --> 03:50:03,140
Now notice we got a bunch
of errors automatically

5204
03:50:03,140 --> 03:50:04,480
right out of the gate.

5205
03:50:04,480 --> 03:50:06,950
So right here in axles
that says public property

5206
03:50:06,950 --> 03:50:09,260
exposes an internal type argument axle,

5207
03:50:09,260 --> 03:50:12,470
which means bill over here in main,

5208
03:50:12,470 --> 03:50:16,130
if I were to type t.axles,

5209
03:50:16,130 --> 03:50:18,040
well, we would have the
ability to have this.

5210
03:50:18,040 --> 03:50:20,280
So now this can be interesting

5211
03:50:20,280 --> 03:50:21,490
if we don't want that to happen.

5212
03:50:21,490 --> 03:50:22,900
So what I can do is I can actually say,

5213
03:50:22,900 --> 03:50:26,190
hey, you know what, I
don't want axles to be...

5214
03:50:27,330 --> 03:50:31,220
Basically Kotlin saying, hey,
look, you can not expose axles

5215
03:50:31,220 --> 03:50:33,720
because axles' internal to this module.

5216
03:50:33,720 --> 03:50:36,010
Meaning that you can
use it in this module.

5217
03:50:36,010 --> 03:50:38,580
We'll compile everything together inside

5218
03:50:38,580 --> 03:50:40,470
of perhaps you're building a library.

5219
03:50:40,470 --> 03:50:42,370
We'll compile everything together,

5220
03:50:42,370 --> 03:50:45,750
but we're only going to
expose vehicle and truck

5221
03:50:45,750 --> 03:50:47,350
because those ones are public.

5222
03:50:47,350 --> 03:50:50,430
However, you said, here's an axle class,

5223
03:50:50,430 --> 03:50:52,640
it's internal, so don't expose it,

5224
03:50:52,640 --> 03:50:55,690
but you're trying to expose
it here, so don't do that.

5225
03:50:55,690 --> 03:50:58,100
So in this case, what I really
need to do is actually say,

5226
03:50:58,100 --> 03:51:00,300
put private axles.

5227
03:51:00,300 --> 03:51:03,330
Now, as we see here, oh,
now we have another problem.

5228
03:51:03,330 --> 03:51:05,400
Okay, can I access because it's private.

5229
03:51:05,400 --> 03:51:06,990
So what we can do is then
we say, you know what,

5230
03:51:06,990 --> 03:51:10,090
let's change this to protected
'cause we have a child class.

5231
03:51:10,090 --> 03:51:12,340
Now, if protected, then
what do we have here?

5232
03:51:13,600 --> 03:51:17,020
Protected exposes its
internal type argument.

5233
03:51:17,020 --> 03:51:19,410
So now we have a whole different situation

5234
03:51:19,410 --> 03:51:22,100
of maybe we don't want
to expose these axles.

5235
03:51:22,100 --> 03:51:24,220
So you have to start
rethinking your API design

5236
03:51:24,220 --> 03:51:26,510
at this point in time
if you want your axles

5237
03:51:26,510 --> 03:51:29,860
available inside of
these other types here.

5238
03:51:29,860 --> 03:51:31,780
And so maybe you don't wanna do that,

5239
03:51:31,780 --> 03:51:35,800
maybe you wanna put it as
private just like this.

5240
03:51:35,800 --> 03:51:38,800
So now you have your
axles that are private.

5241
03:51:38,800 --> 03:51:42,030
And then perhaps you want
to say the number of axles

5242
03:51:42,030 --> 03:51:44,400
in the wheels and you just
wanna expose this as a function.

5243
03:51:44,400 --> 03:51:45,610
So you could do that.

5244
03:51:45,610 --> 03:51:50,610
So you say, add axle and you
say a number of wheels int.

5245
03:51:55,080 --> 03:51:56,230
And then what you could do is you could do

5246
03:51:56,230 --> 03:51:57,697
something like this.

5247
03:51:57,697 --> 03:52:01,480
And all this would do
is, would say axles dot.

5248
03:52:03,520 --> 03:52:05,280
You know, we just turn
this into a list actually

5249
03:52:05,280 --> 03:52:08,029
to make it a little bit
easier to work with,

5250
03:52:08,029 --> 03:52:11,310
let's say axles dot and
we need to make this

5251
03:52:11,310 --> 03:52:15,220
actually a mutable list so
we can actually change it

5252
03:52:16,210 --> 03:52:18,600
otherwise we have a read only list.

5253
03:52:18,600 --> 03:52:20,710
Add, and then we'll say axle,

5254
03:52:22,980 --> 03:52:25,220
and then we'll parse in
the number of wheels.

5255
03:52:25,220 --> 03:52:26,210
And there we go.

5256
03:52:26,210 --> 03:52:27,580
Now we can actually have that.

5257
03:52:27,580 --> 03:52:31,097
And so if we know that we need
this, we can say, add axle.

5258
03:52:31,097 --> 03:52:34,510
I see two, add axle four.

5259
03:52:36,120 --> 03:52:39,440
Now what this is allowing us
to do is have this axle class

5260
03:52:39,440 --> 03:52:42,950
inside of our module, but not allow it

5261
03:52:42,950 --> 03:52:44,230
outside of the public API.

5262
03:52:44,230 --> 03:52:49,230
So if we are over here, now
we could say t.add axle.

5263
03:52:49,540 --> 03:52:51,320
So I could still kind
of work with the axles,

5264
03:52:51,320 --> 03:52:53,960
but it's hidden behind an API here.

5265
03:52:53,960 --> 03:52:56,930
So I said add axle on a vehicle.

5266
03:52:56,930 --> 03:52:58,730
So the vehicle can also add an axle.

5267
03:53:00,680 --> 03:53:03,810
But if I were to try to
do anything with that axle

5268
03:53:04,800 --> 03:53:07,147
such as return, and maybe I want to say,

5269
03:53:07,147 --> 03:53:08,562
all right, well let's return the axle,

5270
03:53:08,562 --> 03:53:09,850
someone might think so.

5271
03:53:09,850 --> 03:53:14,850
So we say, get axle, so you get axle info.

5272
03:53:18,040 --> 03:53:20,400
And what we're gonna do is
we return all the axles,

5273
03:53:21,640 --> 03:53:23,430
we'll turn a list of axle.

5274
03:53:26,160 --> 03:53:29,200
Well, as you can already
see, we have a problem.

5275
03:53:29,200 --> 03:53:32,300
Public function exposes
internal return type axle.

5276
03:53:32,300 --> 03:53:37,080
So even if I wanted this get axle info,

5277
03:53:38,025 --> 03:53:39,600
this is not gonna work
because Kotlin would say,

5278
03:53:39,600 --> 03:53:40,830
look, this is internal.

5279
03:53:40,830 --> 03:53:43,290
You're trying to expose
us as a public API.

5280
03:53:43,290 --> 03:53:45,140
We're not gonna allow that to happen.

5281
03:53:45,140 --> 03:53:47,860
So perhaps I need to just
expose some additional

5282
03:53:47,860 --> 03:53:49,750
information, I exposed the strings

5283
03:53:49,750 --> 03:53:52,200
and then maybe for whatever
reason I iterate over them

5284
03:53:52,200 --> 03:53:53,033
or whatever.

5285
03:53:53,033 --> 03:53:55,820
Now, if I do need my class
to be accessible outside,

5286
03:53:55,820 --> 03:53:57,030
then internal is not gonna work.

5287
03:53:57,030 --> 03:53:58,980
However, it's very useful.

5288
03:53:58,980 --> 03:54:01,710
If you have a particular
function class where you need

5289
03:54:01,710 --> 03:54:03,070
to encapsulate behavior,

5290
03:54:04,188 --> 03:54:05,070
but you don't wanna expose this behavior

5291
03:54:05,070 --> 03:54:07,640
and all of its intricacies
to the outside public

5292
03:54:07,640 --> 03:54:09,740
and you don't want anyone
to be able to call it.

5293
03:54:09,740 --> 03:54:12,690
You want that to be perhaps
any of the interaction

5294
03:54:12,690 --> 03:54:16,570
with that internal class to
happen through its public API,

5295
03:54:16,570 --> 03:54:18,800
such as we're doing
here in the main class.

5296
03:54:18,800 --> 03:54:22,860
If I wanna add a axle to a vehicle,

5297
03:54:22,860 --> 03:54:27,860
I can number of wheels
three or four or whatever.

5298
03:54:28,000 --> 03:54:30,710
And maybe this method perhaps
does a bunch of validation

5299
03:54:30,710 --> 03:54:33,220
and a bunch of checking
before it actually creates

5300
03:54:33,220 --> 03:54:34,090
this axle class,

5301
03:54:34,090 --> 03:54:36,360
or maybe it has to do a
whole bunch of other things

5302
03:54:36,360 --> 03:54:38,530
that if at your application maybe goes out

5303
03:54:38,530 --> 03:54:41,520
and checks to see if
are any access available

5304
03:54:41,520 --> 03:54:44,490
at the manufacturer, can we
even add an axle right now?

5305
03:54:44,490 --> 03:54:46,920
What is an axle, et cetera.

5306
03:54:46,920 --> 03:54:48,370
So there's a whole bunch
of things you can do,

5307
03:54:48,370 --> 03:54:52,020
but it allows you to lock
down your API internally.

5308
03:54:52,020 --> 03:54:54,406
And so you kind of wanna play with it

5309
03:54:54,406 --> 03:54:55,239
and see what works best for you,

5310
03:54:55,239 --> 03:54:59,040
but it's very useful
for hiding bits of code

5311
03:54:59,040 --> 03:55:01,590
and functionality and logic
inside of your application,

5312
03:55:01,590 --> 03:55:03,790
but still providing you with the ability

5313
03:55:03,790 --> 03:55:05,720
to be organized inside of your module.

5314
03:55:07,840 --> 03:55:10,120
To create an abstract class in Kotlin,

5315
03:55:10,120 --> 03:55:12,680
all you're gonna do is
slap the abstract keyword

5316
03:55:12,680 --> 03:55:13,980
right on the class itself.

5317
03:55:15,083 --> 03:55:15,916
Now you have an abstract class.

5318
03:55:17,050 --> 03:55:18,881
Let's go ahead and delete that though.

5319
03:55:18,881 --> 03:55:20,570
And back at the main file
and see how this impacts it.

5320
03:55:21,650 --> 03:55:23,620
By default classes are open.

5321
03:55:23,620 --> 03:55:26,000
So we can go ahead and create
instances of them in Kotlin.

5322
03:55:26,000 --> 03:55:28,640
So now I have a vehicle,
I wanna provide the color,

5323
03:55:28,640 --> 03:55:31,280
which would be red and I can
create many different vehicles.

5324
03:55:31,280 --> 03:55:36,017
So I create, we'll call this
one A, this will be blue

5325
03:55:38,190 --> 03:55:40,490
and I can create many more, et cetera.

5326
03:55:40,490 --> 03:55:43,670
However, if I want this to be abstract,

5327
03:55:44,980 --> 03:55:48,180
all I have to do is add
the abstract keyword,

5328
03:55:48,180 --> 03:55:50,720
which is a modifier to the class.

5329
03:55:50,720 --> 03:55:53,370
Now I am not allowed to create an instance

5330
03:55:53,370 --> 03:55:54,490
of an abstract class.

5331
03:55:55,751 --> 03:55:57,910
Now you may be wondering why
would you not wanna create

5332
03:55:57,910 --> 03:56:00,370
an instance of an abstract class?

5333
03:56:00,370 --> 03:56:04,080
If you think about it, when
we're designing type systems,

5334
03:56:04,080 --> 03:56:07,090
we have various different types
we're trying to represent.

5335
03:56:07,090 --> 03:56:09,460
In this case, we might be
building an application

5336
03:56:09,460 --> 03:56:11,200
which works with vehicles,

5337
03:56:11,200 --> 03:56:14,280
but we do not want
users of our application

5338
03:56:14,280 --> 03:56:16,510
to create just a vehicle instance,

5339
03:56:16,510 --> 03:56:19,910
we want them to create actual
implementations of a car

5340
03:56:19,910 --> 03:56:21,740
and a truck and so forth.

5341
03:56:21,740 --> 03:56:25,350
And so a lot of these vehicles
will have some similar things

5342
03:56:25,350 --> 03:56:27,750
to them, for example,
they may all have a color.

5343
03:56:28,620 --> 03:56:30,460
They all may have a number of wheels.

5344
03:56:30,460 --> 03:56:33,190
So we say val number of wheels,

5345
03:56:35,880 --> 03:56:38,320
they may all have various
different things and doors

5346
03:56:38,320 --> 03:56:40,579
and so forth that are all similar.

5347
03:56:40,579 --> 03:56:42,130
So we could say number of doors as well.

5348
03:56:42,130 --> 03:56:44,790
So val number of doors.

5349
03:56:47,020 --> 03:56:48,280
Now, for whatever reason,

5350
03:56:49,210 --> 03:56:54,210
this vehicle may actually
drive a certain way.

5351
03:56:54,500 --> 03:56:56,450
So it may need to shift
gears a certain way.

5352
03:56:56,450 --> 03:56:59,050
So it may be an automatic,
it might be a manual,

5353
03:56:59,050 --> 03:57:01,610
different type of vehicle.

5354
03:57:01,610 --> 03:57:04,030
And we may not know what that is.

5355
03:57:04,030 --> 03:57:07,360
So we may wanna actually
have, if we, for example,

5356
03:57:07,360 --> 03:57:12,360
wants to provide a method to
tell the vehicle how to drive.

5357
03:57:13,490 --> 03:57:16,580
And so that function might
be just be called drive.

5358
03:57:17,670 --> 03:57:20,770
Now this perhaps does something.

5359
03:57:20,770 --> 03:57:24,210
Well, now depending upon the vehicle,

5360
03:57:24,210 --> 03:57:26,520
drive can mean one thing or another.

5361
03:57:26,520 --> 03:57:29,720
For example, in a car
that's not a automatic,

5362
03:57:29,720 --> 03:57:31,310
we just step on the accelerator

5363
03:57:32,144 --> 03:57:33,610
as long as we're in the
drive position, it drives.

5364
03:57:33,610 --> 03:57:37,740
However, if you're in a manual
transmission environment

5365
03:57:37,740 --> 03:57:39,010
where you have to shift gears manually,

5366
03:57:39,010 --> 03:57:42,390
well, drive is gonna
require a few more steps.

5367
03:57:42,390 --> 03:57:44,870
So we cannot abstract all this information

5368
03:57:44,870 --> 03:57:47,060
into just this class
here and too abstract.

5369
03:57:47,060 --> 03:57:50,490
So this class we might
wanna actually say abstract,

5370
03:57:51,700 --> 03:57:54,960
abstract function drive.

5371
03:57:54,960 --> 03:57:57,294
Now I'm not gonna provide
an implementation here

5372
03:57:57,294 --> 03:57:59,113
because the implementation is gonna change

5373
03:57:59,113 --> 03:58:01,860
based upon each different
implementation of the class.

5374
03:58:01,860 --> 03:58:04,650
Now, one thing that may be
the same as everything else

5375
03:58:05,700 --> 03:58:07,370
is a function called open door.

5376
03:58:09,540 --> 03:58:11,790
And this function just
simply opens the door.

5377
03:58:13,350 --> 03:58:15,696
And all that does is open the door.

5378
03:58:15,696 --> 03:58:16,529
Now it's gonna be the same,

5379
03:58:16,529 --> 03:58:18,118
perhaps for every single vehicle you have,

5380
03:58:18,118 --> 03:58:18,951
you pull on the handle and the door opens.

5381
03:58:18,951 --> 03:58:21,020
Now, of course, this is
different if in real world,

5382
03:58:21,020 --> 03:58:23,080
we're gonna have electric
cars and electric doors

5383
03:58:23,080 --> 03:58:25,390
and electronic doors and manual doors.

5384
03:58:25,390 --> 03:58:28,410
But for the brevity and situation here,

5385
03:58:28,410 --> 03:58:31,360
perhaps just assume that every
door is opened the same way.

5386
03:58:32,197 --> 03:58:33,420
And so we can leave that
inside of our class.

5387
03:58:33,420 --> 03:58:34,420
Here's an abstract class.

5388
03:58:34,420 --> 03:58:37,500
We can start having other
different things inside of here,

5389
03:58:37,500 --> 03:58:38,950
such as function called stop.

5390
03:58:39,950 --> 03:58:42,030
What would a stop do,
it just stops the car

5391
03:58:42,030 --> 03:58:45,160
and maybe even better say, turn off.

5392
03:58:46,940 --> 03:58:48,970
Every car can be turned off,
vehicle we could turn it off.

5393
03:58:48,970 --> 03:58:51,150
Let's just turn off the ignition.

5394
03:58:51,150 --> 03:58:53,190
And if we only wanna be real specific,

5395
03:58:54,390 --> 03:58:56,190
say, turn off ignition.

5396
03:58:56,190 --> 03:58:57,920
And perhaps this is gonna
turn off the ignition,

5397
03:58:57,920 --> 03:59:00,489
whatever that implementation looks like

5398
03:59:00,489 --> 03:59:01,322
is what it looks like.

5399
03:59:01,322 --> 03:59:03,010
However, we now have an abstract class

5400
03:59:03,010 --> 03:59:05,600
that does a couple of things
for us that we don't have

5401
03:59:05,600 --> 03:59:07,700
to re-implement everywhere else.

5402
03:59:07,700 --> 03:59:09,200
And this is the vehicle class,

5403
03:59:10,047 --> 03:59:12,520
this is how we can define natural class,

5404
03:59:12,520 --> 03:59:14,070
but we can not implement it.

5405
03:59:16,250 --> 03:59:18,230
So we actually have to
implement it in another class

5406
03:59:18,230 --> 03:59:22,330
somehow, but so we can have
a function that's abstract,

5407
03:59:22,330 --> 03:59:24,740
which means, hey,
whoever's going to extend

5408
03:59:24,740 --> 03:59:29,280
this vehicle class at that
point has to also implement

5409
03:59:29,280 --> 03:59:31,520
this drive method
because it's gonna differ

5410
03:59:31,520 --> 03:59:32,910
between different classes.

5411
03:59:33,840 --> 03:59:36,850
However, they can go ahead
and use the open door

5412
03:59:36,850 --> 03:59:38,350
and turn off ignition methods.

5413
03:59:40,070 --> 03:59:43,700
And that's how we can develop
a very simple abstract class

5414
03:59:43,700 --> 03:59:45,370
and define it in Kotlin.

5415
03:59:45,370 --> 03:59:47,450
To implement a abstract class in Kotlin

5416
03:59:47,450 --> 03:59:48,570
is actually pretty easy.

5417
03:59:48,570 --> 03:59:50,560
So let's say that you
wanna have a car class

5418
03:59:50,560 --> 03:59:51,920
that extends this vehicle class.

5419
03:59:51,920 --> 03:59:55,180
So we'd have class car.

5420
03:59:55,180 --> 03:59:57,604
And for whatever reason, when you say

5421
03:59:57,604 --> 03:59:59,230
we're also gonna have a color,
which is gonna be string

5422
03:59:59,230 --> 04:00:02,480
or have number of wheels
as integer and number,

5423
04:00:03,400 --> 04:00:07,290
this needs to be bow number of doors.

5424
04:00:17,200 --> 04:00:19,330
And then what you can do as
you're just gonna go ahead

5425
04:00:19,330 --> 04:00:21,560
and extend the vehicle class.

5426
04:00:21,560 --> 04:00:23,320
And vehicle of course
is gonna need that color

5427
04:00:23,320 --> 04:00:26,650
and number of wheels and number of doors,

5428
04:00:26,650 --> 04:00:28,900
because those are constructed parameters.

5429
04:00:28,900 --> 04:00:31,110
However, notice we have
a red squiggly here.

5430
04:00:31,110 --> 04:00:34,350
And the reason why we
have that is the car class

5431
04:00:34,350 --> 04:00:35,870
is not an abstract and does not implement

5432
04:00:35,870 --> 04:00:39,150
the abstract base class member drive.

5433
04:00:39,150 --> 04:00:44,150
So what this is saying
is, look, maybe you can do

5434
04:00:44,151 --> 04:00:44,984
one of two things here.

5435
04:00:44,984 --> 04:00:49,060
You can have an abstract class
extend an abstract class.

5436
04:00:49,060 --> 04:00:50,600
So you could map this one here

5437
04:00:52,140 --> 04:00:54,834
and you can maybe even call this a two,

5438
04:00:54,834 --> 04:00:55,667
let's call this a two door car.

5439
04:00:58,250 --> 04:01:01,092
So call us a two door car,
and I'm gonna go ahead

5440
04:01:01,092 --> 04:01:01,980
and break this into a new line here

5441
04:01:01,980 --> 04:01:03,170
so it's easier to read.

5442
04:01:05,010 --> 04:01:07,870
And so instead of parsing
in the doors here,

5443
04:01:07,870 --> 04:01:10,460
I already know that this is
gonna be my two door sports car

5444
04:01:10,460 --> 04:01:12,050
for whatever reason.

5445
04:01:12,050 --> 04:01:14,150
And now I have an abstract class here

5446
04:01:14,150 --> 04:01:15,490
and this one might have a function here,

5447
04:01:15,490 --> 04:01:16,540
an abstract function,

5448
04:01:18,370 --> 04:01:20,170
and so I'm gonna call it drive fast.

5449
04:01:21,340 --> 04:01:22,860
Of course, I don't know
what dry fast means

5450
04:01:22,860 --> 04:01:24,610
'cause in this two door
car, it could be a Porsche,

5451
04:01:24,610 --> 04:01:27,710
it could be a Lamborghini, it
could be any number of cars,

5452
04:01:27,710 --> 04:01:30,430
but I know that this two door
car is going to drive fast

5453
04:01:30,430 --> 04:01:33,470
and how it does that depends
on the implementation.

5454
04:01:33,470 --> 04:01:35,390
Maybe it's an electric car.

5455
04:01:35,390 --> 04:01:37,210
So that's one way I could do it.

5456
04:01:37,210 --> 04:01:38,980
I could also just go
ahead and implement a car

5457
04:01:38,980 --> 04:01:41,820
if I just know that I want
perhaps a simple TownCar

5458
04:01:42,930 --> 04:01:47,930
or this is called a hatchback,
even simpler, hatchback car,

5459
04:01:49,110 --> 04:01:51,190
so you know it has
little hatch in the back.

5460
04:01:51,190 --> 04:01:55,250
And then I say color of course
is string number of wheels

5461
04:01:55,250 --> 04:02:00,060
gonna compute any variable,
number of doors it's gonna be,

5462
04:02:00,060 --> 04:02:02,870
who knows, same thing here,
I'm gonna put in a new line.

5463
04:02:02,870 --> 04:02:05,010
This one's gonna implement vehicle

5464
04:02:05,010 --> 04:02:07,910
and it's gonna be the
color number of wheels,

5465
04:02:07,910 --> 04:02:09,940
number of doors, et cetera.

5466
04:02:09,940 --> 04:02:11,420
Now, again, I'm going to get this

5467
04:02:11,420 --> 04:02:12,810
because I'm gonna get this error

5468
04:02:12,810 --> 04:02:15,180
saying that we have not
implemented the drive function.

5469
04:02:15,180 --> 04:02:18,120
So what I can do is implement that member.

5470
04:02:18,970 --> 04:02:22,210
And basically what we're telling here is,

5471
04:02:22,210 --> 04:02:26,270
hey Kotlin, I have now
implemented the hatchback car.

5472
04:02:26,270 --> 04:02:29,470
It is of type vehicle and
this one is going to drive

5473
04:02:29,470 --> 04:02:30,710
a certain way.

5474
04:02:30,710 --> 04:02:33,770
And so when the drive method is called,

5475
04:02:33,770 --> 04:02:37,080
it will then call this
implementation right here.

5476
04:02:37,080 --> 04:02:40,920
Now I can have many different
implementations of this car.

5477
04:02:40,920 --> 04:02:45,290
So I'm gonna actually copy
this and paste it right above.

5478
04:02:45,290 --> 04:02:46,710
And then I'm gonna call this one,

5479
04:02:46,710 --> 04:02:49,670
perhaps, call this a TownCar.

5480
04:02:53,672 --> 04:02:56,510
I'll call it a TownCar and
same thing we have drive.

5481
04:02:57,670 --> 04:02:59,170
So we have different implementations here.

5482
04:02:59,170 --> 04:03:02,500
And this TownCar might
have something different

5483
04:03:02,500 --> 04:03:04,270
where it has a very smooth ride.

5484
04:03:06,400 --> 04:03:08,670
And this one is a very basic smooth,

5485
04:03:10,549 --> 04:03:11,780
and this one is very basic.

5486
04:03:13,640 --> 04:03:15,090
It's very just hatchback car.

5487
04:03:16,194 --> 04:03:18,070
So we're gonna have many
different implementations here,

5488
04:03:18,070 --> 04:03:19,530
however, in order to
implement an abstract class,

5489
04:03:19,530 --> 04:03:23,360
you also have to implement
the abstract functions here.

5490
04:03:23,360 --> 04:03:25,980
So, which is interesting, let's
go with this two door car.

5491
04:03:25,980 --> 04:03:27,790
Let's create some space
here and let's implement

5492
04:03:27,790 --> 04:03:28,890
this two door car.

5493
04:03:28,890 --> 04:03:30,590
So we've already seen
how we can do it once.

5494
04:03:30,590 --> 04:03:32,960
But now we have an
abstract class that extends

5495
04:03:32,960 --> 04:03:34,340
an abstract class.

5496
04:03:34,340 --> 04:03:35,540
What does that look like?

5497
04:03:35,540 --> 04:03:38,370
And so let's go ahead and
implement something here.

5498
04:03:38,370 --> 04:03:43,370
So we'll call this Lambo
and of course it will,

5499
04:03:44,730 --> 04:03:47,720
perhaps we just are gonna
assume that every Lambo

5500
04:03:47,720 --> 04:03:51,030
is gonna have, so it's
gonna be extended vehicle.

5501
04:03:51,900 --> 04:03:54,311
I'm not even gonna provide this things

5502
04:03:54,311 --> 04:03:56,130
inside of the class
Lambbo 'cause every Lambo

5503
04:03:56,130 --> 04:03:59,190
that we're going to create is gonna be red

5504
04:03:59,190 --> 04:04:01,450
and it's gonna have four wheels

5505
04:04:01,450 --> 04:04:03,630
and it's gonna have two doors.

5506
04:04:03,630 --> 04:04:04,600
There we go, simple enough.

5507
04:04:04,600 --> 04:04:06,490
Now we have this little error here saying,

5508
04:04:06,490 --> 04:04:10,950
hey, look, drive has not been implemented.

5509
04:04:10,950 --> 04:04:13,640
And actually we know it's
gonna be a two-door car,

5510
04:04:13,640 --> 04:04:15,950
so let's change this to two door

5511
04:04:15,950 --> 04:04:17,450
and we can get rid of this right here.

5512
04:04:19,453 --> 04:04:20,286
And now we have Lambo says,

5513
04:04:20,286 --> 04:04:22,870
look, drive fast has not been implemented.

5514
04:04:22,870 --> 04:04:25,020
So let's go ahead and
implement drive fast.

5515
04:04:27,060 --> 04:04:28,130
Okay, look, we have two things here.

5516
04:04:28,130 --> 04:04:29,610
Well, let's just go ahead
and put and drive fast

5517
04:04:29,610 --> 04:04:31,050
'cause that's what it
was complaining about.

5518
04:04:31,050 --> 04:04:34,910
And we'll say, and whatever
this is going to look like,

5519
04:04:37,280 --> 04:04:38,200
is what it's gonna look like.

5520
04:04:38,200 --> 04:04:39,590
Depends on your implementation.

5521
04:04:39,590 --> 04:04:40,960
Now we also have another
error here saying,

5522
04:04:40,960 --> 04:04:42,630
hey, the drive has not been implemented.

5523
04:04:42,630 --> 04:04:43,480
And why is that?

5524
04:04:43,480 --> 04:04:47,100
Well, because drive fast method

5525
04:04:47,100 --> 04:04:50,350
came from this abstract
class and the drive method

5526
04:04:50,350 --> 04:04:51,370
comes from the vehicle.

5527
04:04:51,370 --> 04:04:55,500
So because two-door car extends vehicle

5528
04:04:55,500 --> 04:04:58,170
and our Lambo class extends to door,

5529
04:04:58,170 --> 04:05:00,530
we basically getting the entire object

5530
04:05:00,530 --> 04:05:02,070
that we need to implement here.

5531
04:05:02,070 --> 04:05:04,280
So as you can see, this can be beneficial,

5532
04:05:04,280 --> 04:05:07,980
depends on how you are
developing your classes.

5533
04:05:07,980 --> 04:05:12,980
However, it can also be very
difficult if you decide,

5534
04:05:13,240 --> 04:05:16,510
let's say you have 20
implementations of vehicle

5535
04:05:16,510 --> 04:05:18,814
and the subclasses are majors 100

5536
04:05:18,814 --> 04:05:21,660
and you decide to add one abstract method

5537
04:05:21,660 --> 04:05:24,060
to the top where the
people must implement it.

5538
04:05:24,060 --> 04:05:27,680
Well, now it's gonna repl
throughout your code base

5539
04:05:27,680 --> 04:05:29,786
and you're gonna have to implement that

5540
04:05:29,786 --> 04:05:30,690
in each of your child classes.

5541
04:05:30,690 --> 04:05:32,390
So it's something to think about

5542
04:05:32,390 --> 04:05:34,210
that you'll encounter from time to time.

5543
04:05:34,210 --> 04:05:35,330
Sometimes that's necessary,

5544
04:05:35,330 --> 04:05:37,690
sometimes that's what
you expect to happen.

5545
04:05:37,690 --> 04:05:39,510
Maybe you need to implement
some type of method,

5546
04:05:39,510 --> 04:05:42,280
like a safety check to ensure
that all of the vehicles

5547
04:05:42,280 --> 04:05:45,260
have meet a particular safety rating

5548
04:05:45,260 --> 04:05:46,800
and you have to implement
that in each class

5549
04:05:46,800 --> 04:05:48,650
and that's what you need and that's okay.

5550
04:05:48,650 --> 04:05:50,280
However, other times you're gonna realize,

5551
04:05:50,280 --> 04:05:53,330
well, maybe I don't need
that method to be abstract,

5552
04:05:53,330 --> 04:05:55,190
and that's gonna be on
a case by case basis.

5553
04:05:55,190 --> 04:05:57,440
Now over here, of course, we can go ahead

5554
04:05:57,440 --> 04:05:59,788
and start implementing all of these.

5555
04:05:59,788 --> 04:06:01,960
So if I wanna say var or val Lambo

5556
04:06:03,690 --> 04:06:07,780
that I can just say equals Lambo.

5557
04:06:09,860 --> 04:06:10,890
Now I've got a Lambo.

5558
04:06:10,890 --> 04:06:13,315
And remember, I didn't have to
provide any variables there.

5559
04:06:13,315 --> 04:06:14,148
Well, why didn't I,
because I already knew,

5560
04:06:14,148 --> 04:06:17,010
could I said, hey, all of
our Lambos are gonna be red

5561
04:06:17,010 --> 04:06:18,330
and are four wheels.

5562
04:06:18,330 --> 04:06:19,890
And since this is a two door car,

5563
04:06:19,890 --> 04:06:21,000
we already know it has two doors.

5564
04:06:21,000 --> 04:06:22,050
I don't have to provide anything,

5565
04:06:22,050 --> 04:06:23,660
I already have a Lambo now.

5566
04:06:23,660 --> 04:06:26,190
And so if we wanted to
provide a method up here,

5567
04:06:26,190 --> 04:06:28,370
we could say what kind they are.

5568
04:06:28,370 --> 04:06:33,370
Another thing you can
also do is let's go ahead

5569
04:06:33,390 --> 04:06:35,040
and create a couple of
these other cars here.

5570
04:06:35,040 --> 04:06:40,040
Var two door equals let's say TownCar.

5571
04:06:42,530 --> 04:06:43,590
Equals TownCar.

5572
04:06:45,620 --> 04:06:46,670
Now of course, what are we missing?

5573
04:06:46,670 --> 04:06:49,560
We're missing the color,
so let's call brown.

5574
04:06:49,560 --> 04:06:51,710
It's gonna have four
wheels and four doors.

5575
04:06:52,920 --> 04:06:54,040
And now I have my two cars.

5576
04:06:54,040 --> 04:06:57,050
And again, I could have multiple
other ones inside of here.

5577
04:06:57,050 --> 04:06:58,510
I've got my Lambo, I've got my TownCar,

5578
04:06:58,510 --> 04:06:59,960
I've got my hatchback.

5579
04:06:59,960 --> 04:07:02,480
I've got all these
different types of cars.

5580
04:07:02,480 --> 04:07:04,850
So one thing I could do here,
so we have a hatchback too.

5581
04:07:09,297 --> 04:07:10,130
So, we have a hatchback car.

5582
04:07:10,130 --> 04:07:11,210
This one's gonna be silver.

5583
04:07:11,210 --> 04:07:14,390
It's gonna have four wheels and two doors.

5584
04:07:14,390 --> 04:07:16,736
So this point, you might realized,

5585
04:07:16,736 --> 04:07:18,260
well, some hatchbacks
have for some have two.

5586
04:07:18,260 --> 04:07:21,080
So that's why we need the,
have the number of doors

5587
04:07:22,880 --> 04:07:25,296
in a way that we can configure them.

5588
04:07:25,296 --> 04:07:28,320
So this is how you can
implement an abstract class

5589
04:07:28,320 --> 04:07:29,710
and you can also have an abstract class

5590
04:07:29,710 --> 04:07:32,757
extend another abstract
class implement that.

5591
04:07:32,757 --> 04:07:34,670
And then you can see
how the abstract methods

5592
04:07:34,670 --> 04:07:38,360
and members are required
inside of each individual class

5593
04:07:38,360 --> 04:07:41,270
itself and you're required
to implement them.

5594
04:07:41,270 --> 04:07:43,480
So for example, our Lambo here extended

5595
04:07:43,480 --> 04:07:47,870
from the two-door car, which
extended the vehicle car.

5596
04:07:47,870 --> 04:07:49,440
So we had to implement the drive method

5597
04:07:49,440 --> 04:07:51,940
and we also had to implement
the dry fast method

5598
04:07:51,940 --> 04:07:55,670
in order to fulfill the
requirements of the abstract class.

5599
04:07:55,670 --> 04:07:57,540
And basically what the abstract
method is saying is like,

5600
04:07:57,540 --> 04:08:00,800
look, we don't know what drive does,

5601
04:08:00,800 --> 04:08:03,990
but we know that every
person or every class

5602
04:08:03,990 --> 04:08:07,350
that implements this
vehicle class has to provide

5603
04:08:07,350 --> 04:08:08,390
an implementation of drive

5604
04:08:08,390 --> 04:08:10,340
and the same thing down here.

5605
04:08:10,340 --> 04:08:11,880
And we didn't have to
implement it down here

5606
04:08:11,880 --> 04:08:13,730
is because this is an abstract class.

5607
04:08:14,725 --> 04:08:16,510
And that means like, hey,
there's nobody who can create

5608
04:08:16,510 --> 04:08:18,140
an instance of two-door car.

5609
04:08:18,140 --> 04:08:21,220
But if you are going to use two-door car,

5610
04:08:21,220 --> 04:08:24,500
then we do know that you
have a drive fast method

5611
04:08:24,500 --> 04:08:25,500
for whatever reason.

5612
04:08:26,812 --> 04:08:27,645
And whenever you implement that,

5613
04:08:27,645 --> 04:08:29,422
you have to also implement whatever else

5614
04:08:29,422 --> 04:08:30,255
vehicle is asking here.

5615
04:08:30,255 --> 04:08:34,070
So if I were to throw another
abstract method on here,

5616
04:08:34,070 --> 04:08:38,150
so abstract fun stop.

5617
04:08:38,150 --> 04:08:40,500
Now notice one thing, Lambo
is gonna give us an error.

5618
04:08:40,500 --> 04:08:42,480
And if we scroll down also, so is TownCar,

5619
04:08:42,480 --> 04:08:43,750
and so it was hatchback.

5620
04:08:43,750 --> 04:08:45,410
Well, why is that?

5621
04:08:45,410 --> 04:08:50,180
Well, simply because stop is
implemented everywhere else.

5622
04:08:50,180 --> 04:08:53,760
So I would have to go into
TownCar, implement stop.

5623
04:08:53,760 --> 04:08:56,690
I would have to go into
hatchback, implement stop.

5624
04:08:56,690 --> 04:08:58,320
Now here's an interesting thing,

5625
04:08:58,320 --> 04:09:01,020
maybe I know that all of my two-door cars,

5626
04:09:01,020 --> 04:09:04,240
the only way to stop them
is to slam on the e-brake.

5627
04:09:04,240 --> 04:09:08,410
And so what I can do
is I can implement stop

5628
04:09:08,410 --> 04:09:10,060
inside of my abstract class here.

5629
04:09:11,210 --> 04:09:14,820
I'd say pull e-brake, which
is the emergency brake.

5630
04:09:14,820 --> 04:09:16,720
That's how we stopped these two door cars,

5631
04:09:16,720 --> 04:09:17,810
just as an example.

5632
04:09:19,180 --> 04:09:22,270
So in this case, Lambo
doesn't have to implement

5633
04:09:22,270 --> 04:09:24,200
the stop method because
that's just handled

5634
04:09:24,200 --> 04:09:25,340
in the two-door car level.

5635
04:09:25,340 --> 04:09:29,440
So I've actually can
override an abstract method

5636
04:09:29,440 --> 04:09:32,450
inside of an abstract class
of the parent abstract class.

5637
04:09:32,450 --> 04:09:37,250
So again, this stop is
actually from up here

5638
04:09:37,250 --> 04:09:38,230
inside of this stop.

5639
04:09:38,230 --> 04:09:40,980
So you can go here and you
can right click on that

5640
04:09:40,980 --> 04:09:42,410
and you can say navigate,

5641
04:09:43,450 --> 04:09:44,283
excuse me, not navigate.

5642
04:09:44,283 --> 04:09:46,110
You can go to command U on Mac,

5643
04:09:46,110 --> 04:09:48,980
it'll take you to the
implementation of where this is at.

5644
04:09:48,980 --> 04:09:51,880
And I think it's control+U for windows.

5645
04:09:51,880 --> 04:09:54,860
So this abstract class has
implemented one member,

5646
04:09:54,860 --> 04:09:57,830
but it's still parsing this
member down further below.

5647
04:09:57,830 --> 04:10:01,300
So we're still saying,
hey, drive needs to happen.

5648
04:10:01,300 --> 04:10:02,540
And what we can also
say is, you know what,

5649
04:10:02,540 --> 04:10:05,800
well maybe any time a
two-door car is driving.

5650
04:10:05,800 --> 04:10:09,087
Well, we also know that
we are going to drive,

5651
04:10:12,700 --> 04:10:14,550
we're just actually just gonna drive fast.

5652
04:10:16,060 --> 04:10:18,890
So anytime you drive two
door cars, only drive fast.

5653
04:10:18,890 --> 04:10:22,470
So notice one thing, I can
actually get rid of this

5654
04:10:22,470 --> 04:10:27,470
down here, because the Lambo
now is using the drive method.

5655
04:10:28,290 --> 04:10:30,960
If anyone calls drive, it's
just gonna call drive fast,

5656
04:10:30,960 --> 04:10:32,870
which calls this drive fast method.

5657
04:10:32,870 --> 04:10:34,300
So let's really see this in action.

5658
04:10:34,300 --> 04:10:36,400
Let's go over here into our main file.

5659
04:10:37,440 --> 04:10:40,420
And inside of our drive fast,

5660
04:10:40,420 --> 04:10:43,120
let's go ahead and just do
a print line, driving fast.

5661
04:10:47,880 --> 04:10:50,690
So if we have a two door
car, it's gonna drive fast

5662
04:10:50,690 --> 04:10:52,900
and let's do a another two-door car here

5663
04:10:55,440 --> 04:10:57,490
and let's create another one here called,

5664
04:10:59,359 --> 04:11:00,696
let's do another one.

5665
04:11:00,696 --> 04:11:01,529
Let's call this one Honda.

5666
04:11:02,579 --> 04:11:03,490
And maybe you were saying,
hey, you might like

5667
04:11:03,490 --> 04:11:05,730
this really fast Honda or let's do Acura.

5668
04:11:07,410 --> 04:11:09,360
And this one's gonna be a two door car,

5669
04:11:12,761 --> 04:11:14,010
a two door car.

5670
04:11:14,010 --> 04:11:17,550
It's gonna be blue and it's
gonna have four wheels,

5671
04:11:18,400 --> 04:11:19,240
there we go.

5672
04:11:19,240 --> 04:11:23,240
However, we do need to
implement this Acura

5673
04:11:24,140 --> 04:11:24,973
drive fast method.

5674
04:11:24,973 --> 04:11:29,020
So we're gonna say print line zoom zoom.

5675
04:11:31,960 --> 04:11:33,850
And what am I getting at with this?

5676
04:11:33,850 --> 04:11:36,840
What we're gonna see here is when we call

5677
04:11:36,840 --> 04:11:40,770
the drive method here on a two-door car,

5678
04:11:40,770 --> 04:11:42,330
it's gonna delegate to the drive fast.

5679
04:11:42,330 --> 04:11:44,140
Now the drive fast has no implementation,

5680
04:11:44,140 --> 04:11:45,820
we don't know what that does yet.

5681
04:11:45,820 --> 04:11:47,740
However, that's gonna delegate down

5682
04:11:47,740 --> 04:11:50,800
into the actual implementation
of the abstract class.

5683
04:11:50,800 --> 04:11:54,210
So the two door car has
a drive fast method.

5684
04:11:54,210 --> 04:11:58,530
So anytime we call drive,
it'll call drive fast,

5685
04:11:58,530 --> 04:12:00,310
which then calls the drive fast method,

5686
04:12:00,310 --> 04:12:02,660
which is implemented
in the abstract class.

5687
04:12:02,660 --> 04:12:06,270
So let's go here and
let's go ahead and create.

5688
04:12:06,270 --> 04:12:08,220
We'll have our Lambo move that down here.

5689
04:12:08,220 --> 04:12:09,860
We can get rid of these two for now.

5690
04:12:10,907 --> 04:12:14,437
And let me say val Acura equals Acura.

5691
04:12:17,260 --> 04:12:20,140
And now what we can do is we
can say something like this.

5692
04:12:20,140 --> 04:12:25,140
Let me say Lambo drive and Acura drive.

5693
04:12:27,390 --> 04:12:28,230
Now they're both gonna drive,

5694
04:12:28,230 --> 04:12:30,110
they both drive the same, whatever.

5695
04:12:30,110 --> 04:12:32,720
They have the same abstract class,

5696
04:12:32,720 --> 04:12:34,300
they have the same interface
so I can work with them.

5697
04:12:34,300 --> 04:12:35,490
They're both vehicles.

5698
04:12:35,490 --> 04:12:37,340
Now we see it on here, one is driving fast

5699
04:12:37,340 --> 04:12:39,690
and one is going, zoom, zoom.

5700
04:12:39,690 --> 04:12:41,840
Now an interesting thing
that you can do here

5701
04:12:43,108 --> 04:12:43,941
is you can start creating

5702
04:12:43,941 --> 04:12:46,008
all different types of implementations.

5703
04:12:46,008 --> 04:12:48,350
Now I can still we'll call drive fast.

5704
04:12:50,740 --> 04:12:54,820
That's not restricted, I can
still say Acura.drive fast.

5705
04:12:56,760 --> 04:12:58,700
and I can still do this and
everything will still work

5706
04:12:58,700 --> 04:12:59,890
and we'll still get the same results.

5707
04:12:59,890 --> 04:13:02,920
So driving fast, driving fast zoom, zoom.

5708
04:13:02,920 --> 04:13:06,080
'Cause remember, drive, if
you go to implementation

5709
04:13:06,080 --> 04:13:08,590
command B, it takes us
to the two-door car,

5710
04:13:08,590 --> 04:13:10,770
which is just going to delegate
down to the drive fast.

5711
04:13:10,770 --> 04:13:12,890
Now implement the drive method.

5712
04:13:12,890 --> 04:13:15,440
That drive method was from
the original vehicle class.

5713
04:13:16,817 --> 04:13:18,040
This is an accidental import.

5714
04:13:20,270 --> 04:13:23,190
And so that's how you can
create an implementation

5715
04:13:23,190 --> 04:13:26,670
and instance of implement
an abstract class

5716
04:13:26,670 --> 04:13:29,420
and have it also extend other
abstract classes as well.

5717
04:13:31,060 --> 04:13:34,180
One of the more interesting
things about abstract classes

5718
04:13:34,180 --> 04:13:35,580
is the word abstract.

5719
04:13:36,470 --> 04:13:38,310
Anytime you think of an abstract class,

5720
04:13:38,310 --> 04:13:40,620
think about the definition
of the word abstract.

5721
04:13:40,620 --> 04:13:41,965
What does it mean?

5722
04:13:41,965 --> 04:13:43,160
It means to basically pull
something away from it,

5723
04:13:43,160 --> 04:13:45,070
to abstract the details away.

5724
04:13:46,300 --> 04:13:48,710
In software when you use abstract classes,

5725
04:13:48,710 --> 04:13:51,110
especially in Kotlin, it
means you can kind of use this

5726
04:13:51,110 --> 04:13:52,510
as an abstraction of source.

5727
04:13:53,382 --> 04:13:54,215
So let's assume that we've created

5728
04:13:54,215 --> 04:13:55,048
these four different cars.

5729
04:13:55,048 --> 04:13:59,450
All of them all inherit
from a base abstract class

5730
04:13:59,450 --> 04:14:00,380
called vehicle.

5731
04:14:00,380 --> 04:14:02,787
So we have vehicle, we
have a two-door car,

5732
04:14:02,787 --> 04:14:03,650
which extends vehicle.

5733
04:14:03,650 --> 04:14:05,880
We have a Lambo which
extends a two-door car

5734
04:14:05,880 --> 04:14:08,580
and an Acura, which
takes is a two-door car,

5735
04:14:08,580 --> 04:14:10,810
a TownCar and hatchback.

5736
04:14:10,810 --> 04:14:13,160
And each one of these have a drive method.

5737
04:14:14,410 --> 04:14:15,243
So the hatchback says driving a hatchback,

5738
04:14:15,243 --> 04:14:17,300
drive for TownCars is so smooth,

5739
04:14:18,255 --> 04:14:20,140
the drive method for
Acura says zoom, zoom,

5740
04:14:20,140 --> 04:14:23,340
and the drive method for
Lambo says driving fast.

5741
04:14:23,340 --> 04:14:25,770
Notice you say drive fast
and why don't I implement

5742
04:14:25,770 --> 04:14:27,520
the drive because that's implemented

5743
04:14:27,520 --> 04:14:29,930
in its superclass up here.

5744
04:14:29,930 --> 04:14:32,260
And anytime someone calls drive,

5745
04:14:32,260 --> 04:14:33,550
we just call the dry fast method

5746
04:14:33,550 --> 04:14:35,950
because we're just going
to assume two-door cars

5747
04:14:35,950 --> 04:14:37,860
just drive fast for whatever reason.

5748
04:14:39,891 --> 04:14:40,780
So we have all of our cars here.

5749
04:14:40,780 --> 04:14:43,350
Now, if we wanted to call
drive on each one of these,

5750
04:14:43,350 --> 04:14:45,550
what we could do is we
could say lamo.drive,

5751
04:14:48,412 --> 04:14:51,950
we have call acura.drive.

5752
04:14:51,950 --> 04:14:54,690
Now this is great and all, or
we could even say drive fast

5753
04:14:54,690 --> 04:14:56,820
if we know we want it to just drive fast.

5754
04:14:56,820 --> 04:14:59,230
However, there are a lot
of instances in power

5755
04:14:59,230 --> 04:15:02,860
when we know that we wanna
rely on the abstraction.

5756
04:15:02,860 --> 04:15:05,160
So we'll say drive vehicle,
let's create a method

5757
04:15:05,160 --> 04:15:08,710
called drive vehicle, which
just tells the vehicle to drive.

5758
04:15:08,710 --> 04:15:09,720
Vehicle.

5759
04:15:09,720 --> 04:15:10,553
And then what we're gonna do

5760
04:15:10,553 --> 04:15:11,960
is we're gonna take in a vehicle

5761
04:15:13,000 --> 04:15:15,150
and inside of here, what we're gonna do

5762
04:15:15,150 --> 04:15:16,250
is say, vehicle.drive.

5763
04:15:17,650 --> 04:15:19,670
Now this vehicle is an abstraction.

5764
04:15:19,670 --> 04:15:21,500
We're not creating an instance
of it, we're just saying,

5765
04:15:21,500 --> 04:15:24,310
hey, this method is gonna
take an instance of a vehicle.

5766
04:15:24,310 --> 04:15:26,140
We don't care what kind it is,

5767
04:15:26,140 --> 04:15:28,810
we just want a vehicle and
we're gonna tell it to drive.

5768
04:15:28,810 --> 04:15:32,310
So what we can do here is
then you could say, Lambo,

5769
04:15:32,310 --> 04:15:36,620
you say drive vehicle
Lambo parsing instance.

5770
04:15:38,030 --> 04:15:40,999
So I'm gonna just
duplicate this a few times

5771
04:15:40,999 --> 04:15:44,080
and I'll say Acura and then
I'm going to say hatchback

5772
04:15:44,080 --> 04:15:44,913
and TownCar.

5773
04:15:45,990 --> 04:15:49,240
Now, when I run, this what's
gonna happen is drive vehicle

5774
04:15:49,240 --> 04:15:50,073
is gonna call in.

5775
04:15:50,073 --> 04:15:52,870
So we're gonna say Lambo,
we're gonna get an instance

5776
04:15:52,870 --> 04:15:54,010
of a Lambo.

5777
04:15:54,010 --> 04:15:56,230
It's in the call this drive
method, which is gonna say,

5778
04:15:56,230 --> 04:15:58,380
all right, who's implementing
this drive method.

5779
04:15:58,380 --> 04:16:01,090
Well, a two-door cars
implementing the drive method

5780
04:16:01,090 --> 04:16:03,183
because well, who is implementing,

5781
04:16:03,183 --> 04:16:05,190
okay, it's going to call drive

5782
04:16:05,190 --> 04:16:07,800
'cause Lambo is a two door car

5783
04:16:07,800 --> 04:16:09,860
and say, oh well, I'm
gonna implement drive fast,

5784
04:16:09,860 --> 04:16:11,160
which is this method.

5785
04:16:11,160 --> 04:16:12,868
Well, who's implementing dry fast.

5786
04:16:12,868 --> 04:16:14,340
And to say one Acura and Lambo are.

5787
04:16:15,422 --> 04:16:17,540
So that case is gonna go
here and call driving fast.

5788
04:16:17,540 --> 04:16:20,440
So if we were to run
this, what we're gonna see

5789
04:16:20,440 --> 04:16:23,730
really easy is we're gonna
see each one of these methods,

5790
04:16:23,730 --> 04:16:26,560
method invocations are gonna dive down

5791
04:16:26,560 --> 04:16:27,830
and call the appropriate methods.

5792
04:16:27,830 --> 04:16:30,340
So for a Lambo, it's driving fast,

5793
04:16:30,340 --> 04:16:32,200
for an Acura, it's zoom zoom,

5794
04:16:32,200 --> 04:16:34,690
for a hatchback, would
say driving a hatchback

5795
04:16:34,690 --> 04:16:37,290
and for TownCar, it's so smooth.

5796
04:16:37,290 --> 04:16:41,110
And so abstract class thing, again,

5797
04:16:41,110 --> 04:16:43,900
think of the word abstract,
allows you to abstract

5798
04:16:43,900 --> 04:16:47,570
the details behind some type
of, almost like a contract.

5799
04:16:47,570 --> 04:16:50,470
So this is the contract
of all the vehicles

5800
04:16:50,470 --> 04:16:51,303
are going to have.

5801
04:16:51,303 --> 04:16:52,880
They're gonna have color,
they have number of wheels

5802
04:16:52,880 --> 04:16:54,700
and have number of doors.

5803
04:16:54,700 --> 04:16:56,120
There have a drive and a stop,

5804
04:16:56,120 --> 04:16:57,920
which is different for each vehicle.

5805
04:16:59,260 --> 04:17:00,580
And then it's those
child classes implement

5806
04:17:00,580 --> 04:17:04,010
can either decide to
override and implement things

5807
04:17:04,010 --> 04:17:05,940
or if it's an abstract class,

5808
04:17:05,940 --> 04:17:09,930
it can leave it as is and
let the implementers downline

5809
04:17:09,930 --> 04:17:13,110
implement it themselves, such
as TownCar is doing here,

5810
04:17:13,110 --> 04:17:14,870
what it needs to implement drive.

5811
04:17:15,720 --> 04:17:17,570
So again, you could have an addition.

5812
04:17:19,216 --> 04:17:23,460
You could extend two-door car
to be a slow two-door car.

5813
04:17:23,460 --> 04:17:25,970
And instead of it being dry fast,

5814
04:17:25,970 --> 04:17:28,290
you could override that
to, I could drive slow.

5815
04:17:28,290 --> 04:17:31,840
So, and then again, up
in your main file here,

5816
04:17:31,840 --> 04:17:34,530
you could still just use
this method to call drive

5817
04:17:34,530 --> 04:17:38,100
and that class would
then react accordingly

5818
04:17:38,100 --> 04:17:40,030
and you can start performing
all different types

5819
04:17:40,030 --> 04:17:43,490
of operations with
different types of vehicles,

5820
04:17:43,490 --> 04:17:46,700
but have them have the same
type of type signatures.

5821
04:17:46,700 --> 04:17:50,480
And that's how you can use
abstract classes as abstractions

5822
04:17:50,480 --> 04:17:51,680
on a very simple manner.

5823
04:17:52,530 --> 04:17:54,530
So when do you want to use an interface?

5824
04:17:55,530 --> 04:17:56,950
Let's take the simple example of you

5825
04:17:56,950 --> 04:17:58,280
going to eat at arraystaurant.

5826
04:17:58,280 --> 04:18:00,060
So here you are, you're getting ready

5827
04:18:00,060 --> 04:18:02,170
to go eat at the restaurant

5828
04:18:02,170 --> 04:18:07,170
and the waiter brings you out a menu.

5829
04:18:08,420 --> 04:18:11,430
Now the menu I want you to
think of as an interface.

5830
04:18:11,430 --> 04:18:12,570
And what is an interface?

5831
04:18:12,570 --> 04:18:14,120
Well, an interface is a contract saying,

5832
04:18:14,120 --> 04:18:16,290
what are the things
that we can do for you?

5833
04:18:16,290 --> 04:18:18,890
So here at the restaurant,
this is an Italian restaurant.

5834
04:18:18,890 --> 04:18:20,760
They say, well, here we
can make you spaghetti

5835
04:18:20,760 --> 04:18:23,840
and meatballs, we can make you bakesidi.

5836
04:18:23,840 --> 04:18:28,320
We can make you lasagna, we can
make linguine and clam sauce

5837
04:18:29,520 --> 04:18:31,790
and shrimp and garlic and
all kinds of stuff like that.

5838
04:18:31,790 --> 04:18:34,480
And you determine the one
thing I would really like

5839
04:18:34,480 --> 04:18:35,830
is spaghetti and meatballs.

5840
04:18:36,990 --> 04:18:39,000
And so what you're using is this contract.

5841
04:18:39,000 --> 04:18:39,910
You're reading the contract saying,

5842
04:18:39,910 --> 04:18:42,490
hey, what are the available
options, which this menu is.

5843
04:18:42,490 --> 04:18:46,470
It's the list of available
options of what this restaurant

5844
04:18:46,470 --> 04:18:48,110
over here can produce.

5845
04:18:48,110 --> 04:18:49,770
And this is the restaurant.

5846
04:18:49,770 --> 04:18:52,920
And the menu is the interface between you

5847
04:18:52,920 --> 04:18:53,753
and the restaurant.

5848
04:18:53,753 --> 04:18:56,020
So the restaurant says,
this is what we provide,

5849
04:18:56,020 --> 04:18:58,880
this is our contract of
goods that we can do for you

5850
04:18:59,729 --> 04:19:00,562
or things we can build.

5851
04:19:00,562 --> 04:19:02,150
And then what you do is you communicate

5852
04:19:02,150 --> 04:19:04,740
through this interface
here, this menu and say,

5853
04:19:04,740 --> 04:19:06,040
hey, I want to order this.

5854
04:19:06,040 --> 04:19:09,580
And so you tell the
waiter, hey, I wanna order

5855
04:19:09,580 --> 04:19:10,620
this spaghetti and meatballs.

5856
04:19:10,620 --> 04:19:13,860
So this order gets go
over here to the kitchen.

5857
04:19:13,860 --> 04:19:16,202
And then what they end
up doing is they end up

5858
04:19:16,202 --> 04:19:18,160
making your spaghetti and meatballs

5859
04:19:18,160 --> 04:19:20,540
and they end up making it
blah, blah, blah, blah, blah.

5860
04:19:20,540 --> 04:19:23,675
And here's all the noodles
and it kind of looks

5861
04:19:23,675 --> 04:19:24,740
like a smiley face now.

5862
04:19:24,740 --> 04:19:26,750
Anyway, there's some
spaghetti and meatballs.

5863
04:19:27,690 --> 04:19:29,580
And then what ends up happening from there

5864
04:19:29,580 --> 04:19:32,740
is that gets directly returned back to you

5865
04:19:32,740 --> 04:19:34,270
and then you get to enjoy it.

5866
04:19:34,270 --> 04:19:39,270
And you are now a happy camper
because you are enjoying

5867
04:19:39,370 --> 04:19:43,070
your spaghetti and meatballs,
so it's a pretty good thing.

5868
04:19:43,070 --> 04:19:44,220
All right, there we go.

5869
04:19:45,150 --> 04:19:47,510
So your spaghetti meatballs,
now this is the contract.

5870
04:19:47,510 --> 04:19:49,790
Now here's the thing, let's
assume that this restaurant

5871
04:19:49,790 --> 04:19:52,560
has many different locations.

5872
04:19:52,560 --> 04:19:56,090
So this locations, you
could have another location,

5873
04:19:56,090 --> 04:19:57,450
which is over here.

5874
04:19:58,420 --> 04:19:59,290
It maybe some different town,

5875
04:19:59,290 --> 04:20:01,860
but they're owned by the same company.

5876
04:20:01,860 --> 04:20:05,380
But when you go to this restaurant
to this chain restaurant,

5877
04:20:05,380 --> 04:20:07,730
you're like, you realize
that, hey, you know what,

5878
04:20:07,730 --> 04:20:10,210
I really like the spaghetti and meatballs.

5879
04:20:10,210 --> 04:20:12,530
And so you go to the blue one here,

5880
04:20:12,530 --> 04:20:13,840
which is the same company.

5881
04:20:13,840 --> 04:20:15,750
They have the same menu,
so they bring out you

5882
04:20:15,750 --> 04:20:18,350
the menu again and say, all
right, here's all the things

5883
04:20:18,350 --> 04:20:19,450
that we have to offer.

5884
04:20:20,480 --> 04:20:22,940
And these things of course are gonna be

5885
04:20:22,940 --> 04:20:25,440
your spaghetti meatballs and your bakesid

5886
04:20:25,440 --> 04:20:27,320
and your linguine and clam
sauce and et cetera, et cetera,

5887
04:20:27,320 --> 04:20:28,630
et cetera, et cetera.

5888
04:20:28,630 --> 04:20:30,740
And of course you say immediately,

5889
04:20:30,740 --> 04:20:34,010
well, I like the spaghetti
meatballs from this place.

5890
04:20:34,010 --> 04:20:36,275
Again, it's owned by the same company.

5891
04:20:36,275 --> 04:20:38,110
So again, you're gonna make an order again

5892
04:20:38,110 --> 04:20:39,710
say, I want spaghetti and meatballs.

5893
04:20:39,710 --> 04:20:42,070
The order goes over to here,
spaghetti and meatballs.

5894
04:20:42,070 --> 04:20:44,680
And then what you don't
know behind the scenes

5895
04:20:44,680 --> 04:20:47,390
is, well, this is just the contract,

5896
04:20:47,390 --> 04:20:50,320
like you don't care how the
spaghetti meatballs are done,

5897
04:20:50,320 --> 04:20:52,680
you just want the spaghetti and meatballs.

5898
04:20:52,680 --> 04:20:54,550
And so what ends up happening is maybe

5899
04:20:54,550 --> 04:20:56,420
because of the way that
the business is built

5900
04:20:56,420 --> 04:20:57,670
or the software is built.

5901
04:20:58,640 --> 04:21:00,850
In this instance, when
I'm running over here,

5902
04:21:00,850 --> 04:21:02,890
instead of building and
making the spaghetti

5903
04:21:02,890 --> 04:21:06,630
and meatballs myself, they
actually kind of just go over

5904
04:21:06,630 --> 04:21:09,140
here and say, hey folks,
we need some spaghetti

5905
04:21:09,140 --> 04:21:10,425
and meatballs.

5906
04:21:10,425 --> 04:21:11,258
And maybe they've already pre-packaged

5907
04:21:11,258 --> 04:21:13,570
those spaghetti and meatballs before.

5908
04:21:13,570 --> 04:21:15,000
And they actually have already delivered

5909
04:21:15,000 --> 04:21:17,950
a box of those spaghetti and meatballs.

5910
04:21:17,950 --> 04:21:20,330
And the spaghetti and meatballs
are already pre-packaged

5911
04:21:20,330 --> 04:21:21,200
and ready to go.

5912
04:21:22,516 --> 04:21:23,349
And then as you can see here,

5913
04:21:23,349 --> 04:21:25,660
they got all these
little meat balls in here

5914
04:21:25,660 --> 04:21:27,920
and you're ready to eat them,

5915
04:21:27,920 --> 04:21:30,314
or they're ready to warm them up.

5916
04:21:30,314 --> 04:21:31,490
And so at this point in time, you, again,

5917
04:21:31,490 --> 04:21:34,270
you've just ordered the say, I
want spaghetti and meatballs.

5918
04:21:34,270 --> 04:21:37,060
The restaurants are also
adhering to this contract

5919
04:21:37,060 --> 04:21:39,860
and saying, okay, spaghetti
and meatballs came in, cool.

5920
04:21:39,860 --> 04:21:42,200
If you're at this
restaurant, we make it fresh

5921
04:21:42,200 --> 04:21:43,033
because we're the main restaurant.

5922
04:21:43,033 --> 04:21:45,840
If you're at our other location,
we've already made a bunch

5923
04:21:45,840 --> 04:21:47,690
and kind of pre-packaged it.

5924
04:21:47,690 --> 04:21:49,560
So this location can kind of get it done

5925
04:21:49,560 --> 04:21:52,000
because we have a special way of making it

5926
04:21:52,000 --> 04:21:53,690
that only two people know how to do.

5927
04:21:53,690 --> 04:21:55,430
And so now over at this location,

5928
04:21:55,430 --> 04:21:57,530
what they do is they come
over here and they say,

5929
04:21:57,530 --> 04:21:58,363
all right, cool.

5930
04:21:58,363 --> 04:22:02,250
Well, let's go ahead and take
some spaghetti meatballs here

5931
04:22:02,250 --> 04:22:04,610
and we'll head and put it on the plate

5932
04:22:04,610 --> 04:22:06,620
and we're gonna warm it
up and we'll do whatever

5933
04:22:06,620 --> 04:22:07,910
we wanna do to it.

5934
04:22:07,910 --> 04:22:09,840
And here's the spaghetti
and meatballs or whatever.

5935
04:22:09,840 --> 04:22:11,600
And then at that point,
we're gonna go ahead.

5936
04:22:11,600 --> 04:22:14,083
And once that's done, we're gonna go ahead

5937
04:22:14,083 --> 04:22:16,570
and deliver it back to you and boom,

5938
04:22:16,570 --> 04:22:18,730
there you go right into your stomach.

5939
04:22:18,730 --> 04:22:21,330
So now you have spaghetti
and meat balls over here.

5940
04:22:21,330 --> 04:22:23,830
The key thing is here
from a user perspective,

5941
04:22:23,830 --> 04:22:27,580
this is the user who is
perhaps consuming a library,

5942
04:22:27,580 --> 04:22:29,880
your code or whatever,
this is your interface.

5943
04:22:30,813 --> 04:22:33,253
Your interface says, hey,
here's the things we can do.

5944
04:22:33,253 --> 04:22:35,370
And then the implementations
are these restaurants.

5945
04:22:35,370 --> 04:22:37,140
These are who implemented the interface.

5946
04:22:37,140 --> 04:22:38,910
This restaurant A
implemented the interface

5947
04:22:38,910 --> 04:22:41,680
and restaurant B implemented
the same interface.

5948
04:22:41,680 --> 04:22:44,780
They both said, hey, we
can both make you spaghetti

5949
04:22:44,780 --> 04:22:45,770
and meatballs.

5950
04:22:45,770 --> 04:22:48,910
Now how they do that, you
really don't care about.

5951
04:22:48,910 --> 04:22:51,270
The caller of that from
the interface perspective

5952
04:22:51,270 --> 04:22:52,180
doesn't care about it.

5953
04:22:52,180 --> 04:22:54,590
The caller says, hey, I want
spaghetti and meatballs.

5954
04:22:55,450 --> 04:22:58,083
At the end of the day, you
know that you've just been

5955
04:22:58,083 --> 04:23:00,295
delivered the spaghetti and
meatballs that you want,

5956
04:23:00,295 --> 04:23:01,648
you don't care how it's done.

5957
04:23:01,648 --> 04:23:02,481
Now behind the scenes,

5958
04:23:02,481 --> 04:23:03,314
the implementation could be different.

5959
04:23:03,314 --> 04:23:04,950
For example, this is code.

5960
04:23:04,950 --> 04:23:07,210
This code might call into a
completely different module

5961
04:23:07,210 --> 04:23:11,700
to generate something or this
code might generated itself.

5962
04:23:11,700 --> 04:23:14,090
It all really depends
on how you're doing it.

5963
04:23:14,090 --> 04:23:18,020
But what it allows you to do
from a developer perspective

5964
04:23:18,020 --> 04:23:21,340
is say, hey, I have this
known interface here.

5965
04:23:21,340 --> 04:23:24,170
And so anyone who interacts
with us just needs to parse us

5966
04:23:24,170 --> 04:23:28,030
an instance at this interface
and call this interface

5967
04:23:28,030 --> 04:23:29,750
and whoever implements it over here

5968
04:23:29,750 --> 04:23:31,780
will do whatever they
need to do to return back

5969
04:23:31,780 --> 04:23:32,760
what they want.

5970
04:23:32,760 --> 04:23:35,080
And so you can have one,
you can have multiple

5971
04:23:35,080 --> 04:23:37,770
different implementations
of these over here.

5972
04:23:37,770 --> 04:23:40,280
You could have, we have two colors here,

5973
04:23:40,280 --> 04:23:41,570
but you can keep going.

5974
04:23:41,570 --> 04:23:44,940
And there could be all different
types of implementations

5975
04:23:44,940 --> 04:23:47,040
of this interface and they
could be all over the place.

5976
04:23:47,040 --> 04:23:49,270
They could be ones up here,
there could be hundreds

5977
04:23:49,270 --> 04:23:50,640
of different of the implementations,

5978
04:23:50,640 --> 04:23:54,140
but they all, every single one of them

5979
04:23:54,140 --> 04:23:57,690
adhere to the same
interface, the same contract.

5980
04:23:57,690 --> 04:24:01,020
So it doesn't matter if
you're ordering spaghetti

5981
04:24:01,020 --> 04:24:04,000
and meatballs from this
location or this location

5982
04:24:04,000 --> 04:24:05,970
or any of these locations, they all know

5983
04:24:05,970 --> 04:24:08,620
how to return back to you
the spaghetti and meatballs

5984
04:24:09,502 --> 04:24:10,640
that you want, all done
through this interface.

5985
04:24:10,640 --> 04:24:13,360
Now, if you take this a step
further and we can go ahead

5986
04:24:13,360 --> 04:24:15,240
and kind of clear this thing out,

5987
04:24:16,080 --> 04:24:17,848
again, you have yourself over here

5988
04:24:17,848 --> 04:24:20,640
and now this is we're going
to a futuristic restaurant.

5989
04:24:21,889 --> 04:24:22,920
And this futuristic restaurant now has

5990
04:24:22,920 --> 04:24:24,830
just a digital ordering pad.

5991
04:24:25,730 --> 04:24:27,930
And you come in here and you
get to press on some buttons.

5992
04:24:27,930 --> 04:24:31,010
So I want, spaghetti and
meatballs or baked ZD or whatever.

5993
04:24:32,239 --> 04:24:33,072
This is just an interface too,

5994
04:24:33,072 --> 04:24:34,320
think about it like a graphical interface.

5995
04:24:34,320 --> 04:24:36,490
This is an interface
that's been implemented.

5996
04:24:36,490 --> 04:24:39,030
Now, depends on where you're going.

5997
04:24:39,030 --> 04:24:41,030
You don't really care
who's implemented it,

5998
04:24:41,030 --> 04:24:42,340
you just wanna know that you're gonna get

5999
04:24:42,340 --> 04:24:45,364
either your spaghetti and meatballs,

6000
04:24:45,364 --> 04:24:47,064
or you're gonna get your baked ZD.

6001
04:24:48,443 --> 04:24:50,650
And you really just don't
care where all these different

6002
04:24:50,650 --> 04:24:53,371
types of things are coming
from because to you,

6003
04:24:53,371 --> 04:24:56,480
you interacting with whoever
agreed to that contract.

6004
04:24:57,410 --> 04:24:58,840
And then at that point in time.

6005
04:24:58,840 --> 04:25:01,380
So for example, let's even
take this a step further.

6006
04:25:01,380 --> 04:25:05,070
You could have two
different implementations

6007
04:25:05,070 --> 04:25:06,440
of that interface.

6008
04:25:06,440 --> 04:25:10,630
So this is gonna number
one will be up here

6009
04:25:11,780 --> 04:25:13,540
and number two will be down here.

6010
04:25:14,770 --> 04:25:16,810
And as you order this item here,

6011
04:25:16,810 --> 04:25:19,410
right in this little section,
so I wanna order this.

6012
04:25:20,360 --> 04:25:22,850
And at this point in time,
you're gonna kind of go down

6013
04:25:22,850 --> 04:25:24,730
this path right here.

6014
04:25:24,730 --> 04:25:27,330
Well, cool, that means I'm gonna go ahead

6015
04:25:27,330 --> 04:25:29,260
and this automatically then says,

6016
04:25:29,260 --> 04:25:30,890
okay, let's spaghetti and meatballs.

6017
04:25:30,890 --> 04:25:33,000
We're gonna go to this module and generate

6018
04:25:33,000 --> 04:25:34,880
whatever we need to generate.

6019
04:25:34,880 --> 04:25:36,070
And for whatever reason,

6020
04:25:36,070 --> 04:25:38,800
you're going down this path over here,

6021
04:25:40,030 --> 04:25:41,970
well, all that's just kind
of, we have custom codes

6022
04:25:41,970 --> 04:25:43,358
for everything.

6023
04:25:43,358 --> 04:25:44,191
So everything is just
kind of done right here

6024
04:25:44,191 --> 04:25:45,250
in this whole section.

6025
04:25:45,250 --> 04:25:47,640
So what that allows you to
do, the interface allows you

6026
04:25:47,640 --> 04:25:51,530
to hide the implementation
behind a particular interface.

6027
04:25:51,530 --> 04:25:53,240
It's the contract that this is the things

6028
04:25:53,240 --> 04:25:55,060
that we can do for you.

6029
04:25:55,060 --> 04:25:56,760
So anytime you want something to adhere

6030
04:25:56,760 --> 04:25:58,660
to the same contract, you can do that.

6031
04:25:59,662 --> 04:26:01,847
And that's exactly what has happened over

6032
04:26:01,847 --> 04:26:04,052
inside of the examples here.

6033
04:26:04,052 --> 04:26:06,340
In this case, we're using
mammals so we can have a mammal

6034
04:26:06,340 --> 04:26:09,040
and it can be a cow, it
can be a human or whatever.

6035
04:26:09,040 --> 04:26:11,846
We noticed that it walks,
it can speak, whatever.

6036
04:26:11,846 --> 04:26:14,100
All we know is it with a mammal interface,

6037
04:26:14,100 --> 04:26:16,470
if I tell a man what
to walk, it will walk.

6038
04:26:16,470 --> 04:26:17,830
Now I don't care how it walks.

6039
04:26:17,830 --> 04:26:20,420
Does it walk on four feet,
two feet, 12 feet, 15,

6040
04:26:20,420 --> 04:26:23,900
I don't know, don't care,
I just know that it walks.

6041
04:26:23,900 --> 04:26:26,190
And so when you have an
interface, it means that,

6042
04:26:26,190 --> 04:26:28,630
hey, these are the things we can do.

6043
04:26:28,630 --> 04:26:30,570
To implement an interface in Kotlin,

6044
04:26:31,409 --> 04:26:32,242
you'll type the word interface

6045
04:26:32,242 --> 04:26:33,590
and then the name of the interface.

6046
04:26:34,530 --> 04:26:36,520
I'm going to call this one discountable

6047
04:26:37,870 --> 04:26:40,310
as in something might
be able to be discounted

6048
04:26:40,310 --> 04:26:42,930
such as a physical product, or
maybe even a digital product,

6049
04:26:42,930 --> 04:26:45,140
but I just want it to be discountable.

6050
04:26:45,140 --> 04:26:48,010
And instead of there, I can
declare values or excuse me,

6051
04:26:48,010 --> 04:26:52,180
functions that I would want
the implementer to implement.

6052
04:26:52,180 --> 04:26:54,811
So here I'm going to implement a function

6053
04:26:54,811 --> 04:26:56,600
called discount percent,

6054
04:26:56,600 --> 04:26:59,450
which will then return the percent amount

6055
04:26:59,450 --> 04:27:02,730
that whatever the discounted
item is going to be

6056
04:27:02,730 --> 04:27:03,940
will be discountable.

6057
04:27:03,940 --> 04:27:05,730
So now I have created an interface

6058
04:27:05,730 --> 04:27:07,280
that is called discountable.

6059
04:27:07,280 --> 04:27:09,730
It has one function, I
create another function

6060
04:27:09,730 --> 04:27:10,730
that could do something else.

6061
04:27:10,730 --> 04:27:13,430
Perhaps I'd call it a foo
and maybe it doesn't have

6062
04:27:13,430 --> 04:27:15,530
a return type, it doesn't have to be,

6063
04:27:15,530 --> 04:27:19,893
it might be something such
as calculate something

6064
04:27:20,840 --> 04:27:22,740
or you could just do whatever you wanna do

6065
04:27:22,740 --> 04:27:24,990
inside of your function.

6066
04:27:24,990 --> 04:27:26,310
So it doesn't have to have a return type

6067
04:27:26,310 --> 04:27:28,190
and return types can be anything you want.

6068
04:27:28,190 --> 04:27:30,950
And that's how you create
an interface in Kotlin.

6069
04:27:32,060 --> 04:27:34,470
To implement an interface in Kotlin,

6070
04:27:34,470 --> 04:27:36,750
you'll want to actually create a class.

6071
04:27:36,750 --> 04:27:40,170
So you say class, it might
wanna have a physical product.

6072
04:27:40,170 --> 04:27:43,060
So we'll just go ahead
and say generic toy.

6073
04:27:44,020 --> 04:27:46,890
And this class is going
to extend and implement

6074
04:27:46,890 --> 04:27:49,920
the discountable interface.

6075
04:27:49,920 --> 04:27:51,910
So here we have the red
squiggly and we can click

6076
04:27:51,910 --> 04:27:53,900
on this button and say, implement members

6077
04:27:53,900 --> 04:27:55,840
and it'll ask us which ones.

6078
04:27:55,840 --> 04:27:57,650
We could select discount percent.

6079
04:27:57,650 --> 04:27:59,640
And then what we have to
do is we have to implement

6080
04:27:59,640 --> 04:28:01,310
whatever that value is.

6081
04:28:02,421 --> 04:28:03,254
And of course, if we do not implement it,

6082
04:28:03,254 --> 04:28:05,840
we can leave the default
to do here, which will then

6083
04:28:05,840 --> 04:28:08,420
if we look at the
implementation, will go ahead

6084
04:28:08,420 --> 04:28:10,870
and throw a null implemented exception.

6085
04:28:10,870 --> 04:28:12,310
So if we run it, we'll
kind of get something

6086
04:28:12,310 --> 04:28:15,160
in our log saying that this
has not been implemented

6087
04:28:15,160 --> 04:28:17,720
for later, but this is how you
can implement the interface.

6088
04:28:17,720 --> 04:28:20,460
Now, if you do add
additional member on here,

6089
04:28:20,460 --> 04:28:22,870
so let's just call this
foo for whatever reason,

6090
04:28:22,870 --> 04:28:24,950
we're gonna get a compilation error again.

6091
04:28:24,950 --> 04:28:26,980
So we won't be able to compile
until we implement that

6092
04:28:26,980 --> 04:28:29,590
on anyone else who has
implemented discountable.

6093
04:28:29,590 --> 04:28:32,390
So we may also have another
class called digital product

6094
04:28:33,370 --> 04:28:37,440
and digital product is also
going to implement discountable

6095
04:28:37,440 --> 04:28:39,130
because perhaps you can
discount that as well.

6096
04:28:39,130 --> 04:28:42,160
And you will also need to
implement both of these values

6097
04:28:42,160 --> 04:28:44,040
on to both of these as well.

6098
04:28:44,040 --> 04:28:46,200
So they'll both be discountable.

6099
04:28:46,200 --> 04:28:49,320
And that's how you implement
an interface in Kotlin.

6100
04:28:50,910 --> 04:28:53,700
And some examples of this
might be you build an interface

6101
04:28:53,700 --> 04:28:54,980
for your file system.

6102
04:28:55,990 --> 04:28:57,900
So if you build a file
file system interface,

6103
04:28:57,900 --> 04:28:59,610
you might have something like this.

6104
04:28:59,610 --> 04:29:02,020
Interface, we'll call it fs for five.

6105
04:29:02,020 --> 04:29:04,120
It's very comical file
system and I think nobody

6106
04:29:04,120 --> 04:29:05,290
even has one called fs.

6107
04:29:06,745 --> 04:29:10,180
And we might have a method called reader,

6108
04:29:10,180 --> 04:29:12,380
which is going to read
back and give us back

6109
04:29:13,778 --> 04:29:17,640
a list of string is called files.

6110
04:29:17,640 --> 04:29:22,640
We could have function read file,

6111
04:29:22,800 --> 04:29:24,750
and it's gonna return us back a string.

6112
04:29:25,607 --> 04:29:26,440
And we can have a whole
bunch of other things

6113
04:29:26,440 --> 04:29:27,273
inside of here.

6114
04:29:27,273 --> 04:29:29,160
Now, what we could do is,

6115
04:29:29,160 --> 04:29:30,350
I'm actually just gonna rename this

6116
04:29:30,350 --> 04:29:31,650
so it's a little bit more,

6117
04:29:33,010 --> 04:29:34,830
make some more sense of file system.

6118
04:29:35,735 --> 04:29:37,290
Then what we could do is we
could have an implementation

6119
04:29:37,290 --> 04:29:38,600
of the file system,

6120
04:29:38,600 --> 04:29:41,810
and we might wanna call
that a real file system,

6121
04:29:43,060 --> 04:29:47,540
or you know what, let's just
call it a fat 32 file system,

6122
04:29:47,540 --> 04:29:49,600
which is a real file system.

6123
04:29:49,600 --> 04:29:51,320
And it's gonna implement file system.

6124
04:29:53,019 --> 04:29:54,969
And then what we'd have here implement,

6125
04:29:56,040 --> 04:29:58,090
oops, implement these members.

6126
04:29:59,573 --> 04:30:01,300
And then we have to do something

6127
04:30:01,300 --> 04:30:03,100
with each one of these members here.

6128
04:30:04,056 --> 04:30:06,280
So we would read the
file in a fat 32 method,

6129
04:30:06,280 --> 04:30:10,730
and we would read the
directory in a fat 32 method.

6130
04:30:10,730 --> 04:30:12,350
And then there's other file systems here.

6131
04:30:12,350 --> 04:30:15,320
So let's just go to return an empty list,

6132
04:30:15,320 --> 04:30:17,220
just so we don't get a compiler error

6133
04:30:17,220 --> 04:30:21,100
and let's just go ahead
and return an empty string.

6134
04:30:22,774 --> 04:30:24,750
And of course, we would
read a file that the file

6135
04:30:24,750 --> 04:30:26,571
would probably have a path of whatever,

6136
04:30:26,571 --> 04:30:28,310
and we're leaving it off
for brevity at this point.

6137
04:30:28,310 --> 04:30:30,120
Then if we wanna have it ext file system.

6138
04:30:30,120 --> 04:30:35,120
So class ext files, we've
gotta have a file system here.

6139
04:30:38,300 --> 04:30:40,950
Same thing, we need to
implement those members,

6140
04:30:40,950 --> 04:30:42,960
and we need to actually
implement the other one too.

6141
04:30:44,730 --> 04:30:47,324
And it's gonna leave us to do there

6142
04:30:47,324 --> 04:30:48,230
so we don't have the error.

6143
04:30:49,429 --> 04:30:52,644
Now, this is great because
we have the ext file system.

6144
04:30:52,644 --> 04:30:54,775
We have the fat 32 file
system, and we know

6145
04:30:54,775 --> 04:30:55,610
that anytime we're working
with a file system,

6146
04:30:55,610 --> 04:30:57,090
we need to do something.

6147
04:30:57,090 --> 04:31:00,950
Now, lastly, we may have
a very interesting one,

6148
04:31:00,950 --> 04:31:02,060
we have right here.

6149
04:31:02,060 --> 04:31:05,170
So I have class memory file system.

6150
04:31:07,333 --> 04:31:08,900
Why would we want this?

6151
04:31:08,900 --> 04:31:10,920
Now, this is very interesting here,

6152
04:31:10,920 --> 04:31:15,920
because we might just have
something that allows us to,

6153
04:31:16,160 --> 04:31:18,310
let's go ahead and
implement these members.

6154
04:31:19,640 --> 04:31:22,480
And we might be able to
have an implementation here

6155
04:31:22,480 --> 04:31:25,040
of memory file system, where we take in

6156
04:31:25,040 --> 04:31:27,230
and a constructor here.

6157
04:31:27,230 --> 04:31:29,320
Watch this, we say read directory.

6158
04:31:29,320 --> 04:31:31,250
We take in files.

6159
04:31:31,250 --> 04:31:32,980
So we've taken a list of strings.

6160
04:31:34,340 --> 04:31:36,470
And look what we're gonna do here,

6161
04:31:40,387 --> 04:31:43,400
and we take in the file content, B string,

6162
04:31:45,081 --> 04:31:47,430
and now all I'm gonna do
here is just return files.

6163
04:31:50,450 --> 04:31:52,130
That needs to be a val,
so we can actually work

6164
04:31:52,130 --> 04:31:53,530
with the inside of the class

6165
04:31:55,210 --> 04:32:00,210
and the same thing down here,
return the file contents.

6166
04:32:02,230 --> 04:32:03,930
So the interesting thing
here is if we go back

6167
04:32:03,930 --> 04:32:06,060
to our main application.

6168
04:32:07,750 --> 04:32:11,450
If for whatever reason inside
of our main function here,

6169
04:32:13,058 --> 04:32:13,891
we wanted...

6170
04:32:13,891 --> 04:32:15,930
If we were to work with
just the file system,

6171
04:32:15,930 --> 04:32:17,640
so it will say file system.

6172
04:32:18,561 --> 04:32:20,710
And we were broke with
the fat 32 file system.

6173
04:32:22,058 --> 04:32:23,650
And then we're gonna do
something with the file system,

6174
04:32:25,810 --> 04:32:26,643
blah, blah, blah.

6175
04:32:26,643 --> 04:32:28,520
We could actually say, I'm
gonna read this directory

6176
04:32:28,520 --> 04:32:29,890
and it's gonna read the directory.

6177
04:32:29,890 --> 04:32:33,150
Now this would be very pertinent
to file 32 fast system.

6178
04:32:33,150 --> 04:32:34,630
Well, what if we wanted our application

6179
04:32:34,630 --> 04:32:37,174
to run on the ext file system?

6180
04:32:37,174 --> 04:32:39,370
Well, now we're gonna
have to do like some,

6181
04:32:40,547 --> 04:32:42,000
if the FL statements to
check what file system

6182
04:32:42,000 --> 04:32:45,550
we're on or whatever, or
what could be provided to us

6183
04:32:45,550 --> 04:32:49,220
during real time is actually a interface.

6184
04:32:49,220 --> 04:32:51,910
So we might actually
say something like this.

6185
04:32:52,920 --> 04:32:57,920
Val file system, file system right here.

6186
04:32:58,630 --> 04:33:00,480
Remember, this is the interface here,

6187
04:33:01,448 --> 04:33:04,290
and we can say equals fat 32 file system.

6188
04:33:04,290 --> 04:33:06,895
Now that's still works and
we can still kind of do

6189
04:33:06,895 --> 04:33:07,728
the same kind of thing we did before.

6190
04:33:07,728 --> 04:33:10,840
And if we were using something
like dependency injection,

6191
04:33:10,840 --> 04:33:13,830
we could actually get
this from a constructor,

6192
04:33:13,830 --> 04:33:15,010
which is beyond the scope of this,

6193
04:33:15,010 --> 04:33:17,730
but we get from a constructor or a setter

6194
04:33:19,080 --> 04:33:21,880
or something like that,
some variable, some type,

6195
04:33:23,018 --> 04:33:25,590
in which, we could set up pretty easily.

6196
04:33:25,590 --> 04:33:27,450
Now the real power from this comes in

6197
04:33:27,450 --> 04:33:29,360
when we determined later on.

6198
04:33:29,360 --> 04:33:31,290
So let's actually do that now.

6199
04:33:32,136 --> 04:33:33,030
We actually just create a method here,

6200
04:33:34,802 --> 04:33:36,452
call get file system to function.

6201
04:33:39,234 --> 04:33:41,834
Get file system is going
to return us a file system,

6202
04:33:45,300 --> 04:33:47,790
turned fat 32 files, okay, there we go.

6203
04:33:47,790 --> 04:33:51,860
And all we can do here is
just say this file system.

6204
04:33:54,240 --> 04:33:55,190
Create file system.

6205
04:33:59,742 --> 04:34:00,575
Now at that point in time, we can do this.

6206
04:34:00,575 --> 04:34:02,630
Now, the interesting thing
here is if this was inside

6207
04:34:02,630 --> 04:34:05,357
of a dependency injection or whatever,

6208
04:34:05,357 --> 04:34:06,990
we could use the in-memory version.

6209
04:34:06,990 --> 04:34:10,320
So if I'm writing a test,
maybe I've just moved this code

6210
04:34:10,320 --> 04:34:12,660
into like a helper function somewhere.

6211
04:34:12,660 --> 04:34:13,980
And then what I do is instead of this one,

6212
04:34:13,980 --> 04:34:16,930
I say return memory file system.

6213
04:34:16,930 --> 04:34:21,803
And then what I do is I
know list of no path to file

6214
04:34:25,260 --> 04:34:30,260
another paths, so remember
this path of file pars,

6215
04:34:30,680 --> 04:34:35,200
file content go here.

6216
04:34:37,490 --> 04:34:39,110
So what I'm doing is I'm actually creating

6217
04:34:39,110 --> 04:34:42,770
a in-memory file system, kind
of faking the whole thing.

6218
04:34:42,770 --> 04:34:44,380
And then inside of my
application, I could say,

6219
04:34:44,380 --> 04:34:46,310
filed.read directory.

6220
04:34:46,310 --> 04:34:47,580
And then what I can do is actually give

6221
04:34:47,580 --> 04:34:51,400
a known list of files here.

6222
04:34:51,400 --> 04:34:54,710
And so now I've actually
and I've enabled myself

6223
04:34:54,710 --> 04:34:56,420
to have different implementations.

6224
04:34:56,420 --> 04:34:57,253
This is the contract.

6225
04:34:57,253 --> 04:35:00,550
Remember the contract says,
hey, I'm gonna redirect

6226
04:35:00,550 --> 04:35:01,630
and I know how to read a file.

6227
04:35:01,630 --> 04:35:03,560
And if I read a file, I'm
gonna get back a string

6228
04:35:03,560 --> 04:35:05,890
and if I read a directory and
to get back a list of strings.

6229
04:35:05,890 --> 04:35:08,550
That's all I know how to do,
I don't care how it's done,

6230
04:35:08,550 --> 04:35:11,180
but I'm a fat 32 system
it's done differently

6231
04:35:11,180 --> 04:35:13,160
than an ext file system.

6232
04:35:13,160 --> 04:35:16,110
And you know what, I may also
build a memory file system,

6233
04:35:16,110 --> 04:35:18,200
which allows me to provide the values

6234
04:35:20,401 --> 04:35:21,740
to the actual file
system so I can actually

6235
04:35:21,740 --> 04:35:25,050
basically do this in memory
or for testing, et cetera.

6236
04:35:25,050 --> 04:35:29,321
So interfaces allow you to
separate and think of them

6237
04:35:29,321 --> 04:35:30,154
almost like shims.

6238
04:35:30,154 --> 04:35:32,540
They allow you to kind of really
decouple your application.

6239
04:35:32,540 --> 04:35:34,360
And so they're just a way
for you to communicate.

6240
04:35:34,360 --> 04:35:38,130
It's a known contract between
you and your application

6241
04:35:38,130 --> 04:35:39,080
and what it can do.

6242
04:35:39,970 --> 04:35:42,690
When creating interfaces, it's
very often that you'll do it

6243
04:35:42,690 --> 04:35:44,660
in an anonymous fashion.

6244
04:35:44,660 --> 04:35:47,550
Here, I have set up an interface
called on click listener.

6245
04:35:47,550 --> 04:35:49,795
This is something you've probably seen

6246
04:35:49,795 --> 04:35:51,245
in various other UI toolkits.

6247
04:35:52,140 --> 04:35:54,420
And this on click listener
has an on click method

6248
04:35:54,420 --> 04:35:57,400
that is called when a
particular view was clicked.

6249
04:35:57,400 --> 04:35:59,850
And so we have a class here called view.

6250
04:35:59,850 --> 04:36:03,220
This could be such as like
a button, a text view,

6251
04:36:03,220 --> 04:36:06,540
an image view, some type of
map or anything like that.

6252
04:36:06,540 --> 04:36:09,620
And it has a listener that's
going to be assigned to it.

6253
04:36:09,620 --> 04:36:12,460
Now, we're just gonna very
simply here use the late init

6254
04:36:12,460 --> 04:36:15,690
modifier to say at some point,
this will be called and set.

6255
04:36:18,165 --> 04:36:18,998
And we're not doing
any null checking here,

6256
04:36:18,998 --> 04:36:19,831
so this is not production quality,

6257
04:36:19,831 --> 04:36:21,670
but this illustrates the example.

6258
04:36:22,648 --> 04:36:24,840
So anytime the view is
clicked, it'll then instantiate

6259
04:36:24,840 --> 04:36:27,370
the click listener and
then whatever happens

6260
04:36:27,370 --> 04:36:28,720
inside the click listener will happen.

6261
04:36:28,720 --> 04:36:31,866
So that's the interface
here, on click listener

6262
04:36:31,866 --> 04:36:32,699
with the on click method.

6263
04:36:32,699 --> 04:36:34,830
So we have a few other
classes that extend view

6264
04:36:34,830 --> 04:36:36,360
such as button image and map.

6265
04:36:37,558 --> 04:36:38,710
So let's assume we create a button here.

6266
04:36:38,710 --> 04:36:41,620
If I wanted to set the click listener,

6267
04:36:41,620 --> 04:36:43,450
I could set it to an instance
of the click listener

6268
04:36:43,450 --> 04:36:45,730
if I had implemented it
in an instance of it,

6269
04:36:45,730 --> 04:36:48,820
in which I could do my own
custom one, like this class,

6270
04:36:50,660 --> 04:36:51,493
my listener.

6271
04:36:52,630 --> 04:36:56,190
And that would be on click
listener and then be like this.

6272
04:36:58,347 --> 04:37:02,440
And then perhaps I wanna say
print line and I say clicked.

6273
04:37:02,440 --> 04:37:05,290
And I can do that very easily
by just saying new listener

6274
04:37:06,130 --> 04:37:07,790
to list my listener.

6275
04:37:09,850 --> 04:37:11,830
And there we go, now that
click listener will work.

6276
04:37:11,830 --> 04:37:14,010
And if I call button.click,

6277
04:37:15,300 --> 04:37:17,580
the listener will now get invoked.

6278
04:37:17,580 --> 04:37:20,170
So if we run this here,
we should see clicked

6279
04:37:20,170 --> 04:37:23,340
in the output window, we do see clicked.

6280
04:37:23,340 --> 04:37:26,360
Now this is not an
anonymous implementation,

6281
04:37:26,360 --> 04:37:27,193
this is a concrete implementation.

6282
04:37:27,193 --> 04:37:28,280
So let's go ahead and get rid of this.

6283
04:37:28,280 --> 04:37:30,210
This is not what we want here.

6284
04:37:30,210 --> 04:37:33,290
There's a way we can do
it directly in line here.

6285
04:37:33,290 --> 04:37:34,810
So what we're going to do is
we use this word called object.

6286
04:37:34,810 --> 04:37:38,710
We're basically creating an
object right here in place,

6287
04:37:38,710 --> 04:37:40,160
and we'll say click listener,

6288
04:37:41,250 --> 04:37:42,900
and then open and close brackets.

6289
04:37:43,989 --> 04:37:45,040
And then you'll see object is highlight

6290
04:37:46,279 --> 04:37:47,980
and you hit alt+enter for Mac
and implement the members.

6291
04:37:47,980 --> 04:37:50,220
And it will just allow you
to implement that member,

6292
04:37:50,220 --> 04:37:52,990
which is on click and then we
can just do print line here.

6293
04:37:55,454 --> 04:37:56,287
Let's say this was clicked.

6294
04:37:57,490 --> 04:37:59,020
And of course, now if we run this,

6295
04:37:59,020 --> 04:38:01,890
what will happen is this basically created

6296
04:38:01,890 --> 04:38:03,100
an inline object here.

6297
04:38:03,990 --> 04:38:07,340
A we've done it in line object,
which is an implementation

6298
04:38:07,340 --> 04:38:09,760
of the on click listener directly in line.

6299
04:38:10,920 --> 04:38:14,280
And it was called here and
directly set up accordingly.

6300
04:38:14,280 --> 04:38:16,960
So that's how you can create
a new instance of that.

6301
04:38:16,960 --> 04:38:20,210
Now, sometimes you'll also see methods

6302
04:38:20,210 --> 04:38:22,350
perhaps that allow you to set listener.

6303
04:38:22,350 --> 04:38:26,660
So to say, set my listener,
we'll just call it that.

6304
04:38:28,330 --> 04:38:31,500
And this is gonna have a click listener,

6305
04:38:36,933 --> 04:38:38,200
and this click listener is going to be

6306
04:38:38,200 --> 04:38:43,200
this dot click listener
equals click listener.

6307
04:38:45,180 --> 04:38:47,430
And so what it basically
says, this one is gonna be set

6308
04:38:47,430 --> 04:38:48,730
equal to this one up here.

6309
04:38:50,234 --> 04:38:52,392
And so that's another way
you could do that there too.

6310
04:38:52,392 --> 04:38:56,150
So inside of here, we say
button.set click listener,

6311
04:38:56,150 --> 04:38:57,310
which is a method now.

6312
04:38:58,210 --> 04:39:01,060
And so I can actually just
cut and paste this out of here

6313
04:39:02,440 --> 04:39:03,990
in the same thing.

6314
04:39:03,990 --> 04:39:04,930
I'm gonna use an object,

6315
04:39:04,930 --> 04:39:07,380
so object: the name of the interface,

6316
04:39:07,380 --> 04:39:09,970
open and close brackets and then implement

6317
04:39:09,970 --> 04:39:12,050
the required methods in the middle.

6318
04:39:12,050 --> 04:39:14,930
So the abstract methods
and this place on click

6319
04:39:14,930 --> 04:39:18,130
and an instance of on click
list will be anonymously created

6320
04:39:18,130 --> 04:39:21,270
and set into this value here.

6321
04:39:21,270 --> 04:39:24,250
So when the click button is called,

6322
04:39:24,250 --> 04:39:26,040
it will then say this was clicked.

6323
04:39:26,040 --> 04:39:28,340
And just to show some differences here,

6324
04:39:29,698 --> 04:39:30,810
let's say this was clicked ABC.

6325
04:39:30,810 --> 04:39:33,710
And if we run this again,
when it gets to button.click,

6326
04:39:33,710 --> 04:39:37,060
we'll see this was clicked ABC.

6327
04:39:37,060 --> 04:39:42,060
Now the same thing happens
here for the map and the image.

6328
04:39:43,150 --> 04:39:46,530
So you could then eat it
very easily and say map.

6329
04:39:48,198 --> 04:39:52,270
So val map equals map and we
would say map.click listener

6330
04:39:52,270 --> 04:39:55,240
equals, and you could do the
object thing here as well.

6331
04:39:58,680 --> 04:40:01,630
Is that on click listener and
then open and close brackets.

6332
04:40:04,100 --> 04:40:05,490
And there you go.

6333
04:40:05,490 --> 04:40:06,670
And then you can do
something inside of there.

6334
04:40:06,670 --> 04:40:08,820
And then of course, if
the map was clicked.

6335
04:40:10,970 --> 04:40:12,520
Now, what this allows you to do is have

6336
04:40:12,520 --> 04:40:16,640
the very common interface,
a contract of, one of you

6337
04:40:16,640 --> 04:40:19,150
is clicked, it'll just invoke a function.

6338
04:40:19,150 --> 04:40:22,330
And then you get to decide what
to do when a map was clicked

6339
04:40:22,330 --> 04:40:24,810
or what to do when this
particular button is clicked.

6340
04:40:24,810 --> 04:40:27,230
And so this is a very common
pattern you'll have seen

6341
04:40:27,230 --> 04:40:28,690
inside of various UI platforms.

6342
04:40:28,690 --> 04:40:31,720
So that's how you can create
an anonymous interface

6343
04:40:31,720 --> 04:40:33,710
implementation in Kotlin.

6344
04:40:34,930 --> 04:40:37,920
You can easily create a raise in Kotlin.

6345
04:40:37,920 --> 04:40:39,010
So let's do that real quick.

6346
04:40:39,010 --> 04:40:41,580
We'll create a variable called items,

6347
04:40:41,580 --> 04:40:45,490
and you can say array
of and then you parse in

6348
04:40:45,490 --> 04:40:46,323
some primitive.

6349
04:40:46,323 --> 04:40:49,040
So we can say one, two, three, four, five,

6350
04:40:49,040 --> 04:40:50,640
and then we can do
something with that array.

6351
04:40:50,640 --> 04:40:52,720
So now we have an array of integers.

6352
04:40:52,720 --> 04:40:55,100
So we can say items.foreach.

6353
04:40:55,100 --> 04:40:57,830
And what we're using is
the extinction function

6354
04:40:57,830 --> 04:40:59,930
on the array class.

6355
04:40:59,930 --> 04:41:02,803
There is a foreach extension method

6356
04:41:02,803 --> 04:41:04,380
built inside of the arrays
instead of the Kotlin

6357
04:41:04,380 --> 04:41:05,250
standard library.

6358
04:41:06,090 --> 04:41:08,383
And so what that allows
us to do is parse in

6359
04:41:08,383 --> 04:41:09,216
a lambda expression,

6360
04:41:09,216 --> 04:41:11,816
and we can actually just
do a print line with value.

6361
04:41:12,814 --> 04:41:15,080
So we can say for each and
print line will then provide

6362
04:41:15,080 --> 04:41:17,940
the, take a value and
print it to the screen.

6363
04:41:17,940 --> 04:41:20,800
IT is the default name of the item

6364
04:41:20,800 --> 04:41:21,800
inside of the lambda expression.

6365
04:41:21,800 --> 04:41:23,420
If we want to change it
to something different,

6366
04:41:23,420 --> 04:41:26,870
we could change it to maybe the word value

6367
04:41:26,870 --> 04:41:29,270
and we would do so like this.

6368
04:41:29,270 --> 04:41:31,720
And then at this point,
we could say value.

6369
04:41:31,720 --> 04:41:33,700
Now that doesn't really provide us

6370
04:41:33,700 --> 04:41:35,350
any additional benefit here.

6371
04:41:36,230 --> 04:41:37,810
If I hit alt enter, we can
see that we can replace

6372
04:41:37,810 --> 04:41:40,710
the explicit parameter
value with the name it,

6373
04:41:40,710 --> 04:41:43,240
and this just kind of cleans
up the code a little bit.

6374
04:41:43,240 --> 04:41:44,970
Now, once we run this, what we will see

6375
04:41:44,970 --> 04:41:47,310
inside of the output window
down here on the bottom

6376
04:41:47,310 --> 04:41:50,030
is all the integers have been printed out.

6377
04:41:50,030 --> 04:41:52,730
Now, an additional cool thing
with some of the built-in

6378
04:41:52,730 --> 04:41:56,470
array classes of Kotlin is we
can also have an int array.

6379
04:41:56,470 --> 04:41:59,190
So by default, we'll
specify how we would like

6380
04:41:59,190 --> 04:42:01,330
some integers, we can
also have a double array.

6381
04:42:01,330 --> 04:42:03,340
And notice this is going
to create a problem here

6382
04:42:03,340 --> 04:42:05,300
because these are not doubled.

6383
04:42:05,300 --> 04:42:08,030
But if we were to turn them into doubles

6384
04:42:08,030 --> 04:42:09,900
by providing a.zero.

6385
04:42:10,955 --> 04:42:12,230
So what is actually a valid double value,

6386
04:42:13,387 --> 04:42:16,680
we can then at that point,
start using the double array

6387
04:42:16,680 --> 04:42:18,160
of call.

6388
04:42:19,342 --> 04:42:20,370
There's multiple other
ones in here as well.

6389
04:42:20,370 --> 04:42:24,970
So we have the array of double
array of, float array of,

6390
04:42:24,970 --> 04:42:27,689
longer range of, of
course, the int array of,

6391
04:42:27,689 --> 04:42:30,150
char array of, shorter arrays, by arrays

6392
04:42:30,150 --> 04:42:32,000
and Boolean arrays.

6393
04:42:32,000 --> 04:42:34,880
Now you'll notice we don't
see a string array in here.

6394
04:42:34,880 --> 04:42:37,260
So what do we do there?

6395
04:42:37,260 --> 04:42:38,380
So that's actually pretty easy.

6396
04:42:38,380 --> 04:42:40,520
We can actually just do array of,

6397
04:42:41,790 --> 04:42:44,759
I know we have to provide
some values in here.

6398
04:42:44,759 --> 04:42:47,240
So Donn Felker via a
simple array of two items.

6399
04:42:47,240 --> 04:42:48,740
And if we were to run this
again, it would just say,

6400
04:42:48,740 --> 04:42:53,010
Donn Felker, one string on each line.

6401
04:42:53,010 --> 04:42:54,690
Now that's not all we can do

6402
04:42:54,690 --> 04:42:56,800
with some of the arrays as well.

6403
04:42:56,800 --> 04:43:01,800
We can also get the array of
objects, so we'd say array of,

6404
04:43:02,350 --> 04:43:04,710
and what I can do here is
since we have our user class,

6405
04:43:04,710 --> 04:43:07,180
which if we remember that
it just has a first name

6406
04:43:07,180 --> 04:43:08,013
and a last name.

6407
04:43:09,270 --> 04:43:11,120
What we'll do here is we'll have user

6408
04:43:12,148 --> 04:43:14,480
and with page, say Donn Felker.

6409
04:43:14,480 --> 04:43:17,890
And then we might have
another one called Jane Doe.

6410
04:43:19,610 --> 04:43:23,700
And now we have two users who
are part of the user array.

6411
04:43:23,700 --> 04:43:25,250
Let's actually call this users.

6412
04:43:26,449 --> 04:43:28,609
And then at that point, we
can actually do the same thing

6413
04:43:28,609 --> 04:43:29,442
that we saw before and then we can iterate

6414
04:43:29,442 --> 04:43:31,960
each over one of them
and we'll call print line

6415
04:43:33,007 --> 04:43:34,157
and we'll call this IT.

6416
04:43:35,229 --> 04:43:38,060
'Cause remember IT at this
point is just a user itself.

6417
04:43:38,060 --> 04:43:40,310
Up here it's going to be a string.

6418
04:43:40,310 --> 04:43:41,610
So the compiler is going to know that.

6419
04:43:41,610 --> 04:43:46,220
If we run this, now we're going
to see the two string value

6420
04:43:46,220 --> 04:43:47,600
of the user class.

6421
04:43:47,600 --> 04:43:50,609
So let's go take a look
at the user class again.

6422
04:43:50,609 --> 04:43:52,290
And the user class, I've
added a quick two string

6423
04:43:52,290 --> 04:43:54,900
implementation, I've
just created an override

6424
04:43:54,900 --> 04:43:58,330
so two string, and we can go
ahead and return something.

6425
04:43:58,330 --> 04:44:01,820
Now its full name and it just
returns this string up here.

6426
04:44:01,820 --> 04:44:05,860
And that's how we can work
with strings and primitives

6427
04:44:05,860 --> 04:44:08,990
and objects and easily
create a raise of them

6428
04:44:08,990 --> 04:44:10,720
and alter them and so forth.

6429
04:44:10,720 --> 04:44:12,760
Now let's assume that we, for some reason,

6430
04:44:12,760 --> 04:44:15,080
we needed to update
the users and we needed

6431
04:44:15,080 --> 04:44:16,738
to add one to it.

6432
04:44:16,738 --> 04:44:18,990
So what we could do is
to say val updated users,

6433
04:44:21,950 --> 04:44:23,980
and we could say users.plus,

6434
04:44:23,980 --> 04:44:25,830
and they're gonna add new user to it.

6435
04:44:27,171 --> 04:44:30,880
And we say, Jon Doe here,
and what this will do

6436
04:44:30,880 --> 04:44:32,880
is if we take a look at
the plus implementation,

6437
04:44:32,880 --> 04:44:35,260
what does it do behind,
underneath the hood.

6438
04:44:35,260 --> 04:44:38,860
It's just an extension
function that creates a copy

6439
04:44:38,860 --> 04:44:41,300
of the array with a one larger index,

6440
04:44:41,300 --> 04:44:44,700
adds the item at that given
index and then returns

6441
04:44:44,700 --> 04:44:46,160
that new array.

6442
04:44:46,160 --> 04:44:48,670
So we have to make sure
we're using that new array.

6443
04:44:48,670 --> 04:44:52,710
And so of course we could
do updated users.foreach

6444
04:44:52,710 --> 04:44:54,030
and it's a print line.

6445
04:44:55,459 --> 04:44:58,239
And then what we could do
inside of here is just say IT.

6446
04:44:58,239 --> 04:45:00,330
And now actually see if we run this again,

6447
04:45:00,330 --> 04:45:04,040
we'll see additional
person down here, Jon Doe

6448
04:45:04,040 --> 04:45:06,522
has now been added to the second array,

6449
04:45:06,522 --> 04:45:07,920
which is these three down at the bottom.

6450
04:45:07,920 --> 04:45:09,840
There's other things you can also do

6451
04:45:09,840 --> 04:45:11,370
with those user objects.

6452
04:45:11,370 --> 04:45:15,050
So you can actually say users
dot there's a little extension

6453
04:45:15,050 --> 04:45:16,479
function on here.

6454
04:45:16,479 --> 04:45:19,540
So you say reverse, this will
give you the reverse array.

6455
04:45:19,540 --> 04:45:23,325
There's a whole bunch of other
collection classes you can do

6456
04:45:23,325 --> 04:45:26,610
and which we'll talk about in
the future here and so forth,

6457
04:45:26,610 --> 04:45:28,150
but you can also get the size.

6458
04:45:28,150 --> 04:45:29,850
You can get a particular value added.

6459
04:45:29,850 --> 04:45:34,850
So if I wanna get the
value at item number zero,

6460
04:45:35,380 --> 04:45:40,250
the location, and I can say
print ln and I can say item,

6461
04:45:40,250 --> 04:45:42,810
that's going to be at that point item zero

6462
04:45:42,810 --> 04:45:44,850
is going to be Donn Felker.

6463
04:45:44,850 --> 04:45:46,500
And then if we run it, you'll see

6464
04:45:46,500 --> 04:45:47,990
that it's just Donn Felker's printed down

6465
04:45:47,990 --> 04:45:49,260
here at the bottom.

6466
04:45:49,260 --> 04:45:50,810
Now you'll see that we
have a squiggly here

6467
04:45:50,810 --> 04:45:53,280
because we can actually
use the indexing operator.

6468
04:45:53,280 --> 04:45:54,820
So we'll place that and
then we can actually do

6469
04:45:54,820 --> 04:45:57,960
the same thing here that
does the same exact method.

6470
04:45:57,960 --> 04:45:59,110
We can set a value.

6471
04:45:59,110 --> 04:46:02,269
So if I wanna set the index of zero

6472
04:46:02,269 --> 04:46:05,480
to be a different user,
so I guess a foo bar.

6473
04:46:06,770 --> 04:46:10,330
And then if I were to
go ahead and get that,

6474
04:46:10,330 --> 04:46:12,530
and if we look at the
implementation of set,

6475
04:46:13,610 --> 04:46:15,070
you'll see it's just gonna return a unit.

6476
04:46:15,070 --> 04:46:16,890
So we don't wanna do
anything with this anymore.

6477
04:46:16,890 --> 04:46:18,990
So now at this point,
we'd want to actually

6478
04:46:18,990 --> 04:46:20,100
get the value again.

6479
04:46:20,100 --> 04:46:25,100
So we'd say val item equals
users dot and we'll just use

6480
04:46:25,100 --> 04:46:27,150
the indexing operator instead of the get.

6481
04:46:28,399 --> 04:46:30,950
If we were to run this,
we'll see here that the item

6482
04:46:30,950 --> 04:46:33,620
that's printed on the bottom is foo bar

6483
04:46:33,620 --> 04:46:35,940
because the first item
in the array was updated.

6484
04:46:35,940 --> 04:46:37,350
Now, again, we see a squiggly here.

6485
04:46:37,350 --> 04:46:40,300
We can update this with an
indexing operator again.

6486
04:46:40,300 --> 04:46:41,450
So we're gonna say, hey the first user

6487
04:46:41,450 --> 04:46:44,680
is actually gonna be equal to
this, go get that first user

6488
04:46:44,680 --> 04:46:46,350
and print it at that point in time.

6489
04:46:46,350 --> 04:46:48,890
So there's all different
kinds of stuff that you can do

6490
04:46:48,890 --> 04:46:50,630
with arrays.

6491
04:46:50,630 --> 04:46:53,240
You can add things, you can
copies, you can reverse them,

6492
04:46:53,240 --> 04:46:55,100
reverse them, slice them.

6493
04:46:55,100 --> 04:46:57,420
There's a tremendous amount of
things you can do with this,

6494
04:46:57,420 --> 04:47:00,410
these collections, such as the
other collections in Kotlin,

6495
04:47:00,410 --> 04:47:01,880
which we will cover.

6496
04:47:01,880 --> 04:47:03,570
And that's how you can work with arrays

6497
04:47:03,570 --> 04:47:05,360
and build them quickly in Kotlin.

6498
04:47:07,270 --> 04:47:10,800
To create a list inside
of Kotlin is pretty easy.

6499
04:47:10,800 --> 04:47:13,520
You can just say let's
create a variable here

6500
04:47:13,520 --> 04:47:16,863
and we can say val item equals list of,

6501
04:47:16,863 --> 04:47:18,980
and then you can provide a list of,

6502
04:47:18,980 --> 04:47:21,202
perhaps a list of primitives
like we have here.

6503
04:47:21,202 --> 04:47:22,120
So we have a list of integers.

6504
04:47:22,120 --> 04:47:24,850
This is very similar to how it's done

6505
04:47:24,850 --> 04:47:28,750
with the array of operator for arrays.

6506
04:47:28,750 --> 04:47:31,620
So if we want to loop
over each one of these

6507
04:47:31,620 --> 04:47:33,830
and print them out to the screen,

6508
04:47:33,830 --> 04:47:38,400
we could say something like
this, say items foreach.

6509
04:47:38,400 --> 04:47:42,420
And then once we compile
this and print it and run it,

6510
04:47:42,420 --> 04:47:44,849
it will then print to the screen

6511
04:47:44,849 --> 04:47:46,350
as we see in the output down here,

6512
04:47:46,350 --> 04:47:48,550
one, two, three, four, and five.

6513
04:47:48,550 --> 04:47:50,480
So we have a list here.

6514
04:47:50,480 --> 04:47:52,450
Now, this is important to note here

6515
04:47:52,450 --> 04:47:56,320
that this is actually an immutable list.

6516
04:47:56,320 --> 04:47:59,930
So if you notice here, I don't
have the add method here.

6517
04:47:59,930 --> 04:48:02,980
I can't add an item to the list at all.

6518
04:48:02,980 --> 04:48:07,370
So if we look at the
implementation of list of,

6519
04:48:07,370 --> 04:48:08,760
we'll see the here, this is gonna return

6520
04:48:08,760 --> 04:48:10,440
a new read only list.

6521
04:48:11,771 --> 04:48:14,180
So that means that we
can not add items to it.

6522
04:48:14,180 --> 04:48:16,860
The same thing goes for, if
you were to create a list

6523
04:48:16,860 --> 04:48:19,110
of perhaps a list of users.

6524
04:48:19,110 --> 04:48:21,781
Let's say list of, and
then we can actually create

6525
04:48:21,781 --> 04:48:22,614
a list of users.

6526
04:48:22,614 --> 04:48:25,880
So I'm just gonna do a new
line here, say Donn Felker,

6527
04:48:27,440 --> 04:48:29,140
and then we can have
another one would say,

6528
04:48:29,140 --> 04:48:33,130
user would be perhaps Jane
Doe and then so forth.

6529
04:48:33,130 --> 04:48:34,930
We could have a number
of them and so forth.

6530
04:48:35,821 --> 04:48:39,290
And of course we could also
iterate over these as well,

6531
04:48:39,290 --> 04:48:40,123
pretty easily.

6532
04:48:40,123 --> 04:48:43,730
So it would say users dot
foreach and inside of this,

6533
04:48:43,730 --> 04:48:45,810
we'd say print line and
inside the print line,

6534
04:48:45,810 --> 04:48:48,070
we could just say, if
we could print the user.

6535
04:48:48,070 --> 04:48:50,100
And that's gonna call the two
string method on the user,

6536
04:48:50,100 --> 04:48:52,670
just like it did when we
did the array version.

6537
04:48:52,670 --> 04:48:55,560
So we'd see a Jane Doe and Jon Doe,

6538
04:48:55,560 --> 04:48:57,810
and actually did print
here and do print line

6539
04:48:58,953 --> 04:48:59,786
to it all put it on the same line.

6540
04:48:59,786 --> 04:49:02,270
Print line will add each
item onto a new line

6541
04:49:02,270 --> 04:49:03,350
as we see here.

6542
04:49:04,983 --> 04:49:06,630
So again, these are immutable lists.

6543
04:49:06,630 --> 04:49:09,040
If we want to add an item to a list,

6544
04:49:09,040 --> 04:49:10,510
we're not gonna be able to do that.

6545
04:49:10,510 --> 04:49:12,690
So we're have to create a mutable list,

6546
04:49:12,690 --> 04:49:14,800
which will be in the next lesson.

6547
04:49:14,800 --> 04:49:18,590
So here we can also get access to items.

6548
04:49:18,590 --> 04:49:20,390
So maybe we wanna do the first item.

6549
04:49:21,532 --> 04:49:25,120
We could say users dot
first, and it's gonna give us

6550
04:49:25,120 --> 04:49:25,953
the first item.

6551
04:49:25,953 --> 04:49:27,030
And notice the first method.

6552
04:49:27,030 --> 04:49:31,500
This is an extension method
on top of a generic list.

6553
04:49:31,500 --> 04:49:34,140
So we have a first item.

6554
04:49:34,140 --> 04:49:38,060
So if for some reason there was a default,

6555
04:49:38,060 --> 04:49:41,120
if we were to print this here,
let's actually do print line,

6556
04:49:41,120 --> 04:49:43,250
just to show you what this looks like.

6557
04:49:43,250 --> 04:49:46,300
We should see Donn Felker again, printed,

6558
04:49:46,300 --> 04:49:47,630
and they're ready to go.

6559
04:49:47,630 --> 04:49:51,840
Now there's also the opportunity
here for us to perhaps

6560
04:49:51,840 --> 04:49:54,490
we need to create a empty
list for whatever reason,

6561
04:49:54,490 --> 04:49:56,870
maybe we have a null value
or something like that.

6562
04:49:56,870 --> 04:49:59,690
So let's say that we have a name.

6563
04:49:59,690 --> 04:50:03,940
So let's say val name
could be a nullable string

6564
04:50:03,940 --> 04:50:05,610
equals whatever.

6565
04:50:05,610 --> 04:50:08,180
And for whatever reason, the code is null.

6566
04:50:08,180 --> 04:50:11,790
And then we wanna create a
new list and we can say stuff.

6567
04:50:11,790 --> 04:50:13,390
We could say, it's going to be.

6568
04:50:18,217 --> 04:50:19,120
If the name is a null.

6569
04:50:22,360 --> 04:50:24,260
So if we wanna do something like this,

6570
04:50:25,370 --> 04:50:27,440
we put it around the if statement.

6571
04:50:27,440 --> 04:50:31,770
if the name is null, then
we could return empty list.

6572
04:50:31,770 --> 04:50:34,650
And that would just
return us an empty list.

6573
04:50:34,650 --> 04:50:39,620
Otherwise we can then
return a list of name.

6574
04:50:41,384 --> 04:50:43,479
And what that's gonna do is
automatically the compiler

6575
04:50:43,479 --> 04:50:46,450
is going to infer, Oh, since
Donn is doing a list of names,

6576
04:50:46,450 --> 04:50:48,050
it's gonna be a list of strings,

6577
04:50:49,860 --> 04:50:50,693
otherwise this is gonna be
an empty list of strings.

6578
04:50:50,693 --> 04:50:53,220
Now notice here, I was
getting a compiler error

6579
04:50:53,220 --> 04:50:56,060
'cause it doesn't know
enough about the type here.

6580
04:50:56,060 --> 04:50:59,550
So if I wanted to specify
the type for empty list,

6581
04:50:59,550 --> 04:51:01,530
I should say string their work.

6582
04:51:02,460 --> 04:51:04,520
And we could say list of name.

6583
04:51:05,510 --> 04:51:07,220
Now, at this point in time, you can see

6584
04:51:07,220 --> 04:51:08,760
that this is grayed out
because the compiler

6585
04:51:08,760 --> 04:51:10,090
can infer the type.

6586
04:51:10,090 --> 04:51:13,470
So I can go ahead and remove
that explicit type argument.

6587
04:51:13,470 --> 04:51:15,670
Now empty list, all it
is again is just some,

6588
04:51:15,670 --> 04:51:18,590
it's just a function just
gives us an implementation

6589
04:51:18,590 --> 04:51:20,240
of what's known as an empty list.

6590
04:51:21,204 --> 04:51:22,150
It doesn't have anything in it.

6591
04:51:22,150 --> 04:51:23,520
There's basically the size.

6592
04:51:23,520 --> 04:51:25,810
If you look at it, the size is zero.

6593
04:51:25,810 --> 04:51:28,560
It is empty, is hard-coded to true.

6594
04:51:28,560 --> 04:51:31,200
So this is just kind of
a general helper method

6595
04:51:31,200 --> 04:51:33,480
inside of our application.

6596
04:51:33,480 --> 04:51:36,960
So if we were to see if this was empty,

6597
04:51:36,960 --> 04:51:39,930
we could actually say stuff.is empty,

6598
04:51:39,930 --> 04:51:40,763
that would return true.

6599
04:51:40,763 --> 04:51:44,040
We'll see a bunch of different
other methods on here as well

6600
04:51:44,040 --> 04:51:45,900
we can see for lifts is empty.

6601
04:51:45,900 --> 04:51:47,510
Again, we can't add anything to it

6602
04:51:47,510 --> 04:51:49,926
because it's an immutable list.

6603
04:51:49,926 --> 04:51:52,590
So that's one way we can
work with an empty list.

6604
04:51:52,590 --> 04:51:55,520
Now we can also grab
the last item of a list.

6605
04:51:56,473 --> 04:51:57,380
So we could say users.last,

6606
04:51:58,868 --> 04:52:01,600
and that will give us the
last item of the list.

6607
04:52:01,600 --> 04:52:04,140
At that point in time, we can
also print that to the screen,

6608
04:52:04,140 --> 04:52:06,810
which is gonna go ahead and show Jane Doe

6609
04:52:06,810 --> 04:52:07,910
at that point in time.

6610
04:52:09,530 --> 04:52:10,840
And then we've got Jane Doe.

6611
04:52:10,840 --> 04:52:14,530
So there's a bunch of
different operators on the list

6612
04:52:14,530 --> 04:52:15,932
you can look at it.

6613
04:52:15,932 --> 04:52:18,480
So you can just say users
and you can use IntelliSense

6614
04:52:18,480 --> 04:52:21,280
to in code completion to check it out.

6615
04:52:21,280 --> 04:52:23,780
You can do last, you can
do last of the prodicate,

6616
04:52:23,780 --> 04:52:24,860
all different types of stuff,

6617
04:52:24,860 --> 04:52:27,390
which we will cover in the future.

6618
04:52:27,390 --> 04:52:29,810
And you can also get the
first value or of null

6619
04:52:29,810 --> 04:52:32,200
if it's nothing's there,
so we'll see here,

6620
04:52:32,200 --> 04:52:35,580
returns the first element or
null if the list is empty.

6621
04:52:35,580 --> 04:52:38,230
So there's a bunch of different things

6622
04:52:38,230 --> 04:52:39,290
that you can check for there as well.

6623
04:52:40,426 --> 04:52:42,220
And that's how you easily can
create a list inside of Kotlin

6624
04:52:42,220 --> 04:52:45,350
with either primitives or you
can create it with objects.

6625
04:52:46,790 --> 04:52:49,220
In another lesson I
showed you how to create

6626
04:52:49,220 --> 04:52:53,650
a immutable list using the list of method.

6627
04:52:53,650 --> 04:52:56,620
The list of method allows
you to create a list

6628
04:52:56,620 --> 04:53:00,700
of some primitives or objects or anything

6629
04:53:00,700 --> 04:53:03,690
of that you desire.

6630
04:53:06,140 --> 04:53:07,940
If you'd like to create a
list in which you can change,

6631
04:53:07,940 --> 04:53:10,090
because let's take a look at this items,

6632
04:53:10,090 --> 04:53:11,320
does not have an add must.

6633
04:53:11,320 --> 04:53:14,900
We can't add or change
or remove or do anything

6634
04:53:14,900 --> 04:53:16,610
of that nature with an immutable list.

6635
04:53:16,610 --> 04:53:19,910
It's just there, it can't be changed.

6636
04:53:19,910 --> 04:53:24,110
If we need to create a
mutable list we can do so

6637
04:53:24,110 --> 04:53:27,120
with the mutable list of,

6638
04:53:29,190 --> 04:53:32,040
and we use mutable list
of, we can provide a type

6639
04:53:32,040 --> 04:53:33,860
if we'd like to such as we can do

6640
04:53:33,860 --> 04:53:36,840
with the list of operators. So
if I know it's gonna be int,

6641
04:53:36,840 --> 04:53:40,070
that I can do that,
and I can say one, two,

6642
04:53:40,070 --> 04:53:41,200
three, four, five.

6643
04:53:43,257 --> 04:53:44,980
But then what will happen is
type inference will kick in

6644
04:53:44,980 --> 04:53:47,980
and the IntelliJ IDE
would let us know saying,

6645
04:53:47,980 --> 04:53:50,620
hey, we don't really need
that explicit type argument,

6646
04:53:50,620 --> 04:53:51,650
so let's go ahead and remove it.

6647
04:53:51,650 --> 04:53:54,700
So at this point in time,
based upon the parameters

6648
04:53:54,700 --> 04:53:59,280
of the mutable list
method, Kotlin can infer

6649
04:53:59,280 --> 04:54:01,100
the types for this list.

6650
04:54:02,067 --> 04:54:03,160
So now I have a mutable list of items.

6651
04:54:03,160 --> 04:54:05,890
Now this work the same
way if I have a list here.

6652
04:54:05,890 --> 04:54:09,210
So if we just do list and we leave that,

6653
04:54:09,210 --> 04:54:10,740
we'll notice that both of these things

6654
04:54:10,740 --> 04:54:13,350
are going to compile just
fine and do the same thing.

6655
04:54:13,350 --> 04:54:16,060
We have the same method for
each, we can print those.

6656
04:54:16,060 --> 04:54:19,160
The differences here though is
that we can add an item here,

6657
04:54:19,160 --> 04:54:21,250
so I can add the number six now.

6658
04:54:21,250 --> 04:54:24,030
And then if I copy this
and I kind of reiterate

6659
04:54:24,030 --> 04:54:27,140
over this again, we'll see
that I have six in here.

6660
04:54:27,140 --> 04:54:30,080
So let's go ahead and print
a line here so we can see

6661
04:54:30,080 --> 04:54:33,890
that there's something
different and let's run this.

6662
04:54:33,890 --> 04:54:36,260
And what we'll see
here, we print one, two,

6663
04:54:36,260 --> 04:54:39,800
three, four, five, and then
we're gonna add an item here

6664
04:54:39,800 --> 04:54:42,485
on number six, and then
I'm gonna run it again

6665
04:54:42,485 --> 04:54:44,260
and say one, two, three, four, five, six.

6666
04:54:44,260 --> 04:54:45,730
So we can also do something else

6667
04:54:45,730 --> 04:54:48,050
and say, we can say items.remove,

6668
04:54:49,040 --> 04:54:50,870
and we could say a whole
bunch of things here.

6669
04:54:50,870 --> 04:54:53,340
We can remove if we meet
a particular condition,

6670
04:54:53,340 --> 04:54:54,830
we could remove all the items.

6671
04:54:54,830 --> 04:54:56,820
We could remove a particular item.

6672
04:54:56,820 --> 04:54:59,810
So I could remove element number zero,

6673
04:54:59,810 --> 04:55:01,900
and we can print this off again.

6674
04:55:01,900 --> 04:55:04,260
So what would happen here
if we were to run this.

6675
04:55:04,260 --> 04:55:08,320
So now we have a list
where we have to make this

6676
04:55:08,320 --> 04:55:10,920
a little more clear, let's
add this in here as well,

6677
04:55:11,870 --> 04:55:13,020
and we'll run it again.

6678
04:55:14,207 --> 04:55:16,550
And we'll see here that we
have now one, two, three,

6679
04:55:16,550 --> 04:55:19,090
four, five, one, two,
three, four, five, six,

6680
04:55:19,090 --> 04:55:20,290
one, two, three, four, five, six.

6681
04:55:20,290 --> 04:55:23,110
So, why didn't we get
anything out of here,

6682
04:55:23,110 --> 04:55:27,140
because we're asking it to
remove a particular item.

6683
04:55:27,140 --> 04:55:30,610
Now it's not finding
the item zero in there,

6684
04:55:30,610 --> 04:55:33,750
so let's tell it to remove number three.

6685
04:55:33,750 --> 04:55:35,160
So let's run that again.

6686
04:55:35,160 --> 04:55:37,330
And then what we will see
down here in the bottom window

6687
04:55:37,330 --> 04:55:40,570
is it was actually
found item number three.

6688
04:55:40,570 --> 04:55:43,492
So it didn't find one, two or three.

6689
04:55:43,492 --> 04:55:45,060
It wasn't the index base,
it was actually the item

6690
04:55:45,060 --> 04:55:46,660
in the list that it was removed.

6691
04:55:47,938 --> 04:55:50,690
So that was able to be
removed out of there.

6692
04:55:50,690 --> 04:55:53,399
Now there's a whole
bunch of other things now

6693
04:55:53,399 --> 04:55:55,360
we can replace items inside of here.

6694
04:55:55,360 --> 04:55:58,110
We're gonna replace all, we
can add a whole bunch of them.

6695
04:55:58,110 --> 04:56:00,799
So if we take a look at the
implementation of add all,

6696
04:56:00,799 --> 04:56:04,190
we can take in our collection
and add another one

6697
04:56:04,190 --> 04:56:06,790
inside of here so we can
add a whole bunch of them.

6698
04:56:06,790 --> 04:56:08,930
So if I had another list,
we can add that list to it.

6699
04:56:08,930 --> 04:56:11,742
We can remove something out of position.

6700
04:56:11,742 --> 04:56:14,040
So let's say we wanna remove
this add position zero,

6701
04:56:14,040 --> 04:56:16,140
let's run this and see what happens.

6702
04:56:16,140 --> 04:56:17,810
Now, notice how this has index.

6703
04:56:18,700 --> 04:56:20,900
So now we have two,
three, four, five, six.

6704
04:56:22,208 --> 04:56:24,060
I'm just gonna delete this
stuff here, just for brevity.

6705
04:56:26,344 --> 04:56:28,475
And we'll run this
again, and we'll see that

6706
04:56:28,475 --> 04:56:30,930
we have two, three, four, five is printed.

6707
04:56:30,930 --> 04:56:33,320
Now, if I were to change
changes to remove,

6708
04:56:33,320 --> 04:56:35,140
just to reiterate here, and we could say,

6709
04:56:35,140 --> 04:56:36,860
I wanna remove a particular element.

6710
04:56:36,860 --> 04:56:39,980
I wanna remove element,
that is the value of three.

6711
04:56:39,980 --> 04:56:43,390
Now we're gonna see one,
four, five is the output

6712
04:56:43,390 --> 04:56:44,223
down here in the bottom.

6713
04:56:44,223 --> 04:56:46,220
So remove at removes it with an index.

6714
04:56:46,220 --> 04:56:48,870
So instead of the index of the list,

6715
04:56:48,870 --> 04:56:50,890
we can find something to remove.

6716
04:56:50,890 --> 04:56:55,424
However, if we wanna move an
actual item given its value,

6717
04:56:55,424 --> 04:56:56,257
we would say remove element.

6718
04:56:56,257 --> 04:57:00,700
Now we can also say we can do
something with a mutable list

6719
04:57:00,700 --> 04:57:01,700
of objects as well.

6720
04:57:01,700 --> 04:57:04,150
So we're gonna say user Donn Felker,

6721
04:57:04,150 --> 04:57:05,890
which is something we have done before

6722
04:57:05,890 --> 04:57:07,340
with the other types of lists

6723
04:57:08,593 --> 04:57:11,000
and we always have a user called Jane Doe.

6724
04:57:11,000 --> 04:57:12,370
So now we have two things in here.

6725
04:57:12,370 --> 04:57:15,720
And if we try to remove
here and we use the,

6726
04:57:15,720 --> 04:57:19,700
I'm using an index here,
because it's the number three,

6727
04:57:19,700 --> 04:57:23,260
even though it's saying,
hey, you're wanting to remove

6728
04:57:23,260 --> 04:57:26,620
something here, removing int is narrow.

6729
04:57:26,620 --> 04:57:29,400
You remove at index
instead because it realizes

6730
04:57:29,400 --> 04:57:31,800
the compiler that I'm
trying to use a number here.

6731
04:57:31,800 --> 04:57:33,160
So it's trying to help me out saying,

6732
04:57:33,160 --> 04:57:36,940
hey, you sure you don't want
to remove a particular index.

6733
04:57:36,940 --> 04:57:39,160
Now what I could do, let me just go ahead

6734
04:57:40,069 --> 04:57:41,720
and comment this out for a second.

6735
04:57:41,720 --> 04:57:44,130
Inside of here is once we let me run this,

6736
04:57:44,130 --> 04:57:45,210
so I'll show you what this looks like.

6737
04:57:45,210 --> 04:57:48,860
We're gonna get basically
two users printed.

6738
04:57:49,740 --> 04:57:52,420
If I wanted to pull this
out into its own variable,

6739
04:57:54,096 --> 04:57:56,217
I could do that and say,
pull it into a variable.

6740
04:57:56,217 --> 04:57:57,230
And I could say, Don.

6741
04:57:57,230 --> 04:57:59,910
Now what I could do inside
of here is I could say,

6742
04:57:59,910 --> 04:58:02,520
remove Donn from the list.

6743
04:58:02,520 --> 04:58:04,670
Now let's print this list
and see what happens.

6744
04:58:04,670 --> 04:58:06,660
What do you think was
gonna see here where see,

6745
04:58:06,660 --> 04:58:08,860
we just have one item in the
list because what happens

6746
04:58:08,860 --> 04:58:10,800
is we have these items.

6747
04:58:10,800 --> 04:58:13,590
So let's actually do two things here.

6748
04:58:13,590 --> 04:58:16,310
Let's do this or print each one of there.

6749
04:58:16,310 --> 04:58:20,160
And then inside of here,
I'm gonna do a print line

6750
04:58:20,160 --> 04:58:22,970
and we'll just print out
a little break there.

6751
04:58:22,970 --> 04:58:26,200
And we're gonna see as both
items are printed first,

6752
04:58:26,200 --> 04:58:27,100
which we see here.

6753
04:58:28,079 --> 04:58:30,654
And then we print this
nice little line break.

6754
04:58:30,654 --> 04:58:32,240
And then we say, hey, I want
to remove Donn from the list.

6755
04:58:32,240 --> 04:58:34,550
Now, remember remove, remove the element,

6756
04:58:34,550 --> 04:58:37,210
it's gonna tell the element
that we'd like to remove.

6757
04:58:37,210 --> 04:58:40,070
Remove at is gonna tell us
we want to remove an index.

6758
04:58:40,070 --> 04:58:42,020
So I can say, hey, if I move index one,

6759
04:58:43,655 --> 04:58:44,488
it's gonna remove Jane Doe.

6760
04:58:44,488 --> 04:58:46,870
Now, if I run this here,
we're gonna see Donn Felker

6761
04:58:46,870 --> 04:58:48,780
and Jane Doe and then we're
going to remove Jane Doe

6762
04:58:48,780 --> 04:58:50,580
and it's just gonna say Donn Felker.

6763
04:58:51,572 --> 04:58:53,210
Now there's a whole bunch
again, this is a mutable list,

6764
04:58:53,210 --> 04:58:56,740
so I can continue to add and
remove items accordingly.

6765
04:58:56,740 --> 04:58:59,010
And the differences it's
beautiful exchanging

6766
04:58:59,010 --> 04:59:00,640
the other one is immutable.

6767
04:59:00,640 --> 04:59:02,660
So if we want to do different
types of things with it,

6768
04:59:02,660 --> 04:59:05,246
you can inspect the various
different operations

6769
04:59:05,246 --> 04:59:07,650
using the code completion here.

6770
04:59:07,650 --> 04:59:10,530
We can remove it out, we
replaced things we can set

6771
04:59:10,530 --> 04:59:13,720
certain values of I would
like to set the first value

6772
04:59:13,720 --> 04:59:14,950
to equal a different user.

6773
04:59:14,950 --> 04:59:19,110
I could say different user
is now going to be Jon Doe

6774
04:59:19,110 --> 04:59:20,820
for whatever reason.

6775
04:59:20,820 --> 04:59:25,820
So let's go ahead and change
that and get this down here.

6776
04:59:26,760 --> 04:59:28,570
Now, what we're gonna
see at this point in time

6777
04:59:28,570 --> 04:59:30,950
is I want to set item one to Jon Doe.

6778
04:59:30,950 --> 04:59:33,468
So the first time through,

6779
04:59:33,468 --> 04:59:34,520
we're gonna see Donn Felker printed,

6780
04:59:34,520 --> 04:59:36,690
and then the next time
through, we're gonna change

6781
04:59:36,690 --> 04:59:40,800
the first, the item index one to Jon Doe.

6782
04:59:40,800 --> 04:59:43,260
So we'll see Donn Felker, Jane Doe.

6783
04:59:43,260 --> 04:59:46,290
We change it and it's
Donn Felker, Jon Doe.

6784
04:59:46,290 --> 04:59:48,640
Now knows we have a little
bit of squiggly here,

6785
04:59:48,640 --> 04:59:49,473
alt enter.

6786
04:59:49,473 --> 04:59:51,150
We'll say we can replace the set call

6787
04:59:51,150 --> 04:59:52,805
with an indexing operator.

6788
04:59:52,805 --> 04:59:55,470
So using the indexing
operator, we can say,

6789
04:59:55,470 --> 04:59:57,360
actually take the first item in the index

6790
04:59:57,360 --> 04:59:58,820
and replace it with this one.

6791
04:59:58,820 --> 05:00:02,190
So it's the same exact code
this does the exact same thing

6792
05:00:02,190 --> 05:00:03,060
as this.

6793
05:00:04,832 --> 05:00:08,060
Now we can also access these
items via the index as well.

6794
05:00:08,060 --> 05:00:12,050
So I might say print, say print line,

6795
05:00:12,050 --> 05:00:14,610
and I wanna do items zero.

6796
05:00:15,634 --> 05:00:16,467
And that's gonna print the first time.

6797
05:00:16,467 --> 05:00:20,380
Now it's gonna be the same
exact thing as if I were to do

6798
05:00:20,380 --> 05:00:25,050
a items.get, and I
could provide the index.

6799
05:00:25,050 --> 05:00:27,070
Now notice again, we're
gonna get the squiggly

6800
05:00:28,152 --> 05:00:30,330
and what IntelliJ is telling us here is,

6801
05:00:30,330 --> 05:00:33,740
hey, we can actually use
the indexing operator.

6802
05:00:33,740 --> 05:00:35,110
So go ahead and do that.

6803
05:00:35,110 --> 05:00:38,020
Now, that's how you create
a very simple mutable list

6804
05:00:38,020 --> 05:00:38,853
inside of Kotlin.

6805
05:00:38,853 --> 05:00:40,950
You can create a mutable
list of primitives,

6806
05:00:40,950 --> 05:00:42,760
could be strings or intergers,

6807
05:00:43,700 --> 05:00:45,900
or could even be something
like an object itself.

6808
05:00:47,070 --> 05:00:49,360
All right, I'm gonna
show you how to filter

6809
05:00:49,360 --> 05:00:51,990
a list of primitive values here.

6810
05:00:51,990 --> 05:00:54,110
I am filtering a list of strings.

6811
05:00:54,110 --> 05:00:57,540
This could be integers
doubles, longs, Boolean values,

6812
05:00:57,540 --> 05:00:58,790
anything of that nature,

6813
05:00:58,790 --> 05:01:01,110
but I've created a list using the list of,

6814
05:01:01,110 --> 05:01:04,210
so this is an immutable
list, a list of names.

6815
05:01:04,210 --> 05:01:07,011
That's why we have Don, Bob, Jane, Jenny,

6816
05:01:07,011 --> 05:01:07,900
Tushar, and Cavita,

6817
05:01:07,900 --> 05:01:10,340
let's assume that we
wanted to filter this list.

6818
05:01:10,340 --> 05:01:13,570
And we only wanted to include,
we wanna include everybody

6819
05:01:13,570 --> 05:01:14,700
but Donn this time.

6820
05:01:14,700 --> 05:01:18,420
And so we would say name.filter,
and then we can parse in

6821
05:01:18,420 --> 05:01:19,600
basically a lambda expression.

6822
05:01:19,600 --> 05:01:20,840
So there's a couple of things we could do,

6823
05:01:20,840 --> 05:01:22,850
we could do open closed parentheses,

6824
05:01:22,850 --> 05:01:25,320
and we need some type of predicate.

6825
05:01:25,320 --> 05:01:27,050
If we look at the implementation of this

6826
05:01:27,050 --> 05:01:30,500
inside of the Kotlin
collection standard library,

6827
05:01:30,500 --> 05:01:33,160
we'll see that we had the filter method

6828
05:01:33,160 --> 05:01:34,510
and we needed a predicate.

6829
05:01:34,510 --> 05:01:37,900
And this predicate is
requiring a lambda expression.

6830
05:01:37,900 --> 05:01:39,890
That's going to return a Boolean value,

6831
05:01:39,890 --> 05:01:43,160
basically return the list
containing only the elements

6832
05:01:43,160 --> 05:01:44,240
matching the predicate.

6833
05:01:44,240 --> 05:01:47,960
So if it's true, it will
be included in the list.

6834
05:01:47,960 --> 05:01:49,120
If it's false, it will not.

6835
05:01:49,120 --> 05:01:50,320
So what does that mean?

6836
05:01:50,320 --> 05:01:52,030
Anything inside this filter we parse in

6837
05:01:52,030 --> 05:01:54,930
which I'm gonna use the
lambda expression version.

6838
05:01:54,930 --> 05:01:57,380
If this equates to true
what happens inside of here,

6839
05:01:57,380 --> 05:01:58,540
it will be included.

6840
05:01:58,540 --> 05:02:03,540
So it's pretty easy using the
default iterator value of it.

6841
05:02:04,000 --> 05:02:09,000
I say it does not equal
Donn it'll be included.

6842
05:02:09,240 --> 05:02:12,620
So what this means is I want
to look through all the names

6843
05:02:12,620 --> 05:02:14,890
and filter it and check to
see if it doesn't equal Don,

6844
05:02:14,890 --> 05:02:16,520
if it doesn't equal Donn then include it.

6845
05:02:16,520 --> 05:02:18,980
So how can we tell if that worked,

6846
05:02:18,980 --> 05:02:21,960
let's print this to the
screen and we'll say filtered,

6847
05:02:22,880 --> 05:02:25,780
and once we run it, you're
gonna see that down here

6848
05:02:25,780 --> 05:02:28,210
in the output window,
we'll see Bob Jane, Jenny

6849
05:02:28,210 --> 05:02:29,090
Tushar and Cavita.

6850
05:02:29,090 --> 05:02:30,540
So Donn was not included.

6851
05:02:32,173 --> 05:02:33,340
Now we could also flip
that around and say,

6852
05:02:33,340 --> 05:02:38,340
we also only want to include
the names if it includes Don.

6853
05:02:39,550 --> 05:02:40,520
So let's do that.

6854
05:02:40,520 --> 05:02:42,220
Say filtered it does equal Don.

6855
05:02:43,313 --> 05:02:44,910
So here we're gonna get
back in array with one value

6856
05:02:44,910 --> 05:02:48,673
in it which is gonna equal
Don, which makes sense.

6857
05:02:48,673 --> 05:02:49,750
Makes sense, it's good enough.

6858
05:02:49,750 --> 05:02:53,400
But sometimes, maybe
inside of your application,

6859
05:02:53,400 --> 05:02:55,300
again, this is a predicate,
a whole number of things

6860
05:02:55,300 --> 05:02:56,536
could happen.

6861
05:02:56,536 --> 05:02:58,580
This could be a bunch of
code that's doing something

6862
05:02:58,580 --> 05:02:59,413
inside of here.

6863
05:03:00,320 --> 05:03:02,740
But let's assume that you
wanna check to see if anyone

6864
05:03:02,740 --> 05:03:05,521
has a letter A and I
only wanna see if someone

6865
05:03:05,521 --> 05:03:06,354
has a letter A.

6866
05:03:06,354 --> 05:03:09,020
So what we might do is
say it.two lowercase

6867
05:03:09,020 --> 05:03:13,510
because I wanna check for
lower upper case.contains

6868
05:03:14,460 --> 05:03:17,500
a character and I wanna see
if it contains the letter A.

6869
05:03:17,500 --> 05:03:19,650
If it contains a letter
A, I want it to go ahead

6870
05:03:19,650 --> 05:03:22,320
and return it, so let's
see what happens here.

6871
05:03:22,320 --> 05:03:24,960
If we run this, we'll
see we get returned Jane,

6872
05:03:24,960 --> 05:03:26,010
Tushar and Kavita.

6873
05:03:26,010 --> 05:03:28,320
That's right, 'cause Don, Bob and Jenny

6874
05:03:29,189 --> 05:03:31,600
do not have the letter A inside of there.

6875
05:03:31,600 --> 05:03:33,600
So you can start filtering based upon

6876
05:03:33,600 --> 05:03:34,950
all different types of things.

6877
05:03:34,950 --> 05:03:39,730
And the same thing will work
if you had a list of ages

6878
05:03:39,730 --> 05:03:40,563
such as this.

6879
05:03:55,020 --> 05:03:56,390
And then you wanted to
actually filter them.

6880
05:03:56,390 --> 05:04:01,390
So you'd say val, over
18, or you say adults,

6881
05:04:01,940 --> 05:04:06,590
which can be over 18,
and you'd say ages.filter

6882
05:04:08,152 --> 05:04:10,430
it.greater than or equal to 18,

6883
05:04:12,560 --> 05:04:14,990
print line that, and we
could see the adults.

6884
05:04:16,270 --> 05:04:18,610
And if we run this, we'll see that we have

6885
05:04:19,620 --> 05:04:24,190
23, 33, 19 and 99, which is
true because if you're 12

6886
05:04:24,190 --> 05:04:26,920
or year nine or 17, you are not an adult.

6887
05:04:26,920 --> 05:04:28,590
One additional thing
you could do is actually

6888
05:04:28,590 --> 05:04:31,000
create a function called is adult.

6889
05:04:31,000 --> 05:04:33,480
And perhaps this function
has a whole bunch of things

6890
05:04:33,480 --> 05:04:34,830
inside of here.

6891
05:04:34,830 --> 05:04:37,770
So we wanna say age,
let's just call it value.

6892
05:04:37,770 --> 05:04:39,030
Let's be int.

6893
05:04:39,030 --> 05:04:41,950
And then inside of here, say if the value,

6894
05:04:42,990 --> 05:04:47,990
so we'll say return value
greater than or equal to 18.

6895
05:04:50,990 --> 05:04:52,750
Again, this is gonna be Boolean.

6896
05:04:53,643 --> 05:04:55,100
So we need to return a value.

6897
05:04:55,100 --> 05:04:57,290
So this function will return
if this person is an adult,

6898
05:04:57,290 --> 05:05:00,597
but now let's assume for whatever reason,

6899
05:05:00,597 --> 05:05:01,430
you have to put a bunch
of if statements in here.

6900
05:05:01,430 --> 05:05:03,380
Maybe in one country and adult is 14

6901
05:05:03,380 --> 05:05:06,920
and the next country it's 21
and the next country it's 18.

6902
05:05:06,920 --> 05:05:09,740
So you might need to
have many different lines

6903
05:05:09,740 --> 05:05:11,210
and logic inside of here,

6904
05:05:12,492 --> 05:05:14,636
but it's gonna return a Boolean value.

6905
05:05:14,636 --> 05:05:17,130
Doing that inside of this
filter is gonna get real messy.

6906
05:05:17,130 --> 05:05:19,100
And so what you can do
is that you actually pars

6907
05:05:19,100 --> 05:05:21,950
a function reference into the filter.

6908
05:05:23,093 --> 05:05:25,250
And you can do this with
a lot of the methods

6909
05:05:25,250 --> 05:05:26,872
inside of Kotlin.

6910
05:05:26,872 --> 05:05:28,394
So here's the age filtering tool,

6911
05:05:28,394 --> 05:05:29,650
it's like colon, colon is adult.

6912
05:05:29,650 --> 05:05:31,920
And what this will do is we'll take this

6913
05:05:32,764 --> 05:05:34,100
as a function reference
and say, as soon as I say,

6914
05:05:34,100 --> 05:05:37,510
age is.filter, it'll
basically parse in the values

6915
05:05:37,510 --> 05:05:40,060
one by one into the is adult function.

6916
05:05:41,008 --> 05:05:41,841
And then we'll run it through everything

6917
05:05:41,841 --> 05:05:43,010
that's inside of here.

6918
05:05:43,010 --> 05:05:46,027
And then whatever the
result is, if it's true,

6919
05:05:46,027 --> 05:05:46,860
it'll be included in the filter.

6920
05:05:46,860 --> 05:05:48,160
Otherwise it will be excluded.

6921
05:05:48,160 --> 05:05:49,990
So if we run this again, we
should get the same result

6922
05:05:49,990 --> 05:05:53,730
as before, so we see 23, 19, 99.

6923
05:05:53,730 --> 05:05:55,680
Now we could change this
and so we could change,

6924
05:05:55,680 --> 05:05:58,580
if we wanna say is adult, we say his child

6925
05:05:59,730 --> 05:06:02,180
and we probably need to
fix the spelling of that.

6926
05:06:06,380 --> 05:06:09,115
And then we can say less than or equal 18.

6927
05:06:09,115 --> 05:06:11,450
And if we rerun this again,
of course this variable name

6928
05:06:11,450 --> 05:06:13,670
is wrong, it's not adult,
that should be children.

6929
05:06:15,290 --> 05:06:16,140
And run it again.

6930
05:06:17,330 --> 05:06:21,730
Well now see 12, nine and 17
for the age of the filter.

6931
05:06:21,730 --> 05:06:26,010
So that's how you can easily
filter a list and array

6932
05:06:26,010 --> 05:06:27,170
and so forth in Kotlin.

6933
05:06:28,880 --> 05:06:30,620
Let's assume you have a list of data

6934
05:06:30,620 --> 05:06:32,720
and you wanna find something
in that list of data.

6935
05:06:32,720 --> 05:06:34,270
This could be primitive as we have here

6936
05:06:34,270 --> 05:06:37,600
such as a list of
strings, or you could have

6937
05:06:37,600 --> 05:06:39,580
a list of objects, anything of that nature

6938
05:06:39,580 --> 05:06:41,050
that you want to filter.

6939
05:06:41,050 --> 05:06:44,040
Not filter, but just find a
particular item in the list,

6940
05:06:44,040 --> 05:06:45,150
how can you go about doing that?

6941
05:06:45,150 --> 05:06:47,712
Well, of course you could use a for-loop.

6942
05:06:47,712 --> 05:06:49,843
However, there's also a built in utilities

6943
05:06:49,843 --> 05:06:50,810
in the Kotlin standard library.

6944
05:06:50,810 --> 05:06:53,700
So Lauren have is I'm gonna
create a result variable.

6945
05:06:53,700 --> 05:06:56,870
And then what I wanna do
is I wanna actually find

6946
05:06:56,870 --> 05:07:00,120
the first instance, excuse me, names.find,

6947
05:07:01,950 --> 05:07:04,110
I wanna find a first instance of Don.

6948
05:07:04,110 --> 05:07:08,490
So let's go ahead and
say it equals equals Don.

6949
05:07:08,490 --> 05:07:10,010
And then I wanna go ahead and print out

6950
05:07:10,010 --> 05:07:10,843
if I actually found it.

6951
05:07:10,843 --> 05:07:13,450
So print ln and a result.

6952
05:07:14,777 --> 05:07:15,700
I we'll go ahead and run that.

6953
05:07:15,700 --> 05:07:18,370
And then what we're gonna
see here is we have Don

6954
05:07:18,370 --> 05:07:19,782
that was returned.

6955
05:07:19,782 --> 05:07:20,910
And that's what we
expect Donn was in there.

6956
05:07:20,910 --> 05:07:23,160
Now however, there is a
kind of a gotcha here.

6957
05:07:23,160 --> 05:07:24,530
So let's just throw something in here

6958
05:07:24,530 --> 05:07:27,490
we know doesn't exist
and let's run it again.

6959
05:07:27,490 --> 05:07:28,370
So I'm gonna use the word foobar.

6960
05:07:28,370 --> 05:07:30,750
Now we have the word foobar,

6961
05:07:30,750 --> 05:07:32,160
of course we're gonna get back null.

6962
05:07:32,160 --> 05:07:36,380
Now we kind of had some help
from Kotlin to find this here.

6963
05:07:36,380 --> 05:07:38,810
So we had find it was
gonna find the first one.

6964
05:07:40,600 --> 05:07:41,470
And if actually look at
this, what it's gonna do

6965
05:07:41,470 --> 05:07:44,696
is it returns the first element
matching the given predicate

6966
05:07:44,696 --> 05:07:46,246
or null if no element is found.

6967
05:07:47,465 --> 05:07:49,310
So fine, kind of helps you,
but now you have to start

6968
05:07:49,310 --> 05:07:51,950
worrying about null values at all times.

6969
05:07:51,950 --> 05:07:54,480
So if you're gonna do
a null value, you say,

6970
05:07:54,480 --> 05:07:58,270
so if you wanna compare
something results equal equals.

6971
05:07:58,270 --> 05:08:01,000
When you say result dot length.

6972
05:08:01,000 --> 05:08:02,460
Well, now you're gonna get a problem here

6973
05:08:02,460 --> 05:08:05,710
because it's saying
this is a null variable.

6974
05:08:05,710 --> 05:08:08,419
So you need to check to
see if it's null first.

6975
05:08:08,419 --> 05:08:11,030
You may have heard too,
that Kotlin will protect you

6976
05:08:11,030 --> 05:08:13,400
from null pointer exceptions,
and doesn't allow you

6977
05:08:13,400 --> 05:08:14,280
to do nulls.

6978
05:08:14,280 --> 05:08:17,090
Well, that's false, as you can
see here, we can use a null.

6979
05:08:17,090 --> 05:08:20,490
However, I prefer to
use things like first.

6980
05:08:20,490 --> 05:08:23,722
Now first will actually
give me the actual value

6981
05:08:23,722 --> 05:08:24,555
first of Don.

6982
05:08:24,555 --> 05:08:28,220
And so if we run this here,
I'm always telling me like,

6983
05:08:28,220 --> 05:08:29,053
I'm always going to get a variable back.

6984
05:08:29,053 --> 05:08:32,318
Now, if I run this, I'll
say result dot length.

6985
05:08:32,318 --> 05:08:34,640
It'll be four 'cause Donn
has four characters in it.

6986
05:08:34,640 --> 05:08:37,210
Now the real interesting
part comes in here.

6987
05:08:38,430 --> 05:08:41,060
It equals equals foobar
which we know foobar

6988
05:08:41,060 --> 05:08:42,640
does not exist in this list.

6989
05:08:43,676 --> 05:08:44,509
But if we run it again,
what we're gonna see

6990
05:08:44,509 --> 05:08:46,240
is we're gonna get an
exception from Kotlin

6991
05:08:46,240 --> 05:08:48,430
and that's the no such element exception.

6992
05:08:49,411 --> 05:08:50,840
And if we look at the
implementation of first here,

6993
05:08:50,840 --> 05:08:52,800
it says it returns the
first element matching,

6994
05:08:52,800 --> 05:08:54,200
or it'll throw an exception.

6995
05:08:55,625 --> 05:08:57,100
So this is something
you need to be aware of.

6996
05:08:57,100 --> 05:09:01,040
And I prefer to use this method
because now I actually have

6997
05:09:01,040 --> 05:09:04,150
a string that's gonna be
returned if it's found.

6998
05:09:05,910 --> 05:09:09,180
Now, but what if I wanna find
the first or the no value?

6999
05:09:09,180 --> 05:09:10,990
I feel that's a decision I need to make

7000
05:09:10,990 --> 05:09:13,930
because I need to be able to
read the code and know that,

7001
05:09:13,930 --> 05:09:17,400
hey, I'm gonna get the
first one or null value

7002
05:09:17,400 --> 05:09:19,660
because it gives me
context into understanding

7003
05:09:19,660 --> 05:09:21,440
what's happening in my code.

7004
05:09:21,440 --> 05:09:24,260
As regards to find, it does make sense,

7005
05:09:24,260 --> 05:09:28,110
but it's not as obvious,
it's not in your face.

7006
05:09:28,110 --> 05:09:31,620
So first has also one
called first or null.

7007
05:09:31,620 --> 05:09:34,130
So I'm gonna take first or null.

7008
05:09:34,130 --> 05:09:36,340
And now again, we get back a string here

7009
05:09:36,340 --> 05:09:37,210
that's gonna be empty.

7010
05:09:37,210 --> 05:09:40,050
So I'm just gonna go ahead
and take that off there,

7011
05:09:40,050 --> 05:09:42,752
just 'cause it's not gonna
work and we'll print it

7012
05:09:42,752 --> 05:09:43,585
and we'll see it says null.

7013
05:09:43,585 --> 05:09:46,030
Now of course I could do
the null operator check.

7014
05:09:46,030 --> 05:09:48,130
Let's give me the null
safety check.length.

7015
05:09:50,580 --> 05:09:52,920
Otherwise I could just go
ahead and do something else,

7016
05:09:52,920 --> 05:09:55,890
do that or that should work.

7017
05:09:58,250 --> 05:10:00,177
I never going to get back null

7018
05:10:00,177 --> 05:10:01,460
because there's no values there.

7019
05:10:01,460 --> 05:10:04,290
So I can find the first instance.

7020
05:10:04,290 --> 05:10:07,380
So what this also means is
if I have another instance

7021
05:10:07,380 --> 05:10:11,080
of Donn in here, well actually
let me say this to say,

7022
05:10:13,110 --> 05:10:15,860
Donovan, let's see, we
have Donovan in here.

7023
05:10:15,860 --> 05:10:19,850
And I wanna see the first instance of,

7024
05:10:19,850 --> 05:10:23,810
watch the always say first.contains.

7025
05:10:23,810 --> 05:10:28,060
So we'll say dot two
lowercase.to contains Don.

7026
05:10:30,481 --> 05:10:31,390
So I just wanna find the
first one that it's gonna find

7027
05:10:31,390 --> 05:10:32,829
in that list.

7028
05:10:32,829 --> 05:10:34,028
So what is it gonna find?

7029
05:10:34,028 --> 05:10:35,250
Well, that's not gonna find anything.

7030
05:10:35,250 --> 05:10:37,786
So let's go back to the result here,

7031
05:10:37,786 --> 05:10:38,619
you didn't get rid of the length.

7032
05:10:40,126 --> 05:10:43,850
First it dot two lowercase contains Don

7033
05:10:43,850 --> 05:10:46,720
and that's not gonna work,
so the capital D there.

7034
05:10:46,720 --> 05:10:50,150
We'll run that and now we'll get back Don.

7035
05:10:51,332 --> 05:10:54,720
But we had we actually
have two instances in here.

7036
05:10:54,720 --> 05:10:59,300
So what if I wanted to
return the last instance,

7037
05:11:02,200 --> 05:11:03,770
we can do last.

7038
05:11:03,770 --> 05:11:06,340
So there's the last operator
we can find the last instance

7039
05:11:06,340 --> 05:11:08,500
of a list Donovan.

7040
05:11:09,510 --> 05:11:11,820
So there's many different
things we can do inside of here.

7041
05:11:11,820 --> 05:11:16,820
We can find names.index of
and what we're gonna see here,

7042
05:11:18,230 --> 05:11:19,990
index of first index of last.

7043
05:11:21,102 --> 05:11:22,110
So I could get the index of the first.

7044
05:11:23,484 --> 05:11:24,317
And what is that gonna return?

7045
05:11:24,317 --> 05:11:25,150
That should return us a zero.

7046
05:11:26,540 --> 05:11:29,980
And if I do index of
last, I can do index last.

7047
05:11:29,980 --> 05:11:32,000
It'll show me the last value here.

7048
05:11:34,850 --> 05:11:38,120
Of course, if I were to throw
something in here and X, Y, Z,

7049
05:11:38,120 --> 05:11:39,790
what do we think would happen here?

7050
05:11:41,384 --> 05:11:42,330
We're getting negative
one, so it's not found.

7051
05:11:42,330 --> 05:11:44,000
So if you look at the
implementation of that

7052
05:11:44,000 --> 05:11:46,637
or negative one, if the
list does not contain

7053
05:11:46,637 --> 05:11:47,689
such an element.

7054
05:11:47,689 --> 05:11:50,070
And this is all within the
Kotlin standard library.

7055
05:11:50,070 --> 05:11:50,903
So there's a number of
things that we can do

7056
05:11:50,903 --> 05:11:53,270
to find values inside of here.

7057
05:11:53,270 --> 05:11:54,540
And just like we had the last before,

7058
05:11:54,540 --> 05:11:56,580
we also have last or null.

7059
05:11:56,580 --> 05:11:58,310
So we can also take last or no as well,

7060
05:11:58,310 --> 05:12:00,160
so we'll just change this back to Don

7061
05:12:01,352 --> 05:12:04,620
and we'll see the last or null
returns us back with Donovan.

7062
05:12:04,620 --> 05:12:07,850
And then we have Donn X,
which there's nothing in there

7063
05:12:07,850 --> 05:12:10,450
with Donn X in there, it will return null.

7064
05:12:10,450 --> 05:12:12,810
So we've got a null value
at that point in time.

7065
05:12:12,810 --> 05:12:15,660
Now, the great thing about
it is I can read this code

7066
05:12:15,660 --> 05:12:17,230
six months down the line and understand

7067
05:12:17,230 --> 05:12:19,210
that I'm sheltering the names list,

7068
05:12:19,210 --> 05:12:21,900
and I wanna find the last
value or give me null.

7069
05:12:21,900 --> 05:12:23,250
And then at that point, I know exactly

7070
05:12:23,250 --> 05:12:24,430
what to expect at this point.

7071
05:12:24,430 --> 05:12:26,270
I'm either gonna have the
value or I'm gonna have null,

7072
05:12:26,270 --> 05:12:28,150
and I need to plan for that accordingly.

7073
05:12:28,150 --> 05:12:30,290
Now, thankfully Kotlin
is not going to allow me

7074
05:12:30,290 --> 05:12:31,890
to just print the length of this

7075
05:12:31,890 --> 05:12:34,000
because this is a nullable type.

7076
05:12:34,000 --> 05:12:36,000
And I need to basically
say, hey, what happens

7077
05:12:36,000 --> 05:12:38,160
if this is null and I'll just provide

7078
05:12:38,160 --> 05:12:39,420
the null safety operator, which says,

7079
05:12:39,420 --> 05:12:41,330
hey, if this is null, just return null,

7080
05:12:41,330 --> 05:12:43,980
otherwise give me the length,
that's what that means.

7081
05:12:45,040 --> 05:12:47,763
You can filter to include certain things

7082
05:12:47,763 --> 05:12:49,220
and you can also filter
to exclude certain things.

7083
05:12:49,220 --> 05:12:51,740
So for example, if we
wanted to have the result

7084
05:12:51,740 --> 05:12:53,240
to include everything from the list,

7085
05:12:53,240 --> 05:12:57,450
except something, we could have
used a inequality expression

7086
05:12:57,450 --> 05:12:59,960
inside of our predicate,
or we can just use

7087
05:13:01,333 --> 05:13:02,483
a names.not filter not.

7088
05:13:03,831 --> 05:13:08,831
And then we can say
it.contained the letter A.

7089
05:13:08,840 --> 05:13:12,580
And what this will do, it
will print line the result.

7090
05:13:12,580 --> 05:13:15,240
And this will go ahead
and include everything

7091
05:13:15,240 --> 05:13:16,680
that doesn't have a letter A.

7092
05:13:16,680 --> 05:13:18,990
So in this case, we're taking the list

7093
05:13:18,990 --> 05:13:21,614
and we're filtering it
to not include anybody

7094
05:13:21,614 --> 05:13:23,278
who has a letter A in their name,

7095
05:13:23,278 --> 05:13:24,111
which is Don, Bob and Jenny.

7096
05:13:24,111 --> 05:13:26,460
And that's how you can use the filter not,

7097
05:13:26,460 --> 05:13:29,240
which is basically the opposite of filter.

7098
05:13:29,240 --> 05:13:30,720
So if we include filter here,

7099
05:13:30,720 --> 05:13:33,230
we're now going to see the
folks who have the letter A

7100
05:13:33,230 --> 05:13:37,100
in their name, which is Jane,
Tushar, Cavita and Donovan.

7101
05:13:37,100 --> 05:13:39,070
So, yeah, filter and filter not,

7102
05:13:39,070 --> 05:13:41,520
which are basically the
exact opposite of each other,

7103
05:13:41,520 --> 05:13:43,840
or you can also just use inequalities

7104
05:13:43,840 --> 05:13:45,020
inside of your expression.

7105
05:13:45,020 --> 05:13:47,780
It just really depends on
what makes sense for you

7106
05:13:47,780 --> 05:13:49,080
and your code readability.

7107
05:13:50,636 --> 05:13:53,610
I prefer to actually use
the different variations,

7108
05:13:53,610 --> 05:13:56,500
so filter and filter not
because it's very readable

7109
05:13:56,500 --> 05:14:00,190
and I have to do less
thinking and cognitive load,

7110
05:14:00,190 --> 05:14:04,100
cognitive load for me
in regular development.

7111
05:14:04,100 --> 05:14:05,580
And in six months from now, I can read it

7112
05:14:05,580 --> 05:14:07,470
as just kind of regular English.

7113
05:14:07,470 --> 05:14:09,720
And that's how you can
filter and not filter.

7114
05:14:10,600 --> 05:14:13,890
You can easily take one list
and then take some values

7115
05:14:13,890 --> 05:14:17,040
out of it and drop it
into another mutable list

7116
05:14:17,040 --> 05:14:18,500
with the filter to commands.

7117
05:14:18,500 --> 05:14:20,810
So we can save names dot filter to,

7118
05:14:22,274 --> 05:14:23,180
and then you have provide the destination,

7119
05:14:23,180 --> 05:14:25,310
which is gonna be where you
want it to be applied to.

7120
05:14:25,310 --> 05:14:26,690
And this has to be a mutable list,

7121
05:14:26,690 --> 05:14:28,510
which is the approved list here.

7122
05:14:28,510 --> 05:14:31,780
So let's take the use case
of you have an approved list

7123
05:14:31,780 --> 05:14:33,670
of people that are going
to be on the guest list

7124
05:14:33,670 --> 05:14:37,930
for a particular event and
you want to randomly choose

7125
05:14:37,930 --> 05:14:40,470
some more people out of this other list.

7126
05:14:40,470 --> 05:14:41,900
And perhaps you wanna say anyone

7127
05:14:41,900 --> 05:14:45,630
who has the letter A in their name,

7128
05:14:46,470 --> 05:14:48,600
we're gonna randomly choose them.

7129
05:14:48,600 --> 05:14:53,540
Not really fair randomized
assessment, but it does work.

7130
05:14:53,540 --> 05:14:58,070
So we'll say print line,
and then we'll say approved.

7131
05:14:58,070 --> 05:15:00,070
And what this is gonna
do is gonna take anyone

7132
05:15:00,070 --> 05:15:03,920
who has not taken just kind of
say anyone who has a name A,

7133
05:15:03,920 --> 05:15:06,320
and we're gonna append
it to this list up here.

7134
05:15:06,320 --> 05:15:10,490
So if we run this here, we'll
see Danielle, Paul, Jane,

7135
05:15:10,490 --> 05:15:12,320
Tushar, Cavita and Donovan.

7136
05:15:13,203 --> 05:15:16,250
And so that's how we
can take one value here,

7137
05:15:16,250 --> 05:15:18,420
which is a list of names and say,

7138
05:15:18,420 --> 05:15:21,740
hey, if anyone in this list has letter A

7139
05:15:21,740 --> 05:15:24,420
or whatever this predicate
is, again, it's true or false.

7140
05:15:24,420 --> 05:15:26,020
It could be a very complex,

7141
05:15:26,870 --> 05:15:30,540
if else switch with a bunch
of things happening behind it.

7142
05:15:31,780 --> 05:15:33,770
If this returns true, then include it

7143
05:15:34,675 --> 05:15:36,270
and drop it and add it
to this mutable list,

7144
05:15:36,270 --> 05:15:37,510
otherwise don't.

7145
05:15:37,510 --> 05:15:40,080
Now we can also do the opposite too,

7146
05:15:40,080 --> 05:15:42,470
filter, not to.

7147
05:15:43,598 --> 05:15:47,060
And what this does is say,
all right, if you don't have

7148
05:15:47,060 --> 05:15:48,940
a letter A in your name,
well, now we're gonna move you

7149
05:15:48,940 --> 05:15:50,910
into this list, it's the exact opposite.

7150
05:15:50,910 --> 05:15:52,670
So we have the inclusion and exclusion.

7151
05:15:52,670 --> 05:15:53,790
So now it's Danielle and Paul,

7152
05:15:53,790 --> 05:15:55,830
they have already existed in the list,

7153
05:15:55,830 --> 05:15:57,830
but now we want anyone who
doesn't have a letter A

7154
05:15:57,830 --> 05:16:01,100
in their name, so Danielle,
Paul, Don, Bob, and Jenny.

7155
05:16:01,100 --> 05:16:02,940
So we're gonna take anyone
who doesn't have letter A

7156
05:16:02,940 --> 05:16:06,470
in this list and apply it to this list.

7157
05:16:06,470 --> 05:16:08,710
And so that's how you can
easily filter from one list

7158
05:16:08,710 --> 05:16:09,890
into another list.

7159
05:16:09,890 --> 05:16:11,730
Now, again, the list has to be mutable.

7160
05:16:11,730 --> 05:16:14,050
So if you were to change
this to just a regular list,

7161
05:16:14,050 --> 05:16:17,430
which is an immutable list,
this is not going to work.

7162
05:16:17,430 --> 05:16:19,610
As you can see here, the error states

7163
05:16:19,610 --> 05:16:23,390
that a required collection
must be mutable.

7164
05:16:23,390 --> 05:16:27,440
So we need to change this
to a mutable list of,

7165
05:16:27,440 --> 05:16:29,430
and we can get rid of the
type parameters there.

7166
05:16:29,430 --> 05:16:31,420
Again, if you want it to
provide them, you could,

7167
05:16:31,420 --> 05:16:34,640
but we don't need to because
it's already being inferred.

7168
05:16:34,640 --> 05:16:36,720
And that's how you can move
one things from one list

7169
05:16:36,720 --> 05:16:39,530
to another using filter
to and filter not to.

7170
05:16:40,510 --> 05:16:42,090
Sometimes in code, you'll find yourself

7171
05:16:42,090 --> 05:16:47,090
having a list of arrays or
basically a list of lists

7172
05:16:47,530 --> 05:16:48,780
and an array of arrays.

7173
05:16:48,780 --> 05:16:51,020
So let's start with the top example here.

7174
05:16:51,020 --> 05:16:54,090
We have an array of think
of a bunch of people

7175
05:16:54,090 --> 05:16:55,760
bringing a bunch of their fruits together,

7176
05:16:55,760 --> 05:16:57,460
and we're gonna have a party

7177
05:16:57,460 --> 05:16:58,770
and everyone's gonna
bring all their fruits,

7178
05:16:58,770 --> 05:17:00,340
and we're gonna combine
all of our fruits together.

7179
05:17:00,340 --> 05:17:02,790
And I need to see which
fruits all of us have

7180
05:17:02,790 --> 05:17:04,870
and we're building an
application for this.

7181
05:17:04,870 --> 05:17:06,930
So mine, I have apples and grapes,

7182
05:17:06,930 --> 05:17:09,750
theirs they have oranges,
pears, and strawberries,

7183
05:17:09,750 --> 05:17:11,830
and there's the other
people were bringing Kiwi

7184
05:17:11,830 --> 05:17:13,060
and watermelon.

7185
05:17:13,060 --> 05:17:14,660
So I need to see exactly what I have.

7186
05:17:14,660 --> 05:17:18,090
And so I am going to combine
all of those together,

7187
05:17:18,090 --> 05:17:20,330
all of these arrays,
because maybe they've come

7188
05:17:20,330 --> 05:17:23,950
into my application at
different periods of time.

7189
05:17:23,950 --> 05:17:25,370
And so I have the three different arrays,

7190
05:17:25,370 --> 05:17:27,020
and now I have an array of arrays.

7191
05:17:27,020 --> 05:17:29,580
So basically I've
created a list of arrays,

7192
05:17:29,580 --> 05:17:31,720
excuse me, and list of lists.

7193
05:17:31,720 --> 05:17:34,170
So I have a list of mine, a
list of theirs and list of.

7194
05:17:34,170 --> 05:17:37,240
And now if I were to print
this, it would show an array.

7195
05:17:38,695 --> 05:17:40,730
It's gonna be a list
with three items in it.

7196
05:17:40,730 --> 05:17:43,950
And this one, the first
item would have two items

7197
05:17:43,950 --> 05:17:46,190
in that list, the second one
have three items on that list

7198
05:17:46,190 --> 05:17:48,440
and the last one would have
two items in that list.

7199
05:17:48,440 --> 05:17:50,280
Now there's actually a
method called flatten.

7200
05:17:50,280 --> 05:17:52,360
And what this will do is
it'll take all these values

7201
05:17:52,360 --> 05:17:56,520
and flatten them out and
basically put them into one list.

7202
05:17:56,520 --> 05:17:59,710
So I'm gonna go in calm
this out so we can run this.

7203
05:18:00,640 --> 05:18:04,050
And you'll see here that down
we have, when we print this,

7204
05:18:05,330 --> 05:18:07,120
these brackets indicate a list.

7205
05:18:07,120 --> 05:18:08,770
So this is one of the lists,

7206
05:18:08,770 --> 05:18:10,470
this is the next list right here.

7207
05:18:11,460 --> 05:18:13,860
And this is the last
list here with the kiwi

7208
05:18:13,860 --> 05:18:14,990
and the watermelon.

7209
05:18:14,990 --> 05:18:17,478
And of course through
the whole thing is inside

7210
05:18:17,478 --> 05:18:18,311
of one set of brackets here,

7211
05:18:18,311 --> 05:18:19,420
which represents that the whole thing

7212
05:18:19,420 --> 05:18:22,770
is inside of a list itself,
so it's a list of lists,

7213
05:18:22,770 --> 05:18:23,720
kind of a mouthful.

7214
05:18:24,632 --> 05:18:25,470
Now, when I call the flatten method,

7215
05:18:25,470 --> 05:18:27,390
what it does is it just
takes all those values

7216
05:18:27,390 --> 05:18:29,360
and flattens it into one list itself.

7217
05:18:29,360 --> 05:18:32,370
So I'm able to combine all of these lists

7218
05:18:32,370 --> 05:18:35,780
if they're inside of one master
list and flatten them out.

7219
05:18:35,780 --> 05:18:38,410
Now you can do the same
exact thing with arrays.

7220
05:18:38,410 --> 05:18:40,970
It's exact same thing, we'll
have an array of arrays here.

7221
05:18:40,970 --> 05:18:43,570
And so we have an array
of the same exact things.

7222
05:18:43,570 --> 05:18:46,080
Instead of using lists,
I'm just using arrays.

7223
05:18:46,080 --> 05:18:48,030
And I'm gonna call it the
same exact method on it.

7224
05:18:48,030 --> 05:18:51,270
And so I'm calling flatten
and both of these actually

7225
05:18:51,270 --> 05:18:52,530
do the exact same thing.

7226
05:18:54,193 --> 05:18:55,430
This one is gonna be iterating on a list.

7227
05:18:56,439 --> 05:18:58,460
And this one is going to
be iterating on an array.

7228
05:18:58,460 --> 05:19:01,510
So you can see they are different
there's different codes.

7229
05:19:01,510 --> 05:19:04,030
So see line 19 inside the arrays file.

7230
05:19:04,030 --> 05:19:08,800
And then we have line 69
of the itterables file.

7231
05:19:08,800 --> 05:19:12,050
So there is different code, but
it does the exact same thing

7232
05:19:12,050 --> 05:19:13,100
in our use case here.

7233
05:19:15,430 --> 05:19:18,330
And so we're going to take
arrays and if we run these here,

7234
05:19:18,330 --> 05:19:21,910
what we'll see as a top two
lines will be for our lists.

7235
05:19:21,910 --> 05:19:25,090
So we have a list up
here and the next one,

7236
05:19:25,090 --> 05:19:27,760
this is the array of arrays,
and it's printing out the,

7237
05:19:27,760 --> 05:19:29,180
hey, there's a bunch of strings in there

7238
05:19:29,180 --> 05:19:31,130
and then it kind of stopped printing

7239
05:19:31,130 --> 05:19:33,790
and then it flattens them
out into one large array.

7240
05:19:33,790 --> 05:19:35,530
So that's how you can go ahead and flatten

7241
05:19:35,530 --> 05:19:38,700
an array of arrays or lists
of lists inside of Kotlin.

7242
05:19:39,680 --> 05:19:41,680
Let's assume you have multiple lists

7243
05:19:41,680 --> 05:19:43,720
that you'd need to combine in Kotlin.

7244
05:19:43,720 --> 05:19:46,270
These are all immutable
lists, so you can not mutate

7245
05:19:46,270 --> 05:19:47,840
any of them, but you
would like to combine them

7246
05:19:47,840 --> 05:19:51,090
and have a list at the end
that contains all the items.

7247
05:19:51,090 --> 05:19:52,130
It's fairly simple.

7248
05:19:52,130 --> 05:19:54,680
All I need to do is you have a variable

7249
05:19:54,680 --> 05:19:55,950
and you actually don't need a variable

7250
05:19:55,950 --> 05:19:57,450
if you're just parsing this,

7251
05:19:57,450 --> 05:20:01,340
you can just say mine.plus theirs.

7252
05:20:01,340 --> 05:20:02,700
This is gonna return a new instance

7253
05:20:02,700 --> 05:20:05,550
and they say .plus others.

7254
05:20:06,430 --> 05:20:09,670
And this is gonna turn all of the values

7255
05:20:09,670 --> 05:20:11,750
of concatenated together.

7256
05:20:11,750 --> 05:20:14,730
So if we were to run this,
you'll now see that the result

7257
05:20:14,730 --> 05:20:17,470
contains apples, grapes,
oranges, pears, strawberries,

7258
05:20:17,470 --> 05:20:18,310
Kiwi, and watermelons.

7259
05:20:18,310 --> 05:20:20,700
So we've combined all
of these immutable lists

7260
05:20:20,700 --> 05:20:23,000
into one final immutable list.

7261
05:20:23,000 --> 05:20:24,830
Furthermore, you can do
something interesting.

7262
05:20:24,830 --> 05:20:27,700
You can, if you have this
list and you want to remove

7263
05:20:27,700 --> 05:20:30,450
a whole bunch of items
from it, you could do this.

7264
05:20:30,450 --> 05:20:33,270
You could say minus, and you
could remove a bunch of items.

7265
05:20:33,270 --> 05:20:36,380
So maybe you wanna remove
theirs from that list.

7266
05:20:36,380 --> 05:20:38,950
And what you're gonna
see here is our result.

7267
05:20:38,950 --> 05:20:41,910
Now is gonna take out
theirs, we're going to remove

7268
05:20:41,910 --> 05:20:44,240
the oranges, pears, and strawberries,

7269
05:20:44,240 --> 05:20:46,560
which on the second line
item here, we've removed

7270
05:20:46,560 --> 05:20:48,860
the oranges, pears, and strawberries.

7271
05:20:48,860 --> 05:20:51,120
Now the minus operator
does allow you to do

7272
05:20:51,120 --> 05:20:51,953
a whole bunch of stuff.

7273
05:20:51,953 --> 05:20:53,740
You can parse in an itterable,

7274
05:20:53,740 --> 05:20:56,140
you can parse in some sequence,

7275
05:20:56,140 --> 05:20:58,470
you can parse in an array elements.

7276
05:20:58,470 --> 05:21:00,960
And you can also parse in
a single element itself.

7277
05:21:00,960 --> 05:21:03,060
So if you just want to remove one item

7278
05:21:03,060 --> 05:21:06,550
and you just wanna remove
Kiwi and you were to run this,

7279
05:21:06,550 --> 05:21:08,820
now you would see that the end that Kiwi

7280
05:21:08,820 --> 05:21:09,800
would then be removed.

7281
05:21:09,800 --> 05:21:11,570
So you can parse in a list

7282
05:21:11,570 --> 05:21:14,140
or an exact element to be removed.

7283
05:21:14,140 --> 05:21:17,310
So that's how you can combine
concatenate lists together

7284
05:21:17,310 --> 05:21:19,560
inside of Kotlin even
if they are immutable.

7285
05:21:21,610 --> 05:21:24,090
One of the most powerful
operators in Kotlin

7286
05:21:24,090 --> 05:21:27,390
on an a collection is going
to be the map operator.

7287
05:21:27,390 --> 05:21:29,420
So we have a list of names here.

7288
05:21:29,420 --> 05:21:31,860
Let's assume that we wanted to
take the first three letters

7289
05:21:31,860 --> 05:21:35,980
of each name, make them uppercase
and make the abbreviation

7290
05:21:35,980 --> 05:21:37,340
for the person's name.

7291
05:21:37,340 --> 05:21:40,018
It's a pretty rudimentary
example, but let's go ahead

7292
05:21:40,018 --> 05:21:40,851
and try to do that.

7293
05:21:40,851 --> 05:21:42,350
We could use a bunch of
different loops to do that,

7294
05:21:42,350 --> 05:21:44,660
or we can use the map operator.

7295
05:21:44,660 --> 05:21:46,510
So when I say items.map.

7296
05:21:46,510 --> 05:21:48,120
And what this allows us to do is parse in

7297
05:21:48,120 --> 05:21:49,790
the lambda function.

7298
05:21:49,790 --> 05:21:52,650
And what we can do here
is start doing something.

7299
05:21:52,650 --> 05:21:54,890
So it is going to be
each name in the list.

7300
05:21:54,890 --> 05:21:57,290
And then we could say sub string,

7301
05:21:57,290 --> 05:21:59,472
we're gonna say zero to three.

7302
05:21:59,472 --> 05:22:02,360
So we'll get the first
three letters.two uppercase.

7303
05:22:02,360 --> 05:22:05,160
Now, what this is going to
do, map is going to return

7304
05:22:05,160 --> 05:22:07,890
a brand new list, so, it
returns a list containing

7305
05:22:07,890 --> 05:22:10,860
the result of applying the
given transformation function

7306
05:22:10,860 --> 05:22:12,850
to each element in the
original collection.

7307
05:22:12,850 --> 05:22:14,300
Okay, what does that mean?

7308
05:22:14,300 --> 05:22:18,930
What that means is for each
item inside of this list,

7309
05:22:18,930 --> 05:22:20,820
when we call map, it's
gonna execute a function.

7310
05:22:20,820 --> 05:22:22,780
That's basically gonna give us that value,

7311
05:22:22,780 --> 05:22:25,170
and then whatever we do with this value,

7312
05:22:25,170 --> 05:22:27,110
it's going to return this back.

7313
05:22:27,110 --> 05:22:29,040
It's gonna return whatever
the result of this is back.

7314
05:22:29,040 --> 05:22:31,330
So let's print it off and
see what happens here.

7315
05:22:31,330 --> 05:22:32,980
All this sub string is doing is taking

7316
05:22:32,980 --> 05:22:35,500
the first three letters of the
name and making it uppercase.

7317
05:22:35,500 --> 05:22:38,090
And so as you can see,
the result is Don, Jan,

7318
05:22:38,090 --> 05:22:41,690
Carl, Pitt and Clar for the three letters

7319
05:22:41,690 --> 05:22:43,908
of each of these names up here.

7320
05:22:43,908 --> 05:22:47,260
Now I could just completely
ignore it and just say, foo.

7321
05:22:47,260 --> 05:22:49,490
Now watch, if I run
this, we're gonna see foo

7322
05:22:49,490 --> 05:22:50,710
over and over and over.

7323
05:22:50,710 --> 05:22:54,220
The reason why, this map,
this function is executed

7324
05:22:54,220 --> 05:22:55,180
every single time.

7325
05:22:55,180 --> 05:22:58,420
So it's executed for Donn
Felker, it gets foo for Jane Doe.

7326
05:22:58,420 --> 05:23:01,080
It gets foo for Karthik,
it gets foo for Peter,

7327
05:23:01,080 --> 05:23:04,440
it gets foo for Clark, it
gets foo it just executes

7328
05:23:04,440 --> 05:23:06,300
each individual time.

7329
05:23:06,300 --> 05:23:09,110
So here, I'm just returning these values.

7330
05:23:09,110 --> 05:23:10,900
So at this point in time, I'm gonna get

7331
05:23:10,900 --> 05:23:12,380
those first three letters.

7332
05:23:12,380 --> 05:23:15,990
Now we can take this a step
further and we could say,

7333
05:23:15,990 --> 05:23:19,080
all right, well, we can break
this into multiple lines

7334
05:23:19,080 --> 05:23:20,750
and say, let's say I
wanted to get the initials

7335
05:23:20,750 --> 05:23:21,583
off of everybody.

7336
05:23:21,583 --> 05:23:24,100
Now there's multiple ways
that I could go doing this.

7337
05:23:24,100 --> 05:23:26,490
Now, what I could do, very kind of,

7338
05:23:26,490 --> 05:23:28,800
this is very naive approach, but it works.

7339
05:23:28,800 --> 05:23:33,020
I could say it.split, and I
wanna split this on the space.

7340
05:23:33,020 --> 05:23:35,044
And now I have some words.

7341
05:23:35,044 --> 05:23:38,390
And then what I can say is
I wanna return basically

7342
05:23:38,390 --> 05:23:41,170
the words with the first word

7343
05:23:41,170 --> 05:23:43,660
and then I wanna sub string that one.

7344
05:23:43,660 --> 05:23:45,400
And that's gonna start from zero to one,

7345
05:23:45,400 --> 05:23:47,800
basically take the first
letter of the first word,

7346
05:23:47,800 --> 05:23:52,720
plus words.sub string is
gonna be the second word,

7347
05:23:54,440 --> 05:23:55,273
.sub string.

7348
05:23:57,073 --> 05:23:58,690
And you take the first
letter of that one as well.

7349
05:23:58,690 --> 05:24:00,310
And so we're gonna see here type mismatch.

7350
05:24:00,310 --> 05:24:02,850
It says, found string required unit.

7351
05:24:02,850 --> 05:24:05,100
So I actually need to just do this.

7352
05:24:05,100 --> 05:24:06,870
And you may notice like,
why am I not returning it?

7353
05:24:06,870 --> 05:24:09,750
Because what happens inside
of the map is the last value

7354
05:24:09,750 --> 05:24:11,650
is what's returned inside of this map,

7355
05:24:11,650 --> 05:24:13,830
which is why it's pointing
with the up arrow.

7356
05:24:13,830 --> 05:24:15,180
It says map inside the IDE.

7357
05:24:16,225 --> 05:24:17,285
So this is a little hint, it says,

7358
05:24:17,285 --> 05:24:19,400
hey, this is the return
value of the map operation.

7359
05:24:19,400 --> 05:24:21,710
So now, if I were run
this, we're gonna see

7360
05:24:21,710 --> 05:24:24,640
that it's just going to return
back the initials, DF, JD,

7361
05:24:24,640 --> 05:24:26,710
KM, PP, and CK.

7362
05:24:26,710 --> 05:24:30,080
Now this is very, this is
not production quality code.

7363
05:24:30,080 --> 05:24:33,270
If the user has multiple
names and multiple spaces

7364
05:24:33,270 --> 05:24:35,090
in their name, this is gonna fail.

7365
05:24:35,090 --> 05:24:37,360
If they only have one
name, this is gonna fail.

7366
05:24:37,360 --> 05:24:38,680
So this is not production quality,

7367
05:24:38,680 --> 05:24:41,620
but this just illustrates
something that you can do

7368
05:24:41,620 --> 05:24:43,560
inside of the map operation.

7369
05:24:43,560 --> 05:24:47,020
So let's go ahead and you
rewind this a little bit here

7370
05:24:47,020 --> 05:24:50,660
and go back to where we were
before with the abbreviations.

7371
05:24:50,660 --> 05:24:52,650
So now I have the abbreviations.

7372
05:24:52,650 --> 05:24:55,440
And just to run it again,
you'll see what we have.

7373
05:24:55,440 --> 05:24:58,350
You have Donn Jan, Car, Pitt, Clar.

7374
05:24:59,300 --> 05:25:02,410
Now, what I might want to
do at this point in time

7375
05:25:02,410 --> 05:25:06,670
is actually go ahead and I
can perform form another map.

7376
05:25:06,670 --> 05:25:08,450
I can map over an existing result.

7377
05:25:08,450 --> 05:25:09,450
I'm just gonna move this over here.

7378
05:25:09,450 --> 05:25:14,450
So whatever the result of
this, which is Don, Jan, Car,

7379
05:25:14,920 --> 05:25:17,310
Pit and Cla, I'm going to go ahead

7380
05:25:17,310 --> 05:25:18,530
and do an operation on that.

7381
05:25:18,530 --> 05:25:20,040
And I can map on top of that.

7382
05:25:20,040 --> 05:25:25,040
So I could say it.length
and we'll return that.

7383
05:25:26,520 --> 05:25:28,900
Now what you're gonna get
back is a list of integers.

7384
05:25:28,900 --> 05:25:29,990
And each one's gonna say three

7385
05:25:29,990 --> 05:25:33,260
'cause each of the
abbreviations was three long.

7386
05:25:33,260 --> 05:25:35,230
So that kind of makes sense.

7387
05:25:35,230 --> 05:25:38,040
Now, what I could also do
is something like this.

7388
05:25:39,140 --> 05:25:42,520
I could decide that maybe
I want to sum something,

7389
05:25:42,520 --> 05:25:46,770
I could sum by a particular
value, say it.length

7390
05:25:47,970 --> 05:25:52,120
and run that and we're gonna
see 15, so some by that.

7391
05:25:52,120 --> 05:25:53,488
But what does that mean?

7392
05:25:53,488 --> 05:25:55,880
It means we've taken
each of the values here

7393
05:25:55,880 --> 05:25:58,750
and then sum them up into 15.

7394
05:25:58,750 --> 05:26:00,720
Now I can also decide if
I don't wanna do a sum,

7395
05:26:00,720 --> 05:26:02,940
maybe I wanted to do a filter.

7396
05:26:02,940 --> 05:26:07,370
So I remember this is applying
to the result of this map.

7397
05:26:07,370 --> 05:26:10,850
So I can say filter I'll
know when I wanna get

7398
05:26:10,850 --> 05:26:15,010
everybody's first three
letters of their name,

7399
05:26:15,010 --> 05:26:17,110
and then if their first
three letters of their name

7400
05:26:17,110 --> 05:26:21,660
have the letter O in it,
so it's it.contained,

7401
05:26:21,660 --> 05:26:24,120
it's all we'll do to
lowercase just in case,

7402
05:26:24,120 --> 05:26:25,670
actually two uppercase.

7403
05:26:27,680 --> 05:26:29,220
Actually it's already uppercase.

7404
05:26:29,220 --> 05:26:30,550
So I say, it.contains.

7405
05:26:32,590 --> 05:26:36,970
Oh, if we run this, we should
only get one value back.

7406
05:26:36,970 --> 05:26:40,390
And that's gonna be Don,
D-O-N because I've now grabbed

7407
05:26:40,390 --> 05:26:42,740
the abbreviation and then
I've now filtered it.

7408
05:26:42,740 --> 05:26:46,014
So I can start stacking these
things on top of each other.

7409
05:26:46,014 --> 05:26:48,150
Now, if I, for some reason,
would like to reverse

7410
05:26:48,150 --> 05:26:50,780
these things, reversed.

7411
05:26:52,951 --> 05:26:56,700
If we run that, you're just gonna see Don.

7412
05:26:56,700 --> 05:26:59,887
So let's say contains and so go ahead

7413
05:26:59,887 --> 05:27:01,530
and flip this filter not.

7414
05:27:01,530 --> 05:27:04,217
So I don't want it if
it contains a letter L

7415
05:27:04,217 --> 05:27:05,700
which should give me all the other ones.

7416
05:27:05,700 --> 05:27:09,510
We're gonna see CLA, PET, KR and JN.

7417
05:27:10,397 --> 05:27:11,900
And now that's because
the array was reversed,

7418
05:27:11,900 --> 05:27:13,150
I've reversed this array.

7419
05:27:15,088 --> 05:27:17,520
And I can continue to
stack different operations

7420
05:27:17,520 --> 05:27:18,510
on top of this.

7421
05:27:18,510 --> 05:27:20,650
So this allows it to be very functional.

7422
05:27:20,650 --> 05:27:23,080
And so I don't have to
perform all of my logic

7423
05:27:23,080 --> 05:27:25,500
directly within one particular map,

7424
05:27:25,500 --> 05:27:28,480
I can map from one thing to
another thing to another thing.

7425
05:27:28,480 --> 05:27:31,280
And this allows you to
have functions that return,

7426
05:27:31,280 --> 05:27:32,710
perhaps a list of something.

7427
05:27:32,710 --> 05:27:35,600
And then inside that list, you
might perform an operation.

7428
05:27:35,600 --> 05:27:37,440
And then you might map over that operation

7429
05:27:37,440 --> 05:27:39,710
and map over something else
and allows you to transform

7430
05:27:39,710 --> 05:27:42,630
your data in real time,
basically as you're typing it,

7431
05:27:42,630 --> 05:27:45,400
it's much more declarative
and easy to read.

7432
05:27:45,400 --> 05:27:47,920
So that's how you can
perform a map operation

7433
05:27:47,920 --> 05:27:50,140
with just regular primitive types.

7434
05:27:50,140 --> 05:27:52,320
Now, of course, you can do this
with other classes as well.

7435
05:27:52,320 --> 05:27:55,070
So let's say we have
a class called person,

7436
05:27:55,070 --> 05:27:58,457
and this person has a
name, which is a string,

7437
05:28:00,600 --> 05:28:02,400
let's do something simple like that.

7438
05:28:03,603 --> 05:28:07,247
And we'll say people, and
we'll say, list of person,

7439
05:28:11,450 --> 05:28:16,140
Donn and then we say person Jane.

7440
05:28:21,180 --> 05:28:22,250
Now I have all my people.

7441
05:28:22,250 --> 05:28:24,710
Well, I can also map right
over these people too.

7442
05:28:26,473 --> 05:28:27,540
We can say people result.

7443
05:28:29,370 --> 05:28:31,620
And what this will be
is I'll say people.map,

7444
05:28:33,517 --> 05:28:36,437
and now I'm gonna have
this IT value as a person.

7445
05:28:36,437 --> 05:28:38,740
So I can say person.name, I
can do something like that.

7446
05:28:38,740 --> 05:28:40,070
So I can just get everybody's name.

7447
05:28:40,070 --> 05:28:42,960
Now, if I were to print
this to the screen,

7448
05:28:42,960 --> 05:28:46,310
I would say people result
with this gonna be,

7449
05:28:46,310 --> 05:28:47,720
is a list of strings,
it's just gonna give you

7450
05:28:47,720 --> 05:28:48,570
everybody's name.

7451
05:28:50,111 --> 05:28:51,650
So this would be Don, Jane, Bob, Cavita.

7452
05:28:51,650 --> 05:28:54,248
So I'm just iterating over, I'm
just getting a list of that.

7453
05:28:54,248 --> 05:28:55,580
So it allows me to transform that data,

7454
05:28:56,540 --> 05:28:57,373
which makes it very, very nice.

7455
05:28:57,373 --> 05:28:59,580
And of course I can map on top of that,

7456
05:28:59,580 --> 05:29:02,600
which might be it.length.

7457
05:29:02,600 --> 05:29:04,880
So I'm gonna get the
length of everybody's name,

7458
05:29:04,880 --> 05:29:07,640
and maybe that would be a useful
function for me somewhere.

7459
05:29:07,640 --> 05:29:10,480
I could put this inside
of a function and say,

7460
05:29:10,480 --> 05:29:13,970
all right, give me the
length of everybody's names.

7461
05:29:13,970 --> 05:29:15,960
And it would give back the
length of everyone's names

7462
05:29:15,960 --> 05:29:17,200
accordingly.

7463
05:29:17,200 --> 05:29:19,930
Now, maybe you would want to
transform a little bit further

7464
05:29:19,930 --> 05:29:21,320
and you could say, all
right, what's the length

7465
05:29:21,320 --> 05:29:25,990
of their name and perhaps also
I would like to show their...

7466
05:29:27,710 --> 05:29:31,080
I want it to include their
name as well with that.

7467
05:29:31,080 --> 05:29:33,310
And then you could create
various different mappings

7468
05:29:33,310 --> 05:29:37,100
and return arrays or raise
arrays list of lists, et cetera.

7469
05:29:37,100 --> 05:29:38,810
The possibilities are endless.

7470
05:29:40,470 --> 05:29:42,730
The map and flat map
operator can sometimes

7471
05:29:42,730 --> 05:29:44,760
be the source of a lot of confusion

7472
05:29:44,760 --> 05:29:46,360
and determining which
one to use can always

7473
05:29:46,360 --> 05:29:49,660
be kind of something that will
confuse you throughout time.

7474
05:29:49,660 --> 05:29:52,130
Very often that I've had
to look the documentation

7475
05:29:52,130 --> 05:29:54,360
and play around with a
few examples to understand

7476
05:29:54,360 --> 05:29:56,170
what I'd normally need to use.

7477
05:29:56,170 --> 05:29:57,920
Now, working with collections most often,

7478
05:29:57,920 --> 05:29:59,320
you wanna use the map operator

7479
05:29:59,320 --> 05:30:01,100
because you just wanna return values

7480
05:30:01,100 --> 05:30:03,260
and perform transformations
on those values

7481
05:30:03,260 --> 05:30:05,070
across all of the items in a list

7482
05:30:05,070 --> 05:30:07,390
or an iterable of some fashion.

7483
05:30:07,390 --> 05:30:09,830
However, let's determine
what the differences are.

7484
05:30:09,830 --> 05:30:12,660
Here we have a class in
line 23 and it represents

7485
05:30:12,660 --> 05:30:13,810
a shopping bag.

7486
05:30:13,810 --> 05:30:16,540
And in each shopping bag,
we have a number of items

7487
05:30:16,540 --> 05:30:17,700
that go into a bag.

7488
05:30:19,151 --> 05:30:20,780
And when you go grocery
shopping, you usually have

7489
05:30:20,780 --> 05:30:21,660
a number of bags.

7490
05:30:21,660 --> 05:30:24,060
So one bag has grapes,
apples, and oranges,

7491
05:30:24,060 --> 05:30:26,030
the next bag has milk, eggs, and pasta

7492
05:30:26,030 --> 05:30:29,460
and the last bag has some
bread, naan and cake in it.

7493
05:30:29,460 --> 05:30:32,620
And we have basically
a list of grocery bags,

7494
05:30:32,620 --> 05:30:34,460
and those are gonna be our
grocery bags that we have

7495
05:30:34,460 --> 05:30:35,610
from the grocery store.

7496
05:30:36,816 --> 05:30:38,736
Now we may have also went
and purchased some clothing.

7497
05:30:38,736 --> 05:30:41,120
And so we went to a few
retail shops and those bags,

7498
05:30:41,120 --> 05:30:42,670
we have three of those as well.

7499
05:30:43,573 --> 05:30:47,000
We have a shirt, pants and
trouser, let's say trousers.

7500
05:30:47,000 --> 05:30:49,970
So we have shirts and trousers,
we have socks and shoes,

7501
05:30:49,970 --> 05:30:52,450
and then another bag
has a jacket, a sweater,

7502
05:30:52,450 --> 05:30:53,283
and a scarf in it.

7503
05:30:53,283 --> 05:30:56,230
So we're gonna use these two lists.

7504
05:30:56,230 --> 05:30:58,070
So basically these two groupings of bags.

7505
05:30:58,070 --> 05:31:00,550
So we have a list of three shopping bags.

7506
05:31:00,550 --> 05:31:02,390
And up here, we have a list
of three shopping bags,

7507
05:31:02,390 --> 05:31:04,280
and we're gonna perform a flat map on it

7508
05:31:04,280 --> 05:31:05,820
and then print the result.

7509
05:31:05,820 --> 05:31:09,720
And then we're gonna perform
a map on the retail bags

7510
05:31:09,720 --> 05:31:10,930
to see what the differences are.

7511
05:31:10,930 --> 05:31:13,180
So here we can take grocery bags.flat map.

7512
05:31:13,180 --> 05:31:15,670
And then what we do is for
the transformation function,

7513
05:31:15,670 --> 05:31:19,140
we just tell it to, hey,
return all of the items.

7514
05:31:19,140 --> 05:31:21,300
And so if we look at the
declaration of flat map,

7515
05:31:21,300 --> 05:31:23,920
it says returns a single
list of all the elements

7516
05:31:23,920 --> 05:31:26,660
yielded from the results
of the transform function

7517
05:31:26,660 --> 05:31:28,930
being invoked on each element
of the original collection.

7518
05:31:28,930 --> 05:31:30,600
That's confusing.

7519
05:31:30,600 --> 05:31:31,890
So basically what it's saying is like,

7520
05:31:31,890 --> 05:31:34,160
look, what's gonna flatten
out, if this is a list,

7521
05:31:34,160 --> 05:31:35,940
it's gonna flatten it all out.

7522
05:31:35,940 --> 05:31:37,430
Now, if we look at the map,

7523
05:31:37,430 --> 05:31:38,590
we've already looked at this before.

7524
05:31:38,590 --> 05:31:40,720
It says returns a list
containing the results

7525
05:31:40,720 --> 05:31:43,164
of applying to give and
transformation function

7526
05:31:43,164 --> 05:31:45,200
to each element in the
original collection.

7527
05:31:45,200 --> 05:31:46,250
So that makes sense.

7528
05:31:46,250 --> 05:31:48,630
All this function is
really doing is saying,

7529
05:31:48,630 --> 05:31:52,420
hey, map over all of the
bags and then we're saying,

7530
05:31:52,420 --> 05:31:54,850
and give me all the items.

7531
05:31:54,850 --> 05:31:58,470
Okay, so let's do something here.

7532
05:31:58,470 --> 05:32:00,690
Let's just run this to
see what the result is.

7533
05:32:02,826 --> 05:32:04,130
If we run this, you'll see down here,

7534
05:32:04,130 --> 05:32:06,560
the flat map actually says,

7535
05:32:06,560 --> 05:32:09,190
hey, I've grabbed a
win inside of each bag,

7536
05:32:09,190 --> 05:32:11,150
I've grabbed the list of
things inside of the bag.

7537
05:32:11,150 --> 05:32:13,950
I've grabbed the list of
groceries that are in each bag.

7538
05:32:13,950 --> 05:32:16,150
And I got back each list of groceries.

7539
05:32:16,150 --> 05:32:16,983
And then basically what it is.

7540
05:32:16,983 --> 05:32:19,880
I flattened them into one single list.

7541
05:32:19,880 --> 05:32:22,230
So it's flattened them
all into one single list.

7542
05:32:22,230 --> 05:32:25,500
In this case, flat map, when
you have a bag of groceries

7543
05:32:25,500 --> 05:32:28,450
and each bag of groceries
has many items in it,

7544
05:32:28,450 --> 05:32:29,880
it's like taking everything
out and putting it

7545
05:32:29,880 --> 05:32:30,840
on the counter.

7546
05:32:30,840 --> 05:32:32,564
So you're flat mapping.

7547
05:32:32,564 --> 05:32:33,430
You flat mapped everything
out on the counter,

7548
05:32:33,430 --> 05:32:35,280
it's all right there in front of you.

7549
05:32:36,225 --> 05:32:38,480
Now, the retail bags and
we're using the map operator.

7550
05:32:38,480 --> 05:32:40,380
What we're basically saying is,

7551
05:32:40,380 --> 05:32:43,550
well, I have a bunch of items in the bag,

7552
05:32:44,410 --> 05:32:45,243
and I may have taken all these items out,

7553
05:32:45,243 --> 05:32:47,350
but I'm still leaving
them in little groups.

7554
05:32:47,350 --> 05:32:50,590
I have a group number one,
which contains the shirts,

7555
05:32:50,590 --> 05:32:52,630
pants and trousers, and
the group, number two,

7556
05:32:52,630 --> 05:32:55,237
the socks and shoes, and
in group number three,

7557
05:32:55,237 --> 05:32:56,070
which is a jacket sweater and scarf.

7558
05:32:56,070 --> 05:32:57,310
But I don't have the bag
anymore because I've taken them

7559
05:32:57,310 --> 05:32:58,330
out of bags.

7560
05:32:58,330 --> 05:32:59,540
And you may be wondering, what do you mean

7561
05:32:59,540 --> 05:33:01,360
I've taken them out of bags.

7562
05:33:01,360 --> 05:33:02,700
So let's do this real quick.

7563
05:33:02,700 --> 05:33:04,450
Let's say print retail bag.

7564
05:33:08,470 --> 05:33:09,590
If I run this again, we're gonna see

7565
05:33:09,590 --> 05:33:11,140
a couple of print lines here.

7566
05:33:11,140 --> 05:33:15,030
So here we go, we have
three shopping bags.

7567
05:33:15,030 --> 05:33:18,210
So if I just print out
the bags themselves,

7568
05:33:18,210 --> 05:33:22,040
that's like putting three
shopping bags on the counter.

7569
05:33:22,040 --> 05:33:25,220
Now, if I were to take
those items out and put them

7570
05:33:25,220 --> 05:33:27,920
on the counter in the same
groups that they were already in,

7571
05:33:27,920 --> 05:33:30,143
that's what retail bags is doing.

7572
05:33:30,143 --> 05:33:30,976
It's just removing the bag,

7573
05:33:30,976 --> 05:33:32,810
but I'm still grouping
everything together.

7574
05:33:32,810 --> 05:33:34,210
Now, flat map basically says,

7575
05:33:34,210 --> 05:33:35,690
hey, look, I've just taken
out all the groceries

7576
05:33:35,690 --> 05:33:36,630
and just put them all on the counter.

7577
05:33:36,630 --> 05:33:37,850
They're all right here in front of me,

7578
05:33:37,850 --> 05:33:40,915
I just kind of put them out
one right next to each other.

7579
05:33:40,915 --> 05:33:42,170
There's no groupings, we're just one,

7580
05:33:42,170 --> 05:33:44,440
one after the other sequential ordering.

7581
05:33:44,440 --> 05:33:47,080
So the best way you usually think of this

7582
05:33:47,080 --> 05:33:49,780
is if you have a list
of a list of something

7583
05:33:49,780 --> 05:33:52,530
to a list of lists, then
at that point in time,

7584
05:33:52,530 --> 05:33:53,470
you need to start thinking about,

7585
05:33:53,470 --> 05:33:54,990
all right, maybe I need to use flat map

7586
05:33:54,990 --> 05:33:57,370
if I need to kind of get
into each individual item

7587
05:33:57,370 --> 05:34:00,360
and combine them into a
larger lists that's congruent.

7588
05:34:00,360 --> 05:34:03,080
However, if I just need
to operate on each item

7589
05:34:03,080 --> 05:34:06,060
in a particular group, then
perhaps I just need to use map.

7590
05:34:06,060 --> 05:34:09,080
So lists of lists think
flat map, everything else

7591
05:34:09,080 --> 05:34:10,750
I default back to map.

7592
05:34:10,750 --> 05:34:13,111
And then of course, if
you ever get confused,

7593
05:34:13,111 --> 05:34:15,040
hop into the documentation,
I hope that helps.

7594
05:34:15,040 --> 05:34:18,280
Sometimes you wanna have a list of data,

7595
05:34:18,280 --> 05:34:20,826
but you don't want items to repeat.

7596
05:34:20,826 --> 05:34:23,320
And so you want the data to
be unique inside of that list.

7597
05:34:23,320 --> 05:34:24,760
That's known as a set.

7598
05:34:24,760 --> 05:34:27,730
And so what we can do is
create a set of values.

7599
05:34:27,730 --> 05:34:30,670
Like I say, set of, and
this is a helper function

7600
05:34:30,670 --> 05:34:32,380
inside of the Kotlin standard library

7601
05:34:32,380 --> 05:34:34,570
and the Kotlin collections library.

7602
05:34:34,570 --> 05:34:36,170
And I'm a create a set of names.

7603
05:34:36,170 --> 05:34:40,460
So I would say Don, and let's
say John, and then Felicia,

7604
05:34:42,760 --> 05:34:45,150
there we go and I can print this out.

7605
05:34:45,150 --> 05:34:48,050
Now what this will do, it should be names.

7606
05:34:49,420 --> 05:34:51,820
When I print this, it'll
look almost similar

7607
05:34:51,820 --> 05:34:54,730
to just like a list that
we have Don, John, Felicia,

7608
05:34:54,730 --> 05:34:56,070
that works well.

7609
05:34:56,070 --> 05:34:59,180
But the benefit of a set is
if we look at the definition

7610
05:34:59,180 --> 05:35:02,120
here of the set of helper method,

7611
05:35:02,120 --> 05:35:05,030
returns a new read only set
what the given elements.

7612
05:35:05,030 --> 05:35:06,650
Element of the set are
iterated in the order

7613
05:35:06,650 --> 05:35:07,590
they are specified.

7614
05:35:07,590 --> 05:35:10,790
And the return set is
realizable, so we can realize it.

7615
05:35:11,880 --> 05:35:12,980
But the interesting thing is here

7616
05:35:12,980 --> 05:35:15,040
is it does not allow duplicate elements.

7617
05:35:15,040 --> 05:35:17,960
If I wanna put Donn in
there twice and I run this,

7618
05:35:17,960 --> 05:35:19,600
you'll see that Donn is not in there.

7619
05:35:19,600 --> 05:35:21,490
Let's see if I tried to
put Felicia twice or John,

7620
05:35:21,490 --> 05:35:26,490
so, let's do John again,
we see this not included.

7621
05:35:26,820 --> 05:35:28,350
So we cannot put that inside of there.

7622
05:35:28,350 --> 05:35:32,720
So with a set, you can't have
duplicate items in there.

7623
05:35:32,720 --> 05:35:34,060
And so that's how we can create a set

7624
05:35:34,060 --> 05:35:36,260
that's basically a read only set.

7625
05:35:36,260 --> 05:35:39,360
If we wanna create a mutable
set, you would actually,

7626
05:35:39,360 --> 05:35:41,490
which through the set you can change.

7627
05:35:41,490 --> 05:35:44,440
And again, you could
specify this differently.

7628
05:35:44,440 --> 05:35:48,940
This is also gonna be known
as basically a set of string.

7629
05:35:48,940 --> 05:35:50,910
That's the way you could do this.

7630
05:35:50,910 --> 05:35:52,880
Instead of string, of course,
this is not the helper method

7631
05:35:52,880 --> 05:35:54,460
doesn't work this way,
but that's what this is,

7632
05:35:54,460 --> 05:35:55,500
is a set of string.

7633
05:35:56,850 --> 05:35:59,399
If you wanna create a mutable set of,

7634
05:35:59,399 --> 05:36:01,130
you would do like this and
we don't need to provide

7635
05:36:01,130 --> 05:36:03,430
the type parameters
because they are inferred.

7636
05:36:04,606 --> 05:36:06,500
If you wanna add something,
you'd just say names.add,

7637
05:36:06,500 --> 05:36:07,780
use the add method.

7638
05:36:07,780 --> 05:36:10,080
And here, we're gonna
go ahead and say, Jenny.

7639
05:36:12,690 --> 05:36:15,430
Yeah, go ahead and print line names.

7640
05:36:16,330 --> 05:36:19,280
And when we print that again,
we should now see Don, John,

7641
05:36:19,280 --> 05:36:20,560
Felicia and Jenny.

7642
05:36:20,560 --> 05:36:24,080
Now what happens here
if we try to add Donn in

7643
05:36:25,379 --> 05:36:27,404
and let's go ahead and print it again.

7644
05:36:27,404 --> 05:36:28,237
Now Donn already exists in there.

7645
05:36:28,237 --> 05:36:30,300
So if we run this and
see what happens now,

7646
05:36:31,230 --> 05:36:33,716
we'll see that Donn is not added again.

7647
05:36:33,716 --> 05:36:35,590
So the set is remaining unique.

7648
05:36:35,590 --> 05:36:37,380
Each item in the set is unique.

7649
05:36:37,380 --> 05:36:40,930
So the supplies for, if you're
gonna have your strings,

7650
05:36:40,930 --> 05:36:42,340
your inner integers, et cetera,

7651
05:36:42,340 --> 05:36:43,960
each item in a set is unique.

7652
05:36:45,860 --> 05:36:47,520
Now let's take this a
little bit further here.

7653
05:36:47,520 --> 05:36:49,740
We've kind of understand what we can do

7654
05:36:49,740 --> 05:36:51,260
for duplicate names here.

7655
05:36:51,260 --> 05:36:53,650
If Donn is up here twice,
it's not gonna show,

7656
05:36:53,650 --> 05:36:55,760
but now what if we have a class?

7657
05:36:56,756 --> 05:36:57,589
So we have an object.

7658
05:36:57,589 --> 05:37:01,980
So an object should not have
duplicate values in there

7659
05:37:03,100 --> 05:37:03,933
for a set.

7660
05:37:05,491 --> 05:37:06,970
Now, however, if I've
added a person class here

7661
05:37:06,970 --> 05:37:11,860
that just has a name, and
then I add two people to this,

7662
05:37:11,860 --> 05:37:14,870
two persons to this people set,

7663
05:37:16,260 --> 05:37:19,630
we should technically only
see one Donn in there.

7664
05:37:19,630 --> 05:37:22,050
Now, when we run this, we
actually see two persons.

7665
05:37:23,345 --> 05:37:24,840
And notice this little
number here at the end.

7666
05:37:24,840 --> 05:37:26,260
I'm not gonna get into
the details of what it is,

7667
05:37:26,260 --> 05:37:28,290
but this basically is saying,

7668
05:37:28,290 --> 05:37:30,010
look, these are different objects.

7669
05:37:31,130 --> 05:37:33,928
And so the equality checks inside of here

7670
05:37:33,928 --> 05:37:34,761
are not being done.

7671
05:37:34,761 --> 05:37:36,350
Now, a way you can implement
these equality checks

7672
05:37:36,350 --> 05:37:38,160
inside of your classes with the equals

7673
05:37:38,160 --> 05:37:42,490
and overriding all the proper
methods to ensure equality

7674
05:37:42,490 --> 05:37:43,340
instead of your classes.

7675
05:37:43,340 --> 05:37:45,670
However, if these are just
classes that are going

7676
05:37:45,670 --> 05:37:48,170
to hold data such as this one is,

7677
05:37:48,170 --> 05:37:49,400
then what you can do is
you can just turn this

7678
05:37:49,400 --> 05:37:50,490
into a data class.

7679
05:37:50,490 --> 05:37:52,880
And use this as a data class
it'll work the same way,

7680
05:37:52,880 --> 05:37:55,080
but all these equality checks
are already done for you.

7681
05:37:55,080 --> 05:37:57,300
It's comparing all the fields, et cetera

7682
05:37:57,300 --> 05:37:59,862
to see if they're exactly the same.

7683
05:37:59,862 --> 05:38:02,462
So now if we run this, I'm
basically adding two Dons

7684
05:38:03,320 --> 05:38:06,070
to the set of the same data class and say,

7685
05:38:06,070 --> 05:38:08,523
nope, no, no, it's not gonna allow it.

7686
05:38:08,523 --> 05:38:09,640
So I could come up here
and add another one.

7687
05:38:10,823 --> 05:38:13,270
Now I'm really sure I don't
wanna add Donn three times.

7688
05:38:13,270 --> 05:38:14,610
What will happen is it
will come back and say,

7689
05:38:14,610 --> 05:38:15,720
nope, there's only one.

7690
05:38:15,720 --> 05:38:18,740
And so then I can actually
maybe just change this one

7691
05:38:18,740 --> 05:38:23,420
to, let's do this one is Janet, run here,

7692
05:38:24,680 --> 05:38:27,180
we'll see there's Don,
there's Janet inside of there.

7693
05:38:27,180 --> 05:38:31,320
So there's the set is
not allowing multiple

7694
05:38:31,320 --> 05:38:34,160
different versions in here of
the different types of folks.

7695
05:38:34,160 --> 05:38:35,330
Again, so you have a mutable set.

7696
05:38:35,330 --> 05:38:39,390
So this is very much a very
kind of Kotlin specific idiom.

7697
05:38:39,390 --> 05:38:41,230
You have immutable and mutable.

7698
05:38:41,230 --> 05:38:42,960
By default everything's immutable.

7699
05:38:42,960 --> 05:38:44,640
So you need to think about this,

7700
05:38:44,640 --> 05:38:46,070
if you want something to be mutable,

7701
05:38:46,070 --> 05:38:48,460
you need to tell Kotlin,
hey, this is a mutable list,

7702
05:38:48,460 --> 05:38:51,580
this is a mutable map,
this is a mutable set.

7703
05:38:51,580 --> 05:38:53,960
And if you need it to be unique,

7704
05:38:53,960 --> 05:38:55,330
like a list of data to be unique,

7705
05:38:55,330 --> 05:38:56,930
then you should be using a set.

7706
05:38:56,930 --> 05:38:58,200
And if you're gonna be using classes,

7707
05:38:58,200 --> 05:38:59,820
you wanna make sure
that the equality checks

7708
05:38:59,820 --> 05:39:01,790
are implemented correctly
in your given class

7709
05:39:01,790 --> 05:39:03,370
or you're using a data class.

7710
05:39:05,560 --> 05:39:08,850
Loops are one of the most common
structures in programming.

7711
05:39:08,850 --> 05:39:10,790
And for loops are gonna be
something you've probably used

7712
05:39:10,790 --> 05:39:11,740
in other languages.

7713
05:39:12,708 --> 05:39:13,660
If not, they're gonna be something

7714
05:39:13,660 --> 05:39:15,770
you'll be very familiar with.

7715
05:39:15,770 --> 05:39:19,950
So let's assume we have a list
of values and those values

7716
05:39:19,950 --> 05:39:24,950
are maybe integers one, two,
three, four, five, six, seven.

7717
05:39:28,430 --> 05:39:31,290
You can iterate over these
or perform various different

7718
05:39:31,290 --> 05:39:33,560
operations of them pretty easily.

7719
05:39:33,560 --> 05:39:35,230
The first thing you can do is
just iterate over the list.

7720
05:39:35,230 --> 05:39:40,230
You can say for number and
values, print line number.

7721
05:39:44,010 --> 05:39:46,980
And what this is, it says for every value

7722
05:39:46,980 --> 05:39:49,472
that's inside of here, we're
gonna give it a variable

7723
05:39:49,472 --> 05:39:51,384
called number, and we
wanna print that number.

7724
05:39:51,384 --> 05:39:52,870
And if we run this, we'll
see one, two, three, four,

7725
05:39:52,870 --> 05:39:54,400
five, six, seven is printed.

7726
05:39:54,400 --> 05:39:55,860
So now I can call this something else.

7727
05:39:55,860 --> 05:39:58,280
This doesn't have to be called number,

7728
05:39:58,280 --> 05:40:02,370
this could be called a chicken,
I mean, just for whatever,

7729
05:40:02,370 --> 05:40:04,120
just for purposes of demonstration,

7730
05:40:04,120 --> 05:40:06,270
this can be anything you want it to be.

7731
05:40:06,270 --> 05:40:07,280
It's gonna print the value.

7732
05:40:07,280 --> 05:40:09,310
And this is each value that's in this list

7733
05:40:09,310 --> 05:40:10,720
will be put inside of here.

7734
05:40:10,720 --> 05:40:13,860
So the same thing goes for
these primitive values.

7735
05:40:13,860 --> 05:40:18,090
It could be names, it could
be anything of that nature.

7736
05:40:18,090 --> 05:40:20,310
And then again, well
that changes from chicken

7737
05:40:20,310 --> 05:40:24,140
'cause doesn't make sense, but
to name, we'll run it again

7738
05:40:25,190 --> 05:40:27,482
and we'll see Don, Bob, Janus.

7739
05:40:27,482 --> 05:40:29,280
That's each one of those
values in that list

7740
05:40:29,280 --> 05:40:32,910
and that's how we can kind of
iterate quickly over a list

7741
05:40:32,910 --> 05:40:34,000
using a four loop.

7742
05:40:34,920 --> 05:40:37,180
Now there's also ways you can do it

7743
05:40:37,180 --> 05:40:38,890
if you wanna do some type of counting.

7744
05:40:38,890 --> 05:40:43,760
For example, if we wanted to
say for I in zero until 10,

7745
05:40:51,110 --> 05:40:52,050
we could print a letter I.

7746
05:40:52,050 --> 05:40:53,930
Now we're used to seeing
I as a counter variable

7747
05:40:53,930 --> 05:40:55,740
in very many languages.

7748
05:40:55,740 --> 05:40:58,590
And you'll see here, what's
happening is I is defined

7749
05:40:58,590 --> 05:41:01,710
as an integer in zero until 10.

7750
05:41:01,710 --> 05:41:04,260
So it says it starts to
zero up until we hit 10,

7751
05:41:04,260 --> 05:41:05,190
We wanna do something.

7752
05:41:05,190 --> 05:41:07,370
So each time it's just
gonna iterate and increment

7753
05:41:07,370 --> 05:41:12,280
the variable value by one, so
we have zero through 10 here.

7754
05:41:12,280 --> 05:41:14,574
Now there's also nothing you can do.

7755
05:41:14,574 --> 05:41:16,710
So that's a very common
way to do some looping

7756
05:41:16,710 --> 05:41:18,080
and you can set this
as a variable up here.

7757
05:41:18,080 --> 05:41:22,540
So 'cause that val say upper limit is 10.

7758
05:41:22,540 --> 05:41:25,330
And so you can say until upper limit.

7759
05:41:26,890 --> 05:41:30,350
Or you could say here's
another way, you stop.

7760
05:41:31,210 --> 05:41:35,770
So stop and then you can make
another one called start.

7761
05:41:35,770 --> 05:41:38,040
So there's all different types
of ways that you can do this

7762
05:41:38,040 --> 05:41:39,311
in your code.

7763
05:41:39,311 --> 05:41:41,310
And it's up to you
depending on the situation.

7764
05:41:43,540 --> 05:41:44,970
For I and start until stop.

7765
05:41:46,030 --> 05:41:47,120
I mean, it doesn't really make sense

7766
05:41:47,120 --> 05:41:48,930
'cause then I have to go find
what start and stop means.

7767
05:41:48,930 --> 05:41:51,790
But as it's just a demonstration
that you can run this

7768
05:41:51,790 --> 05:41:54,148
and it'll still execute accordingly.

7769
05:41:54,148 --> 05:41:55,700
So I'm gonna undo this here
and we're gonna go back

7770
05:41:55,700 --> 05:41:57,770
to how it was before until 10.

7771
05:41:58,940 --> 05:42:00,690
Now you can also perform stepping.

7772
05:42:01,930 --> 05:42:06,855
So what this says is for I in zero to 10,

7773
05:42:06,855 --> 05:42:09,040
I want you to step by two.

7774
05:42:09,040 --> 05:42:12,350
What that means is basically count by two

7775
05:42:12,350 --> 05:42:13,183
as we're iterating.

7776
05:42:13,183 --> 05:42:15,650
So instead of incrementing
by one, increment by two.

7777
05:42:15,650 --> 05:42:18,580
So therefore you see
two, four, six, eight.

7778
05:42:18,580 --> 05:42:21,570
So if I were to jump this
up to, let's go to 100.

7779
05:42:22,460 --> 05:42:24,988
We're gonna see it's gonna count by twos

7780
05:42:24,988 --> 05:42:26,050
all the way up until 100.

7781
05:42:26,050 --> 05:42:27,450
And there it has done here at the bottom.

7782
05:42:27,450 --> 05:42:31,610
Now I can say step 10
and that's gonna iterate

7783
05:42:31,610 --> 05:42:33,110
all the way up to 100.

7784
05:42:34,095 --> 05:42:36,135
So we're gonna see starting
at zero all the way up

7785
05:42:36,135 --> 05:42:37,560
until 100, and I've had to do step five,

7786
05:42:37,560 --> 05:42:40,350
of course is just gonna
run it till it's five

7787
05:42:40,350 --> 05:42:41,900
and then it'll iterate upwards.

7788
05:42:43,110 --> 05:42:46,090
Now you can also do it the opposite way.

7789
05:42:46,090 --> 05:42:48,780
So let's go down to the step,
let's get rid of step again.

7790
05:42:50,500 --> 05:42:53,690
So we have item 100 down to zero.

7791
05:42:53,690 --> 05:42:56,490
So this will be basically
a reverse for loop.

7792
05:42:56,490 --> 05:42:58,460
So it's gonna count from 100 down to zero

7793
05:42:58,460 --> 05:43:00,780
and it's gonna increment
by one by default.

7794
05:43:00,780 --> 05:43:02,680
Now again, I could do step two here

7795
05:43:04,091 --> 05:43:06,891
and that's gonna count down
by two or I could do step 10

7796
05:43:08,784 --> 05:43:09,620
and then we're gonna
have 100 all the way down

7797
05:43:09,620 --> 05:43:11,260
until 10 to zero.

7798
05:43:12,530 --> 05:43:15,560
So we can see here on the
100 all the way down to zero.

7799
05:43:15,560 --> 05:43:17,010
It's all one more step by 10.

7800
05:43:18,750 --> 05:43:20,790
Now the last thing you
could have possibly,

7801
05:43:21,666 --> 05:43:23,040
let's take a simple class like,

7802
05:43:24,054 --> 05:43:26,090
let's create a quick
data class called person.

7803
05:43:28,075 --> 05:43:29,720
And this person of course
is gonna have a name,

7804
05:43:30,770 --> 05:43:32,040
which is a string.

7805
05:43:32,040 --> 05:43:33,280
And let's create a
couple of people up here.

7806
05:43:33,280 --> 05:43:38,280
So we'll say val people
equals list of I'm gonna say

7807
05:43:38,700 --> 05:43:43,700
person Don, person Jane, person Karthik.

7808
05:43:50,890 --> 05:43:53,120
And then what we'll do inside of here,

7809
05:43:53,120 --> 05:43:58,120
we'll say for I and people
we're gonna print the people.

7810
05:44:02,170 --> 05:44:04,330
And so you can iterate
over objects as well.

7811
05:44:04,330 --> 05:44:06,800
So here we're either writing
over each item in a list,

7812
05:44:06,800 --> 05:44:10,064
just using a simple for
loop inside of Kotlin

7813
05:44:10,064 --> 05:44:12,520
and that's how you can
use a for loop and Kotlin.

7814
05:44:13,920 --> 05:44:16,290
A while loop in Kotlin
is very easy to create.

7815
05:44:17,370 --> 05:44:21,570
So we'll say while X is less than 10,

7816
05:44:21,570 --> 05:44:24,114
we wanna perform some type of operation.

7817
05:44:24,114 --> 05:44:26,640
So here we'll say print line X.

7818
05:44:26,640 --> 05:44:28,880
And then what we need to do
is increment the X value.

7819
05:44:28,880 --> 05:44:30,610
So it continues to increment upwards

7820
05:44:30,610 --> 05:44:32,740
as we are progressing through the loop.

7821
05:44:32,740 --> 05:44:35,560
And if we run this, what
we'll see is while X

7822
05:44:35,560 --> 05:44:38,320
is less than 10, we
perform some operation.

7823
05:44:38,320 --> 05:44:40,490
Now a while loop is very
useful where you need

7824
05:44:40,490 --> 05:44:44,210
to do something while a
particular condition is met.

7825
05:44:44,210 --> 05:44:47,830
And so this could be maybe you
need to be running something

7826
05:44:47,830 --> 05:44:50,910
in a loop the entire time and only do it

7827
05:44:50,910 --> 05:44:53,350
when maybe perhaps a
certain button is pressed

7828
05:44:54,598 --> 05:44:55,431
that needs X it out.

7829
05:44:55,431 --> 05:44:58,440
Now, for example, if I forget
to set this X variable here

7830
05:44:58,440 --> 05:45:01,650
and increment it and I run
this, watch the terminal window,

7831
05:45:01,650 --> 05:45:03,530
I'm gonna stop this pretty quickly,

7832
05:45:03,530 --> 05:45:05,150
but then we're gonna stop it now.

7833
05:45:06,120 --> 05:45:10,090
But this is a very long scroll of zeroes.

7834
05:45:10,090 --> 05:45:13,240
I mean I'm scrolling a lot
and it's barely moving.

7835
05:45:13,240 --> 05:45:17,510
If I let that run, most
likely the IDE would have had

7836
05:45:17,510 --> 05:45:21,160
out of memory exception or
stack overflow exception

7837
05:45:21,160 --> 05:45:24,770
because it's continuing to print
line over and over and over

7838
05:45:24,770 --> 05:45:26,340
and over and over and over and over

7839
05:45:26,340 --> 05:45:28,410
and this loop is never going to stop.

7840
05:45:28,410 --> 05:45:30,220
This is basically an
infinite loop at this point

7841
05:45:30,220 --> 05:45:32,630
because there is no termination

7842
05:45:32,630 --> 05:45:34,575
that's being provided by it.

7843
05:45:34,575 --> 05:45:36,590
And when we increment this X value,

7844
05:45:36,590 --> 05:45:39,210
we're actually incrementing
the X and eventually

7845
05:45:39,210 --> 05:45:42,990
this expression will end up being false.

7846
05:45:42,990 --> 05:45:46,640
And so as soon as it hits
false, the loop will exit.

7847
05:45:46,640 --> 05:45:48,210
and then the next line of code will run.

7848
05:45:48,210 --> 05:45:52,503
So say print line, let
me see this all done.

7849
05:45:54,250 --> 05:45:59,250
If we run this now, see all
done is printed afterwards.

7850
05:45:59,510 --> 05:46:02,780
And if we just let this
go for 100 or whatever,

7851
05:46:02,780 --> 05:46:04,250
then it could be a problem.

7852
05:46:04,250 --> 05:46:07,430
Now, a lot of times folks
will actually run these

7853
05:46:07,430 --> 05:46:10,090
while loops in various different
programs in the backend

7854
05:46:10,090 --> 05:46:12,500
and incline applications
while they're waiting

7855
05:46:12,500 --> 05:46:14,150
for a file to process
while they're waiting

7856
05:46:14,150 --> 05:46:15,160
for something to happen.

7857
05:46:15,160 --> 05:46:17,856
Perhaps they put asleep command in here

7858
05:46:17,856 --> 05:46:18,689
for the thread to sleep.

7859
05:46:18,689 --> 05:46:20,530
And again, there's pros
and cons of all this.

7860
05:46:20,530 --> 05:46:22,680
I'm not telling you and
advocating to you sleep

7861
05:46:22,680 --> 05:46:25,870
inside of your code, that's
usually a code smell.

7862
05:46:25,870 --> 05:46:29,300
However you'll wanna
understand when is a good time

7863
05:46:29,300 --> 05:46:30,230
to use a while loop.

7864
05:46:30,230 --> 05:46:32,420
A lot of games, stuff like
that use a lot of while loops

7865
05:46:32,420 --> 05:46:34,650
to keep things running in a game loop.

7866
05:46:34,650 --> 05:46:36,650
So while loops you'll need to make sure

7867
05:46:36,650 --> 05:46:39,150
that everything's going to
run inside of the while loop

7868
05:46:39,150 --> 05:46:41,720
inside of between these two brackets,

7869
05:46:41,720 --> 05:46:44,550
everything is gonna run while
this expression is true.

7870
05:46:45,500 --> 05:46:48,520
And so this could equate
to be some type of value

7871
05:46:48,520 --> 05:46:52,250
and perhaps this root loop
runs until a user presses

7872
05:46:52,250 --> 05:46:53,590
a particular button.

7873
05:46:53,590 --> 05:46:56,180
Maybe it's drawing something on the screen

7874
05:46:56,180 --> 05:46:58,700
and you're determining
where to render things.

7875
05:46:58,700 --> 05:47:01,050
A while loop is a perfect
opportunity to do that.

7876
05:47:01,050 --> 05:47:02,920
I need something to happen
over and over and over

7877
05:47:02,920 --> 05:47:05,990
until an exact particular
condition has been met.

7878
05:47:05,990 --> 05:47:08,200
That's when you're gonna
wanna use while loop.

7879
05:47:08,200 --> 05:47:10,630
And that's what you can
do is this can be a very,

7880
05:47:10,630 --> 05:47:13,067
this could be a method call inside of here

7881
05:47:13,067 --> 05:47:16,430
if you want it to be, this
could be a fun is okay too,

7882
05:47:16,430 --> 05:47:19,600
or like keep going, how would
you want to try Boolean.

7883
05:47:19,600 --> 05:47:23,180
And at this point you could
have some code in here.

7884
05:47:23,180 --> 05:47:26,390
It says return, true or false,

7885
05:47:27,290 --> 05:47:28,520
true or false in this point,

7886
05:47:28,520 --> 05:47:30,210
we'll say true for whatever reason.

7887
05:47:31,140 --> 05:47:33,744
And you could actually just
call it this right here.

7888
05:47:33,744 --> 05:47:34,577
So we'll keep going.

7889
05:47:34,577 --> 05:47:35,730
While keep going, blah, blah, blah.

7890
05:47:35,730 --> 05:47:38,300
And this method in here could be going out

7891
05:47:38,300 --> 05:47:42,280
and checking file system, checking an API,

7892
05:47:43,670 --> 05:47:47,620
waiting for an input or checking the input

7893
05:47:49,600 --> 05:47:52,400
or interrupts some form to say,

7894
05:47:52,400 --> 05:47:54,710
"Hey, should I continue
to go," and so forth.

7895
05:47:54,710 --> 05:47:57,030
So that's when you're gonna
wanna use a while loop

7896
05:47:57,030 --> 05:47:58,430
in Kotlin and how to use it.

7897
05:47:59,280 --> 05:48:02,510
Let's assume that you have a
list of people here in a list.

7898
05:48:02,510 --> 05:48:04,930
Now you could, of course,
go ahead and iterate

7899
05:48:04,930 --> 05:48:08,560
over each one of these
inside of people like this,

7900
05:48:08,560 --> 05:48:09,700
for I and people.

7901
05:48:09,700 --> 05:48:12,840
And you could print line
each one of these people

7902
05:48:12,840 --> 05:48:15,330
inside of this list, and
this will work just fine.

7903
05:48:15,330 --> 05:48:17,310
There's nothing wrong with this.

7904
05:48:17,310 --> 05:48:20,240
In fact, many people
probably do this day to day

7905
05:48:20,240 --> 05:48:21,130
and it works.

7906
05:48:22,596 --> 05:48:24,450
However, there is a more
idiomatic way to do it in Kotlin

7907
05:48:24,450 --> 05:48:26,340
and you can use the Kotlin
collections to view that.

7908
05:48:26,340 --> 05:48:30,190
So you can say, people
dot, you can say for each,

7909
05:48:30,190 --> 05:48:32,660
for each, for each here,

7910
05:48:32,660 --> 05:48:36,200
and then what you can say is
print ln, and then you DIT.

7911
05:48:37,160 --> 05:48:39,830
And that's basically ended
the same exact thing for you.

7912
05:48:39,830 --> 05:48:42,290
It's gonna allow you to
iterate over each item inside

7913
05:48:42,290 --> 05:48:44,280
of the array, but allows you to say,

7914
05:48:44,280 --> 05:48:46,280
"Hey, for each item and this array,

7915
05:48:46,280 --> 05:48:48,600
"do some particular function."

7916
05:48:48,600 --> 05:48:51,710
Anytime I'm working with a list, a map,

7917
05:48:51,710 --> 05:48:54,160
some type of collection
array or whatever it is,

7918
05:48:54,160 --> 05:48:56,760
if it's a, some type of
collection inside of Kotlin,

7919
05:48:57,895 --> 05:48:59,340
I'll always wanna prefer to use iteration

7920
05:48:59,340 --> 05:49:01,360
on the actual list itself.

7921
05:49:01,360 --> 05:49:03,480
It makes it much easier
unless I'm modifying the list

7922
05:49:03,480 --> 05:49:04,810
and I need to do something with a list.

7923
05:49:04,810 --> 05:49:07,410
And then I might use a
different type of loop structure

7924
05:49:07,410 --> 05:49:08,460
around it.

7925
05:49:08,460 --> 05:49:10,490
But for the most part, for
most of the operations,

7926
05:49:10,490 --> 05:49:15,210
I'll have, I'll prefer to use
the actual, each operator.

7927
05:49:15,210 --> 05:49:17,710
So I can iterate each over
each one of those things

7928
05:49:17,710 --> 05:49:18,543
and so forth.

7929
05:49:18,543 --> 05:49:20,000
So another thing that you could do,

7930
05:49:20,000 --> 05:49:21,900
I mean, you can also,
as we've seen before,

7931
05:49:21,900 --> 05:49:25,700
you can perhaps map these
things together and say map,

7932
05:49:25,700 --> 05:49:29,820
I could say a sub string of
each one of these things,

7933
05:49:29,820 --> 05:49:32,900
and it would be it.name.sub string.

7934
05:49:34,210 --> 05:49:36,430
I'll actually just take each
person's name and then I can do

7935
05:49:36,430 --> 05:49:39,290
for each and then I can
perform some operation on that.

7936
05:49:39,290 --> 05:49:43,150
And I could say something
like it.to upper case.

7937
05:49:45,830 --> 05:49:47,320
So I kind of start chaining all these

7938
05:49:47,320 --> 05:49:48,153
different things together.

7939
05:49:48,153 --> 05:49:50,260
And as soon as I get one or two
of these things in the line,

7940
05:49:50,260 --> 05:49:52,010
I'd like to kind of drop them here.

7941
05:49:52,939 --> 05:49:57,090
And then I might say for
each, and I can do a map

7942
05:49:57,090 --> 05:49:57,980
on top of this.

7943
05:49:57,980 --> 05:50:01,740
Actually, I can do another
map here if I want to.

7944
05:50:01,740 --> 05:50:03,810
And then as soon as I have that list down

7945
05:50:03,810 --> 05:50:05,460
and I wanna do something with it,

7946
05:50:06,308 --> 05:50:07,141
I can then do four each over it.

7947
05:50:07,141 --> 05:50:10,260
Now for each returns a unit,
which means it's just a unit.

7948
05:50:10,260 --> 05:50:11,530
It doesn't return on our map,

7949
05:50:11,530 --> 05:50:14,940
which is why I was not able
to add a map operator before.

7950
05:50:14,940 --> 05:50:17,428
So if I wanted to do something
additionally to this,

7951
05:50:17,428 --> 05:50:19,396
to transform these values,

7952
05:50:19,396 --> 05:50:22,960
I would before map here
and say it.to uppercase

7953
05:50:24,340 --> 05:50:28,170
and we can turn through this.reverse.

7954
05:50:32,920 --> 05:50:35,030
And if we ran this, we
would see each person's name

7955
05:50:35,030 --> 05:50:36,490
is upper case and reversed,

7956
05:50:38,180 --> 05:50:41,200
but we did not print it,
which is the problem.

7957
05:50:41,200 --> 05:50:43,460
And here, when we actually
print it to the screen,

7958
05:50:43,460 --> 05:50:48,460
we'll see everything here
will be all the names reversed

7959
05:50:49,390 --> 05:50:51,400
and upper cased in there.

7960
05:50:51,400 --> 05:50:53,630
So again, if you're going to be using

7961
05:50:53,630 --> 05:50:54,780
any of the Kotlin collections,

7962
05:50:54,780 --> 05:50:57,897
I highly recommend using
the for each operator

7963
05:50:57,897 --> 05:50:59,220
to iterate over a collection.

7964
05:50:59,220 --> 05:51:01,340
It's much more idiomatic
and easier to read

7965
05:51:01,340 --> 05:51:02,490
and actually less code.

7966
05:51:04,260 --> 05:51:07,090
Very often in Kotlin you'll
receive multiple lists

7967
05:51:07,961 --> 05:51:09,240
and you need to combine
those lists into a list

7968
05:51:09,240 --> 05:51:11,420
that does not contain duplicate elements.

7969
05:51:12,320 --> 05:51:14,720
Now you could iterate over
both lists and check to see

7970
05:51:14,720 --> 05:51:16,550
if either one contains a value

7971
05:51:16,550 --> 05:51:19,390
and if it does then not include it.

7972
05:51:19,390 --> 05:51:21,700
So each item in the new list is unique.

7973
05:51:21,700 --> 05:51:23,270
And that's usually what you're after.

7974
05:51:23,270 --> 05:51:26,050
Is a list who has a unique values

7975
05:51:26,050 --> 05:51:28,780
but really at the end of the
day what you're looking for

7976
05:51:28,780 --> 05:51:32,950
is actually a set and a
set, if you look at it,

7977
05:51:32,950 --> 05:51:34,740
is a generic unordered
collection of elements

7978
05:51:34,740 --> 05:51:36,820
that does not support duplicate elements.

7979
05:51:36,820 --> 05:51:40,330
And that's line 252 here,
this is in the collections

7980
05:51:40,330 --> 05:51:42,760
class of the Kotlin standard library.

7981
05:51:42,760 --> 05:51:45,510
So basically I set is
an order to collection

7982
05:51:45,510 --> 05:51:48,480
that does not support duplicate elements.

7983
05:51:48,480 --> 05:51:50,750
Now, thankfully, there are some utilities

7984
05:51:50,750 --> 05:51:52,850
built into the Kotlin collections library

7985
05:51:52,850 --> 05:51:54,510
that allow you to do this real easily.

7986
05:51:54,510 --> 05:51:58,340
So here we have two
different lists of people.

7987
05:51:58,340 --> 05:52:00,440
This one is Don, Jake, Janet, Cavita,

7988
05:52:00,440 --> 05:52:05,380
and this list has Don, Janet,
Jumo, Cavita, Kevin and Kathy.

7989
05:52:05,380 --> 05:52:07,780
For whatever reason,
there's in both lists,

7990
05:52:07,780 --> 05:52:08,810
both people are present.

7991
05:52:08,810 --> 05:52:11,760
Now, maybe this could be
because these could be groups

7992
05:52:11,760 --> 05:52:14,400
that are on a popular site that you have,

7993
05:52:14,400 --> 05:52:17,480
or maybe you're building an
event management platform.

7994
05:52:19,344 --> 05:52:21,590
And so Donn and Janet
and Cavita are both going

7995
05:52:21,590 --> 05:52:23,990
to these two events, but
there's some differences here.

7996
05:52:23,990 --> 05:52:27,050
But you wanna find all the
unique people that are there.

7997
05:52:27,050 --> 05:52:30,100
So this could happen for
one, two lists, 100 lists,

7998
05:52:30,100 --> 05:52:32,260
and you need to find out
which ones are unique.

7999
05:52:32,260 --> 05:52:33,930
Now, there is a built-in
operator to do that.

8000
05:52:33,930 --> 05:52:36,410
So say val, unique values.

8001
05:52:37,850 --> 05:52:40,820
And all we really have to
do is say people.union,

8002
05:52:41,690 --> 05:52:43,000
more people.

8003
05:52:43,000 --> 05:52:46,770
And what union will do is
a return a set containing

8004
05:52:46,770 --> 05:52:48,950
all the distinct elements
from both collections.

8005
05:52:48,950 --> 05:52:50,980
And it's gonna return a set of the values.

8006
05:52:50,980 --> 05:52:53,360
So a set of whatever type it is,

8007
05:52:53,360 --> 05:52:55,370
and this tastes we're using persons.

8008
05:52:55,370 --> 05:52:57,200
So what it will do is
it'll look inside of here

8009
05:52:57,200 --> 05:52:59,430
using the equality
operations on the data class,

8010
05:52:59,430 --> 05:53:01,910
which it checks, you know,
the values, et cetera.

8011
05:53:01,910 --> 05:53:04,550
And it'll check to make sure
that there's no duplicate.

8012
05:53:04,550 --> 05:53:09,040
And so now, if we were to run
this, so we'd say print ln,

8013
05:53:09,890 --> 05:53:13,990
unique values, we run this,
we'll see that we will only have

8014
05:53:13,990 --> 05:53:17,140
Donn inside of here once,
Jake is only in here once,

8015
05:53:17,140 --> 05:53:20,140
Janet's only here once to
Cavita, Jumo, Kevin and Kathleen.

8016
05:53:20,140 --> 05:53:23,110
There is no duplicates inside of here.

8017
05:53:23,110 --> 05:53:25,920
So even if you were to add
another one here, say a union

8018
05:53:25,920 --> 05:53:29,330
something else, and you could say person,

8019
05:53:29,330 --> 05:53:30,910
and again, you'd say maybe Donn again.

8020
05:53:30,910 --> 05:53:35,000
So the third time that Donn
is gonna be inside of there,

8021
05:53:35,000 --> 05:53:36,990
you'll see that it's still only added once

8022
05:53:36,990 --> 05:53:41,040
because the union operator will return you

8023
05:53:41,040 --> 05:53:43,610
the set containing all
the distinct elements

8024
05:53:43,610 --> 05:53:45,050
in both collections.

8025
05:53:45,050 --> 05:53:48,070
And that's how you can merge
multiple different lists

8026
05:53:48,070 --> 05:53:50,650
and return unique elements
across all of them

8027
05:53:50,650 --> 05:53:52,050
into one final set.

8028
05:53:53,440 --> 05:53:55,940
When working with list of
data, it's very often to want

8029
05:53:55,940 --> 05:53:59,580
to know the index of an item
as you're iterating over it.

8030
05:53:59,580 --> 05:54:03,090
With Kotlin's built-in for each iterator,

8031
05:54:03,090 --> 05:54:04,810
you don't have access to the index.

8032
05:54:04,810 --> 05:54:07,840
You only have access to the
value, which is the person.

8033
05:54:07,840 --> 05:54:10,410
However, there is an
overload that we can use

8034
05:54:10,410 --> 05:54:11,560
for each indexed.

8035
05:54:12,410 --> 05:54:13,960
This will allow us to use,

8036
05:54:13,960 --> 05:54:16,050
get us the index of the current operation

8037
05:54:16,050 --> 05:54:18,430
and the person at that given index.

8038
05:54:18,430 --> 05:54:20,820
So for example, if we
were to print line this,

8039
05:54:20,820 --> 05:54:22,560
we could see something like this:

8040
05:54:22,560 --> 05:54:25,210
it's an index and we'd use
string interpolation here.

8041
05:54:26,459 --> 05:54:27,650
And then we could say person,

8042
05:54:29,976 --> 05:54:33,500
and if we were to run this
and actually we can use move

8043
05:54:33,500 --> 05:54:36,340
the curly braces there
because the class will give us

8044
05:54:36,340 --> 05:54:37,590
a good two string method.

8045
05:54:39,054 --> 05:54:40,280
We'll see, when we print this out here,

8046
05:54:41,263 --> 05:54:43,140
we have the index zero
and the person objects

8047
05:54:43,140 --> 05:54:45,070
that's associated with the index zero.

8048
05:54:45,070 --> 05:54:47,010
Now this is very useful
if you're doing operations

8049
05:54:47,010 --> 05:54:49,580
in which you need the know the
index of a particular value

8050
05:54:49,580 --> 05:54:52,140
inside of that data structure
for whatever reason,

8051
05:54:52,140 --> 05:54:53,980
you now have the index
and you have the value

8052
05:54:53,980 --> 05:54:56,200
that's associated to that
given index to perform

8053
05:54:56,200 --> 05:54:58,020
whatever operation that you need.

8054
05:54:58,020 --> 05:54:59,410
So if you need that, you'll wanna use

8055
05:54:59,410 --> 05:55:02,360
the for each index operator.

8056
05:55:02,360 --> 05:55:05,007
We're using the lambda
expression version here.

8057
05:55:05,007 --> 05:55:07,560
You may also have seen us
with parentheses like this.

8058
05:55:07,560 --> 05:55:08,610
This will also work.

8059
05:55:08,610 --> 05:55:11,370
However, you'll notice that
IntelliJ or Android Studio,

8060
05:55:11,370 --> 05:55:13,800
whatever you're using,
will give you a hint here

8061
05:55:13,800 --> 05:55:15,280
that it does not need that.

8062
05:55:15,280 --> 05:55:16,410
This is a lambda argument

8063
05:55:16,410 --> 05:55:18,460
so it can be moved out of the parentheses.

8064
05:55:18,460 --> 05:55:20,400
Basically just remove the parentheses

8065
05:55:20,400 --> 05:55:22,460
and the lambda expression is parsed in

8066
05:55:22,460 --> 05:55:23,720
via the Sam operations.

8067
05:55:24,880 --> 05:55:26,880
And that's how you use for each indexed.

8068
05:55:27,920 --> 05:55:31,240
Arranging Kotlin allows us
to specify a range of values.

8069
05:55:32,334 --> 05:55:34,730
So here I'm specifying a range
of values from one to five

8070
05:55:34,730 --> 05:55:37,960
saying if the I is in within
this range of one to five,

8071
05:55:37,960 --> 05:55:42,850
then print the value yes,
otherwise, print the value no.

8072
05:55:42,850 --> 05:55:46,090
So if we were to change
this to 12 and rerun this,

8073
05:55:46,090 --> 05:55:47,790
we would see that the value of 12,

8074
05:55:48,704 --> 05:55:51,310
because I is not within
this range of one to five.

8075
05:55:51,310 --> 05:55:53,520
We can also say for J,

8076
05:55:58,320 --> 05:56:01,760
this will give us a range very
much a for loop variable now.

8077
05:56:01,760 --> 05:56:02,900
So I can say print ln.

8078
05:56:04,376 --> 05:56:07,170
So JN zero to 10, the
range again is zero to 10.

8079
05:56:07,170 --> 05:56:08,820
This is the range that
we're working within.

8080
05:56:08,820 --> 05:56:11,330
And so we could say J
and when we print this,

8081
05:56:12,537 --> 05:56:15,130
we're gonna see one through
10 printed down here.

8082
05:56:15,130 --> 05:56:18,280
Now, again, this is, if you're
familiar with the four loops

8083
05:56:18,280 --> 05:56:21,170
inside of Kotlin, you can
also provide stepping.

8084
05:56:21,170 --> 05:56:23,380
So I might decide to
say, I wanna step by two,

8085
05:56:23,380 --> 05:56:26,040
meaning that instead of
incrementing the value of one

8086
05:56:26,040 --> 05:56:29,790
for the J counter variable,
it's gonna increment by two.

8087
05:56:29,790 --> 05:56:33,580
So it's basically in this
range from zero to 10,

8088
05:56:33,580 --> 05:56:36,910
I want you to execute something
if J is within that value,

8089
05:56:36,910 --> 05:56:38,970
execute some code, count from zero to 10.

8090
05:56:38,970 --> 05:56:41,830
And then I want you to make a step of two,

8091
05:56:41,830 --> 05:56:45,490
which as we're gonna see down
here iterates from zero to two

8092
05:56:45,490 --> 05:56:47,710
to four, six, eight, 10.

8093
05:56:47,710 --> 05:56:49,940
And so every once in a
while, you will use ranges.

8094
05:56:49,940 --> 05:56:52,520
And of course these values
can be variables, et cetera.

8095
05:56:52,520 --> 05:56:55,780
So this is a very simple
implementation of how you can use

8096
05:56:55,780 --> 05:56:57,780
ranges to count inside of Kotlin.

8097
05:56:58,930 --> 05:57:02,470
A map is a very common data
structure in computer science.

8098
05:57:02,470 --> 05:57:04,560
A lot of times this would
be called a map hash map

8099
05:57:04,560 --> 05:57:05,500
or dictionary.

8100
05:57:05,500 --> 05:57:08,380
And basically it's a key
value pair that you can store

8101
05:57:08,380 --> 05:57:09,510
inside of a data structure.

8102
05:57:09,510 --> 05:57:11,180
And this is a map data structure.

8103
05:57:11,180 --> 05:57:14,880
To create one, you can use
the map of helper function

8104
05:57:14,880 --> 05:57:17,930
and this will actually let
you create an immutable map

8105
05:57:17,930 --> 05:57:18,763
of values.

8106
05:57:18,763 --> 05:57:21,740
And what this means is we'll
have a map where the keys

8107
05:57:21,740 --> 05:57:24,370
are strings and the values are strings.

8108
05:57:24,370 --> 05:57:27,404
The keys over here are over here,

8109
05:57:27,404 --> 05:57:29,690
which means NY maps to New York,

8110
05:57:29,690 --> 05:57:33,770
NJ maps to New Jersey and
CA maps to California.

8111
05:57:33,770 --> 05:57:36,800
And of course you can continue
mapping all these down there.

8112
05:57:36,800 --> 05:57:39,020
Then if you wanna get that
value, it's pretty easy.

8113
05:57:39,020 --> 05:57:41,720
You're gonna say, do say states.get,

8114
05:57:44,000 --> 05:57:45,750
and you can parse in the value of NY.

8115
05:57:45,750 --> 05:57:47,370
And then of course, we
would print line this

8116
05:57:47,370 --> 05:57:49,350
and see what the result is.

8117
05:57:49,350 --> 05:57:51,110
Now, as you're executing this,

8118
05:57:52,018 --> 05:57:52,851
you'll see that New
York has been returned.

8119
05:57:52,851 --> 05:57:56,690
However, if I were to type,
let's go FL for Florida

8120
05:57:56,690 --> 05:57:58,610
and run it, we're gonna
see that's not in there

8121
05:57:58,610 --> 05:58:00,860
and a null value is returned.

8122
05:58:00,860 --> 05:58:04,880
That is because it will
return the corresponding value

8123
05:58:04,880 --> 05:58:07,660
if it exists or null if
it's not present in the map.

8124
05:58:07,660 --> 05:58:10,540
So it's very often that
sometimes you'll wanna say

8125
05:58:10,540 --> 05:58:13,860
get or default if you
want a value to be known.

8126
05:58:13,860 --> 05:58:16,320
So I don't wanna work
with a nullable type.

8127
05:58:16,320 --> 05:58:18,790
So I'm gonna say unknown value.

8128
05:58:20,200 --> 05:58:24,350
And then at that point,
when I run FL we'll get back

8129
05:58:24,350 --> 05:58:25,680
unknown value that's printed out

8130
05:58:25,680 --> 05:58:27,900
down to the screen down here.

8131
05:58:27,900 --> 05:58:29,520
So that's one thing you can do.

8132
05:58:30,406 --> 05:58:32,150
You can also use get or else.

8133
05:58:32,150 --> 05:58:36,590
And or else is going to get
or else is gonna allow you

8134
05:58:36,590 --> 05:58:39,010
to provide a function
where you can actually

8135
05:58:40,330 --> 05:58:45,330
return some code, which could
be whatever, could be foo.

8136
05:58:46,470 --> 05:58:48,120
This is function that you're gonna call

8137
05:58:48,120 --> 05:58:51,170
that it's going to be invoked
when the default thing,

8138
05:58:51,170 --> 05:58:53,020
nothing can be found here to match FL.

8139
05:58:53,020 --> 05:58:54,890
So if I were to run this,

8140
05:58:54,890 --> 05:58:57,150
we're going to see that
when we say, get her else,

8141
05:58:57,150 --> 05:58:59,420
foo is being returned.

8142
05:58:59,420 --> 05:59:03,280
Now back to the original
method here of FL,

8143
05:59:03,280 --> 05:59:07,190
we saw that the squiggly
here inside of IntelliJ

8144
05:59:07,190 --> 05:59:09,480
is saying that we can
improve this through the,

8145
05:59:09,480 --> 05:59:12,640
basically the code improvements.

8146
05:59:12,640 --> 05:59:16,520
And when we press the light
bulb here to get that,

8147
05:59:16,520 --> 05:59:19,030
or over here, I'll be
able to just turn this

8148
05:59:19,030 --> 05:59:20,210
into an indexing operator.

8149
05:59:20,210 --> 05:59:23,510
So basically saying, hey,
state's just like an array index.

8150
05:59:23,510 --> 05:59:26,210
Give me the value for the key of FL.

8151
05:59:26,210 --> 05:59:29,003
And then of course it returns
back a nullable string,

8152
05:59:29,003 --> 05:59:30,060
and we're gonna get back null here.

8153
05:59:30,935 --> 05:59:32,090
A couple of other things
that are very useful

8154
05:59:32,090 --> 05:59:33,700
inside of matches.

8155
05:59:33,700 --> 05:59:36,220
You can check to see if a key is there,

8156
05:59:36,220 --> 05:59:38,290
so you can say, is there a key there,

8157
05:59:38,290 --> 05:59:39,640
returns a Boolean value.

8158
05:59:39,640 --> 05:59:41,470
If the key is there it'll return true.

8159
05:59:41,470 --> 05:59:43,670
We can also say, hey,
does this value exist?

8160
05:59:43,670 --> 05:59:47,250
And we know the value NY
does not exist as the values,

8161
05:59:47,250 --> 05:59:49,410
'cause the values are here
in New York, New Jersey,

8162
05:59:49,410 --> 05:59:50,990
California, those are the values.

8163
05:59:50,990 --> 05:59:53,240
These are the keys.

8164
05:59:53,240 --> 05:59:54,940
And so the values don't container.

8165
05:59:55,825 --> 05:59:56,890
So we can do that.

8166
05:59:56,890 --> 05:59:58,410
And so there's a whole
bunch of operations.

8167
05:59:58,410 --> 06:00:00,100
And if you're interested
to see what you can do,

8168
06:00:00,100 --> 06:00:03,540
because a map is part of the
collections library in Kotlin,

8169
06:00:03,540 --> 06:00:05,840
so we can actually get all the entries.

8170
06:00:05,840 --> 06:00:08,480
So, which is gonna be a set,
because remember, in a map,

8171
06:00:08,480 --> 06:00:10,470
we can't have a duplicate.

8172
06:00:10,470 --> 06:00:12,150
We can't have duplicate keys.

8173
06:00:12,150 --> 06:00:13,690
So key has to be unique.

8174
06:00:13,690 --> 06:00:15,550
So when get back to this result,

8175
06:00:15,550 --> 06:00:18,070
if we print this, this
will be a set of strings.

8176
06:00:19,246 --> 06:00:21,010
And we can see here,
there's all of our entries,

8177
06:00:21,010 --> 06:00:22,630
which is gonna be, for all the,

8178
06:00:23,544 --> 06:00:24,377
assuming it's gonna have
the keys and the values,

8179
06:00:24,377 --> 06:00:25,210
all the entries.

8180
06:00:26,140 --> 06:00:29,040
And then what we can do here
is also, we can see the keys.

8181
06:00:30,270 --> 06:00:31,330
So if we wanna look at the keys,

8182
06:00:31,330 --> 06:00:32,750
you can also inspect all of the keys,

8183
06:00:32,750 --> 06:00:35,100
which will return back NY, NJ and CA,

8184
06:00:35,100 --> 06:00:39,240
and of course you can inspect
the values across the board.

8185
06:00:39,240 --> 06:00:41,590
So you can start working with
all of these different types

8186
06:00:41,590 --> 06:00:42,920
of things in a map.

8187
06:00:42,920 --> 06:00:46,600
Now, that's how you can kind
of set up a regular immutable

8188
06:00:46,600 --> 06:00:47,910
map inside of Kotlin.

8189
06:00:49,460 --> 06:00:52,110
Just like lists, which can have a mutable

8190
06:00:52,110 --> 06:00:55,440
and immutable lists, you
can have immutable maps

8191
06:00:55,440 --> 06:00:56,840
and mutable maps.

8192
06:00:56,840 --> 06:01:00,210
And so if you were to create your map,

8193
06:01:00,210 --> 06:01:03,030
so we can just call this map,
actually call this items.

8194
06:01:04,180 --> 06:01:05,760
You can create a mutable map.

8195
06:01:06,630 --> 06:01:09,390
And what a mutable map
will do is it'll allow you

8196
06:01:09,390 --> 06:01:12,780
to add and remove items to the map.

8197
06:01:12,780 --> 06:01:14,240
So what we could say here again,

8198
06:01:14,240 --> 06:01:19,240
we could do the New York to New York.

8199
06:01:19,710 --> 06:01:21,510
And again, this is just gonna create a map

8200
06:01:21,510 --> 06:01:25,290
of basically state abbreviations
in the United States

8201
06:01:25,290 --> 06:01:29,590
to the actual full spelled out version.

8202
06:01:29,590 --> 06:01:31,410
And we'll just do the
same three that we have

8203
06:01:31,410 --> 06:01:33,320
for the immutable version,

8204
06:01:35,660 --> 06:01:38,260
which are New York,
New Jersey, California.

8205
06:01:38,260 --> 06:01:39,460
And of course you could
have all of them in here

8206
06:01:39,460 --> 06:01:40,860
if you want it to.

8207
06:01:40,860 --> 06:01:43,970
Now, at this point in time,
if I wanted to remove an item,

8208
06:01:49,190 --> 06:01:50,550
I would use the put command.

8209
06:01:50,550 --> 06:01:51,900
And then inside of the put command,

8210
06:01:51,900 --> 06:01:53,570
I would provide another key.

8211
06:01:53,570 --> 06:01:56,210
And so I could say TX and then the value,

8212
06:01:56,210 --> 06:01:58,010
what it would be, it would be Texas.

8213
06:01:59,410 --> 06:02:01,510
Now, notice how we have
a little squiggly here.

8214
06:02:01,510 --> 06:02:05,050
What this is telling us
is that the put method

8215
06:02:05,050 --> 06:02:07,040
can be converted into an assignment call.

8216
06:02:07,040 --> 06:02:10,118
So I'll hit Alt + Enter or
you can also just click on

8217
06:02:10,118 --> 06:02:12,960
the little light bulb right here

8218
06:02:12,960 --> 06:02:15,880
when you put my cursor here, there you go.

8219
06:02:18,265 --> 06:02:19,740
And we can just say, it looks like that.

8220
06:02:19,740 --> 06:02:21,060
I'm gonna leave it for put for now,

8221
06:02:21,060 --> 06:02:23,010
just 'cause it reads a little bit better

8222
06:02:23,880 --> 06:02:27,020
and we can print line so we
can see what this looks like.

8223
06:02:28,000 --> 06:02:31,380
And if we run this, we'll
see down in the output window

8224
06:02:31,380 --> 06:02:35,060
that we have one, two, three, four items.

8225
06:02:35,060 --> 06:02:38,700
So we said New York, New
Jersey, California, and Texas.

8226
06:02:38,700 --> 06:02:41,210
Now, if for some reason, I
wanted to, whatever reason,

8227
06:02:41,210 --> 06:02:43,510
to remove an item from
the state of structure,

8228
06:02:44,350 --> 06:02:49,230
I could say items remove
and all I have to do

8229
06:02:49,230 --> 06:02:50,430
is provide the key here.

8230
06:02:51,342 --> 06:02:52,250
And now to provide a key, I'm gonna say,

8231
06:02:52,250 --> 06:02:54,350
all right, I'd like to remove New York.

8232
06:02:54,350 --> 06:02:56,460
And then of course, I
wanna go ahead and validate

8233
06:02:56,460 --> 06:02:58,200
that our items were removed.

8234
06:02:59,720 --> 06:03:00,880
And if we go ahead and run that again,

8235
06:03:00,880 --> 06:03:04,480
we'll see that we now have the first call,

8236
06:03:04,480 --> 06:03:09,480
had all four items and the
next call had removed New York.

8237
06:03:13,420 --> 06:03:16,070
Now something interesting will happen here

8238
06:03:16,070 --> 06:03:16,990
inside of your code.

8239
06:03:16,990 --> 06:03:18,740
If you already have this list,

8240
06:03:18,740 --> 06:03:22,520
let's go ahead and remove
these we'll leave Texas.

8241
06:03:22,520 --> 06:03:24,370
And we decide to put an item in here.

8242
06:03:26,130 --> 06:03:28,340
And we decided to put New Jersey in,

8243
06:03:28,340 --> 06:03:31,720
though we already have New
Jersey up here on line five.

8244
06:03:31,720 --> 06:03:35,260
If we decide to put New
Jersey in, and we say Joisey,

8245
06:03:35,260 --> 06:03:38,030
because sometimes that's
how they say it out here.

8246
06:03:38,030 --> 06:03:39,380
And we print line.

8247
06:03:39,380 --> 06:03:41,740
We're gonna notice an interesting
thing will happen here.

8248
06:03:41,740 --> 06:03:42,930
And what happens is,

8249
06:03:44,291 --> 06:03:48,510
is that New Jersey is actually
replaced inside of the race.

8250
06:03:48,510 --> 06:03:51,770
So instead of New Jersey,
it's replaced with New Joisey.

8251
06:03:51,770 --> 06:03:54,300
So perhaps that was a mistake in our code.

8252
06:03:54,300 --> 06:03:56,440
Now it's perhaps created
a weird side effect

8253
06:03:56,440 --> 06:03:57,440
where there's a bug.

8254
06:03:58,926 --> 06:03:59,759
Now there's something you can do

8255
06:03:59,759 --> 06:04:00,592
to kind of help prevent this.

8256
06:04:00,592 --> 06:04:03,610
So if you thought that
New Jersey was there

8257
06:04:03,610 --> 06:04:05,330
and you didn't mean to overwrite it,

8258
06:04:05,330 --> 06:04:08,950
or you don't wanna override
it, you can say put if absent.

8259
06:04:08,950 --> 06:04:10,550
And what put, so if we run this,

8260
06:04:13,100 --> 06:04:15,370
we'll see is New Jersey
was not overwritten.

8261
06:04:15,370 --> 06:04:20,010
Why, because put if absent
will only put the item there

8262
06:04:20,010 --> 06:04:22,210
if we scroll up, we see
this, if the specified key

8263
06:04:22,210 --> 06:04:24,260
is not already associated with the value,

8264
06:04:25,470 --> 06:04:27,520
otherwise it'll return the current value.

8265
06:04:28,450 --> 06:04:31,420
So if we look back at
the code here, again,

8266
06:04:31,420 --> 06:04:32,950
it returned a value.

8267
06:04:32,950 --> 06:04:34,100
So what does it return?

8268
06:04:36,181 --> 06:04:37,210
Let's go ahead and check it out.

8269
06:04:38,050 --> 06:04:41,570
So say print line and
what this will return

8270
06:04:41,570 --> 06:04:43,910
is gonna be the item that
was currently existing

8271
06:04:43,910 --> 06:04:45,180
already for that key.

8272
06:04:46,320 --> 06:04:47,520
And so we're saying, hey,
put something in there

8273
06:04:47,520 --> 06:04:48,990
if it's absent.

8274
06:04:48,990 --> 06:04:51,180
Hey, I'm trying to put
something into this map

8275
06:04:51,180 --> 06:04:55,010
that has the key NJ,
and I wanna use Joisey.

8276
06:04:55,010 --> 06:04:56,340
And what it comes back is saying,

8277
06:04:56,340 --> 06:04:58,800
Well, just letting you know,
we already have something

8278
06:04:58,800 --> 06:05:01,220
in there, so we're gonna
go ahead and show you

8279
06:05:01,220 --> 06:05:03,150
what that is, and we're
not going to overwrite it.

8280
06:05:03,150 --> 06:05:05,970
So that's very useful, so
you don't overwrite anything.

8281
06:05:07,410 --> 06:05:11,120
Now on the flip side, let's
say for whatever reason,

8282
06:05:12,140 --> 06:05:16,210
we realized there are some,
you're allowing the user

8283
06:05:16,210 --> 06:05:20,740
to edit something on a screen
and they are removing items

8284
06:05:20,740 --> 06:05:22,230
and putting them et cetera.

8285
06:05:22,230 --> 06:05:25,490
And you want them to allow
them to remove something,

8286
06:05:25,490 --> 06:05:27,880
but only if the key and the value match.

8287
06:05:27,880 --> 06:05:31,520
So if I remove this, if I
say remove, what will happen

8288
06:05:31,520 --> 06:05:35,070
is New Jersey will be
removed from the list.

8289
06:05:35,070 --> 06:05:37,640
And we can see that when we run this.

8290
06:05:37,640 --> 06:05:42,080
But what if I wanna keep
New Jersey inside of there,

8291
06:05:42,080 --> 06:05:45,140
but I only wanna remove it
if somebody accidentally

8292
06:05:45,140 --> 06:05:46,940
kind of got wise was a wise guy and said,

8293
06:05:46,940 --> 06:05:49,280
"Hey, the data is Joisey."

8294
06:05:49,280 --> 06:05:53,760
So what this says is,
"Hey, only remove this key

8295
06:05:53,760 --> 06:05:56,030
"if its value is Joisey."

8296
06:05:56,030 --> 06:05:58,370
So let's go ahead and run
this and what we'll see down

8297
06:05:58,370 --> 06:06:02,040
the last print line is that
New Jersey was not removed.

8298
06:06:02,040 --> 06:06:04,630
So this key and the value stayed put,

8299
06:06:04,630 --> 06:06:08,670
because while it did find
a key for New Jersey,

8300
06:06:08,670 --> 06:06:09,930
it didn't match the value.

8301
06:06:09,930 --> 06:06:12,080
So the value Joisey was not removed.

8302
06:06:13,320 --> 06:06:15,240
Also sometimes during development
you'll need to retrieve

8303
06:06:15,240 --> 06:06:18,430
an item, but sometimes it won't be there,

8304
06:06:18,430 --> 06:06:19,790
but you do expect it to be there.

8305
06:06:19,790 --> 06:06:22,850
And if it's not there, you
would like to add it to the map.

8306
06:06:22,850 --> 06:06:24,800
There's actually something you can use

8307
06:06:24,800 --> 06:06:27,600
and that's called get or put,

8308
06:06:27,600 --> 06:06:31,850
and what that means returns
the value for the given key.

8309
06:06:31,850 --> 06:06:33,190
If the key is not found the map,

8310
06:06:33,190 --> 06:06:35,460
it calls a default value
function and puts its result

8311
06:06:35,460 --> 06:06:38,270
into the map under the
given key and returns it.

8312
06:06:38,270 --> 06:06:42,713
So if we go back here, so get or put

8313
06:06:46,100 --> 06:06:48,650
we're gonna take this key,
and we're gonna say, UT,

8314
06:06:51,142 --> 06:06:54,930
we'll say Utah, and notice
how it's giving us an error,

8315
06:06:54,930 --> 06:06:57,310
because it actually needs
to be an expression.

8316
06:06:57,310 --> 06:06:58,950
So it's a lambda
expression because perhaps

8317
06:06:58,950 --> 06:07:01,850
this needs to be a method that
goes out and does something

8318
06:07:02,730 --> 06:07:04,440
or a bunch of different things.

8319
06:07:04,440 --> 06:07:07,131
So it gives us the ability to do that.

8320
06:07:07,131 --> 06:07:08,420
So we're say Utah, and if we print this,

8321
06:07:09,351 --> 06:07:11,640
what we're now going to see
is because we have not ever

8322
06:07:11,640 --> 06:07:16,340
added Utah to this map, we put Texas in,

8323
06:07:16,340 --> 06:07:17,530
and now we're gonna basically say,

8324
06:07:17,530 --> 06:07:22,445
"Hey, map, get me Utah, but
if Utah does not exist for UT

8325
06:07:22,445 --> 06:07:23,900
"for this key UT, go
ahead and insert it for me

8326
06:07:23,900 --> 06:07:24,733
"and return it."

8327
06:07:24,733 --> 06:07:27,420
So, which we could
basically do inside of here.

8328
06:07:27,420 --> 06:07:29,910
So we say, val result equals this.

8329
06:07:29,910 --> 06:07:33,900
And then we would say print
line and what the result

8330
06:07:33,900 --> 06:07:36,400
would be would just be that, that value.

8331
06:07:36,400 --> 06:07:39,280
So when we run this here, we're
gonna see Utah was returned

8332
06:07:39,280 --> 06:07:42,390
because it's basically
saying, "Hey, give me the key.

8333
06:07:42,390 --> 06:07:44,960
"Give me the value for the key UT."

8334
06:07:44,960 --> 06:07:48,680
And behind the scenes,
the mutable map is saying,

8335
06:07:48,680 --> 06:07:51,010
"I don't have this in here,
let me go ahead and insert it.

8336
06:07:51,010 --> 06:07:51,970
"And now I've inserted it.

8337
06:07:51,970 --> 06:07:53,080
"I'm going to return it back to you."

8338
06:07:53,080 --> 06:07:55,490
So there's one little
line of code can save you

8339
06:07:55,490 --> 06:07:58,400
a number of lines of
code if you need to add

8340
06:07:58,400 --> 06:08:00,720
and remove things to a value.

8341
06:08:00,720 --> 06:08:03,750
Now of course, this is
a map, it's mutable map.

8342
06:08:03,750 --> 06:08:06,180
You can do all different
types of things with it.

8343
06:08:06,180 --> 06:08:08,690
If you would like to clear
it at this point in time.

8344
06:08:08,690 --> 06:08:10,490
And then we can say, so
here, we're gonna print

8345
06:08:10,490 --> 06:08:12,600
all the items and we'll print it again.

8346
06:08:12,600 --> 06:08:15,130
The items that clear is
gonna go ahead and clear

8347
06:08:15,130 --> 06:08:16,580
all the items out of the map.

8348
06:08:17,568 --> 06:08:20,420
So it's just a very, very
kind of just typical map,

8349
06:08:20,420 --> 06:08:22,250
hash map, dictionary, object,

8350
06:08:22,250 --> 06:08:24,480
data structure that you
used to working with.

8351
06:08:24,480 --> 06:08:26,450
And that's how you can work very easily

8352
06:08:26,450 --> 06:08:28,280
with a mutable map in Kotlin.

8353
06:08:29,220 --> 06:08:32,120
Retrieving values from a map
is usually pretty simple.

8354
06:08:32,120 --> 06:08:34,800
And you've seen this
probably in other lessons.

8355
06:08:34,800 --> 06:08:37,610
You can retrieve the
value via the get method,

8356
06:08:37,610 --> 06:08:40,710
what you could just say NY
here or this will return you

8357
06:08:40,710 --> 06:08:42,930
your result as we can see here,

8358
06:08:42,930 --> 06:08:47,930
or you can actually go ahead
and use the indexing operator

8359
06:08:48,560 --> 06:08:49,950
to return the value.

8360
06:08:49,950 --> 06:08:52,800
Now, there are a bunch of
other things that you can do

8361
06:08:52,800 --> 06:08:56,830
because a mutable map inside of Kotlin

8362
06:08:57,770 --> 06:09:00,840
is inside of the collections library.

8363
06:09:00,840 --> 06:09:03,230
And so there's a bunch of
different types of collections.

8364
06:09:03,230 --> 06:09:05,417
And the map is one of the most common

8365
06:09:05,417 --> 06:09:06,420
that you're going to end up using.

8366
06:09:06,420 --> 06:09:09,990
Now there's a bunch of different
utilities that you can use

8367
06:09:09,990 --> 06:09:12,350
on a map, just like for a list and arrays

8368
06:09:12,350 --> 06:09:15,780
and other common collection data types.

8369
06:09:15,780 --> 06:09:19,680
So if we say items dot,
the best recommendation

8370
06:09:19,680 --> 06:09:21,930
I can give to you is
to start looking around

8371
06:09:21,930 --> 06:09:24,310
at all the different things it can do.

8372
06:09:24,310 --> 06:09:27,610
Now, one of the things that
I am really happy about

8373
06:09:27,610 --> 06:09:29,300
is actually the, any method.

8374
06:09:29,300 --> 06:09:30,490
And any method basically says,

8375
06:09:30,490 --> 06:09:35,020
"Hey, if there's any items
inside of this list."

8376
06:09:35,020 --> 06:09:39,330
And this is very useful,
especially in common expressions

8377
06:09:39,330 --> 06:09:41,870
where you're checking to see
if there's anything in there.

8378
06:09:41,870 --> 06:09:44,420
And so if you would like
to see if there's any items

8379
06:09:44,420 --> 06:09:46,660
in the map, then do something.

8380
06:09:46,660 --> 06:09:49,400
So you wanna do X, Y, or Z.

8381
06:09:49,400 --> 06:09:51,580
Otherwise, maybe you wanna prompt the user

8382
06:09:51,580 --> 06:09:54,690
to add some values because
they can't continue.

8383
06:09:54,690 --> 06:09:57,630
So any is a quick way to check
if there's anything in there.

8384
06:09:57,630 --> 06:09:59,550
Now there's other things in there as well,

8385
06:09:59,550 --> 06:10:01,130
which kind of is the opposite of that,

8386
06:10:01,130 --> 06:10:04,210
which is none basically says returns true

8387
06:10:04,210 --> 06:10:06,310
if the map has no entries.

8388
06:10:06,310 --> 06:10:08,950
So is there nothing in there, okay, cool.

8389
06:10:08,950 --> 06:10:12,070
Then at that point, it's
kind of the opposite of any.

8390
06:10:12,070 --> 06:10:17,070
So this would then operate
if there are no entries

8391
06:10:17,910 --> 06:10:20,860
and this operates if there are entries.

8392
06:10:20,860 --> 06:10:22,910
So these are very useful little operators

8393
06:10:23,867 --> 06:10:24,930
onsite of the map.

8394
06:10:25,920 --> 06:10:26,753
This is also very common
stuff that you're gonna see

8395
06:10:26,753 --> 06:10:28,360
instead of lists of stuff as well.

8396
06:10:29,750 --> 06:10:31,950
Now, if you also would
like to return values

8397
06:10:32,974 --> 06:10:33,810
outside of a map, again,
the most common way

8398
06:10:33,810 --> 06:10:37,900
is going to be using the
items.get or get or default

8399
06:10:37,900 --> 06:10:41,290
or get or put get, get
or else, get values.

8400
06:10:41,290 --> 06:10:44,110
You can actually iterate
over the values themselves.

8401
06:10:44,110 --> 06:10:46,870
You can also check to see if
it contains a particular key.

8402
06:10:46,870 --> 06:10:50,080
So does it contain the
key and NE for Nebraska,

8403
06:10:50,080 --> 06:10:54,770
this will return true because
we do have the key Nebraska

8404
06:10:54,770 --> 06:10:56,170
inside of here.

8405
06:10:56,170 --> 06:10:58,270
Now, one of the things
you have to be aware of

8406
06:10:58,270 --> 06:11:01,650
is when you're using the
common methods inside of here

8407
06:11:01,650 --> 06:11:04,390
is you may wanna say, "Hey, I wanna filter

8408
06:11:04,390 --> 06:11:05,223
"a particular value."

8409
06:11:05,223 --> 06:11:07,990
So let's say val result equals filter.

8410
06:11:07,990 --> 06:11:12,130
And I wanna say, item.key equals NY.

8411
06:11:12,130 --> 06:11:16,080
Now you may think, well, that's
gonna give me back my value.

8412
06:11:16,080 --> 06:11:19,090
Well, that's incorrect, you
actually gonna get back a map.

8413
06:11:19,090 --> 06:11:24,090
And we can see this simply
through the code help

8414
06:11:24,240 --> 06:11:25,440
inside of IntelliJ.

8415
06:11:25,440 --> 06:11:26,710
But let's just go ahead and print that out

8416
06:11:26,710 --> 06:11:28,830
to see what that looks like.

8417
06:11:28,830 --> 06:11:31,330
And when we look at the
output, we're gonna see

8418
06:11:31,330 --> 06:11:33,970
that we actually get back an actual map

8419
06:11:33,970 --> 06:11:36,050
and we can see it's a little
bit further if we actually

8420
06:11:36,050 --> 06:11:39,300
just filter this just by saying contains.

8421
06:11:40,750 --> 06:11:43,208
Let's go with the letter
N and we'll go ahead

8422
06:11:43,208 --> 06:11:44,270
and get rid of this NY here.

8423
06:11:45,200 --> 06:11:47,370
And what this is gonna do
is actually filter the map

8424
06:11:47,370 --> 06:11:52,370
and give us a new map back
that only has any of the items

8425
06:11:53,160 --> 06:11:55,960
in the map where the
key contains a letter N.

8426
06:11:55,960 --> 06:11:59,130
So we have New York, New
Jersey, New Mexico, Nevada,

8427
06:11:59,130 --> 06:12:00,340
Minnesota, and Nebraska.

8428
06:12:01,940 --> 06:12:03,630
If we were to change this
to the letter F of course,

8429
06:12:03,630 --> 06:12:05,010
we're only gonna get back Florida

8430
06:12:05,010 --> 06:12:06,990
because as we see down here,

8431
06:12:06,990 --> 06:12:11,410
because Florida is the only
one that has any of the keys

8432
06:12:11,410 --> 06:12:13,520
with the letter F inside of it.

8433
06:12:13,520 --> 06:12:18,520
Now that it's kind of a
very common filter method

8434
06:12:18,840 --> 06:12:20,970
you're used to seeing, but
you can also use filter keys.

8435
06:12:20,970 --> 06:12:24,830
And what that will do is
remove the requirement for you

8436
06:12:24,830 --> 06:12:28,260
to type keys, because
it is the key right now.

8437
06:12:28,260 --> 06:12:31,100
So now it is the key, we'll
run the same exact thing

8438
06:12:32,200 --> 06:12:33,200
and it'll filter out the keys.

8439
06:12:33,200 --> 06:12:35,260
And of course, we just get the letter N,

8440
06:12:35,260 --> 06:12:36,990
you can see that here,
so we can say filter key.

8441
06:12:36,990 --> 06:12:39,370
So you can start filtering
based upon the keys.

8442
06:12:39,370 --> 06:12:41,380
If you only wanna filter the values,

8443
06:12:41,380 --> 06:12:43,270
you can say filter values, same thing.

8444
06:12:43,270 --> 06:12:45,870
Does it contain the letter
N and that's only gonna be

8445
06:12:45,870 --> 06:12:47,170
a capital N, by the way.

8446
06:12:47,170 --> 06:12:50,085
And so we're gonna see
back, we do have New Mexico,

8447
06:12:50,085 --> 06:12:50,970
New Jersey, blah, blah, blah.

8448
06:12:50,970 --> 06:12:53,620
If we wanted it to be lowercase,

8449
06:12:54,760 --> 06:12:57,700
then we will kind of get all of our values

8450
06:12:57,700 --> 06:12:59,720
that have a letter N which
might be additional ones

8451
06:12:59,720 --> 06:13:01,950
like Minnesota and
California and so forth.

8452
06:13:01,950 --> 06:13:04,410
They're all gonna be
included inside of there.

8453
06:13:05,260 --> 06:13:07,090
So there are different
ways that you can work

8454
06:13:07,090 --> 06:13:07,923
with these things.

8455
06:13:07,923 --> 06:13:11,880
And of course, these are
basically collection operations.

8456
06:13:11,880 --> 06:13:13,770
So if we wanted to filter those values,

8457
06:13:13,770 --> 06:13:16,060
and then I wanted to
provide a map over it,

8458
06:13:16,060 --> 06:13:17,510
and I wanted to do something to that map,

8459
06:13:17,510 --> 06:13:19,790
and again, this is gonna
be a transform function

8460
06:13:19,790 --> 06:13:21,560
that's applied to this.

8461
06:13:21,560 --> 06:13:23,780
I could say at this point, I wanna take

8462
06:13:23,780 --> 06:13:28,190
the first three letters of the value.

8463
06:13:28,190 --> 06:13:31,070
And I just wanna go
ahead and map that value

8464
06:13:31,070 --> 06:13:32,514
and give me the value.

8465
06:13:32,514 --> 06:13:35,240
So if we did this and then
we did the substring of it,

8466
06:13:35,240 --> 06:13:37,930
and we said, all right, we'll
take the first three letters.

8467
06:13:37,930 --> 06:13:39,230
What would that look like?

8468
06:13:40,597 --> 06:13:41,430
You may think, all right,
I'm gonna get a map back.

8469
06:13:41,430 --> 06:13:42,350
No, you're actually gonna get a string

8470
06:13:42,350 --> 06:13:45,380
because we're just actually
taking the value here.

8471
06:13:46,220 --> 06:13:48,370
So you can take a look at
all of the different things.

8472
06:13:48,370 --> 06:13:53,370
So we can perhaps filter
keys, filter not to,

8473
06:13:53,400 --> 06:13:55,750
we could say map keys.

8474
06:13:55,750 --> 06:13:57,280
So there's different things
you can do inside of here.

8475
06:13:57,280 --> 06:13:59,740
So you can map the keys,
you can map the value.

8476
06:14:00,790 --> 06:14:04,450
So if we take a look at this,
it's going to be it.value.

8477
06:14:05,600 --> 06:14:08,193
And then what we're gonna
do here is we're gonna say

8478
06:14:08,193 --> 06:14:10,470
sub string zero, comma three.

8479
06:14:11,360 --> 06:14:14,390
And if we run this, what
we're gonna see back

8480
06:14:14,390 --> 06:14:18,590
is now we still have our map
intact because we're using

8481
06:14:18,590 --> 06:14:21,150
map of values instead of the map.

8482
06:14:21,150 --> 06:14:23,810
So previously again, let's go
ahead and comment this out,

8483
06:14:23,810 --> 06:14:26,570
just to see the difference
here, we use map,

8484
06:14:26,570 --> 06:14:29,190
and then we say it.value.sub string.

8485
06:14:31,053 --> 06:14:32,430
And we said, all right, we
wanna take zero to three.

8486
06:14:33,586 --> 06:14:35,570
And when we ran this, we just
got back a list of strings

8487
06:14:35,570 --> 06:14:38,370
that contain the first three
letters of all the states.

8488
06:14:38,370 --> 06:14:40,880
And the reason for that is
the map is just a mapping.

8489
06:14:40,880 --> 06:14:42,440
"Hey, this is a transform function

8490
06:14:42,440 --> 06:14:46,430
"applied to the map entry."

8491
06:14:46,430 --> 06:14:49,230
Which is basically each entry
inside of a mutable maps

8492
06:14:49,230 --> 06:14:51,130
is called a map entry.

8493
06:14:51,130 --> 06:14:52,880
And the map entry is a string.

8494
06:14:52,880 --> 06:14:55,260
As we can see here, it's
a string and a string.

8495
06:14:55,260 --> 06:14:57,260
So the key is a string,
the value is a string.

8496
06:14:57,260 --> 06:15:00,190
And I'm just saying, "Hey,
I wanna take the value.

8497
06:15:00,190 --> 06:15:02,630
"And whatever is returned
from this is what's going

8498
06:15:02,630 --> 06:15:04,220
"to be returned from the map."

8499
06:15:04,220 --> 06:15:06,780
So it's gonna be the first
three letters of the value,

8500
06:15:06,780 --> 06:15:08,949
and it'll be shoved back in there.

8501
06:15:08,949 --> 06:15:09,782
And now, if we kind of switch us around

8502
06:15:09,782 --> 06:15:13,030
and come put this out,
there we go and we run this,

8503
06:15:13,030 --> 06:15:15,280
now, of course, what then
that values is gonna do.

8504
06:15:15,280 --> 06:15:17,490
It's gonna say, "Hey, well, let's go ahead

8505
06:15:17,490 --> 06:15:21,090
"and take the values and allow
you to transform something

8506
06:15:21,090 --> 06:15:22,790
"on the value itself."

8507
06:15:22,790 --> 06:15:25,810
So returns a new map as we
see from the documentation

8508
06:15:25,810 --> 06:15:27,590
with entries having the keys of this map

8509
06:15:27,590 --> 06:15:30,530
and the values obtained by
applying the transform function.

8510
06:15:30,530 --> 06:15:33,520
So in short, what that
allows you to do is transform

8511
06:15:33,520 --> 06:15:36,170
the values, but maintain
your map structure.

8512
06:15:36,170 --> 06:15:40,170
You can do the same thing
with things like map.keys.

8513
06:15:40,170 --> 06:15:43,770
You could do some type of
transform function inside of here.

8514
06:15:43,770 --> 06:15:45,620
We don't wanna say map.value.

8515
06:15:48,634 --> 06:15:50,727
We would say map.key. I'm gonna say,

8516
06:15:52,980 --> 06:15:56,680
just make it all lowercase, to lowercase.

8517
06:15:56,680 --> 06:15:58,080
And now if we to run this,

8518
06:15:59,235 --> 06:16:01,050
we'll see that the result that
we get back is now we have

8519
06:16:01,050 --> 06:16:03,480
all of our keys have now
been turned into lowercase,

8520
06:16:03,480 --> 06:16:06,620
but we still maintain our map
structure and our map data.

8521
06:16:06,620 --> 06:16:08,760
So anytime you are working with a map

8522
06:16:08,760 --> 06:16:11,480
and you wanna kind of transform
the data, iterate over it,

8523
06:16:11,480 --> 06:16:13,350
you wanna go ahead and take
a look at some of the various

8524
06:16:13,350 --> 06:16:14,790
different map operators.

8525
06:16:14,790 --> 06:16:18,020
So you can do flat maps and
regular maps and map not nulls

8526
06:16:18,020 --> 06:16:19,400
and so forth like that.

8527
06:16:19,400 --> 06:16:20,520
Which are very useful.

8528
06:16:20,520 --> 06:16:23,140
But this is one way that you
can find and filter values

8529
06:16:23,140 --> 06:16:26,130
other than using the
traditional get and put methods

8530
06:16:26,130 --> 06:16:29,270
inside of the immutable
map and maps themselves.

8531
06:16:30,600 --> 06:16:33,420
One thing that you will eventually
run into in almost every

8532
06:16:33,420 --> 06:16:37,110
programming endeavor is the
point in time in which you have

8533
06:16:37,110 --> 06:16:39,050
to start working with null values.

8534
06:16:39,050 --> 06:16:41,620
Now, by default, you wanna
try to work with as many

8535
06:16:41,620 --> 06:16:44,290
non null values as possible,

8536
06:16:44,290 --> 06:16:46,790
which by default is why Kotlin makes you

8537
06:16:46,790 --> 06:16:48,880
specify nullable types.

8538
06:16:48,880 --> 06:16:51,720
However, there are times when
you perhaps need to perform

8539
06:16:51,720 --> 06:16:53,320
some type of map operation.

8540
06:16:54,740 --> 06:16:57,770
Now, for example, this map
might have you do something

8541
06:16:57,770 --> 06:17:00,435
and you have to call
into a certain function.

8542
06:17:00,435 --> 06:17:02,560
So we have a function down
here below and it's called

8543
06:17:02,560 --> 06:17:04,220
find value in web service.

8544
06:17:04,220 --> 06:17:06,890
Now this doesn't really find
a value in a web service,

8545
06:17:06,890 --> 06:17:10,400
but we are trying to
emulate that environment.

8546
06:17:10,400 --> 06:17:13,150
Let's assume for whatever
reason that all of your items

8547
06:17:13,150 --> 06:17:15,030
in your map, you need to
go up to a web service

8548
06:17:15,030 --> 06:17:17,780
and you need to ask it for some value

8549
06:17:17,780 --> 06:17:20,100
and you don't control the web service,

8550
06:17:20,100 --> 06:17:21,100
but for whatever reason,

8551
06:17:21,100 --> 06:17:23,660
that web service could
either return a null value,

8552
06:17:23,660 --> 06:17:26,360
or it could return back
that particular entry,

8553
06:17:26,360 --> 06:17:27,620
maybe it's been modified.

8554
06:17:27,620 --> 06:17:30,291
You know, it could be something different

8555
06:17:30,291 --> 06:17:32,290
or it's just gonna return
it back as a regular entry.

8556
06:17:32,290 --> 06:17:34,220
So if we were to print this out here,

8557
06:17:35,060 --> 06:17:38,310
what you might see at this
point in time is that we have

8558
06:17:38,310 --> 06:17:41,380
a bunch of weird values in here.

8559
06:17:41,380 --> 06:17:45,390
So it looks now we have
basically a map, which again,

8560
06:17:45,390 --> 06:17:49,360
is just going to return us
back a list of certain values

8561
06:17:49,360 --> 06:17:51,990
or whatever, we're
going over the map here,

8562
06:17:52,890 --> 06:17:55,180
and we're saying, hey, give me
all the values of everything.

8563
06:17:55,180 --> 06:17:57,350
So it's returning us back a list,

8564
06:17:57,350 --> 06:17:59,730
but this list has a bunch
of null values in it.

8565
06:17:59,730 --> 06:18:00,890
And we don't want these nulls

8566
06:18:00,890 --> 06:18:04,030
because now when we have a null value,

8567
06:18:04,030 --> 06:18:06,920
you can see that the entry
that's returned is a list

8568
06:18:06,920 --> 06:18:09,140
of all these different entries,

8569
06:18:09,140 --> 06:18:11,270
which makes it very difficult

8570
06:18:11,270 --> 06:18:12,340
because now we have to worry about

8571
06:18:12,340 --> 06:18:14,030
null checking and so forth.

8572
06:18:14,030 --> 06:18:16,410
And if your method that you're sending in

8573
06:18:16,410 --> 06:18:17,820
this result value into,

8574
06:18:17,820 --> 06:18:20,790
so if you have another method
down the line that says,

8575
06:18:20,790 --> 06:18:24,980
you wanna process results
and process values,

8576
06:18:24,980 --> 06:18:27,610
and that method for whatever
reason takes in a result,

8577
06:18:27,610 --> 06:18:29,360
and it takes in a non nullable type,

8578
06:18:29,360 --> 06:18:31,800
which is what you should try to aim for,

8579
06:18:31,800 --> 06:18:34,350
because nulls can create
a lot of problems for you.

8580
06:18:35,590 --> 06:18:37,810
That's gonna create a problem
here because you're parsing

8581
06:18:37,810 --> 06:18:39,550
in null values now you
have to do the checking,

8582
06:18:39,550 --> 06:18:40,440
now you have to remove them.

8583
06:18:40,440 --> 06:18:42,090
Well, thankfully, there's
a way around that.

8584
06:18:42,090 --> 06:18:46,130
So you could say map not null.

8585
06:18:46,130 --> 06:18:49,910
And what map not null will
do is if it encounters

8586
06:18:49,910 --> 06:18:52,500
any situation where a
null value is returned,

8587
06:18:52,500 --> 06:18:54,220
which is what it will do here,

8588
06:18:54,220 --> 06:18:58,870
and basically what that happens
is any time one of the keys

8589
06:18:58,870 --> 06:19:00,730
inside of our map starts with the letter N

8590
06:19:00,730 --> 06:19:02,300
we're just gonna return a null,

8591
06:19:02,300 --> 06:19:04,370
otherwise just return the entry.

8592
06:19:04,370 --> 06:19:07,690
So if it encounters, you know,
New York, New Jersey, Nevada,

8593
06:19:07,690 --> 06:19:10,620
Nebraska, anything like that,
it's gonna return a null,

8594
06:19:10,620 --> 06:19:11,580
which is what we saw here.

8595
06:19:11,580 --> 06:19:14,630
That's just, these are all
the null values that we see

8596
06:19:14,630 --> 06:19:17,920
down inside that were
returned back and so forth.

8597
06:19:17,920 --> 06:19:19,820
So we got them there, we
got there, we got it there.

8598
06:19:19,820 --> 06:19:23,880
We got them all over the
place and we don't want that.

8599
06:19:23,880 --> 06:19:25,700
We only want the values
that are not gonna be null,

8600
06:19:25,700 --> 06:19:27,520
because perhaps we need
to do some processing.

8601
06:19:27,520 --> 06:19:29,870
We don't have to worry
about nulls, et cetera.

8602
06:19:29,870 --> 06:19:31,270
So you can use map not null.

8603
06:19:32,208 --> 06:19:33,520
And if you run this,
now, what this will do is

8604
06:19:33,520 --> 06:19:36,157
Kotlin will say, all
right, we're gonna iterate

8605
06:19:36,157 --> 06:19:36,990
through the map, if we get a null,

8606
06:19:36,990 --> 06:19:38,420
we're just not gonna include it.

8607
06:19:38,420 --> 06:19:41,020
So here down on our result,
we could see that we do not

8608
06:19:41,020 --> 06:19:44,410
have any null values whatsoever.

8609
06:19:44,410 --> 06:19:47,560
These are just values that are not null.

8610
06:19:47,560 --> 06:19:52,560
So if you ever need to
have a list map, whatever,

8611
06:19:52,590 --> 06:19:54,520
and you don't want the
null values included in it,

8612
06:19:54,520 --> 06:19:56,390
but you do need to perform
some type of processing

8613
06:19:56,390 --> 06:19:59,290
over them, and a lot of
times you may not even have

8614
06:19:59,290 --> 06:20:00,810
the ability to change that code

8615
06:20:00,810 --> 06:20:03,330
because maybe it's inside
of a library somewhere

8616
06:20:03,330 --> 06:20:04,720
and it returns these null values,

8617
06:20:04,720 --> 06:20:07,590
you can use map not null
to ensure that the map

8618
06:20:07,590 --> 06:20:09,670
that you're going to get back is not null.

8619
06:20:09,670 --> 06:20:11,260
Now, of course, items might be missing

8620
06:20:11,260 --> 06:20:12,650
that you were expecting to be there,

8621
06:20:12,650 --> 06:20:15,460
but you'll have to handle
that as a case by case basis.

8622
06:20:15,460 --> 06:20:18,540
And that's how you can work
with a map and make sure

8623
06:20:18,540 --> 06:20:19,850
the items are not null.

8624
06:20:19,850 --> 06:20:21,550
This also works for lists as well.

8625
06:20:22,540 --> 06:20:25,340
Let's assume that you wanted
to generate a very large list

8626
06:20:25,340 --> 06:20:28,230
for whatever reason to do
some testing or perhaps

8627
06:20:28,230 --> 06:20:29,700
just to play around.

8628
06:20:29,700 --> 06:20:32,110
What you can use is the
generate sequence method

8629
06:20:32,110 --> 06:20:34,580
that's inside of the
Kotlin standard library,

8630
06:20:34,580 --> 06:20:36,020
which returns the sequence.

8631
06:20:36,020 --> 06:20:38,540
Now a sequence is a
completely different beast,

8632
06:20:38,540 --> 06:20:40,120
and there's some other videos that talk

8633
06:20:40,120 --> 06:20:42,740
about what sequences are
and why they're important,

8634
06:20:42,740 --> 06:20:45,600
but just know now that you
can generate a sequence

8635
06:20:45,600 --> 06:20:46,740
using this method.

8636
06:20:46,740 --> 06:20:48,500
We wanna seed it with the value of one.

8637
06:20:48,500 --> 06:20:51,320
And then for each iteration,
we want to do something,

8638
06:20:51,320 --> 06:20:53,260
we're gonna perform some
type of function here,

8639
06:20:53,260 --> 06:20:55,790
and that's gonna be the next
function that gets executed.

8640
06:20:55,790 --> 06:20:58,910
And all we're doing is we're
taking that existing value,

8641
06:20:58,910 --> 06:21:00,780
which is the integer value of one

8642
06:21:00,780 --> 06:21:02,800
and incrementing it plus one.

8643
06:21:02,800 --> 06:21:05,560
And then we say dot take,
and what take is going to do

8644
06:21:05,560 --> 06:21:06,750
is re return to sequence

8645
06:21:06,750 --> 06:21:08,900
containing those number of elements.

8646
06:21:08,900 --> 06:21:12,680
And basically we want to
do this 50 million times,

8647
06:21:12,680 --> 06:21:13,513
which is a lot.

8648
06:21:13,513 --> 06:21:15,250
And so again, this is a shorthand version

8649
06:21:15,250 --> 06:21:17,510
for making longer numbers.

8650
06:21:17,510 --> 06:21:20,250
Now, of course, we could
have done this too,

8651
06:21:20,250 --> 06:21:23,410
that would work, but
thankfully Kotlin allows us

8652
06:21:23,410 --> 06:21:25,790
to have some readability
with the underscores.

8653
06:21:25,790 --> 06:21:27,690
So we wanna do this 50 million times,

8654
06:21:27,690 --> 06:21:29,330
and then we wanna turn this into a list.

8655
06:21:29,330 --> 06:21:31,830
So now we have a list of 50 million items

8656
06:21:31,830 --> 06:21:35,540
that are all different, that
have different values in there.

8657
06:21:35,540 --> 06:21:37,160
And then let's say that
for whatever reason,

8658
06:21:37,160 --> 06:21:39,240
we wanted to do some operation.

8659
06:21:39,240 --> 06:21:42,150
Now we could do this operation here,

8660
06:21:42,150 --> 06:21:44,210
and now we have a very
large list to work with

8661
06:21:44,210 --> 06:21:45,560
to see what's gonna happen.

8662
06:21:46,885 --> 06:21:48,341
Now I'm gonna run this here, actually.

8663
06:21:48,341 --> 06:21:49,174
And then what you're going to see

8664
06:21:49,174 --> 06:21:50,580
is it's going to take awhile.

8665
06:21:50,580 --> 06:21:52,390
And so this is currently running.

8666
06:21:53,365 --> 06:21:55,680
We'll know when it's done,
when we see the print line

8667
06:21:55,680 --> 06:21:57,160
is done on here.

8668
06:21:57,160 --> 06:21:59,920
Now, it's very possible that
you could hear my computer fan

8669
06:21:59,920 --> 06:22:02,640
start-up in a second because
this code is still running

8670
06:22:02,640 --> 06:22:05,050
right now, it's still
filtering and averaging

8671
06:22:05,050 --> 06:22:08,460
over 50 million items and
it's running on my laptop.

8672
06:22:08,460 --> 06:22:11,980
And now I can hear my fans
turning on, and there it goes.

8673
06:22:11,980 --> 06:22:16,610
It's now done, so it took
quite a while to generate that.

8674
06:22:16,610 --> 06:22:20,970
And so we get back a double,
so we could say the result,

8675
06:22:21,920 --> 06:22:24,840
and then we say print line
and we could say the result,

8676
06:22:26,014 --> 06:22:27,290
and then we can see the results here.

8677
06:22:27,290 --> 06:22:29,300
And again, if we were running it again,

8678
06:22:29,300 --> 06:22:31,330
it would take quite a while to run this,

8679
06:22:31,330 --> 06:22:35,430
but this is one way that you
can use the generate sequence

8680
06:22:35,430 --> 06:22:39,010
built inside of the
Kotlin standard library

8681
06:22:39,010 --> 06:22:41,390
to generate a very large
list to do some testing with.

8682
06:22:41,390 --> 06:22:45,500
So again, this is generating
a with 50 million items in it,

8683
06:22:45,500 --> 06:22:47,300
and then I'm iterating over it,

8684
06:22:47,300 --> 06:22:50,580
basically filtering out the
items that I have a modulus

8685
06:22:50,580 --> 06:22:53,250
of three, zero.

8686
06:22:53,250 --> 06:22:55,720
So if it's divisible
by three, then go ahead

8687
06:22:55,720 --> 06:22:58,240
and take those out and then I
wanna average those together.

8688
06:22:58,240 --> 06:23:00,130
And then what happens is
I get the result back,

8689
06:23:00,130 --> 06:23:02,080
which is a double, and that's printed out

8690
06:23:02,080 --> 06:23:03,510
down here at the bottom.

8691
06:23:03,510 --> 06:23:05,750
And that's how you can
generate very large sequences

8692
06:23:05,750 --> 06:23:08,200
and very large lists inside of Kotlin

8693
06:23:08,200 --> 06:23:10,650
so you can work and do
some testing, very useful.

8694
06:23:12,952 --> 06:23:14,380
Let's assume you have
this chunk of code here.

8695
06:23:14,380 --> 06:23:17,360
And if you run this code,
you'll notice that it takes

8696
06:23:17,360 --> 06:23:21,180
anywhere from on my
machine, upwards of nine

8697
06:23:21,180 --> 06:23:23,080
to about 20 seconds to run.

8698
06:23:23,080 --> 06:23:25,980
And the reason why is because
we're generating a sequence,

8699
06:23:25,980 --> 06:23:27,250
which is like a collection,

8700
06:23:27,250 --> 06:23:28,450
and we're turning it into a list.

8701
06:23:28,450 --> 06:23:32,410
And this line basically says,
hey, we have 50 million items

8702
06:23:32,410 --> 06:23:33,790
in this list.

8703
06:23:33,790 --> 06:23:36,309
And then what we're gonna do is kind of do

8704
06:23:36,309 --> 06:23:37,400
some operations over it and
then we're gonna calculate

8705
06:23:37,400 --> 06:23:40,322
the average of some of
the values in there,

8706
06:23:40,322 --> 06:23:41,490
and then we're gonna
print and result and done.

8707
06:23:41,490 --> 06:23:43,140
And so we can see that here.

8708
06:23:43,140 --> 06:23:45,570
Now, one of the problems that
we have with a lot of code

8709
06:23:45,570 --> 06:23:48,890
sometimes is we don't know
how long it takes to run.

8710
06:23:48,890 --> 06:23:52,080
All I know here is like, wow,
that was a long time to run.

8711
06:23:52,080 --> 06:23:53,630
So how could we measure this?

8712
06:23:53,630 --> 06:23:55,870
Well, what we can do is
actually create a function

8713
06:23:55,870 --> 06:23:56,703
called measure.

8714
06:23:58,260 --> 06:24:02,580
And this function measure is gonna take in

8715
06:24:02,580 --> 06:24:04,480
what's known as a lambda expression.

8716
06:24:08,500 --> 06:24:12,940
And this lambda expression
kinda confusing.

8717
06:24:12,940 --> 06:24:14,940
So it's called a block and
this is just a function.

8718
06:24:14,940 --> 06:24:16,040
We're just parsing a function.

8719
06:24:16,040 --> 06:24:20,190
And this function right
here has no parameters,

8720
06:24:20,190 --> 06:24:22,650
that's why it's an empty, it's
like an empty parameter list.

8721
06:24:22,650 --> 06:24:24,300
And this function is gonna return units.

8722
06:24:24,300 --> 06:24:27,530
So this block right here,
right here, this block

8723
06:24:27,530 --> 06:24:30,920
is going to have no parameters
and it's gonna return a unit.

8724
06:24:30,920 --> 06:24:33,880
So it's basically a void,
so it's gonna be a void.

8725
06:24:33,880 --> 06:24:35,790
So we can parse some type of function

8726
06:24:35,790 --> 06:24:38,670
inside of this measure block here.

8727
06:24:38,670 --> 06:24:40,180
But now we need to be
able to measure that.

8728
06:24:40,180 --> 06:24:42,230
So we're gonna say, nano time.

8729
06:24:43,540 --> 06:24:47,160
And then what we're gonna
do is say measure nano time.

8730
06:24:47,160 --> 06:24:49,630
And we can actually
parse a block in there.

8731
06:24:49,630 --> 06:24:52,490
Measure nano time, if
we take a look at it,

8732
06:24:52,490 --> 06:24:55,030
it executes the given block
and return to the elapsed time

8733
06:24:55,030 --> 06:24:55,863
in nanoseconds.

8734
06:24:55,863 --> 06:24:57,820
This is built into the
Kotlin standard library

8735
06:24:57,820 --> 06:24:59,310
and the timing file.

8736
06:24:59,310 --> 06:25:02,580
And all it does is it looks
at the system nano time,

8737
06:25:02,580 --> 06:25:03,950
and then it executes the block.

8738
06:25:03,950 --> 06:25:06,190
And remember the block,
which is what we parsing,

8739
06:25:06,190 --> 06:25:07,500
it's just a function.

8740
06:25:07,500 --> 06:25:09,860
So I'll show you how to
parse a function in a second,

8741
06:25:09,860 --> 06:25:13,260
we're gonna parse a function
in the measure nano time

8742
06:25:13,260 --> 06:25:16,490
basically just grabs the nano
time, then tells the function,

8743
06:25:16,490 --> 06:25:18,410
hey, execute, do whatever you need to do.

8744
06:25:18,410 --> 06:25:20,810
Remember the function is returned to unit,

8745
06:25:20,810 --> 06:25:24,420
which is basically the same
as void in most JVM languages.

8746
06:25:24,420 --> 06:25:26,940
It's gonna return a void, and
then at that point in time,

8747
06:25:26,940 --> 06:25:29,430
it just calculates how
long it took a nanoseconds

8748
06:25:29,430 --> 06:25:30,950
for this function to execute,

8749
06:25:30,950 --> 06:25:33,560
because again, that's
a blocking operation.

8750
06:25:33,560 --> 06:25:35,800
We get the start time and
we calculate the end time

8751
06:25:35,800 --> 06:25:37,550
and that's how long it
took and nanoseconds.

8752
06:25:37,550 --> 06:25:38,720
So now we have nanoseconds,

8753
06:25:38,720 --> 06:25:41,120
but we're not too familiar
with how it would work

8754
06:25:41,120 --> 06:25:44,220
with nanosecond, so let's
go and get the milliseconds.

8755
06:25:44,220 --> 06:25:48,930
And so we're gonna do time
unit.nanosecond.two millies

8756
06:25:49,860 --> 06:25:52,050
and now we're gonna
parse in the nano time.

8757
06:25:52,050 --> 06:25:53,200
That's how long it took.

8758
06:25:53,200 --> 06:25:54,390
And then now that we
have the milliseconds,

8759
06:25:54,390 --> 06:25:55,650
we can just do print line.

8760
06:25:56,882 --> 06:25:59,460
And then what we can do is a print ln.

8761
06:25:59,460 --> 06:26:02,473
We actually take the millies,
print ln and parse it

8762
06:26:08,540 --> 06:26:11,750
in the millies and then
type in miliseconds.

8763
06:26:12,600 --> 06:26:13,890
And what this will do is show us how long

8764
06:26:13,890 --> 06:26:14,820
something took to execute.

8765
06:26:14,820 --> 06:26:17,110
So how do we use this function right here?

8766
06:26:17,110 --> 06:26:18,980
So what are we gonna do,
because this is a block

8767
06:26:18,980 --> 06:26:20,280
we'll just scroll up here.

8768
06:26:21,140 --> 06:26:22,940
And this is called a
block because it looks

8769
06:26:22,940 --> 06:26:25,540
like a block of code and I'll
show you what I mean by that.

8770
06:26:25,540 --> 06:26:27,880
Let's type in measure and see how we hit

8771
06:26:27,880 --> 06:26:30,400
the code completion here.

8772
06:26:30,400 --> 06:26:32,917
And it looks like these
little brackets are,

8773
06:26:32,917 --> 06:26:34,260
we'd like to call that a little block.

8774
06:26:34,260 --> 06:26:36,310
And so right now we're in the block.

8775
06:26:36,310 --> 06:26:39,940
This is the piece of code
that's gonna get executed.

8776
06:26:39,940 --> 06:26:42,370
So we can just provide these brackets here

8777
06:26:42,370 --> 06:26:44,580
because is a lambda expression.

8778
06:26:44,580 --> 06:26:46,460
And anything that's in
between these brackets

8779
06:26:46,460 --> 06:26:47,850
is considered the block of codes.

8780
06:26:47,850 --> 06:26:50,190
I'm just gonna go ahead and take all this

8781
06:26:51,300 --> 06:26:53,510
and I'm gonna go ahead and
clean this up a little bit,

8782
06:26:53,510 --> 06:26:55,750
and I'm just gonna drop it right in here.

8783
06:26:55,750 --> 06:26:58,350
So now all this code
that's inside of here,

8784
06:26:59,320 --> 06:27:02,850
this area right here,
this is the block of code.

8785
06:27:03,770 --> 06:27:04,603
So remember it.

8786
06:27:04,603 --> 06:27:08,880
So this right here is what
turns into this block.

8787
06:27:10,570 --> 06:27:13,390
And then when we get onto the nano time,

8788
06:27:13,390 --> 06:27:15,400
that's, what's executes right there.

8789
06:27:15,400 --> 06:27:17,820
So anything between
these two brackets here.

8790
06:27:17,820 --> 06:27:22,820
So top bracket, bottom
bracket is the block.

8791
06:27:22,950 --> 06:27:24,900
And all this code that's inside of here

8792
06:27:26,670 --> 06:27:28,810
is what's gonna get executed and measured.

8793
06:27:28,810 --> 06:27:30,670
So let's go ahead and do that.

8794
06:27:30,670 --> 06:27:33,070
So now what's gonna happen
is we'll still run this code

8795
06:27:33,070 --> 06:27:34,030
as we normally would have,

8796
06:27:34,030 --> 06:27:36,707
but what's gonna happen
is it's going to run

8797
06:27:36,707 --> 06:27:37,580
and then it's gonna show us
how long it took the run.

8798
06:27:37,580 --> 06:27:42,580
So if we run this now, okay, execute this.

8799
06:27:42,900 --> 06:27:45,390
Again, this is gonna take
anywhere from five to eight

8800
06:27:45,390 --> 06:27:46,223
to 10 seconds.

8801
06:27:46,223 --> 06:27:48,560
And as it runs, it's
basically calculating it.

8802
06:27:48,560 --> 06:27:50,680
Again, take a look here right now

8803
06:27:50,680 --> 06:27:52,500
it's executing this code right here.

8804
06:27:52,500 --> 06:27:55,114
It's already calculated the start time

8805
06:27:55,114 --> 06:27:56,970
and it's calculating the end
time as soon as it's complete.

8806
06:27:56,970 --> 06:27:57,900
And as soon as it's complete,

8807
06:27:57,900 --> 06:28:01,950
we'll then see the millies
ms, there we go done.

8808
06:28:01,950 --> 06:28:03,750
So we know that we are
done, we got the result,

8809
06:28:03,750 --> 06:28:05,990
which is the average that was calculated

8810
06:28:05,990 --> 06:28:08,460
and it took 18,244 seconds.

8811
06:28:08,460 --> 06:28:11,680
So on my machine, this operation takes

8812
06:28:11,680 --> 06:28:15,000
a little over 18 seconds.

8813
06:28:15,000 --> 06:28:20,000
Now it's important to
note that measuring time

8814
06:28:21,670 --> 06:28:26,670
and diagnostics for how valid
timing is a difficult task

8815
06:28:27,560 --> 06:28:29,600
inside of JVM.

8816
06:28:29,600 --> 06:28:31,050
So this is a very important note

8817
06:28:31,050 --> 06:28:34,050
that this can not be treated
as the end all be all

8818
06:28:34,050 --> 06:28:36,470
performance checking solution.

8819
06:28:36,470 --> 06:28:41,470
The reason being is the
JVM has in deterministic

8820
06:28:42,270 --> 06:28:43,570
garbage collection.

8821
06:28:43,570 --> 06:28:46,170
So we could be in the
middle of running this

8822
06:28:46,170 --> 06:28:49,410
and for whatever reason, the JVM decides,

8823
06:28:49,410 --> 06:28:51,971
you know what, we needed higher time.

8824
06:28:51,971 --> 06:28:52,804
It's to garbage collect.

8825
06:28:52,804 --> 06:28:55,450
And that could happen right in
the middle of your execution

8826
06:28:55,450 --> 06:28:56,530
and might throw this off.

8827
06:28:56,530 --> 06:28:59,520
So I don't want you to
take the measure nano time

8828
06:28:59,520 --> 06:29:01,060
as the end all be all solution.

8829
06:29:01,060 --> 06:29:04,290
However, it is a very, very
useful tool to kind of get

8830
06:29:04,290 --> 06:29:07,198
a good diagnostic feel of all right,

8831
06:29:07,198 --> 06:29:09,240
how long is this taking,
why is this taking so long?

8832
06:29:09,240 --> 06:29:10,440
And you can use this.

8833
06:29:10,440 --> 06:29:13,410
So what I recommend is taking
this little measure thing,

8834
06:29:13,410 --> 06:29:16,350
you can kind of copy and paste
it into maybe a scratch file

8835
06:29:16,350 --> 06:29:19,370
somewhere or some type
of a tool where you say

8836
06:29:19,370 --> 06:29:22,180
some code snippets and
use it any time you want

8837
06:29:22,180 --> 06:29:24,512
to start measuring things,

8838
06:29:24,512 --> 06:29:26,160
or you can put it in your
project under a utils

8839
06:29:26,160 --> 06:29:28,080
and then decide if you
wanna use it or not.

8840
06:29:28,080 --> 06:29:30,562
Now, of course, you
probably don't want this

8841
06:29:30,562 --> 06:29:31,860
in your production code,
but it's very useful

8842
06:29:31,860 --> 06:29:32,693
if for some reason you're like,

8843
06:29:32,693 --> 06:29:34,830
wow, how long is this really taking?

8844
06:29:34,830 --> 06:29:36,120
And then you can start determining,

8845
06:29:36,120 --> 06:29:38,540
oh wow, this is the chart, you know?

8846
06:29:38,540 --> 06:29:39,700
And then if you wanted to, you could say,

8847
06:29:39,700 --> 06:29:44,140
all right, well, is it really,
is the measure actually,

8848
06:29:44,140 --> 06:29:45,930
is it this piece right here?

8849
06:29:45,930 --> 06:29:47,260
So then, what is that?

8850
06:29:47,260 --> 06:29:49,100
So we actually, we'd probably
want to take this out here

8851
06:29:49,100 --> 06:29:54,100
and say, wanna take this list
out and say list var list.

8852
06:29:58,485 --> 06:30:01,660
So we do a late init var list,

8853
06:30:01,660 --> 06:30:04,810
and that's gonna be a list of integers

8854
06:30:06,960 --> 06:30:08,360
and now we can just do this.

8855
06:30:09,350 --> 06:30:10,720
So then we can see how long that took.

8856
06:30:10,720 --> 06:30:12,220
So if we were to run this now,

8857
06:30:14,270 --> 06:30:17,230
we would see as it's generating
how long it's gonna to take.

8858
06:30:17,230 --> 06:30:20,330
So to generate the 50,000
and then turn it to a list,

8859
06:30:22,520 --> 06:30:23,460
as it's executing.

8860
06:30:27,140 --> 06:30:28,410
Okay, so I'm gonna stop it here.

8861
06:30:28,410 --> 06:30:31,310
Now what we see here is that
it took about nine seconds

8862
06:30:31,310 --> 06:30:33,000
to generate that sequence.

8863
06:30:33,000 --> 06:30:34,870
So then we could start measuring

8864
06:30:34,870 --> 06:30:36,280
various different components here.

8865
06:30:36,280 --> 06:30:39,000
All right, how long did it
take for this other stuff?

8866
06:30:39,000 --> 06:30:41,110
So if I wanted to, I
can move this down here.

8867
06:30:41,110 --> 06:30:43,430
Okay, that took nine seconds.

8868
06:30:43,430 --> 06:30:45,550
How long does it take for this stuff here?

8869
06:30:45,550 --> 06:30:46,950
Let's go ahead and run that.

8870
06:30:48,910 --> 06:30:50,187
And then you can run this, et cetera.

8871
06:30:50,187 --> 06:30:51,600
And then you're gonna be
able to see how long it takes

8872
06:30:51,600 --> 06:30:53,380
for each one of these
things to be generated.

8873
06:30:53,380 --> 06:30:55,950
Now, of course, there's a
bunch of variables in here.

8874
06:30:55,950 --> 06:30:58,720
Okay, we're not late,
we're late in initializing.

8875
06:30:58,720 --> 06:30:59,740
Is that impacting it?

8876
06:30:59,740 --> 06:31:04,110
If you're looking for very,
very fine tuned ways to tune it,

8877
06:31:04,110 --> 06:31:05,550
this is not gonna be a solution,

8878
06:31:05,550 --> 06:31:08,330
this'll be just something
to help you kind of gauge

8879
06:31:08,330 --> 06:31:09,950
whether or not something is slow

8880
06:31:09,950 --> 06:31:11,110
and how to do it very easily.

8881
06:31:11,110 --> 06:31:14,330
So here we can see that
the averaging itself

8882
06:31:14,330 --> 06:31:16,379
takes about eight seconds.

8883
06:31:16,379 --> 06:31:17,970
So generating the list
took a little over nine,

8884
06:31:17,970 --> 06:31:20,520
almost 10 seconds, and this
takes almost nine seconds itself

8885
06:31:20,520 --> 06:31:23,210
to calculate the average and print it.

8886
06:31:23,210 --> 06:31:25,850
And that's how you can
use the measure nano time

8887
06:31:25,850 --> 06:31:27,630
to create a measure block,

8888
06:31:27,630 --> 06:31:29,440
which then you can use
inside of your application

8889
06:31:29,440 --> 06:31:31,530
to measure chunks of code to see how long

8890
06:31:31,530 --> 06:31:32,580
they take to execute.

8891
06:31:33,530 --> 06:31:35,150
To understand sequences in Kotlin,

8892
06:31:35,150 --> 06:31:37,540
it's important to
understand how list operate

8893
06:31:37,540 --> 06:31:40,230
over list of data and how
the mapping operations

8894
06:31:40,230 --> 06:31:42,970
occur to each of the list items.

8895
06:31:42,970 --> 06:31:44,760
So we're gonna do is
create a list of strings,

8896
06:31:44,760 --> 06:31:46,050
and then we're gonna filter that list.

8897
06:31:46,050 --> 06:31:47,320
And it's not really gonna filter anything,

8898
06:31:47,320 --> 06:31:49,820
it's just gonna go ahead and
process it and print line,

8899
06:31:49,820 --> 06:31:52,640
and then return back true
basically saying all the items

8900
06:31:52,640 --> 06:31:53,830
will be included.

8901
06:31:53,830 --> 06:31:56,080
And then finally, we'll go
ahead and then print line it

8902
06:31:56,080 --> 06:31:58,150
at the end of each one of those.

8903
06:31:58,150 --> 06:32:01,780
Now for each is one of the
things we're doing here

8904
06:32:01,780 --> 06:32:06,410
is actually showing that a
list is eagerly evaluated.

8905
06:32:06,410 --> 06:32:09,990
So each time there's an
operation, a new list is created.

8906
06:32:09,990 --> 06:32:13,640
So what that means is if I were
to perform this same filter

8907
06:32:13,640 --> 06:32:18,540
operation twice, and I
were to say, hello here,

8908
06:32:18,540 --> 06:32:22,110
what would happen is Kotlin
is then going to create a,

8909
06:32:23,829 --> 06:32:24,970
it's gonna take the
list from the beginning.

8910
06:32:24,970 --> 06:32:26,220
And then in the filter function,

8911
06:32:26,220 --> 06:32:28,350
it's going to create another list.

8912
06:32:28,350 --> 06:32:31,440
And then from that list, that
list will then be turned in

8913
06:32:31,440 --> 06:32:34,130
and sent into this list right here.

8914
06:32:34,130 --> 06:32:37,130
And when this one is done,
a new list to be created

8915
06:32:37,130 --> 06:32:38,370
and sent into here.

8916
06:32:38,370 --> 06:32:41,120
So basically we're having this
type of thing happen here,

8917
06:32:41,120 --> 06:32:44,870
where these lists are being
created over and over and over,

8918
06:32:44,870 --> 06:32:45,730
but there are new lists.

8919
06:32:45,730 --> 06:32:47,910
So this is a list off of this one,

8920
06:32:47,910 --> 06:32:50,670
this is a list off of this one.

8921
06:32:50,670 --> 06:32:53,400
And then a new list is finally
created that we have a list

8922
06:32:53,400 --> 06:32:54,810
down here.

8923
06:32:54,810 --> 06:32:58,110
So Kotlin is lazily evaluating those.

8924
06:32:58,110 --> 06:33:01,220
And the easy way to see that
is with this function here.

8925
06:33:01,220 --> 06:33:03,320
So let's go ahead and run this
and what we're going to see

8926
06:33:03,320 --> 06:33:06,050
here on the screen down here on the bottom

8927
06:33:06,990 --> 06:33:11,180
is that we have the filter
was run for every single item

8928
06:33:11,180 --> 06:33:13,900
in the list and it didn't
progress until the next function

8929
06:33:13,900 --> 06:33:16,370
until all of the items
are processed in the list.

8930
06:33:16,370 --> 06:33:18,780
The same thing here, and
then the same thing here.

8931
06:33:18,780 --> 06:33:21,960
So as each item walked down,

8932
06:33:21,960 --> 06:33:24,330
so this function did these ones,

8933
06:33:24,330 --> 06:33:26,530
this function did these ones,

8934
06:33:26,530 --> 06:33:28,570
and this function did these ones.

8935
06:33:28,570 --> 06:33:30,910
So it operated one at a time.

8936
06:33:30,910 --> 06:33:34,290
This one, then this one, then this one,

8937
06:33:35,590 --> 06:33:38,130
and that's what's happening
behind the scenes.

8938
06:33:38,130 --> 06:33:40,410
Now this can be home problematic
when you have a very large

8939
06:33:40,410 --> 06:33:43,590
list or many processing
steps inside of your list,

8940
06:33:43,590 --> 06:33:46,600
because if they are processing intensive,

8941
06:33:46,600 --> 06:33:48,550
then if we're creating a new collection,

8942
06:33:48,550 --> 06:33:50,230
each time eagerly evaluating it,

8943
06:33:50,230 --> 06:33:52,710
we can just start
slowing down the process.

8944
06:33:52,710 --> 06:33:55,130
So let's see what that kind of looks like

8945
06:33:55,130 --> 06:33:56,590
if we were to use a sequence.

8946
06:33:57,470 --> 06:33:59,320
Okay, so I've copied and pasted some code

8947
06:33:59,320 --> 06:34:01,640
and I've removed the
additional filter up here.

8948
06:34:01,640 --> 06:34:04,200
Now we now have down here
almost the same exact code.

8949
06:34:04,200 --> 06:34:06,660
The only thing is difference
is we have the sequence of,

8950
06:34:06,660 --> 06:34:10,100
and what the sequence of
is it returns a sequence,

8951
06:34:10,100 --> 06:34:12,520
which is basically something
that can be iterated over.

8952
06:34:12,520 --> 06:34:15,360
And a sequence is returned to
value through its iterator,

8953
06:34:15,360 --> 06:34:17,480
the values are evaluated lazily.

8954
06:34:17,480 --> 06:34:20,910
That's the key, values
are evaluated lazily

8955
06:34:20,910 --> 06:34:23,320
while lists are evaluated eagerly.

8956
06:34:24,210 --> 06:34:26,530
So we've created a sequence of this,

8957
06:34:26,530 --> 06:34:28,960
basically everything
else is the exact same

8958
06:34:28,960 --> 06:34:29,793
for both of these.

8959
06:34:29,793 --> 06:34:31,950
Now, if we run this, we're
gonna see the difference here

8960
06:34:31,950 --> 06:34:33,490
in the output.

8961
06:34:33,490 --> 06:34:36,140
And so we have the line
that's separating down here,

8962
06:34:36,140 --> 06:34:37,430
the top from the bottom.

8963
06:34:37,430 --> 06:34:41,600
So up top we have new list was
created, new list is created.

8964
06:34:41,600 --> 06:34:44,150
We can tell that because all
of the items were processed

8965
06:34:44,150 --> 06:34:45,950
in sequential order before it moved on

8966
06:34:45,950 --> 06:34:48,340
to the next map operation
or the next operation

8967
06:34:48,340 --> 06:34:49,340
inside of the chain.

8968
06:34:50,635 --> 06:34:51,680
However, instead of a sequence we can see

8969
06:34:51,680 --> 06:34:54,570
that the filter executed
for the first value X

8970
06:34:54,570 --> 06:34:57,730
and then X moved on to the next operation,

8971
06:34:57,730 --> 06:35:00,690
which was for each, the same thing for Y.

8972
06:35:00,690 --> 06:35:04,060
So as each item is coming
out of the sequence,

8973
06:35:04,060 --> 06:35:06,457
it's processing through the entire chain

8974
06:35:06,457 --> 06:35:08,220
until it hits down here,
hits the termination.

8975
06:35:08,220 --> 06:35:10,450
And so each item is
processed sequentially,

8976
06:35:10,450 --> 06:35:12,530
so as a sequence.

8977
06:35:12,530 --> 06:35:14,760
So if you have a very
large list or you have

8978
06:35:14,760 --> 06:35:17,470
a very high intensive chain of events

8979
06:35:17,470 --> 06:35:21,220
that are being processed,
it's recommending that you use

8980
06:35:21,220 --> 06:35:23,250
a sequence because it's
much more performing.

8981
06:35:23,250 --> 06:35:25,330
Now, if you have 10 items
and you're only performing

8982
06:35:25,330 --> 06:35:28,180
a couple of operations on
the list, should you use it,

8983
06:35:28,180 --> 06:35:31,330
we don't know, what if
it's 100, we don't know.

8984
06:35:31,330 --> 06:35:34,260
As the saying goes, what
gets measured gets managed.

8985
06:35:34,260 --> 06:35:37,630
So how do we measure if
something is slow or not?

8986
06:35:37,630 --> 06:35:39,680
Well, let's go ahead and delete this code

8987
06:35:41,313 --> 06:35:42,870
and let's go ahead and generate some code

8988
06:35:42,870 --> 06:35:45,770
that has a very high number of values.

8989
06:35:45,770 --> 06:35:48,460
Now the code that I'm
showing you is actually

8990
06:35:48,460 --> 06:35:51,070
from a gentleman named Benjamin.

8991
06:35:51,070 --> 06:35:54,720
And if we go over to,
I found this blog post

8992
06:35:54,720 --> 06:35:56,980
quite a while ago and it's
been the one I've relied on

8993
06:35:56,980 --> 06:35:59,350
for years on the sequences.

8994
06:35:59,350 --> 06:36:00,900
And he talks about all this stuff in here,

8995
06:36:00,900 --> 06:36:02,100
and I'll provide a link to it.

8996
06:36:02,100 --> 06:36:05,610
So I'm actually using the
same exact example he's using

8997
06:36:05,610 --> 06:36:09,160
to show how performant
some of this stuff is,

8998
06:36:09,160 --> 06:36:10,190
very, very useful.

8999
06:36:10,190 --> 06:36:12,200
Thank you, Benjamin, just
want them to give you credit

9000
06:36:12,200 --> 06:36:14,650
for writing this phenomenal blog article.

9001
06:36:14,650 --> 06:36:16,580
And I'm basically explaining
a lot of what's covered

9002
06:36:16,580 --> 06:36:19,200
in here, though he does
go into some more detail

9003
06:36:19,200 --> 06:36:20,720
with some other information.

9004
06:36:20,720 --> 06:36:22,730
Okay, so let's go ahead and get some code

9005
06:36:22,730 --> 06:36:24,680
to actually show how to measure things.

9006
06:36:25,760 --> 06:36:27,630
So I have some code in here and this code

9007
06:36:27,630 --> 06:36:29,120
does a couple of things.

9008
06:36:29,120 --> 06:36:33,160
We're generating a sequence as we can do,

9009
06:36:33,160 --> 06:36:35,800
which is built into the
Kotlin standard library.

9010
06:36:35,800 --> 06:36:37,530
So I'm generating a sequence,

9011
06:36:37,530 --> 06:36:38,860
I'm gonna seed it with a value of one.

9012
06:36:38,860 --> 06:36:41,710
And then for each iteration
again, generate sequence

9013
06:36:41,710 --> 06:36:44,410
is in the Kotlin center
library and it basically says,

9014
06:36:45,507 --> 06:36:47,320
you can give it a seed
value, and then we'll invoke

9015
06:36:47,320 --> 06:36:49,400
the next function for every single time

9016
06:36:49,400 --> 06:36:52,150
you want something from the sequence.

9017
06:36:52,150 --> 06:36:54,190
And so I'm gonna tell it to
just increment that value

9018
06:36:54,190 --> 06:36:56,906
and I want it to do it 15 million times.

9019
06:36:56,906 --> 06:36:58,710
So I have a sequence of 50
million items and then I say,

9020
06:36:58,710 --> 06:37:00,200
hey, turn that into a list.

9021
06:37:01,416 --> 06:37:04,730
And so now I have this
list of 50 million items,

9022
06:37:04,730 --> 06:37:07,420
which is a very large list
and it's gonna be processed

9023
06:37:07,420 --> 06:37:08,500
on the laptop.

9024
06:37:08,500 --> 06:37:10,460
So 50 million integers in the list.

9025
06:37:10,460 --> 06:37:11,840
And then what I wanna do is filter it.

9026
06:37:11,840 --> 06:37:14,230
So find anything that's
dividable by three,

9027
06:37:14,230 --> 06:37:15,180
and then average that out.

9028
06:37:15,180 --> 06:37:16,700
And of course, we're
gonna get a value back.

9029
06:37:16,700 --> 06:37:18,760
So let's go ahead and grab that value.

9030
06:37:18,760 --> 06:37:19,660
That's the result.

9031
06:37:21,000 --> 06:37:22,670
And we can go ahead and
put everything back up

9032
06:37:22,670 --> 06:37:25,480
on a single line here, 'cause
it kind of makes sense.

9033
06:37:25,480 --> 06:37:27,860
And then we'll do is print the result,

9034
06:37:28,910 --> 06:37:30,810
print line and we'll do it the result.

9035
06:37:33,170 --> 06:37:35,520
And then what this measure
method will do here,

9036
06:37:35,520 --> 06:37:37,440
which is what you've probably
been wondering about.

9037
06:37:37,440 --> 06:37:40,390
It takes in a block and a
block is just a unit of code.

9038
06:37:40,390 --> 06:37:43,180
And this measure function is
explained in another video,

9039
06:37:43,180 --> 06:37:45,840
but basically shows how long
it takes this chunk of code

9040
06:37:45,840 --> 06:37:47,390
to execute.

9041
06:37:47,390 --> 06:37:48,870
And so this is what's parsed in.

9042
06:37:48,870 --> 06:37:50,240
And so let's go ahead and execute this.

9043
06:37:50,240 --> 06:37:51,830
And then what we're gonna see at the end

9044
06:37:51,830 --> 06:37:55,230
is how long it took and
milliseconds to process this.

9045
06:37:55,230 --> 06:37:57,580
This could take anywhere
from eight to 20 seconds,

9046
06:37:57,580 --> 06:37:59,980
depends on my machine today.

9047
06:37:59,980 --> 06:38:02,498
I've seen it kind of
range all over the place,

9048
06:38:02,498 --> 06:38:04,390
depends on what's happening on my machine.

9049
06:38:04,390 --> 06:38:05,223
And it's still running.

9050
06:38:05,223 --> 06:38:08,640
We can tell this by the
stop icon is active,

9051
06:38:08,640 --> 06:38:11,066
which means there's something running.

9052
06:38:11,066 --> 06:38:12,350
The green little dot there
also helps us indicate

9053
06:38:12,350 --> 06:38:13,183
that something's running.

9054
06:38:13,183 --> 06:38:15,180
There we go, something came back.

9055
06:38:15,180 --> 06:38:19,600
So we have the result, which
is 2.5 to whatever power,

9056
06:38:19,600 --> 06:38:21,240
et cetera, very large number.

9057
06:38:21,240 --> 06:38:23,720
And it took us 18,000 milliseconds,

9058
06:38:23,720 --> 06:38:27,400
so basically about 18
seconds to run this process.

9059
06:38:27,400 --> 06:38:30,420
So, okay, so we have a
list we're processing

9060
06:38:30,420 --> 06:38:32,350
over the list and remember how we executed

9061
06:38:32,350 --> 06:38:33,610
those things before.

9062
06:38:33,610 --> 06:38:36,070
So let's go ahead and change this.

9063
06:38:36,070 --> 06:38:38,540
And instead of making this a list,

9064
06:38:38,540 --> 06:38:40,800
let's go ahead and make
this just a sequence.

9065
06:38:40,800 --> 06:38:43,240
And so to do that, I'm just
gonna remove this list here.

9066
06:38:43,240 --> 06:38:44,480
And instead of calling this a list,

9067
06:38:44,480 --> 06:38:47,720
I'm gonna call this to change
the name to a sequence.

9068
06:38:47,720 --> 06:38:48,670
So now this is a sequence.

9069
06:38:48,670 --> 06:38:49,960
So it's almost the same exact code,

9070
06:38:49,960 --> 06:38:52,460
I've just changed the
variable name and removed it

9071
06:38:52,460 --> 06:38:53,880
from being a list.

9072
06:38:53,880 --> 06:38:56,920
So let's rerun this to see
how fast it is to process

9073
06:38:56,920 --> 06:38:59,980
a very large list and do
a couple of operations.

9074
06:38:59,980 --> 06:39:01,460
Boom, we're already done.

9075
06:39:01,460 --> 06:39:05,990
So 50 million items with a
sequence took 628 milliseconds.

9076
06:39:05,990 --> 06:39:07,460
And if we did it with a list,

9077
06:39:08,316 --> 06:39:10,473
it took us almost 20 seconds to do.

9078
06:39:10,473 --> 06:39:11,530
So it's orders of operations,

9079
06:39:11,530 --> 06:39:15,220
much more efficient to use
a sequence in this manner.

9080
06:39:15,220 --> 06:39:17,460
At what point should you use a sequence,

9081
06:39:17,460 --> 06:39:20,930
that's up to you to decide,
should you be using a sequence?

9082
06:39:20,930 --> 06:39:23,380
If it's 10 items, depends
on how much processing

9083
06:39:23,380 --> 06:39:24,580
you're doing on those 10 items.

9084
06:39:24,580 --> 06:39:26,360
Are you doing 100 operations on it?

9085
06:39:27,515 --> 06:39:29,300
Maybe it's important to
you the sequence then.

9086
06:39:29,300 --> 06:39:31,450
What if you have 100 million
items and you're only doing

9087
06:39:31,450 --> 06:39:33,680
two operations on it,
like we're doing here

9088
06:39:33,680 --> 06:39:36,000
and only doing a filter and an average.

9089
06:39:36,000 --> 06:39:38,160
Should you use a sequencer, probably so.

9090
06:39:38,160 --> 06:39:41,290
But what if you have 10 operations,

9091
06:39:41,290 --> 06:39:43,710
it's not really doing much calculation

9092
06:39:43,710 --> 06:39:47,340
and it's only maybe 10
items in the collection.

9093
06:39:47,340 --> 06:39:50,810
Should you use a list maybe, maybe not,

9094
06:39:50,810 --> 06:39:52,180
it's up to you to decide.

9095
06:39:52,180 --> 06:39:55,600
I wouldn't focus on making
sure that everything

9096
06:39:55,600 --> 06:39:58,540
is performant, that's
premature optimization.

9097
06:39:58,540 --> 06:40:02,530
However, you can use this nice
little handy measure block

9098
06:40:02,530 --> 06:40:05,155
as we have here inside of your code,

9099
06:40:05,155 --> 06:40:07,316
throw it inside of a
utils folder or whatever

9100
06:40:07,316 --> 06:40:08,149
and then measure something.

9101
06:40:08,149 --> 06:40:10,440
If you find piece of your code,
kind of being really slow,

9102
06:40:10,440 --> 06:40:12,670
I highly recommend slapping
the measure block around it.

9103
06:40:12,670 --> 06:40:14,720
It'll give you a good
rule of thumb of like,

9104
06:40:14,720 --> 06:40:17,870
alright, is this taking a long
time or where is this slow?

9105
06:40:17,870 --> 06:40:20,360
If you find you're processing
around a large list

9106
06:40:20,360 --> 06:40:23,090
or list operations to
be slow, at that point,

9107
06:40:23,090 --> 06:40:26,510
it might be time to take
something and make it a sequence,

9108
06:40:26,510 --> 06:40:28,390
which it could be also very interesting.

9109
06:40:28,390 --> 06:40:32,600
So let's assume that for whatever
reason, we have a method.

9110
06:40:32,600 --> 06:40:37,280
And this method is called
get list of customers.

9111
06:40:37,280 --> 06:40:40,920
And this list of customers
comes from a database.

9112
06:40:40,920 --> 06:40:44,320
And it's gonna return a list
of data and this returns,

9113
06:40:44,320 --> 06:40:45,950
let's call this integers for now.

9114
06:40:46,917 --> 06:40:48,620
And then what we'll do
is I'm just gonna do this

9115
06:40:48,620 --> 06:40:53,110
right here, it's gonna return
a list to that to list.

9116
06:40:54,250 --> 06:40:56,280
We're just gonna pretend
that this is actually

9117
06:40:56,280 --> 06:40:57,320
is from a database.

9118
06:40:57,320 --> 06:40:58,930
So I'm gonna pretend it's in the library

9119
06:40:58,930 --> 06:40:59,870
and I get this out of here.

9120
06:40:59,870 --> 06:41:01,120
Okay, whatever.

9121
06:41:01,120 --> 06:41:04,690
So now I'm gonna have my changes to list.

9122
06:41:06,510 --> 06:41:08,900
Actually it will leave a sequence.

9123
06:41:08,900 --> 06:41:10,730
Actually, I'm gonna change it back to list

9124
06:41:10,730 --> 06:41:12,020
and I'll show you why in a second.

9125
06:41:12,020 --> 06:41:13,650
So we're gonna say this is list and say,

9126
06:41:13,650 --> 06:41:18,650
we'll say val list equals
get list of customers.

9127
06:41:19,200 --> 06:41:20,532
So there we go.

9128
06:41:20,532 --> 06:41:21,365
Now we have our list of customers.

9129
06:41:21,365 --> 06:41:23,900
we're gonna perform some filtering
on it and it's gonna run.

9130
06:41:23,900 --> 06:41:25,880
Now, as we know, this is
gonna take a long time

9131
06:41:25,880 --> 06:41:28,390
because this list of customers here

9132
06:41:28,390 --> 06:41:30,610
is a very, very large list.

9133
06:41:30,610 --> 06:41:33,410
Now, again, we're
generating this on the fly,

9134
06:41:33,410 --> 06:41:36,290
so let's go ahead and
pretend you don't see that.

9135
06:41:36,290 --> 06:41:39,460
Let's assume that it just returns a list

9136
06:41:39,460 --> 06:41:41,330
and we don't have control over that.

9137
06:41:41,330 --> 06:41:43,780
But however, now that
we have this large list,

9138
06:41:43,780 --> 06:41:45,960
however it's been processed
maybe on a background thread,

9139
06:41:45,960 --> 06:41:48,480
but now we have it and
we need to process it.

9140
06:41:48,480 --> 06:41:49,880
We now have control of them.

9141
06:41:49,880 --> 06:41:51,560
So this is a very large list.

9142
06:41:51,560 --> 06:41:53,260
Let's go ahead and run this again.

9143
06:41:55,450 --> 06:41:57,780
So we have that list of customers,

9144
06:41:57,780 --> 06:41:59,370
actually, we can go ahead and take,

9145
06:41:59,370 --> 06:42:00,340
let's assume that this is out here

9146
06:42:00,340 --> 06:42:02,580
'cause we don't wanna
measure that component there.

9147
06:42:02,580 --> 06:42:04,420
So we have our list of customers.

9148
06:42:04,420 --> 06:42:06,710
That list of customers is
gonna take probably eight

9149
06:42:06,710 --> 06:42:08,950
or 10 seconds to generate
because it has to turn it

9150
06:42:08,950 --> 06:42:10,310
into a list.

9151
06:42:10,310 --> 06:42:12,560
And most likely this block
of code will probably take

9152
06:42:12,560 --> 06:42:15,620
another eight or 10
seconds to execute as well.

9153
06:42:15,620 --> 06:42:17,570
So perhaps this is on a background thread.

9154
06:42:17,570 --> 06:42:20,250
We can't control that,
that just is what it is.

9155
06:42:20,250 --> 06:42:22,710
And we're maybe we're
gonna get that data back.

9156
06:42:22,710 --> 06:42:24,710
But now once it's off
that background thread,

9157
06:42:24,710 --> 06:42:28,070
we can control it, so for
example, it takes eight seconds.

9158
06:42:28,070 --> 06:42:31,380
So at that point, how
could we speed this up?

9159
06:42:32,610 --> 06:42:34,820
Well, because this is a
list at this point in time,

9160
06:42:34,820 --> 06:42:35,810
everything's running slow.

9161
06:42:35,810 --> 06:42:38,890
Now, thankfully there's
actually a nice method

9162
06:42:38,890 --> 06:42:42,060
on the collection here called as sequence.

9163
06:42:42,060 --> 06:42:44,510
And what this will do is will turn this,

9164
06:42:44,510 --> 06:42:46,780
I'm gonna go ahead and break
these into new lines here.

9165
06:42:46,780 --> 06:42:51,150
This will turn this list into a sequence.

9166
06:42:53,830 --> 06:42:56,335
And so what this will
allow us to do is get

9167
06:42:56,335 --> 06:42:57,840
some performance benefit
as treating this list

9168
06:42:57,840 --> 06:42:58,673
as a sequence.

9169
06:42:58,673 --> 06:43:01,780
And then from this point
on after this line,

9170
06:43:01,780 --> 06:43:04,160
everything will be operated sequentially

9171
06:43:04,160 --> 06:43:04,993
as a sequence would.

9172
06:43:04,993 --> 06:43:06,850
So let's go ahead and rerun this.

9173
06:43:10,230 --> 06:43:11,630
And as we're running
it here, we're waiting.

9174
06:43:11,630 --> 06:43:12,970
And of course, it's gonna take a while

9175
06:43:12,970 --> 06:43:14,850
because we're assuming this
is on a background thread.

9176
06:43:14,850 --> 06:43:17,260
It's gonna take awhile
eight or 10 seconds.

9177
06:43:17,260 --> 06:43:19,800
And then once we get a result back, boom.

9178
06:43:19,800 --> 06:43:21,490
Now this code has been measured.

9179
06:43:21,490 --> 06:43:23,780
Previously, it took them
as nine seconds to run.

9180
06:43:23,780 --> 06:43:27,670
Now we turned it into a
sequence via the as sequence

9181
06:43:27,670 --> 06:43:28,740
helper method.

9182
06:43:28,740 --> 06:43:31,740
And we have transformed this
from a nine second operation

9183
06:43:31,740 --> 06:43:34,860
into a 244 millisecond.

9184
06:43:34,860 --> 06:43:37,750
244 millisecond operation
orders of magnitude

9185
06:43:37,750 --> 06:43:40,820
faster just by slapping on as sequence.

9186
06:43:40,820 --> 06:43:42,710
Now, of course, you're not
going to get this benefit

9187
06:43:42,710 --> 06:43:44,600
if your list is 10 items,

9188
06:43:44,600 --> 06:43:47,380
you're not gonna see
that drastic improvement.

9189
06:43:47,380 --> 06:43:49,050
It's gonna be very
negligible at that point.

9190
06:43:49,050 --> 06:43:54,000
So follow the mantra of whatever
gets measured gets managed.

9191
06:43:54,000 --> 06:43:55,380
If you find slow piece in your code,

9192
06:43:55,380 --> 06:43:56,790
see what's taking a long time.

9193
06:43:56,790 --> 06:43:59,040
If it's a (indistinct) list or
a map or something like that,

9194
06:43:59,040 --> 06:44:00,790
perhaps you need to figure
out a way to turn it into

9195
06:44:00,790 --> 06:44:02,970
a sequence so you can get
some performance benefit

9196
06:44:02,970 --> 06:44:03,803
out of it.

9197
06:44:03,803 --> 06:44:05,380
And of course, be sure to
check out the blog link

9198
06:44:05,380 --> 06:44:07,370
in the show notes.

9199
06:44:07,370 --> 06:44:10,350
So big hat tip to
Benjamin for demonstrating

9200
06:44:10,350 --> 06:44:11,330
a perfect example.

9201
06:44:11,330 --> 06:44:12,270
I tried to create my own,

9202
06:44:12,270 --> 06:44:14,400
but his example was just
so succinct and great.

9203
06:44:14,400 --> 06:44:16,100
Thank you Benjamin for doing that.

9204
06:44:21,080 --> 06:44:24,470
What's the difference
between a list, a set, a map,

9205
06:44:24,470 --> 06:44:25,303
and a sequence?

9206
06:44:26,170 --> 06:44:28,270
Well, a list of data inside of Kotlin

9207
06:44:28,270 --> 06:44:29,380
can be a list of anything.

9208
06:44:29,380 --> 06:44:31,060
It can be a list of primitive values

9209
06:44:31,060 --> 06:44:32,660
such as strings as we have here.

9210
06:44:33,721 --> 06:44:34,554
So we have lists.

9211
06:44:34,554 --> 06:44:38,230
We have some names, Donn
Tushar, Cavita Evelyn, Felicia.

9212
06:44:38,230 --> 06:44:40,531
This could also be a list of integers.

9213
06:44:40,531 --> 06:44:45,531
So we could have a list of
integers of one, two, 12, 23, 44,

9214
06:44:45,540 --> 06:44:46,680
66, et cetera.

9215
06:44:47,630 --> 06:44:49,890
And they can be a list of integers.

9216
06:44:49,890 --> 06:44:50,723
It could be a list of objects.

9217
06:44:50,723 --> 06:44:55,470
So any time you need a
list of data to work with,

9218
06:44:55,470 --> 06:44:56,910
you're gonna wanna use a list.

9219
06:44:56,910 --> 06:44:58,140
Now, as you can see here,

9220
06:44:58,140 --> 06:45:01,490
the list right now is strongly
typed to be a list of string.

9221
06:45:01,490 --> 06:45:03,680
And again, if you need
it to be a mutable list,

9222
06:45:03,680 --> 06:45:07,499
you would type mutable list
of which means this is a list

9223
06:45:07,499 --> 06:45:08,332
that you could change.

9224
06:45:08,332 --> 06:45:10,500
So the same thing goes for
almost any of the collections

9225
06:45:10,500 --> 06:45:13,480
inside of Kotlin.

9226
06:45:13,480 --> 06:45:14,650
If you want it to be mutable,

9227
06:45:14,650 --> 06:45:17,680
you'll actually slot the word
mutable at the beginning.

9228
06:45:17,680 --> 06:45:18,940
So when do you wanna use a set?

9229
06:45:18,940 --> 06:45:22,840
Well, a set remember only
include unique items.

9230
06:45:22,840 --> 06:45:23,990
So in this case,

9231
06:45:23,990 --> 06:45:27,130
I've set a creative set
of these four items,

9232
06:45:27,130 --> 06:45:29,550
Don, Tusha, Donn and Tusha.

9233
06:45:29,550 --> 06:45:31,200
Now, when we actually print these out,

9234
06:45:31,200 --> 06:45:32,033
if we were to print it,

9235
06:45:32,033 --> 06:45:34,940
we would see that this set
actually only includes two items

9236
06:45:34,940 --> 06:45:37,710
because a set does not
allow multiple duplicates

9237
06:45:37,710 --> 06:45:39,410
of an item inside of there.

9238
06:45:39,410 --> 06:45:42,430
So here, it's going to see that
Donn is then presented twice

9239
06:45:42,430 --> 06:45:43,990
so it will not add the second one.

9240
06:45:43,990 --> 06:45:46,120
And the same thing for Tusha
has been added another time.

9241
06:45:46,120 --> 06:45:48,010
So it will not add a second one.

9242
06:45:48,010 --> 06:45:51,740
And this result will only be
in the set be Donn and Tusha.

9243
06:45:51,740 --> 06:45:54,870
So if you need your items to
be unique inside of basically

9244
06:45:54,870 --> 06:45:57,520
you need a unique list,
you're gonna wanna use a set.

9245
06:45:58,562 --> 06:45:59,395
So what about a map?

9246
06:45:59,395 --> 06:46:00,520
So when would you use a map?

9247
06:46:00,520 --> 06:46:04,460
Well, a map is basically a
mapping of one value to another,

9248
06:46:04,460 --> 06:46:06,310
and I like to think of
it as a key-value pair.

9249
06:46:06,310 --> 06:46:09,050
And that's what this is, is a
map right here with the helper

9250
06:46:09,050 --> 06:46:12,350
is we have the key, which
is a string and the value,

9251
06:46:12,350 --> 06:46:13,390
which is a string.

9252
06:46:13,390 --> 06:46:16,440
Now this does not mean that
you have to always use string

9253
06:46:16,440 --> 06:46:17,708
and string.

9254
06:46:17,708 --> 06:46:20,330
So we can say map to, we
could actually say map of,

9255
06:46:20,330 --> 06:46:24,060
and I'm going to say one to Don

9256
06:46:24,060 --> 06:46:28,400
and then we say two to Tusha.

9257
06:46:28,400 --> 06:46:32,220
And what this does, it creates
a map with the key being

9258
06:46:32,220 --> 06:46:35,060
an integer and then the
value being a string.

9259
06:46:35,060 --> 06:46:37,850
So you can create a map of
all different types of things.

9260
06:46:37,850 --> 06:46:40,313
If you wanted to create it as an object,

9261
06:46:40,313 --> 06:46:41,200
you could create it as
its own custom object.

9262
06:46:41,200 --> 06:46:44,150
If you had say a data class,

9263
06:46:44,150 --> 06:46:48,180
it'd be person and we maybe
had val name, it's a string.

9264
06:46:48,180 --> 06:46:52,960
What you could do is you can
make this map, turn to person,

9265
06:46:52,960 --> 06:46:57,960
Donn to, maybe he does Android.

9266
06:46:58,980 --> 06:47:01,880
And we wanna have a map of person Tushar,

9267
06:47:04,450 --> 06:47:08,410
which then maps to let's say he does J2EE.

9268
06:47:09,940 --> 06:47:13,530
And at that point, we now
have a map where the key

9269
06:47:13,530 --> 06:47:15,750
is a person object and
the value of the string.

9270
06:47:15,750 --> 06:47:17,060
And of course it could be flipped around.

9271
06:47:17,060 --> 06:47:19,860
There's no rhyme or reason
to what you would want.

9272
06:47:19,860 --> 06:47:21,370
It's just a data structure that allows you

9273
06:47:21,370 --> 06:47:22,540
to have a map and a key.

9274
06:47:22,540 --> 06:47:24,660
So if you ever need to
have a map and a key,

9275
06:47:24,660 --> 06:47:27,600
you're gonna wanna use a
map type data structure.

9276
06:47:28,790 --> 06:47:31,500
All right, so when would
you wanna use a sequence?

9277
06:47:31,500 --> 06:47:33,450
Now sequence is basically
going to be anytime

9278
06:47:33,450 --> 06:47:36,360
you want something that's gonna
be more highly performant.

9279
06:47:36,360 --> 06:47:38,790
And this could be, if you
have a very large list.

9280
06:47:38,790 --> 06:47:41,000
So maybe 50 million items in a list

9281
06:47:41,000 --> 06:47:43,200
or you have a bunch of
items you need to process.

9282
06:47:43,200 --> 06:47:45,500
So you have 100 items in a
list and you need to process it

9283
06:47:45,500 --> 06:47:48,269
through a bunch of different maps.

9284
06:47:48,269 --> 06:47:49,102
You're gonna do list.map,

9285
06:47:50,331 --> 06:47:52,950
and then you need to do another
map for whatever reason,

9286
06:47:53,847 --> 06:47:54,780
a map, and then you're
gonna do it for a reason,

9287
06:47:54,780 --> 06:47:57,080
you can do a flat map and then
you're gonna go from there

9288
06:47:57,080 --> 06:47:59,830
and you're gonna do a filter,
or you can do an average,

9289
06:48:00,710 --> 06:48:01,870
actually I'm not gonna work that way.

9290
06:48:01,870 --> 06:48:04,792
But the new map won't work on a flat map

9291
06:48:04,792 --> 06:48:05,625
because you have a list.

9292
06:48:06,841 --> 06:48:08,750
And then so you have, you
know, some averages that are,

9293
06:48:08,750 --> 06:48:11,350
or whatever you get inside
of here and you can filter

9294
06:48:11,350 --> 06:48:13,190
and all different kinds of things.

9295
06:48:13,190 --> 06:48:15,150
And let's say, assume all
of these different things

9296
06:48:15,150 --> 06:48:20,150
had very complex calculations
that took a lot of time

9297
06:48:20,230 --> 06:48:23,630
because lists and so forth
are evaluated eagerly.

9298
06:48:24,610 --> 06:48:26,180
A new list is created each time.

9299
06:48:26,180 --> 06:48:28,780
Then there's actually a
lesson that you can view

9300
06:48:28,780 --> 06:48:31,010
that will show the performance
metrics of actually using

9301
06:48:31,010 --> 06:48:33,580
a sequence overlords lists.

9302
06:48:33,580 --> 06:48:35,670
And so if you need performance,
you'll wanna use a sequence.

9303
06:48:35,670 --> 06:48:37,530
Now, you can also take a large list

9304
06:48:37,530 --> 06:48:39,970
and turn it into a sequence here.

9305
06:48:39,970 --> 06:48:43,220
You can also turn a map and
turn it into a sequence as well.

9306
06:48:43,220 --> 06:48:45,470
So if you have a large map or a large list

9307
06:48:45,470 --> 06:48:47,450
and you need to process it, sequentially,

9308
06:48:47,450 --> 06:48:49,120
you can just slap as sequence on there

9309
06:48:49,120 --> 06:48:51,230
and it will process accordingly.

9310
06:48:51,230 --> 06:48:52,570
And then you can make things very quickly.

9311
06:48:52,570 --> 06:48:53,790
And then if for whatever reason,

9312
06:48:53,790 --> 06:48:55,970
after you're done processing the sequence,

9313
06:48:55,970 --> 06:48:58,260
you would like to turn that
sequence into a list again,

9314
06:48:58,260 --> 06:49:00,502
you can turn it into a list as well.

9315
06:49:00,502 --> 06:49:01,335
Of course, you're gonna wanna measure

9316
06:49:01,335 --> 06:49:02,168
the performance benefit.

9317
06:49:02,168 --> 06:49:05,610
So sequence usually use for performants.

9318
06:49:05,610 --> 06:49:07,480
So if you have large lists, large maps,

9319
06:49:07,480 --> 06:49:10,140
or you're doing a lot
of mapping operations,

9320
06:49:10,140 --> 06:49:12,160
you're doing a lot of
operations, you know,

9321
06:49:12,160 --> 06:49:15,390
on the data structure itself,
then you wanna go ahead

9322
06:49:15,390 --> 06:49:18,890
and turn it into a sequence
or use a sequence if possible.

9323
06:49:20,398 --> 06:49:21,750
And of course you can always
use generate sequence.

9324
06:49:21,750 --> 06:49:24,380
So that's the difference
between the list, set, map

9325
06:49:24,380 --> 06:49:25,213
and sequence.

9326
06:49:26,650 --> 06:49:29,150
Kotlin does not have a ternary operator.

9327
06:49:29,150 --> 06:49:31,672
So if you're looking to
do something like this,

9328
06:49:31,672 --> 06:49:34,440
let's assume we want to get
the length of the string,

9329
06:49:34,440 --> 06:49:36,500
but we only wanna do it, if it's not null,

9330
06:49:36,500 --> 06:49:39,220
perhaps we could say something like this.

9331
06:49:39,220 --> 06:49:40,770
You might be used to doing like this.

9332
06:49:40,770 --> 06:49:43,986
If name does not equal
null then we're gonna do

9333
06:49:43,986 --> 06:49:47,280
name.length, otherwise wanna do zero.

9334
06:49:48,315 --> 06:49:50,480
So you may wanna do something like that.

9335
06:49:50,480 --> 06:49:53,110
You'll see here, we have
to use some wiggly things.

9336
06:49:53,110 --> 06:49:54,490
It's not letting us do this.

9337
06:49:54,490 --> 06:49:56,790
This is because the ternary
operator does not exist

9338
06:49:56,790 --> 06:49:57,760
in Kotlin.

9339
06:49:57,760 --> 06:50:00,600
So to do this, you need to use
a single line if statement.

9340
06:50:00,600 --> 06:50:05,460
So if name's not equal to
null you can do name.length,

9341
06:50:07,650 --> 06:50:10,530
else zero.

9342
06:50:11,790 --> 06:50:14,770
Now this will give you the
length here so we can say

9343
06:50:15,780 --> 06:50:20,780
print line length, and then
you can run the code here

9344
06:50:23,120 --> 06:50:25,470
and you'll see that the
length is then returned.

9345
06:50:25,470 --> 06:50:27,520
And for whatever reason, if this is null,

9346
06:50:29,160 --> 06:50:30,140
we can return that.

9347
06:50:31,560 --> 06:50:34,190
And then we'll get zero because
it's handled accordingly.

9348
06:50:34,190 --> 06:50:39,160
Now we get this nice little use
here where we can replace it

9349
06:50:39,160 --> 06:50:40,980
with the Elvis expression.

9350
06:50:40,980 --> 06:50:43,110
If you know what that
is, you can use that.

9351
06:50:43,110 --> 06:50:46,470
But if you are looking for a
ternary operator in Kotlin,

9352
06:50:46,470 --> 06:50:47,303
it does not exist.

9353
06:50:47,303 --> 06:50:49,820
So you wanna use a single
line If Statement instead.

9354
06:50:52,034 --> 06:50:52,867
It's very often that you could be working

9355
06:50:52,867 --> 06:50:55,550
inside of some code and you
may need to do something.

9356
06:50:55,550 --> 06:50:58,900
For example, you may need to
get the length of the name

9357
06:50:58,900 --> 06:51:02,000
of a particular value, maybe of a string

9358
06:51:02,000 --> 06:51:03,700
and you wanna say name.length.

9359
06:51:04,620 --> 06:51:05,500
Now what you'll notice here,

9360
06:51:05,500 --> 06:51:08,070
because we're working
with a nullable string,

9361
06:51:08,070 --> 06:51:09,180
that we cannot do this.

9362
06:51:09,180 --> 06:51:11,610
Only safe calls can, this can happen.

9363
06:51:11,610 --> 06:51:12,660
So we're gonna get back.

9364
06:51:12,660 --> 06:51:14,860
We could change this to a safe call.

9365
06:51:14,860 --> 06:51:16,400
This would give us a nullable integer.

9366
06:51:16,400 --> 06:51:18,840
However, if we're
working in an environment

9367
06:51:18,840 --> 06:51:21,200
where we do not wanna work with nulls,

9368
06:51:21,200 --> 06:51:22,900
this is not going to work for us.

9369
06:51:22,900 --> 06:51:24,770
So there's a couple of things we could do.

9370
06:51:24,770 --> 06:51:27,440
If we can change the data type
to actually be non-nullable,

9371
06:51:27,440 --> 06:51:28,950
that would be fantastic.

9372
06:51:28,950 --> 06:51:32,130
However, sometimes data comes
back from other libraries,

9373
06:51:32,130 --> 06:51:35,030
such as Java libraries,
where the nullable type

9374
06:51:35,030 --> 06:51:37,750
is just going to be there and
we can't do anything about it.

9375
06:51:37,750 --> 06:51:41,070
However, we may understand
at some point in time

9376
06:51:41,070 --> 06:51:44,080
that we know for certain that this value

9377
06:51:44,080 --> 06:51:44,913
is not going to be known.

9378
06:51:44,913 --> 06:51:47,080
Now, this is something I
usually don't recommend,

9379
06:51:47,080 --> 06:51:48,390
but there's a way to do that.

9380
06:51:48,390 --> 06:51:52,290
And we can use the double
bang operator to tell Kotlin,

9381
06:51:52,290 --> 06:51:53,810
look, I know what I'm doing.

9382
06:51:53,810 --> 06:51:56,300
I know that a named value
is not gonna be null,

9383
06:51:56,300 --> 06:51:58,490
which we can see directly from here.

9384
06:51:58,490 --> 06:52:00,810
There's no way on nothing in line five.

9385
06:52:00,810 --> 06:52:03,350
That's making this not null.

9386
06:52:03,350 --> 06:52:04,280
We're making this null.

9387
06:52:04,280 --> 06:52:06,320
So we're basically telling Kotlin,

9388
06:52:06,320 --> 06:52:07,390
don't worry, I know what I'm doing.

9389
06:52:07,390 --> 06:52:09,680
Trust me, just go ahead and treat this

9390
06:52:09,680 --> 06:52:11,590
as something that's not null.

9391
06:52:11,590 --> 06:52:14,280
And then what we'll have
happen is we'll go ahead

9392
06:52:14,280 --> 06:52:19,280
and we can say print line
length, and then we can run it.

9393
06:52:19,550 --> 06:52:23,220
And then what will happen is
we'll then have a int value,

9394
06:52:23,220 --> 06:52:27,050
which is again, it's only
going to be a regular integer,

9395
06:52:27,050 --> 06:52:28,570
so it's not gonna be nullable

9396
06:52:28,570 --> 06:52:30,910
and then we'll get the length of four.

9397
06:52:30,910 --> 06:52:33,100
Now, the real challenge comes in here

9398
06:52:35,420 --> 06:52:37,540
when you're telling Kotlin, hey, trust me,

9399
06:52:37,540 --> 06:52:39,510
I know this is not gonna be null,

9400
06:52:39,510 --> 06:52:41,490
but for some reason it ends up null.

9401
06:52:41,490 --> 06:52:43,510
And this can end up showing
up inside of your code

9402
06:52:43,510 --> 06:52:44,690
multiple times.

9403
06:52:44,690 --> 06:52:47,430
So if you find yourself
doing something like this

9404
06:52:47,430 --> 06:52:49,620
all over the place, you
might wanna inspect your code

9405
06:52:49,620 --> 06:52:51,640
to see if it's something is correct.

9406
06:52:51,640 --> 06:52:54,241
Now on tests, you may have it a lot,

9407
06:52:54,241 --> 06:52:56,220
but in this instance, perhaps I've said,

9408
06:52:56,220 --> 06:52:57,360
hey, this should not be null.

9409
06:52:57,360 --> 06:52:59,870
Maybe this code on line
six is buried somewhere

9410
06:52:59,870 --> 06:53:01,330
in a method somewhere.

9411
06:53:01,330 --> 06:53:03,120
But what happen is when Kotlin says,

9412
06:53:03,120 --> 06:53:07,320
hey, go ahead and just treat
this as a nominal value

9413
06:53:07,320 --> 06:53:09,610
and give me the length
on it, and it's null,

9414
06:53:09,610 --> 06:53:11,900
it'll throw a Kotlin and
null pointer exception.

9415
06:53:11,900 --> 06:53:13,940
So this will blow up your application.

9416
06:53:13,940 --> 06:53:16,750
So you do have to be
careful in this regard

9417
06:53:16,750 --> 06:53:18,750
to see if you want to
actually work with this.

9418
06:53:18,750 --> 06:53:20,630
So again, if you know what you're doing

9419
06:53:20,630 --> 06:53:22,190
and you wanna tell Kotlin about it,

9420
06:53:22,190 --> 06:53:23,300
you can go ahead and say,

9421
06:53:23,300 --> 06:53:24,600
hey, Kotlin, I know what I'm doing.

9422
06:53:24,600 --> 06:53:26,200
Use the double bang operator.

9423
06:53:26,200 --> 06:53:28,859
The same thing could go for a class.

9424
06:53:28,859 --> 06:53:31,790
So if we have a person and
then we have a vowel name

9425
06:53:32,655 --> 06:53:33,890
and that's gonna be a string,

9426
06:53:33,890 --> 06:53:35,560
we could actually say something like this.

9427
06:53:35,560 --> 06:53:37,260
And we can have a nullable person.

9428
06:53:38,395 --> 06:53:39,950
Let's say person,

9429
06:53:39,950 --> 06:53:42,641
and that's gonna be a
person that's nullable,

9430
06:53:42,641 --> 06:53:44,290
again, maybe this comes back from an API

9431
06:53:44,290 --> 06:53:46,150
and it could be empty or whatever.

9432
06:53:46,150 --> 06:53:48,340
And so the person could be Don.

9433
06:53:49,470 --> 06:53:52,000
At this point in time
I could say, if I wanna

9434
06:53:52,000 --> 06:53:54,130
kind of get the values of print ln,

9435
06:53:55,090 --> 06:53:56,690
I wanna print the person's name.

9436
06:53:57,790 --> 06:54:00,600
Well, this is not gonna
work because again,

9437
06:54:00,600 --> 06:54:02,690
person is nullable and Kotlin will say,

9438
06:54:02,690 --> 06:54:04,700
hey, we're not sure if this is a safe call

9439
06:54:04,700 --> 06:54:07,260
because well, person's nullable,

9440
06:54:07,260 --> 06:54:09,120
and this could end up being
a null pointer exception.

9441
06:54:09,120 --> 06:54:10,260
So I could handle it this way.

9442
06:54:10,260 --> 06:54:12,780
And if I did handle it
this way, if we ran it,

9443
06:54:12,780 --> 06:54:15,190
it would still work, we
would get the person's name.

9444
06:54:15,190 --> 06:54:16,023
It would be Don.

9445
06:54:16,023 --> 06:54:19,540
However, if for some reason
this was comment that out,

9446
06:54:19,540 --> 06:54:21,940
and this was no we're now gonna go ahead

9447
06:54:21,940 --> 06:54:25,920
and we run this again,
it's gonna show up as null.

9448
06:54:25,920 --> 06:54:27,430
But again, maybe we don't want that,

9449
06:54:27,430 --> 06:54:30,670
we want it to say, hey, trust
us, we know what we're doing.

9450
06:54:30,670 --> 06:54:33,440
So you can use also the double
bang operator inside of here.

9451
06:54:33,440 --> 06:54:35,770
Again, if the value is null
as it's happening here,

9452
06:54:35,770 --> 06:54:38,960
you're going to get this
Kotlin null pointer exception.

9453
06:54:38,960 --> 06:54:40,740
So if we were to just remove this,

9454
06:54:40,740 --> 06:54:43,341
again, it's going to work as we expect.

9455
06:54:43,341 --> 06:54:46,000
But usually my recommendation
is if you see yourself

9456
06:54:46,000 --> 06:54:48,470
or wanting yourself to add
these values all over the place,

9457
06:54:48,470 --> 06:54:50,070
you might wanna figure
out if there's a way

9458
06:54:50,070 --> 06:54:53,030
where you can not use that or
use something like required,

9459
06:54:53,030 --> 06:54:55,190
not null which is in another video

9460
06:54:55,190 --> 06:54:57,260
and link in the show notes below.

9461
06:54:58,820 --> 06:55:01,940
In some Kotlin code bases,
you may find yourself

9462
06:55:01,940 --> 06:55:03,970
wanting to type the double
bang operator to force

9463
06:55:03,970 --> 06:55:06,780
a nullable value to not
be nullable anymore.

9464
06:55:06,780 --> 06:55:07,710
You're basically telling Kotlin,

9465
06:55:07,710 --> 06:55:10,215
hey, trust me, I know what I'm doing.

9466
06:55:10,215 --> 06:55:12,340
This can happen for regular
primitive nullable types,

9467
06:55:12,340 --> 06:55:15,840
such as the strings integers,
et cetera, Boolean values,

9468
06:55:15,840 --> 06:55:18,940
or it can also happen
for the nullable objects

9469
06:55:18,940 --> 06:55:21,800
such as a person object that we have here.

9470
06:55:21,800 --> 06:55:23,000
Now, there's a way around this.

9471
06:55:23,000 --> 06:55:24,790
If you don't wanna type
the double bang operator,

9472
06:55:24,790 --> 06:55:26,720
you can also use what is built in

9473
06:55:26,720 --> 06:55:27,990
to the Kotlin standard library,

9474
06:55:27,990 --> 06:55:30,520
which is called require not null,

9475
06:55:30,520 --> 06:55:35,520
and require not null basically
will turn this value,

9476
06:55:35,620 --> 06:55:38,690
which if you look at it
into a non nullable type,

9477
06:55:38,690 --> 06:55:39,930
if it's null, though,

9478
06:55:39,930 --> 06:55:41,950
it will throw in a legal argument section,

9479
06:55:41,950 --> 06:55:44,350
otherwise returns the not null value.

9480
06:55:44,350 --> 06:55:48,060
So if we run this here, what
we'll see is it'll continue

9481
06:55:48,060 --> 06:55:51,750
to run this fine because we
have the length of the name.

9482
06:55:51,750 --> 06:55:55,370
This has now been turned
into a regular string,

9483
06:55:55,370 --> 06:55:56,690
not a nullable string.

9484
06:55:56,690 --> 06:56:00,640
However, if for whatever reason,
this comes back from an API

9485
06:56:00,640 --> 06:56:04,060
or database or something,
and that value is null

9486
06:56:04,060 --> 06:56:05,320
and we process it.

9487
06:56:05,320 --> 06:56:07,230
What will then happen is Kotlin will throw

9488
06:56:07,230 --> 06:56:08,760
an illegal argument exception saying,

9489
06:56:08,760 --> 06:56:10,850
hey, the required value is null.

9490
06:56:10,850 --> 06:56:14,040
Now, to be honest, this
error message while helpful,

9491
06:56:14,040 --> 06:56:16,900
this required value is
null, in a large code base,

9492
06:56:16,900 --> 06:56:18,150
this is not very helpful.

9493
06:56:19,188 --> 06:56:21,210
This can be kind of like,
okay, there was a null value

9494
06:56:21,210 --> 06:56:23,280
somewhere that we shouldn't
have got, where's it at?

9495
06:56:23,280 --> 06:56:26,250
Okay, let's look at the stack
trace, there's a stack trace.

9496
06:56:26,250 --> 06:56:27,300
Let's go investigate it.

9497
06:56:27,300 --> 06:56:29,740
Sometimes it helps to have
some additional information

9498
06:56:29,740 --> 06:56:30,573
inside of there.

9499
06:56:30,573 --> 06:56:32,970
And so you can do that,
there's actually an overload

9500
06:56:32,970 --> 06:56:36,740
of this, which will allow you
to provide a lazy message,

9501
06:56:36,740 --> 06:56:38,910
which will be the result
of that being called.

9502
06:56:38,910 --> 06:56:40,730
And so it can be a function.

9503
06:56:40,730 --> 06:56:42,860
And we're just gonna go
ahead and use the lambda.

9504
06:56:42,860 --> 06:56:45,992
And I'm gonna say something like the name

9505
06:56:45,992 --> 06:56:50,380
should not be null, but
it was, exclamation point.

9506
06:56:50,380 --> 06:56:52,580
Now, if I run this, we'll
still get an illegal

9507
06:56:52,580 --> 06:56:54,810
argument exception, but
we'll get the message

9508
06:56:54,810 --> 06:56:56,900
the name should not be null but it was.

9509
06:56:56,900 --> 06:56:59,458
And you could provide some
additional information

9510
06:56:59,458 --> 06:57:02,430
inside of here, perhaps that
might help you debugging,

9511
06:57:02,430 --> 06:57:05,243
if you were throwing in
legal argument exception,

9512
06:57:05,243 --> 06:57:07,540
and you have a crash
handler on your application,

9513
06:57:07,540 --> 06:57:09,440
if you're having an Android application,

9514
06:57:09,440 --> 06:57:11,330
this information is gonna show up inside

9515
06:57:11,330 --> 06:57:13,660
of your crash tracking utility.

9516
06:57:13,660 --> 06:57:14,670
So you might be able to say,

9517
06:57:14,670 --> 06:57:16,900
hey, here's the value that came in.

9518
06:57:16,900 --> 06:57:19,800
You could throw additional
information inside of here

9519
06:57:19,800 --> 06:57:22,970
that might help you diagnose what it is.

9520
06:57:22,970 --> 06:57:26,450
Sometimes, maybe a backend
changed and they are sending

9521
06:57:26,450 --> 06:57:29,360
a nullable value that was
not supposed to be nullable,

9522
06:57:29,360 --> 06:57:32,890
and you're not expecting it
to be null and things blow up.

9523
06:57:32,890 --> 06:57:35,580
And so you can just say require not null

9524
06:57:35,580 --> 06:57:37,240
and that'll get you around it there.

9525
06:57:37,240 --> 06:57:39,680
Now there's also, you
can do the same thing

9526
06:57:39,680 --> 06:57:42,950
for objects as well, not
just primitive types.

9527
06:57:42,950 --> 06:57:46,180
So we have this person here,
perhaps we don't wanna use

9528
06:57:46,180 --> 06:57:47,510
a double bang operator here.

9529
06:57:47,510 --> 06:57:51,380
We can go ahead and say require not null.

9530
06:57:51,380 --> 06:57:53,010
And again, it's just
gonna take this object

9531
06:57:53,010 --> 06:57:54,950
and make it to this not null type.

9532
06:57:55,910 --> 06:57:56,810
And there we go.

9533
06:57:56,810 --> 06:57:59,320
And if we run that everything
should run accordingly,

9534
06:57:59,320 --> 06:58:02,680
except we're gonna get that
exception, so let's fix that.

9535
06:58:02,680 --> 06:58:04,310
That's the exception from up here.

9536
06:58:04,310 --> 06:58:05,660
So I would just say Don.

9537
06:58:07,136 --> 06:58:10,060
And if we run this now, we'll
see that we get the Don,

9538
06:58:10,060 --> 06:58:11,000
which is down here in the bottom,

9539
06:58:11,000 --> 06:58:13,140
which is from this print line down here.

9540
06:58:13,140 --> 06:58:15,500
So we can actually just go
ahead and get rid of that

9541
06:58:15,500 --> 06:58:17,130
to make it easier.

9542
06:58:17,130 --> 06:58:21,180
And then if for whatever
reason this person was null,

9543
06:58:22,980 --> 06:58:24,180
same thing happens here.

9544
06:58:25,469 --> 06:58:26,870
So you can say require not
null on an actual class,

9545
06:58:26,870 --> 06:58:28,900
you'll get the same thing,
the required value was null.

9546
06:58:28,900 --> 06:58:30,420
Again, just like the other version,

9547
06:58:30,420 --> 06:58:32,260
it's the same exact thing.

9548
06:58:32,260 --> 06:58:34,370
You can put some other our message here.

9549
06:58:34,370 --> 06:58:36,570
So hi friends.

9550
06:58:36,570 --> 06:58:38,040
Not that you would wanna
do this in production,

9551
06:58:38,040 --> 06:58:39,980
but this basically oops,

9552
06:58:39,980 --> 06:58:41,980
and that needs to be inside of a lambda.

9553
06:58:43,550 --> 06:58:45,570
So that just needs to be there.

9554
06:58:45,570 --> 06:58:48,830
And then it'll actually show
up in there, so hi friends.

9555
06:58:48,830 --> 06:58:50,300
You can put any message
you want inside there.

9556
06:58:50,300 --> 06:58:53,580
So person should not be null, here we go.

9557
06:58:57,060 --> 06:58:59,637
And then once you run it and
you'll see that the person

9558
06:58:59,637 --> 06:59:00,470
should not be null.

9559
06:59:00,470 --> 06:59:03,220
And that's how you can
use a require not null

9560
06:59:03,220 --> 06:59:04,570
inside of your application.

9561
06:59:05,494 --> 06:59:06,330
So you may have some
code in your application

9562
06:59:06,330 --> 06:59:09,300
that looks like this, you have
an object, that's a person.

9563
06:59:09,300 --> 06:59:11,760
And for whatever reason, it
comes back from the API as null

9564
06:59:11,760 --> 06:59:13,366
or it doesn't.

9565
06:59:13,366 --> 06:59:15,323
And then inside of your code,
you're using the double bang

9566
06:59:15,323 --> 06:59:20,323
operator to force the person
object to not be null.

9567
06:59:20,510 --> 06:59:21,530
So of course this wouldn't work.

9568
06:59:21,530 --> 06:59:23,630
You could do something like
this, this would also work.

9569
06:59:23,630 --> 06:59:25,010
It's actually much cleaner in my opinion,

9570
06:59:25,010 --> 06:59:28,040
this way than forcing it to be not null,

9571
06:59:28,040 --> 06:59:31,290
because we could not run into situations.

9572
06:59:31,290 --> 06:59:33,380
But as for whatever reason,
let's say you do have that

9573
06:59:33,380 --> 06:59:35,860
or you're using require not null.

9574
06:59:35,860 --> 06:59:37,880
And require not null will basically turn

9575
06:59:39,632 --> 06:59:40,530
that nullable person
into a regular person.

9576
06:59:40,530 --> 06:59:42,900
However, there's also check not null.

9577
06:59:44,420 --> 06:59:47,930
And check not null basically
does the exact same thing

9578
06:59:47,930 --> 06:59:49,700
as required not null.

9579
06:59:49,700 --> 06:59:51,870
And if we go to the implementation here,

9580
06:59:51,870 --> 06:59:54,130
we'll actually see that check not null,

9581
06:59:54,130 --> 06:59:58,300
which is down here at the bottom
is basically the exact same

9582
06:59:58,300 --> 06:59:59,740
as require not null.

9583
06:59:59,740 --> 07:00:01,690
So let's go ahead and shrink this down.

9584
07:00:02,896 --> 07:00:04,790
Let's see if we can get it
all into the same screen.

9585
07:00:04,790 --> 07:00:05,900
Very close.

9586
07:00:05,900 --> 07:00:07,510
So require not null is up here.

9587
07:00:10,036 --> 07:00:12,770
And then we have check not
null, which is down here.

9588
07:00:12,770 --> 07:00:15,000
And we could see it as a
contract for require not null

9589
07:00:15,000 --> 07:00:17,090
checks the value, we get the lazy message.

9590
07:00:17,090 --> 07:00:21,280
And if we look down here,
the code is exactly the same.

9591
07:00:21,280 --> 07:00:22,560
So it's doing the same exact thing.

9592
07:00:22,560 --> 07:00:25,470
It's basically checking
to see if it's not null

9593
07:00:26,356 --> 07:00:27,189
and requiring it if it's not null.

9594
07:00:27,189 --> 07:00:29,260
And if it does, if it's
there, it returns the value,

9595
07:00:29,260 --> 07:00:30,270
otherwise it doesn't.

9596
07:00:30,270 --> 07:00:32,650
So you can use either one
of these check not null

9597
07:00:32,650 --> 07:00:34,810
or require not null, depends
on what you'd like to do.

9598
07:00:34,810 --> 07:00:37,590
I have seen in multiple code
bases where a check not null

9599
07:00:37,590 --> 07:00:40,260
will be somewhere
randomly in the code base,

9600
07:00:40,260 --> 07:00:43,650
perhaps after an API call,

9601
07:00:43,650 --> 07:00:46,192
just make sure that the users not null.

9602
07:00:46,192 --> 07:00:47,110
And then at that point in time,

9603
07:00:47,110 --> 07:00:50,810
the person might be a
var if that's the case.

9604
07:00:51,910 --> 07:00:54,810
So if that's the case, it
might be var person equals

9605
07:00:54,810 --> 07:00:57,070
check not null or person two.

9606
07:00:59,211 --> 07:01:00,050
At that point in time, check not null.

9607
07:01:00,050 --> 07:01:01,800
So you hadn't have a nullable version.

9608
07:01:01,800 --> 07:01:04,980
So you can either use require
not null or check not null.

9609
07:01:04,980 --> 07:01:06,910
Let's go ahead and assume
you have a list of names

9610
07:01:06,910 --> 07:01:09,380
or some list of data that
has come back from a database

9611
07:01:09,380 --> 07:01:11,480
API call or anything like that.

9612
07:01:12,460 --> 07:01:13,750
Here we're just creating a list of names

9613
07:01:13,750 --> 07:01:16,647
and we have a couple
of null values in here.

9614
07:01:16,647 --> 07:01:17,660
Now it's very often that, for example,

9615
07:01:17,660 --> 07:01:21,040
we now have a list front
that is a nullable string.

9616
07:01:21,040 --> 07:01:24,470
So a list of nullable strings
and in our application,

9617
07:01:24,470 --> 07:01:26,640
or maybe even a library
that does not allow

9618
07:01:26,640 --> 07:01:28,720
a list of nullable strings, all the values

9619
07:01:28,720 --> 07:01:30,220
have to be present.

9620
07:01:30,220 --> 07:01:32,420
So what can you do here?

9621
07:01:32,420 --> 07:01:34,270
Well, there's a couple
of things you could do.

9622
07:01:34,270 --> 07:01:36,610
You could go through
each one of these things.

9623
07:01:36,610 --> 07:01:39,670
And so we could say you
could filter them out.

9624
07:01:39,670 --> 07:01:41,680
You can map them to a correct value.

9625
07:01:41,680 --> 07:01:44,060
Or if you just want all of
the items that are not null,

9626
07:01:44,060 --> 07:01:48,360
you could say val names that are not null.

9627
07:01:48,360 --> 07:01:53,360
And you could say names
dot filter not null.

9628
07:01:53,380 --> 07:01:54,640
It's a nice little help our method there.

9629
07:01:54,640 --> 07:01:57,325
And then you can just go
ahead and print line that

9630
07:01:57,325 --> 07:01:59,630
to the screen, name that are not null.

9631
07:01:59,630 --> 07:02:01,750
Let's going and fix that
because it should say names.

9632
07:02:03,090 --> 07:02:04,020
And if we go ahead and run this,

9633
07:02:04,020 --> 07:02:06,260
what we'll see is we're
gonna have all of the names

9634
07:02:06,260 --> 07:02:07,980
and we are not going
to have the null value.

9635
07:02:07,980 --> 07:02:10,730
So very easy to filter out a list

9636
07:02:10,730 --> 07:02:12,540
of all the non nullable types.

9637
07:02:12,540 --> 07:02:14,720
So if you don't want nulls in your list

9638
07:02:14,720 --> 07:02:16,670
and they are already there,
you can filter it out

9639
07:02:16,670 --> 07:02:19,180
with the easy filter not null method.

9640
07:02:20,540 --> 07:02:22,040
One of the keys to understanding Kotlin

9641
07:02:22,040 --> 07:02:24,190
is understanding the
type hierarchy system.

9642
07:02:25,100 --> 07:02:29,230
So this is a great diagram,
which is actually used over here

9643
07:02:29,230 --> 07:02:30,890
from this gentleman who created it,

9644
07:02:30,890 --> 07:02:32,080
which is Marcos Sandoval.

9645
07:02:32,080 --> 07:02:33,250
So, thank you, Marcos.

9646
07:02:33,250 --> 07:02:37,000
This is a great diagram that
illustrates the Kotlin type

9647
07:02:37,000 --> 07:02:39,330
hierarchy system, which basically states

9648
07:02:39,330 --> 07:02:42,060
that any non-billable type
is always going to extend

9649
07:02:42,060 --> 07:02:44,810
to any type and any nullable type

9650
07:02:44,810 --> 07:02:48,050
will extend the nullable any
type which we can see here.

9651
07:02:49,063 --> 07:02:51,487
And then we have also
nothing in there, et cetera.

9652
07:02:51,487 --> 07:02:52,320
We get into that later.

9653
07:02:52,320 --> 07:02:54,860
So Boolean, string, a class,
you create unit number,

9654
07:02:54,860 --> 07:02:56,300
everything extends any.

9655
07:02:56,300 --> 07:02:59,240
So you can use any or
the nullable any type

9656
07:02:59,240 --> 07:03:02,090
instead of your functions
as a parameter type.

9657
07:03:02,090 --> 07:03:05,050
So this is very similar
to in the Java world

9658
07:03:05,050 --> 07:03:05,980
of using object.

9659
07:03:07,240 --> 07:03:09,260
Now you can actually test this by writing

9660
07:03:09,260 --> 07:03:12,990
a simple little program And
we'll say Val age equals 32.

9661
07:03:12,990 --> 07:03:14,360
And we could say something like this.

9662
07:03:14,360 --> 07:03:18,100
If age is any, then we can actually say

9663
07:03:18,100 --> 07:03:20,680
print is any.

9664
07:03:22,061 --> 07:03:23,220
And that would tell us if this is any.

9665
07:03:23,220 --> 07:03:26,700
Now this is how we can check
for types inside of Kotlin.

9666
07:03:26,700 --> 07:03:27,990
This is type checking.

9667
07:03:27,990 --> 07:03:30,310
We're checking to see if age
is of this particular type.

9668
07:03:30,310 --> 07:03:33,870
Now I can change this to
say, hey if age is a string

9669
07:03:33,870 --> 07:03:36,630
and we're gonna see here,
the incompatible types

9670
07:03:36,630 --> 07:03:39,280
type string and into it already
knows the compiler knows

9671
07:03:39,280 --> 07:03:41,140
at this point in time that
this is not going to work.

9672
07:03:41,140 --> 07:03:45,120
So what we could say is I can
change this to the type any.

9673
07:03:46,568 --> 07:03:47,401
I could say if age is a string,

9674
07:03:47,401 --> 07:03:48,810
then it would print that off.

9675
07:03:48,810 --> 07:03:51,020
And if we run this, we'll
see we get nothing back.

9676
07:03:51,020 --> 07:03:52,970
So let's go ahead and add
an else statement here.

9677
07:03:53,970 --> 07:03:54,803
Print ln.any.

9678
07:03:58,640 --> 07:04:02,310
Now, if we say not any,
well, this is a string,

9679
07:04:02,310 --> 07:04:07,030
so we're just gonna change
this to it is, it is not.

9680
07:04:08,720 --> 07:04:12,390
And so is it page, which has
any, does it equal string?

9681
07:04:12,390 --> 07:04:13,223
No, it's not.

9682
07:04:13,223 --> 07:04:16,980
Okay, well, is it a int, let's
run that, see is it an int?

9683
07:04:18,240 --> 07:04:20,970
We see it is, we can change
these to different values.

9684
07:04:20,970 --> 07:04:22,420
So we'll say, is it a double?

9685
07:04:23,730 --> 07:04:24,730
And we can run is it a double?

9686
07:04:25,709 --> 07:04:26,542
It is not.

9687
07:04:26,542 --> 07:04:28,170
So this allows us to start doing various

9688
07:04:28,170 --> 07:04:29,080
different types of things.

9689
07:04:29,080 --> 07:04:32,610
We could change this to
because again, string.

9690
07:04:32,610 --> 07:04:36,380
We'll use Donn actually
is a string and we'll see

9691
07:04:36,380 --> 07:04:39,700
that is not a double,
again it still compiles.

9692
07:04:39,700 --> 07:04:41,130
Is it a int?

9693
07:04:41,130 --> 07:04:43,320
No, it's not because it's an int.

9694
07:04:43,320 --> 07:04:45,340
But if we were to change this to string,

9695
07:04:47,430 --> 07:04:49,760
then we would see that we can
actually easily type check it.

9696
07:04:49,760 --> 07:04:53,830
Now this also works for other,
your own custom classes too.

9697
07:04:53,830 --> 07:04:56,820
So we could say a data
class say create an order.

9698
07:04:57,920 --> 07:05:00,140
And maybe it has an
amount which is an int.

9699
07:05:01,125 --> 07:05:02,870
And then maybe we have
just a regular class

9700
07:05:02,870 --> 07:05:03,910
that is a person.

9701
07:05:05,324 --> 07:05:08,520
And this person has a
name, which is a string.

9702
07:05:08,520 --> 07:05:10,920
So we can create an object here, say,

9703
07:05:10,920 --> 07:05:14,900
val, I'll be J and we would call this.

9704
07:05:15,775 --> 07:05:17,570
We're gonna say, hey, this is
any, so we're kind of just,

9705
07:05:17,570 --> 07:05:19,870
we're using the root object here.

9706
07:05:19,870 --> 07:05:21,680
And we're saying that this is any.

9707
07:05:21,680 --> 07:05:25,220
And we're gonna create this
person and his name's gonna be,

9708
07:05:25,220 --> 07:05:29,960
let's call it Bob, Bob.

9709
07:05:29,960 --> 07:05:32,430
And then what we can say, let
me get rid of this age thing.

9710
07:05:32,430 --> 07:05:33,890
We'll say this object string.

9711
07:05:36,700 --> 07:05:38,650
No, it's not, so it's not a string.

9712
07:05:39,540 --> 07:05:40,600
And we see that it is not.

9713
07:05:40,600 --> 07:05:43,990
However, it would be nice to
see what kind of object it is.

9714
07:05:43,990 --> 07:05:47,070
And we can do that pretty
easily say print line,

9715
07:05:47,070 --> 07:05:49,970
and we can just inspect the
object, object.javaClass.name.

9716
07:05:51,077 --> 07:05:54,000
And this will give us the name
of the Java class that it is.

9717
07:05:54,000 --> 07:05:56,480
So is this person a string?

9718
07:05:56,480 --> 07:05:58,080
No, it's not, it's a person class.

9719
07:05:58,080 --> 07:06:02,310
So let's change this back
to a, let's go do a 16.0

9720
07:06:03,700 --> 07:06:04,533
let's see what that is.

9721
07:06:04,533 --> 07:06:06,390
So is it a string, it's
not, and we'll see,

9722
07:06:06,390 --> 07:06:07,840
it looks like it is a double.

9723
07:06:08,820 --> 07:06:13,170
And then we can also print
a, we could change this to,

9724
07:06:15,439 --> 07:06:16,272
you can change this back to Bob.

9725
07:06:16,272 --> 07:06:18,364
And of course, this is gonna say it is,

9726
07:06:18,364 --> 07:06:20,360
but let's go ahead and
change this to int now.

9727
07:06:20,360 --> 07:06:22,150
And if we run this, what
we're gonna see now,

9728
07:06:22,150 --> 07:06:26,010
is it gonna say it is not and
the type is Java.line.string.

9729
07:06:26,010 --> 07:06:28,280
Now we can change this around too.

9730
07:06:28,280 --> 07:06:29,790
We can say, is this any.

9731
07:06:29,790 --> 07:06:32,363
Now this is just gonna
execute for everything,

9732
07:06:32,363 --> 07:06:33,730
it's just gonna say it is.

9733
07:06:33,730 --> 07:06:37,150
So it is, we could say 12.

9734
07:06:37,150 --> 07:06:39,690
We're just gonna say that it is.

9735
07:06:39,690 --> 07:06:43,210
And we could say for the data class order,

9736
07:06:43,210 --> 07:06:48,210
which is gonna have an
amount of 120 is object any,

9737
07:06:49,170 --> 07:06:52,930
it is so any is the
root object of anything.

9738
07:06:52,930 --> 07:06:56,420
So this allows you to do
some cool type checking

9739
07:06:56,420 --> 07:06:58,850
inside of your application,

9740
07:06:58,850 --> 07:07:01,340
because you may have an
application that returns,

9741
07:07:01,340 --> 07:07:02,480
you working with some different types

9742
07:07:02,480 --> 07:07:06,940
and for whatever reason,
it returns back in any

9743
07:07:06,940 --> 07:07:09,490
which can happen for some various reasons.

9744
07:07:09,490 --> 07:07:14,170
And so if, for example, let's
go ahead and in a string.

9745
07:07:15,477 --> 07:07:17,427
So val value and it's gonna be a string

9746
07:07:18,772 --> 07:07:21,560
and we'll use a one expression, one value.

9747
07:07:21,560 --> 07:07:26,560
And when we say the value is
one, then we want it to return.

9748
07:07:28,904 --> 07:07:30,204
Let's say return here two.

9749
07:07:36,890 --> 07:07:41,370
And if we return two,
we're gonna return a hello.

9750
07:07:44,360 --> 07:07:47,700
If we say three, then we're
gonna return something else,

9751
07:07:47,700 --> 07:07:50,690
such as a true Boolean value.

9752
07:07:50,690 --> 07:07:53,920
If we ask for four, then
we're gonna return a double.

9753
07:07:53,920 --> 07:07:55,900
And so we'll say 16.01.

9754
07:07:56,940 --> 07:07:59,100
And then of course we have
to provide an exhaustive else

9755
07:07:59,100 --> 07:08:02,590
because this could end
up being a certain value.

9756
07:08:02,590 --> 07:08:05,900
So we can get rid of that, there we go.

9757
07:08:05,900 --> 07:08:07,930
And now at this point,
what we can do up here

9758
07:08:07,930 --> 07:08:12,930
is we can just say, what we
can do is if we were to say,

9759
07:08:15,710 --> 07:08:20,710
get stuff in order to parsing
them to number one there,

9760
07:08:20,950 --> 07:08:23,500
what that's gonna do is any
is gonna report to it is.

9761
07:08:23,500 --> 07:08:25,730
But let's go ahead and
change this to string.

9762
07:08:26,990 --> 07:08:29,930
So if my method, maybe a
library I'm working with

9763
07:08:29,930 --> 07:08:31,990
returns, an object or any,
or something like that,

9764
07:08:31,990 --> 07:08:34,980
I can do the type checking
with the is key word.

9765
07:08:34,980 --> 07:08:37,050
And so it's not, so it's an integer.

9766
07:08:37,050 --> 07:08:38,020
What about number two?

9767
07:08:38,020 --> 07:08:41,630
So whatever this method
returns is in any, it is.

9768
07:08:41,630 --> 07:08:45,590
So now I can actually do this
and do different type checking

9769
07:08:45,590 --> 07:08:48,160
and perform various different operations

9770
07:08:48,160 --> 07:08:51,770
based upon the type checking
if I'm working with any type.

9771
07:08:52,900 --> 07:08:54,850
Sometimes you have a
method that returns any,

9772
07:08:54,850 --> 07:08:57,010
and you need to cast that
into a particular value.

9773
07:08:57,010 --> 07:09:00,310
So maybe we know that we
need this to be the age

9774
07:09:00,310 --> 07:09:01,270
and it's gonna be int.

9775
07:09:01,270 --> 07:09:03,500
And so we need to cast
this into an integer.

9776
07:09:03,500 --> 07:09:07,420
So we could say obj.as
int, and when we run this,

9777
07:09:07,420 --> 07:09:09,740
because the OBJ is in any value.

9778
07:09:11,130 --> 07:09:13,460
If we run it, we'll go ahead and see

9779
07:09:13,460 --> 07:09:16,910
that it did execute correctly
and we forgot to print it.

9780
07:09:16,910 --> 07:09:19,255
So we print this to the screen,

9781
07:09:19,255 --> 07:09:22,460
we'll see that it was run as OBJ to 99.

9782
07:09:22,460 --> 07:09:23,760
Now, for whatever reason,

9783
07:09:23,760 --> 07:09:27,730
we were working with the string
and we wanted to use a name.

9784
07:09:27,730 --> 07:09:30,020
So let's just call this
cast so it's easier.

9785
07:09:30,890 --> 07:09:34,110
And this was a name and we'll
call this, this was a string.

9786
07:09:34,110 --> 07:09:35,950
We're expecting it to be a string.

9787
07:09:35,950 --> 07:09:38,584
And we want this to be cast to a string.

9788
07:09:38,584 --> 07:09:40,740
And of course we want maybe
our method of assuming

9789
07:09:40,740 --> 07:09:42,790
this is from like an API
or something like that

9790
07:09:42,790 --> 07:09:45,510
or some library that
gives us back an any type,

9791
07:09:45,510 --> 07:09:46,780
somewhat for some reason.

9792
07:09:47,710 --> 07:09:50,178
We know that number two returns, hello,

9793
07:09:50,178 --> 07:09:51,011
we can then cast that to a string.

9794
07:09:51,011 --> 07:09:53,877
And then at this point
in time going forward,

9795
07:09:53,877 --> 07:09:54,710
we now have a string.

9796
07:09:54,710 --> 07:09:57,960
And what that gives us is
the ability to actually use

9797
07:09:57,960 --> 07:10:00,550
different, for example, I have the length,

9798
07:10:00,550 --> 07:10:03,320
I can do all different kinds
of stuff with this as well.

9799
07:10:03,320 --> 07:10:05,920
If for let's even take this a step further

9800
07:10:05,920 --> 07:10:09,730
and say that I had a data class, a person,

9801
07:10:09,730 --> 07:10:14,290
and that person has a
name and that's a string.

9802
07:10:14,290 --> 07:10:17,720
Then what I could do inside
of here if we say five,

9803
07:10:17,720 --> 07:10:22,720
I would then return back
person with the name of Don.

9804
07:10:23,050 --> 07:10:24,980
So this is gonna work because I have two,

9805
07:10:24,980 --> 07:10:27,310
and I'm gonna return back to value of two,

9806
07:10:27,310 --> 07:10:29,810
but I could also do something like this.

9807
07:10:29,810 --> 07:10:31,770
I could say five.

9808
07:10:31,770 --> 07:10:36,350
Now this of course is, if
we look at object, OBJ,

9809
07:10:36,350 --> 07:10:39,232
what do we have on it, what is it?

9810
07:10:39,232 --> 07:10:42,840
It's any type as you
can see here, it's any.

9811
07:10:42,840 --> 07:10:44,920
So the things that we can do with it.

9812
07:10:45,790 --> 07:10:48,380
If I know that when I parse a five in,

9813
07:10:48,380 --> 07:10:51,000
I'm gonna get a person,
I can't say any.name.

9814
07:10:51,000 --> 07:10:53,760
Name doesn't exist because
I'm working with an any type.

9815
07:10:53,760 --> 07:10:55,490
So I need to cast that
to have the type them,

9816
07:10:55,490 --> 07:10:56,420
which I can work with it.

9817
07:10:56,420 --> 07:11:00,100
So five let's go and
cast that to a person.

9818
07:11:00,100 --> 07:11:02,080
I need to make this person.

9819
07:11:02,080 --> 07:11:03,730
And now I have a person object.

9820
07:11:04,658 --> 07:11:06,070
And what that means is
now I can say cast it.

9821
07:11:07,528 --> 07:11:09,320
And now I have the name and
I also have the copy method,

9822
07:11:09,320 --> 07:11:11,170
which is built into data classes.

9823
07:11:11,170 --> 07:11:13,942
And everything else that
data class is also have

9824
07:11:13,942 --> 07:11:15,570
along with it or any other
class that you're working with.

9825
07:11:15,570 --> 07:11:16,840
So now I can access the name.

9826
07:11:16,840 --> 07:11:20,020
So I've basically turned this
any type right here, any,

9827
07:11:20,020 --> 07:11:21,520
I've turned it into a person.

9828
07:11:21,520 --> 07:11:23,700
So now when I work with
this person object,

9829
07:11:23,700 --> 07:11:25,740
which is right here, I
can see that it's a person

9830
07:11:25,740 --> 07:11:28,110
and I can use the type system accordingly.

9831
07:11:28,110 --> 07:11:30,760
So if I run this here,
we'll see that we can run

9832
07:11:30,760 --> 07:11:33,767
and we can get the object
turned into a person.

9833
07:11:33,767 --> 07:11:36,500
And that's how you can
perform casting in Kotlin.

9834
07:11:36,500 --> 07:11:38,850
Let's assume you have a
method called get stuff,

9835
07:11:38,850 --> 07:11:40,690
and it can return in any type,

9836
07:11:40,690 --> 07:11:43,480
which is the root of all types in Kotlin

9837
07:11:43,480 --> 07:11:44,850
for non nullable types.

9838
07:11:44,850 --> 07:11:46,910
So if you parse into
one, you get an integer,

9839
07:11:46,910 --> 07:11:49,040
if you parse in two, you get a string,

9840
07:11:49,040 --> 07:11:50,640
three, you get a Boolean value,

9841
07:11:50,640 --> 07:11:54,000
four, you get a double and
anything else, you get a false.

9842
07:11:54,000 --> 07:11:57,530
So sometimes we need to perform
various different casting.

9843
07:11:57,530 --> 07:11:59,200
We need to cast it to a particular value.

9844
07:11:59,200 --> 07:12:01,620
So I'm gonna create a new
variable called cast it.

9845
07:12:01,620 --> 07:12:06,310
And what I'm going to
do is say OBJ as int.

9846
07:12:06,310 --> 07:12:08,450
And so what I wanna do
is I wanna get this.

9847
07:12:08,450 --> 07:12:12,700
I wanna cast this value that
I get back to an integer.

9848
07:12:12,700 --> 07:12:15,370
And so when I try to do
this, I'm gonna run this.

9849
07:12:15,370 --> 07:12:17,880
And what we're going to see is
we're gonna get an exception.

9850
07:12:17,880 --> 07:12:19,960
And the exception is a
class cast exception,

9851
07:12:19,960 --> 07:12:22,520
basically stating you can't cast...

9852
07:12:24,085 --> 07:12:26,530
Basically a string can
not be cast to an integer.

9853
07:12:26,530 --> 07:12:29,150
And that's because the value
we got back from get stuff,

9854
07:12:29,150 --> 07:12:32,090
we parsed it two in two came
in executed this line of code.

9855
07:12:32,090 --> 07:12:35,620
We returned the value of OBJ was hello.

9856
07:12:35,620 --> 07:12:37,670
And we're trying to cast
the string as an integer

9857
07:12:37,670 --> 07:12:40,680
and Java says, nope, no
dice, that can't happen.

9858
07:12:40,680 --> 07:12:42,630
So we got a class cast exception to,

9859
07:12:42,630 --> 07:12:46,710
how can we solve this? So
we can't cast it this way.

9860
07:12:46,710 --> 07:12:48,930
So what we could do is we
could do some type checking.

9861
07:12:48,930 --> 07:12:52,930
We could do if object and we
change this to as is into,

9862
07:12:52,930 --> 07:12:55,280
we could get back the OBJ else,

9863
07:12:55,280 --> 07:12:59,860
maybe willing to return to
zero, that that would work.

9864
07:12:59,860 --> 07:13:02,710
We could run this, and this
would work accordingly.

9865
07:13:02,710 --> 07:13:05,780
We'd get back zero because
object is not an integer.

9866
07:13:07,058 --> 07:13:11,000
If it was, so if we came back
here and we changed to a one,

9867
07:13:11,000 --> 07:13:13,850
which again, would return
us back in any value of one,

9868
07:13:13,850 --> 07:13:15,650
we'd get back the one there.

9869
07:13:15,650 --> 07:13:17,523
And actually who's go and change this

9870
07:13:17,523 --> 07:13:20,504
to just what makes more
sense to change it the 99.

9871
07:13:20,504 --> 07:13:22,620
And so when we parse in one
for the value of the get stuff

9872
07:13:22,620 --> 07:13:23,940
method, we'll get back 99,

9873
07:13:23,940 --> 07:13:26,830
which has hap executes
this line right here.

9874
07:13:26,830 --> 07:13:29,130
And since it is because an
integer, we got this back,

9875
07:13:29,130 --> 07:13:30,290
that makes sense.

9876
07:13:30,290 --> 07:13:31,440
However, there's also another way

9877
07:13:31,440 --> 07:13:32,840
that we can do this as well.

9878
07:13:33,910 --> 07:13:35,890
Perhaps we're okay with working
with some nullable types.

9879
07:13:35,890 --> 07:13:40,600
One thing we can do is we can
cast it and do a safe cast.

9880
07:13:40,600 --> 07:13:45,080
And what the safecast
is saved as an integer.

9881
07:13:45,080 --> 07:13:48,050
And what this basically says,
hey, I would like you to,

9882
07:13:48,050 --> 07:13:49,570
as I'm gonna change this to two,

9883
07:13:51,245 --> 07:13:52,270
done a second, we'll do that.

9884
07:13:52,270 --> 07:13:55,300
I would like you to try to
cast this object right here,

9885
07:13:55,300 --> 07:13:58,690
this object as an integer.

9886
07:13:58,690 --> 07:14:01,070
And so when this piece of code executes,

9887
07:14:01,070 --> 07:14:03,250
if it can execute it as an a can do it,

9888
07:14:03,250 --> 07:14:04,170
it'll return the integer,

9889
07:14:04,170 --> 07:14:06,738
otherwise it'll return a nullable type.

9890
07:14:06,738 --> 07:14:09,130
So if we re run this right
now, we're gonna get back 99.

9891
07:14:09,130 --> 07:14:11,570
That makes sense, because
if we parse in one,

9892
07:14:11,570 --> 07:14:12,403
we get back 99.

9893
07:14:12,403 --> 07:14:13,860
So let me change this to two,

9894
07:14:13,860 --> 07:14:15,190
which is gonna give me back a string.

9895
07:14:15,190 --> 07:14:18,030
Now, if I run this, what
we're gonna get back is null.

9896
07:14:18,030 --> 07:14:21,320
And the reason for that is
because this line of code

9897
07:14:21,320 --> 07:14:23,630
right here that executed said,

9898
07:14:23,630 --> 07:14:27,260
hey, this object is actually null.

9899
07:14:27,260 --> 07:14:30,330
And so the smart cast said,
hey, I recognize that was null.

9900
07:14:30,330 --> 07:14:32,970
So I'm just gonna go ahead
and give you back a null value

9901
07:14:32,970 --> 07:14:34,790
at that point in time, we can continue on

9902
07:14:34,790 --> 07:14:36,530
and our application didn't crash.

9903
07:14:36,530 --> 07:14:38,090
And that's how you can use a smart cast.

9904
07:14:38,090 --> 07:14:42,326
So this could be anything for Boolean,

9905
07:14:42,326 --> 07:14:43,420
can I parse that to a Boolean?

9906
07:14:43,420 --> 07:14:45,180
And if we run that, is that going to work?

9907
07:14:45,180 --> 07:14:48,935
Let's see, no that's null as
well, it's not true or false.

9908
07:14:48,935 --> 07:14:49,768
So we can't do that.

9909
07:14:49,768 --> 07:14:52,664
So anytime you need to cast
something and be safe about it

9910
07:14:52,664 --> 07:14:54,070
with a nullable type,
you can use a smart cast,

9911
07:14:54,070 --> 07:14:57,400
which is the word as with
a question mark after it.

9912
07:14:59,218 --> 07:15:01,370
You've probably heard the
word generic tossed around

9913
07:15:01,370 --> 07:15:03,040
inside of Kotlin various times.

9914
07:15:04,566 --> 07:15:06,080
And the word generic just
means that we're using a class

9915
07:15:06,080 --> 07:15:09,100
or an implementation in
a very generic manner.

9916
07:15:09,100 --> 07:15:11,600
And so here we have an
interface which has a list,

9917
07:15:12,438 --> 07:15:13,330
and then it has this
weird little parameter.

9918
07:15:13,330 --> 07:15:14,480
Ignore the out for now.

9919
07:15:15,350 --> 07:15:18,220
And it has this little E and
that E is the type of elements

9920
07:15:18,220 --> 07:15:19,990
that are contained within the list.

9921
07:15:19,990 --> 07:15:22,960
And so this is a collection
which extends collection,

9922
07:15:22,960 --> 07:15:24,230
and it takes a type E.

9923
07:15:24,230 --> 07:15:26,930
So what this allows us to do is have

9924
07:15:26,930 --> 07:15:30,310
all the same operations,
like we can some contains,

9925
07:15:30,310 --> 07:15:33,280
is it empty, we can use get index.

9926
07:15:33,280 --> 07:15:36,330
It allows us for high levels of code reuse

9927
07:15:36,330 --> 07:15:38,340
and allows us to specify different types.

9928
07:15:38,340 --> 07:15:39,960
So we still have type safety.

9929
07:15:39,960 --> 07:15:42,210
So I can do that a list of strings,

9930
07:15:42,210 --> 07:15:45,760
or I could do, let's call
this list of strings,

9931
07:15:47,840 --> 07:15:51,360
or I could say, val list of ints.

9932
07:15:51,360 --> 07:15:55,180
And then I could basically
either say a list int

9933
07:15:55,180 --> 07:16:00,180
and as a list of, and I can
say one, two, three, whatever.

9934
07:16:03,870 --> 07:16:05,170
And I can have my list of integers.

9935
07:16:05,170 --> 07:16:08,270
And now they're all both
going to have same operations.

9936
07:16:09,472 --> 07:16:11,600
List of strings, I'm gonna
have the get operation,

9937
07:16:12,905 --> 07:16:14,070
I'm gonna have a list of ints.

9938
07:16:14,070 --> 07:16:15,150
I'm gonna have the same get operation.

9939
07:16:15,150 --> 07:16:17,800
Now, a lot of these things
are already built for you.

9940
07:16:18,867 --> 07:16:20,700
So a lot of these generic
operations and generic classes,

9941
07:16:20,700 --> 07:16:24,000
such as a list and a map and a set,

9942
07:16:24,000 --> 07:16:26,670
anything like that have
already been built for you.

9943
07:16:26,670 --> 07:16:28,310
And so it's very easy to use them.

9944
07:16:28,310 --> 07:16:32,930
So if you want to use a
map, you can specify a map

9945
07:16:32,930 --> 07:16:34,920
and say map, and you can specify the types

9946
07:16:34,920 --> 07:16:35,753
that you would like as well.

9947
07:16:35,753 --> 07:16:38,430
So the key is gonna be
a string and the value

9948
07:16:38,430 --> 07:16:39,900
will be an int.

9949
07:16:39,900 --> 07:16:42,710
And then perhaps you wanna
create a map of that.

9950
07:16:42,710 --> 07:16:46,054
And now you don't have to
provide these type parameters,

9951
07:16:46,054 --> 07:16:48,890
because it will be inferred
if from the map creation,

9952
07:16:48,890 --> 07:16:50,740
but here I'm just being
very explicit about it.

9953
07:16:50,740 --> 07:16:55,663
So I might map Donn to 32
and I might map Tushar to 42

9954
07:16:58,530 --> 07:16:59,998
and so forth.

9955
07:16:59,998 --> 07:17:03,290
But now I have a map and
that string is it's key

9956
07:17:03,290 --> 07:17:04,500
and the value is its int.

9957
07:17:04,500 --> 07:17:06,970
And this is all already built for us.

9958
07:17:07,955 --> 07:17:09,651
So here's just using a map interface.

9959
07:17:09,651 --> 07:17:10,484
And so there's a bunch of different maps

9960
07:17:10,484 --> 07:17:12,260
that are implemented inside of the Kotlin

9961
07:17:12,260 --> 07:17:15,810
collections library and all
different kinds of things.

9962
07:17:15,810 --> 07:17:18,980
So you can see, so we'll go map.entries

9963
07:17:18,980 --> 07:17:21,190
and we can look inside of there and see

9964
07:17:21,190 --> 07:17:22,970
all the various different entries.

9965
07:17:22,970 --> 07:17:25,650
We can do different, you
know, for different things,

9966
07:17:25,650 --> 07:17:29,860
such as map.map, which is
kind of weird sounding,

9967
07:17:29,860 --> 07:17:32,860
but it's part of the maps
function and allows us

9968
07:17:32,860 --> 07:17:35,100
to transform items inside of there.

9969
07:17:35,100 --> 07:17:38,800
But the key thing here is
that all of that common

9970
07:17:38,800 --> 07:17:42,050
functionality is buried
inside of these generics.

9971
07:17:42,050 --> 07:17:44,620
So you don't have to worry
about building a list,

9972
07:17:44,620 --> 07:17:49,320
just custom for strings or
a custom list for integers.

9973
07:17:49,320 --> 07:17:51,600
All that's buried behind
the generics themselves.

9974
07:17:51,600 --> 07:17:53,090
And the good thing is
you can actually build

9975
07:17:53,090 --> 07:17:54,680
your own generic classes,
which I'll show you

9976
07:17:54,680 --> 07:17:55,770
in another video.

9977
07:17:55,770 --> 07:17:59,150
However, these are the bald basic built-in

9978
07:17:59,150 --> 07:18:00,440
different types of generics.

9979
07:18:00,440 --> 07:18:03,200
And very often when you're
looking at the documentation,

9980
07:18:03,200 --> 07:18:05,020
you're gonna notice these single letters.

9981
07:18:05,020 --> 07:18:07,780
So E in this case is gonna be the type.

9982
07:18:07,780 --> 07:18:09,590
Sometimes you'll see
multiple different types.

9983
07:18:09,590 --> 07:18:11,300
So if we go look at a map,

9984
07:18:11,300 --> 07:18:13,318
you're gonna see different types in here,

9985
07:18:13,318 --> 07:18:14,820
you're gonna see K and V.

9986
07:18:14,820 --> 07:18:17,950
Now the letters, they don't
have to be letters themselves,

9987
07:18:17,950 --> 07:18:21,633
but they're using very
good terminology here.

9988
07:18:21,633 --> 07:18:24,740
K for key and V for value in this case.

9989
07:18:24,740 --> 07:18:29,740
And so up here, the E I think
is for element of the list.

9990
07:18:32,609 --> 07:18:33,442
And so it was a very element.

9991
07:18:33,442 --> 07:18:35,587
Now you could actually, if you're building

9992
07:18:35,587 --> 07:18:38,500
your own generics, you can
actually provide a full on word

9993
07:18:38,500 --> 07:18:41,290
for the different type,
if you would like to.

9994
07:18:41,290 --> 07:18:43,590
But a lot of these
things are just that way.

9995
07:18:44,552 --> 07:18:45,385
So that's what generics are.

9996
07:18:45,385 --> 07:18:47,530
They allow you to encapsulate
common functionality

9997
07:18:47,530 --> 07:18:51,800
across a large swath of
code and folks can end up

9998
07:18:51,800 --> 07:18:53,870
using them for various different things.

9999
07:18:53,870 --> 07:18:56,250
So for example, here's a mutable list

10000
07:18:56,250 --> 07:18:57,420
that extends another one.

10001
07:18:57,420 --> 07:18:59,550
And all that's doing is
saying, hey, we're gonna use

10002
07:18:59,550 --> 07:19:02,350
all of the exact stuff
from within the list

10003
07:19:02,350 --> 07:19:05,089
and everything from within
a mutable collection

10004
07:19:05,089 --> 07:19:05,922
and we're gonna create mutable list.

10005
07:19:05,922 --> 07:19:09,210
And by the way, here's how
we're going to override

10006
07:19:09,210 --> 07:19:11,800
this remove function and
here's how we're gonna do

10007
07:19:11,800 --> 07:19:13,720
all these other different types of things

10008
07:19:13,720 --> 07:19:16,110
based upon this type of collection.

10009
07:19:16,110 --> 07:19:18,720
So these are the generic
kind of collections classes.

10010
07:19:18,720 --> 07:19:21,080
There's a whole swath of
things that are all generic

10011
07:19:21,080 --> 07:19:23,870
inside of various different
apps that you're gonna use

10012
07:19:23,870 --> 07:19:25,400
instead of different libraries.

10013
07:19:25,400 --> 07:19:28,000
HTTP libraries will have you returning

10014
07:19:28,000 --> 07:19:29,496
a different component.

10015
07:19:29,496 --> 07:19:31,480
If you're using reactive
libraries, we'll be working

10016
07:19:31,480 --> 07:19:34,390
with reactive streams of
different types of data

10017
07:19:34,390 --> 07:19:35,270
and so forth.

10018
07:19:35,270 --> 07:19:38,720
And those keys and values and
et cetera, are all performed

10019
07:19:38,720 --> 07:19:41,050
and mapped inside of the various different

10020
07:19:41,050 --> 07:19:44,200
generic classes themselves
built by the developers.

10021
07:19:44,200 --> 07:19:46,746
And so these are all the built-in ones,

10022
07:19:46,746 --> 07:19:48,350
and here's how you can kind of
understand what generics are

10023
07:19:48,350 --> 07:19:49,400
at a very high level.

10024
07:19:51,798 --> 07:19:55,491
Let's assume that you wanna
create your own generic class.

10025
07:19:55,491 --> 07:19:57,060
So the first thing you need
to do is define a class

10026
07:19:58,247 --> 07:19:59,750
and what we're gonna do is
create a class called even list.

10027
07:20:00,936 --> 07:20:02,210
And even list is going to give us,

10028
07:20:02,210 --> 07:20:05,040
we're gonna take in a list,
so here we'll say val.

10029
07:20:05,988 --> 07:20:09,130
We'll say list, and
this'll be a list of type T

10030
07:20:09,130 --> 07:20:11,630
and then inside of here,
we're gonna do something

10031
07:20:12,521 --> 07:20:14,030
or we're gonna return so function.

10032
07:20:14,030 --> 07:20:16,210
And I we'll say items.

10033
07:20:16,210 --> 07:20:18,928
And then what we're gonna
do is we're gonna return

10034
07:20:18,928 --> 07:20:20,570
a list out of this, and it's
gonna be the same type too.

10035
07:20:20,570 --> 07:20:24,380
So notice how I'm not providing
anything inside of here.

10036
07:20:24,380 --> 07:20:26,480
So what this class is going to do for us,

10037
07:20:26,480 --> 07:20:28,120
this is generic class.

10038
07:20:28,120 --> 07:20:31,529
And I'm basically saying,
look, this class is gonna hold

10039
07:20:31,529 --> 07:20:34,393
a bunch of things and
they're gonna be of type T.

10040
07:20:34,393 --> 07:20:36,950
Even lists, it can be of type
T, you don't know what it is.

10041
07:20:38,285 --> 07:20:40,860
The constructor is going
to take a list into it,

10042
07:20:40,860 --> 07:20:42,010
and it's gonna be of type T.

10043
07:20:42,010 --> 07:20:44,430
So basically if it's a list of strings,

10044
07:20:44,430 --> 07:20:46,750
then it'll be even list of strings.

10045
07:20:46,750 --> 07:20:50,100
And then what will
happen is I wanna return

10046
07:20:50,100 --> 07:20:51,106
the even items.

10047
07:20:51,106 --> 07:20:52,557
And so I'm just gonna go ahead and return

10048
07:20:52,557 --> 07:20:53,500
those even items.

10049
07:20:53,500 --> 07:20:56,050
And to do that, I'm gonna
say return list.filtered.

10050
07:20:58,620 --> 07:21:02,030
Now, I need to put val on here
so I can get access to it.

10051
07:21:02,030 --> 07:21:03,390
Val.filtered index.

10052
07:21:05,248 --> 07:21:09,320
And then what I'm going
to do is parse into lambda

10053
07:21:10,165 --> 07:21:12,820
and it's gonna give me
an index and a value.

10054
07:21:15,040 --> 07:21:16,320
And then from here, what I can do is say,

10055
07:21:16,320 --> 07:21:21,320
index modulates two equal
equals zero, which means,

10056
07:21:21,700 --> 07:21:22,820
hey, if it's divisible by two,

10057
07:21:22,820 --> 07:21:25,370
if it's a second item inside of there,

10058
07:21:25,370 --> 07:21:28,700
then if it's divisible by two,
so two zero, two, four, six,

10059
07:21:28,700 --> 07:21:31,335
eight, 10, and then go
ahead and return the items.

10060
07:21:31,335 --> 07:21:33,340
So only return the even
items in this list.

10061
07:21:33,340 --> 07:21:36,180
So I have not actually
specified that I'm working

10062
07:21:36,180 --> 07:21:38,490
with strings or integers or anything.

10063
07:21:38,490 --> 07:21:40,410
And here I'm using this type T.

10064
07:21:40,410 --> 07:21:43,670
So how would I use this
class, this is a generic class

10065
07:21:43,670 --> 07:21:46,640
that only works with even items.

10066
07:21:46,640 --> 07:21:49,010
And perhaps for whatever reason,
I want this to be something

10067
07:21:49,010 --> 07:21:50,630
I can use all over my application,

10068
07:21:50,630 --> 07:21:53,350
because I am maybe
building some type of game

10069
07:21:53,350 --> 07:21:55,130
where I only work with even ones.

10070
07:21:55,130 --> 07:21:57,430
And you know, of course
I could build another one

10071
07:21:58,340 --> 07:21:59,178
called odd.

10072
07:21:59,178 --> 07:22:02,120
So to do this, I could say
val result equals even list,

10073
07:22:03,580 --> 07:22:04,990
not event list, even list.

10074
07:22:05,883 --> 07:22:08,980
And I could specify a string
here, I want it to be string.

10075
07:22:08,980 --> 07:22:11,250
I need to parse in, I'm gonna
parse in my list of strings.

10076
07:22:11,250 --> 07:22:14,540
Now look, the IDE says, hey,
we can remove the explicit type

10077
07:22:14,540 --> 07:22:16,460
arguments because it's
going to be inferred

10078
07:22:16,460 --> 07:22:19,250
because you're parsing
in the list of strings.

10079
07:22:19,250 --> 07:22:21,950
And we already know that
this list of strings

10080
07:22:21,950 --> 07:22:23,970
is this type right here is a string.

10081
07:22:24,898 --> 07:22:26,349
So we already know that
you're a string over here.

10082
07:22:26,349 --> 07:22:27,610
So you don't really need to
tell us that it's a string.

10083
07:22:27,610 --> 07:22:30,080
We kind of already
figured that out for you,

10084
07:22:30,080 --> 07:22:32,650
so you don't need to
provide that information.

10085
07:22:32,650 --> 07:22:34,930
So then what I can do is
I have my list of strings.

10086
07:22:34,930 --> 07:22:37,370
So now I have an event list of strings.

10087
07:22:38,304 --> 07:22:41,473
And if I wanted to print
out the actual even ones,

10088
07:22:41,473 --> 07:22:43,900
I could say, result.items,

10089
07:22:43,900 --> 07:22:45,950
which is gonna call this function here.

10090
07:22:45,950 --> 07:22:47,810
It's gonna call the items, function.

10091
07:22:47,810 --> 07:22:49,780
And wait, maybe we even
wanna call this even,

10092
07:22:49,780 --> 07:22:53,160
be a little more explicit
here, we'll call it even items,

10093
07:22:54,116 --> 07:22:55,620
which makes more sense, result.even items.

10094
07:22:55,620 --> 07:22:58,020
And if we print this out,
what we're gonna see here,

10095
07:22:59,101 --> 07:23:00,525
and we're only using
the strings right now,

10096
07:23:00,525 --> 07:23:01,358
let's see Donn and Mary.

10097
07:23:01,358 --> 07:23:04,180
Now the power of generics really comes in

10098
07:23:04,180 --> 07:23:05,740
that you can reuse it
with different types.

10099
07:23:05,740 --> 07:23:09,900
So let's reuse this again,
the same val results,

10100
07:23:09,900 --> 07:23:12,670
let's say other result 'cause
we need another variable

10101
07:23:14,510 --> 07:23:16,630
and this one's gonna be event list.

10102
07:23:16,630 --> 07:23:19,260
And this time we're gonna
take in a list of ints

10103
07:23:20,920 --> 07:23:22,790
not event, even list.

10104
07:23:23,771 --> 07:23:25,538
So we're gonna take a list of integers in,

10105
07:23:25,538 --> 07:23:27,181
and we're gonna print this out,

10106
07:23:27,181 --> 07:23:29,630
I'm gonna say result.even items.

10107
07:23:31,132 --> 07:23:32,205
And when we print this one out,

10108
07:23:32,205 --> 07:23:33,110
we're now working with integers.

10109
07:23:36,240 --> 07:23:37,640
And I used the wrong result.

10110
07:23:38,480 --> 07:23:39,313
There we go.

10111
07:23:40,860 --> 07:23:43,308
And if we use the other result,
which is the proper one,

10112
07:23:43,308 --> 07:23:45,790
we'll now see, we were able to reuse

10113
07:23:45,790 --> 07:23:48,250
this class's exact functionality.

10114
07:23:48,250 --> 07:23:51,290
I didn't have to write it twice,
I'm now relying on a type,

10115
07:23:51,290 --> 07:23:53,390
this called a type parameter, the type key

10116
07:23:54,723 --> 07:23:55,556
to do some work for us.

10117
07:23:55,556 --> 07:23:59,541
And if we can look at this
value, look, if we go over here

10118
07:23:59,541 --> 07:24:01,552
and actually do something
with a value actually,

10119
07:24:01,552 --> 07:24:04,837
we can see the value over
here is actually type T.

10120
07:24:04,837 --> 07:24:06,440
So I don't know what that type is.

10121
07:24:07,854 --> 07:24:09,230
I could say the value is of type blah.

10122
07:24:09,230 --> 07:24:12,830
Now I could do some, I could
do as value as a string.

10123
07:24:12,830 --> 07:24:14,840
So if I parse in an any into this,

10124
07:24:14,840 --> 07:24:17,150
then we could do some type
of stuff inside of here.

10125
07:24:17,150 --> 07:24:19,050
Now that's gonna limit
me on what I can do,

10126
07:24:19,050 --> 07:24:23,060
but depends on my implementation
of my generic class

10127
07:24:23,060 --> 07:24:23,893
if that's what I wanna do.

10128
07:24:23,893 --> 07:24:26,070
So here now I have an
even class that will work

10129
07:24:27,150 --> 07:24:29,100
exactly with what these and I could be.

10130
07:24:30,254 --> 07:24:31,087
Again, we could even go a step further

10131
07:24:31,087 --> 07:24:35,410
and we can go class person
and we could easily do

10132
07:24:35,410 --> 07:24:38,200
name string, and then we
can create a list of people.

10133
07:24:38,200 --> 07:24:42,770
So let's just do that,
val people equals list of,

10134
07:24:43,682 --> 07:24:44,515
and then let's do person.

10135
07:24:51,191 --> 07:24:53,600
And now if I have these people
and I wanna print it out,

10136
07:24:53,600 --> 07:24:55,234
we're just gonna do this.

10137
07:24:55,234 --> 07:24:56,378
We're gonna single line this right now.

10138
07:24:56,378 --> 07:24:58,330
So I'm just gonna do even list

10139
07:24:58,330 --> 07:25:00,580
and then I'm gonna parse in my people.

10140
07:25:00,580 --> 07:25:02,130
And then I'm gonna say, I
wanna get my even items.

10141
07:25:02,130 --> 07:25:03,890
I'm just gonna print that out.

10142
07:25:03,890 --> 07:25:04,980
And then what we're gonna see here

10143
07:25:04,980 --> 07:25:08,140
is even with my own custom
class, I'm getting that.

10144
07:25:08,140 --> 07:25:10,750
And I can make a little bit
nicer and just say data class,

10145
07:25:10,750 --> 07:25:12,940
'cause data classes will
give you a nice little

10146
07:25:12,940 --> 07:25:15,030
two string representation
of your class already

10147
07:25:15,030 --> 07:25:16,210
as we can see here.

10148
07:25:16,210 --> 07:25:18,150
Now the two string is
represented that two strings

10149
07:25:18,150 --> 07:25:21,090
is built for you by
default and data classes.

10150
07:25:21,090 --> 07:25:22,340
So I can print out and everything here.

10151
07:25:22,340 --> 07:25:24,220
So now I'm only receiving the even number.

10152
07:25:24,220 --> 07:25:27,710
So I'm receiving Donn and Mary,
but Bob has index number one

10153
07:25:27,710 --> 07:25:29,150
and Felicia's index number three.

10154
07:25:29,150 --> 07:25:31,360
So we're just gonna
completely skip over that.

10155
07:25:31,360 --> 07:25:33,940
Remember 'cause these
are zero-based index.

10156
07:25:33,940 --> 07:25:38,230
So remember that this is
zero, this is one, this is two

10157
07:25:39,730 --> 07:25:41,940
and this is three inside of array index

10158
07:25:41,940 --> 07:25:43,680
'cause we're zero-based.

10159
07:25:43,680 --> 07:25:45,680
So this is why we're
getting it even index.

10160
07:25:45,680 --> 07:25:47,120
So the other cool thing about this too,

10161
07:25:47,120 --> 07:25:48,980
is like, let's say that
you don't really like

10162
07:25:48,980 --> 07:25:50,630
the type T.

10163
07:25:50,630 --> 07:25:53,660
I prefer to use the word T
because it means type to me

10164
07:25:53,660 --> 07:25:55,050
and it's a type system.

10165
07:25:55,050 --> 07:25:56,980
I could also just say this right here.

10166
07:25:56,980 --> 07:26:00,750
I could rename this type
and say type like that.

10167
07:26:00,750 --> 07:26:02,500
And now it could use the same thing.

10168
07:26:02,500 --> 07:26:04,400
I could even call this something else.

10169
07:26:04,400 --> 07:26:08,183
If I wanted to call this, we
wanted to call this tiger.

10170
07:26:10,960 --> 07:26:12,505
I call it tiger.

10171
07:26:12,505 --> 07:26:13,338
It doesn't matter what I call it.

10172
07:26:13,338 --> 07:26:15,510
This is just a tight parameter
that I'm gonna be using.

10173
07:26:15,510 --> 07:26:18,740
And if I look over here,
now this might get confusing

10174
07:26:19,670 --> 07:26:20,503
because I would never use the word tiger

10175
07:26:20,503 --> 07:26:23,220
because tiger has an implicit
meaning of an animal.

10176
07:26:23,220 --> 07:26:25,390
So I see that this value is of type tiger,

10177
07:26:25,390 --> 07:26:26,720
but that doesn't make any sense.

10178
07:26:26,720 --> 07:26:29,590
So it's usually good to
keep these tight parameters

10179
07:26:29,590 --> 07:26:32,580
to be a very simple name
that represents something.

10180
07:26:32,580 --> 07:26:34,110
So it could be type.

10181
07:26:34,110 --> 07:26:36,750
It could be sometimes people use action.

10182
07:26:36,750 --> 07:26:40,020
If they're building something
with actions and so forth.

10183
07:26:40,020 --> 07:26:44,090
However, it's really easy just
to use simple single letter

10184
07:26:44,090 --> 07:26:46,280
types, because then when
you're looking inside

10185
07:26:46,280 --> 07:26:50,180
of perhaps your code and
you're looking at the value

10186
07:26:50,180 --> 07:26:51,610
of something, you can look over and say,

10187
07:26:51,610 --> 07:26:54,050
Oh, that's gonna be of type T.

10188
07:26:54,050 --> 07:26:56,357
Oh, okay, I don't know if that is,

10189
07:26:56,357 --> 07:26:58,120
that's a type or I need
to think about this more.

10190
07:26:58,120 --> 07:27:02,410
So that's how you can build
a very simple generic class

10191
07:27:02,410 --> 07:27:05,470
in your very first generic
class inside of Kotlin.

10192
07:27:07,763 --> 07:27:08,790
Let's assume that you have a person

10193
07:27:08,790 --> 07:27:11,010
and inside of your application,
for whatever reason,

10194
07:27:11,010 --> 07:27:14,120
you can't allow anyone to
be under the age of 18.

10195
07:27:15,295 --> 07:27:17,080
Perhaps it's an application
for allowing people

10196
07:27:17,080 --> 07:27:20,190
into particular restaurants
or music events.

10197
07:27:20,190 --> 07:27:22,090
So you wanna make sure
that no one gets in,

10198
07:27:22,090 --> 07:27:23,600
unless they're over 18.

10199
07:27:23,600 --> 07:27:27,050
However, this is an exceptional case.

10200
07:27:27,050 --> 07:27:30,590
So you wanna check to see if
the person is over age 18.

10201
07:27:30,590 --> 07:27:33,230
If they're basically
under the age of 18 now,

10202
07:27:33,230 --> 07:27:34,110
that should never happen.

10203
07:27:34,110 --> 07:27:36,910
Perhaps these values are
coming back from an API

10204
07:27:36,910 --> 07:27:38,120
or somewhere else.

10205
07:27:38,120 --> 07:27:40,080
And at this point you're
like, you know what,

10206
07:27:40,080 --> 07:27:42,380
if I get someone back
less than the age of 18,

10207
07:27:43,228 --> 07:27:44,150
this application just
needs to basically blow up.

10208
07:27:44,150 --> 07:27:45,430
There's something that should happen.

10209
07:27:45,430 --> 07:27:48,010
And to do that, you can throw
what's known as an exception

10210
07:27:48,010 --> 07:27:50,660
and you use the throw keyword for that.

10211
07:27:50,660 --> 07:27:52,200
And so we can throw an exception.

10212
07:27:52,200 --> 07:27:53,900
And so we have an
exception here in Kotlin.

10213
07:27:53,900 --> 07:27:55,780
We provide an error message.

10214
07:27:55,780 --> 07:27:57,310
User is not old enough.

10215
07:28:00,381 --> 07:28:02,320
All right, now, at this point,
if we run this application,

10216
07:28:02,320 --> 07:28:06,460
what we're going to see is that
this person Donnie who's 13.

10217
07:28:06,460 --> 07:28:08,440
Little Donnie can't
come in because the user

10218
07:28:08,440 --> 07:28:09,670
is not old enough.

10219
07:28:09,670 --> 07:28:12,860
Now the exception is built into
the Kotlin standard library

10220
07:28:12,860 --> 07:28:16,750
and all it really is the type
alias for Java Lang exception.

10221
07:28:16,750 --> 07:28:18,960
And what that means is
this kind of just created

10222
07:28:18,960 --> 07:28:21,500
a little shortcut for you,
like a little link and said,

10223
07:28:21,500 --> 07:28:23,240
hey, if you type exception,

10224
07:28:23,240 --> 07:28:26,570
and this is a type in Kotlin
what you're actually meaning

10225
07:28:26,570 --> 07:28:29,210
is this actual Java language exception.

10226
07:28:29,210 --> 07:28:30,970
There's a bunch of
different exception types

10227
07:28:30,970 --> 07:28:33,610
inside of Kotlin and
a million more of them

10228
07:28:33,610 --> 07:28:35,180
in various libraries.

10229
07:28:35,180 --> 07:28:36,200
But the common ones are gonna see

10230
07:28:36,200 --> 07:28:38,330
you as just regular exception,
where you provide a message,

10231
07:28:38,330 --> 07:28:40,580
a runtime exception and a legal argument,

10232
07:28:40,580 --> 07:28:42,937
maybe provide an illegal argument.

10233
07:28:42,937 --> 07:28:44,360
and a legal argument, maybe
provide an illegal argument.

10234
07:28:44,360 --> 07:28:46,760
So it got into a weird
state that it doesn't know

10235
07:28:46,760 --> 07:28:48,900
how to handle and it needs to get out.

10236
07:28:48,900 --> 07:28:51,490
So that's an illegal state
exception index out of bounds.

10237
07:28:51,490 --> 07:28:54,898
You know, if you're working
with an array or a list,

10238
07:28:54,898 --> 07:28:56,790
an index out of bounds
unsupported operation,

10239
07:28:56,790 --> 07:28:58,990
you're doing something
that's not built yet.

10240
07:29:00,118 --> 07:29:00,951
Perhaps this could be
very useful for a feature

10241
07:29:00,951 --> 07:29:02,700
you're building out, but
the function isn't done,

10242
07:29:02,700 --> 07:29:05,440
but you need to make sure
that you do something

10243
07:29:05,440 --> 07:29:07,100
in the function so it compiles.

10244
07:29:08,290 --> 07:29:10,630
You could just throw it on
supported operation exception.

10245
07:29:10,630 --> 07:29:13,110
And then if you accidentally
hit that in testing or in code,

10246
07:29:13,110 --> 07:29:13,943
it'll blow up.

10247
07:29:14,799 --> 07:29:15,730
And of course there's
various other exceptions

10248
07:29:15,730 --> 07:29:16,670
inside of here,

10249
07:29:16,670 --> 07:29:19,940
but this is how you can throw
an exception inside of Kotlin.

10250
07:29:19,940 --> 07:29:21,200
And it can be any other exception here.

10251
07:29:21,200 --> 07:29:24,740
So if we wanted it to be a
illegal argument exception,

10252
07:29:24,740 --> 07:29:28,990
we could say the user is not
old enough, user is too young,

10253
07:29:29,900 --> 07:29:31,200
and then we could run that.

10254
07:29:31,200 --> 07:29:33,310
And then of course the
output would then show

10255
07:29:33,310 --> 07:29:35,830
that we then got an
illegal argument exception.

10256
07:29:37,277 --> 07:29:38,110
You wanna use the correct exception

10257
07:29:38,110 --> 07:29:40,940
for whatever you would like,
for whatever you're wanting

10258
07:29:40,940 --> 07:29:44,720
to do and you can throw that
correct exception to that time.

10259
07:29:45,571 --> 07:29:47,190
And if you're using any
type of code and production,

10260
07:29:47,190 --> 07:29:48,850
that's looking for these exceptions,

10261
07:29:48,850 --> 07:29:50,810
you can start filtering
on the types of exceptions

10262
07:29:50,810 --> 07:29:51,890
that were thrown,

10263
07:29:51,890 --> 07:29:54,340
and that's how you throw
an exception and Kotlin.

10264
07:29:56,355 --> 07:29:57,620
In Kotlin, and in many other JVM languages

10265
07:29:57,620 --> 07:29:59,130
and most programming languages,

10266
07:29:59,130 --> 07:30:01,740
you're not limited to the
default set of exceptions.

10267
07:30:01,740 --> 07:30:03,660
You can actually create your own set

10268
07:30:03,660 --> 07:30:05,140
that you would need as well.

10269
07:30:05,140 --> 07:30:07,824
So let's assume that
you didn't want to use

10270
07:30:07,824 --> 07:30:08,657
the illegal argument exception,

10271
07:30:08,657 --> 07:30:09,490
but you wanted to create your own.

10272
07:30:09,490 --> 07:30:12,990
So you can create a class and
we'll call it illegal age,

10273
07:30:12,990 --> 07:30:16,240
or it's called invalidate age exception.

10274
07:30:18,260 --> 07:30:21,700
And usually you'll add
the suffix exception

10275
07:30:21,700 --> 07:30:22,980
to the end of an exception.

10276
07:30:22,980 --> 07:30:24,390
So, you know what that type means.

10277
07:30:24,390 --> 07:30:26,490
If I just typed in valid age,

10278
07:30:26,490 --> 07:30:27,680
I don't know if this is an exception,

10279
07:30:27,680 --> 07:30:29,200
if it's an object or what is it for,

10280
07:30:29,200 --> 07:30:31,680
but if I say exception at the end,

10281
07:30:31,680 --> 07:30:33,900
it's very easy to read for what it is.

10282
07:30:33,900 --> 07:30:36,260
Now, this is a class I can
provide anything I like.

10283
07:30:36,260 --> 07:30:38,850
So maybe I wanna provide
the age, which is an int.

10284
07:30:38,850 --> 07:30:40,220
And then I'll also wanna
provide the message,

10285
07:30:40,220 --> 07:30:41,780
which is a string.

10286
07:30:41,780 --> 07:30:45,000
And then I'm gonna go
ahead and pars, make this.

10287
07:30:45,000 --> 07:30:45,910
I can either make this just an exception,

10288
07:30:45,910 --> 07:30:48,941
or you know what, since
this has has something

10289
07:30:48,941 --> 07:30:50,920
to do with an argument, I'm
gonna extend illegal argument

10290
07:30:50,920 --> 07:30:54,390
exception and then I need to
parse in either no parameters

10291
07:30:54,390 --> 07:30:55,920
or the message.

10292
07:30:55,920 --> 07:30:58,050
And I'm gonna go ahead
and create a message

10293
07:30:58,050 --> 07:31:00,270
that's going to be based
upon the other stuff.

10294
07:31:01,187 --> 07:31:03,779
And I'll say in a valid
age and then I'll go ahead

10295
07:31:03,779 --> 07:31:04,910
and render the age variable.

10296
07:31:04,910 --> 07:31:06,580
And then I'm gonna go ahead and then also

10297
07:31:06,580 --> 07:31:07,780
append the message here.

10298
07:31:08,640 --> 07:31:12,010
So now instead of using an
illegal argument exception,

10299
07:31:12,010 --> 07:31:14,436
I can say invalid age exception,

10300
07:31:14,436 --> 07:31:16,601
throw new invalid age exception.

10301
07:31:16,601 --> 07:31:17,460
And of course it can give me an error here

10302
07:31:17,460 --> 07:31:19,900
because I don't have the age parsed in.

10303
07:31:19,900 --> 07:31:24,450
So I'm gonna say P.age,
which is the person's age.

10304
07:31:24,450 --> 07:31:26,480
And now if I run this
and what we're gonna see

10305
07:31:26,480 --> 07:31:29,470
in the output is that an
illegal age exception is thrown.

10306
07:31:29,470 --> 07:31:31,920
So illegal age exception
and valid age, 13.

10307
07:31:31,920 --> 07:31:34,020
User is not old enough, user is too young.

10308
07:31:35,040 --> 07:31:37,240
And so I'm parsing this message in,

10309
07:31:38,227 --> 07:31:40,230
and this is which means
invalid age exception

10310
07:31:40,230 --> 07:31:44,970
is basically a child of
illegal argument exception.

10311
07:31:44,970 --> 07:31:47,010
And so now I've created my own exception.

10312
07:31:47,010 --> 07:31:50,135
You can create as many
exceptions as you would like.

10313
07:31:50,135 --> 07:31:52,385
These can help you inside
of your application

10314
07:31:53,830 --> 07:31:54,663
when things are perhaps not working

10315
07:31:54,663 --> 07:31:55,860
and your applications is crashing,

10316
07:31:55,860 --> 07:31:58,960
you can see exactly what
type of exceptions they are.

10317
07:31:58,960 --> 07:32:01,800
Perhaps a particular
part of your application

10318
07:32:01,800 --> 07:32:02,840
is really difficult.

10319
07:32:02,840 --> 07:32:05,570
So you may wanna create a
couple of different exceptions

10320
07:32:05,570 --> 07:32:08,270
and you track those
inside of your application

10321
07:32:08,270 --> 07:32:09,730
or inside of your crash tool,

10322
07:32:09,730 --> 07:32:12,130
or maybe you're building
a library and that library

10323
07:32:12,130 --> 07:32:13,370
has very particular needs.

10324
07:32:13,370 --> 07:32:14,920
And so you need to make
sure that you returning

10325
07:32:14,920 --> 07:32:17,480
certain exceptions from your application

10326
07:32:17,480 --> 07:32:20,990
and giving exceptional situations.

10327
07:32:20,990 --> 07:32:21,900
So that's how you can do it.

10328
07:32:21,900 --> 07:32:23,410
You just have to go ahead and take class

10329
07:32:23,410 --> 07:32:26,290
and extend exception or
you can just even extend

10330
07:32:26,290 --> 07:32:29,663
just regular exception and so forth,

10331
07:32:29,663 --> 07:32:30,725
and then you can start building your own.

10332
07:32:30,725 --> 07:32:31,558
So it depends on which
one you want to extend.

10333
07:32:31,558 --> 07:32:33,110
You need to make sure
that you can extend it.

10334
07:32:33,110 --> 07:32:36,080
So there is an exception,
you can also extend

10335
07:32:36,080 --> 07:32:37,360
runtime exception as well.

10336
07:32:37,360 --> 07:32:39,310
So if you wanna make your
own runtime exceptions,

10337
07:32:39,310 --> 07:32:40,870
you can do that as well.

10338
07:32:40,870 --> 07:32:43,180
So that's how you can
create your own exceptions

10339
07:32:43,180 --> 07:32:44,580
in Kotlin.

10340
07:32:44,580 --> 07:32:46,090
Okay, let's assume we have some code here.

10341
07:32:46,090 --> 07:32:49,720
We have a person object, and
this side, this person object

10342
07:32:49,720 --> 07:32:53,830
has a user with the name
Donnie and age of 13

10343
07:32:53,830 --> 07:32:55,360
and a method called check age.

10344
07:32:55,360 --> 07:32:58,590
And if the age is less than
18, it throws an exception.

10345
07:32:58,590 --> 07:33:01,510
And maybe this, let's assume
that this is in a different

10346
07:33:01,510 --> 07:33:04,631
library somewhere, so we
can't even control it.

10347
07:33:04,631 --> 07:33:05,620
So this is beyond the scope of our things.

10348
07:33:05,620 --> 07:33:08,500
We have to call into this
library to do something.

10349
07:33:08,500 --> 07:33:11,810
And for whatever reason, this
library throws an exception,

10350
07:33:11,810 --> 07:33:14,090
even though we may or
may not agree with that

10351
07:33:14,090 --> 07:33:16,990
on the way that the code is working level,

10352
07:33:16,990 --> 07:33:19,540
sometimes that's just the
reality of the situation.

10353
07:33:20,645 --> 07:33:21,900
I've worked with many libraries
in which I can't control

10354
07:33:21,900 --> 07:33:23,450
or don't agree with how
they handle something

10355
07:33:23,450 --> 07:33:24,480
and they throw an exception.

10356
07:33:24,480 --> 07:33:27,550
I don't want the application to blow up.

10357
07:33:27,550 --> 07:33:29,510
So what I can do is I can wrap this

10358
07:33:29,510 --> 07:33:31,820
in what's known as a try-catch.

10359
07:33:31,820 --> 07:33:35,710
And try-catch is going
to give us a ability

10360
07:33:35,710 --> 07:33:36,970
to catch the exception.

10361
07:33:36,970 --> 07:33:40,350
So basically what's gonna happen
I wanna show you something.

10362
07:33:43,980 --> 07:33:47,172
what's gonna happen is
check age is gonna happen.

10363
07:33:47,172 --> 07:33:48,005
And then that's gonna throw an exception

10364
07:33:48,005 --> 07:33:49,000
so we can see the exception again.

10365
07:33:49,000 --> 07:33:50,870
It's gonna throw this exception,

10366
07:33:50,870 --> 07:33:53,803
then what's gonna happen is
basically gonna short circuit

10367
07:33:53,803 --> 07:33:54,636
right here.

10368
07:33:54,636 --> 07:33:55,520
I could have a whole bunch code.

10369
07:33:55,520 --> 07:33:58,649
Most like I probably will
have a whole bunch of code

10370
07:33:58,649 --> 07:34:02,060
down here and none of this
code is gonna execute.

10371
07:34:02,060 --> 07:34:05,260
Why, because this thing right
here is doing an exception

10372
07:34:05,260 --> 07:34:07,440
and I need to do something
with that exception.

10373
07:34:07,440 --> 07:34:09,940
And so here I can actually
catch that exception

10374
07:34:10,836 --> 07:34:13,236
and I can actually get
rid of that if I want to.

10375
07:34:14,490 --> 07:34:17,501
Catch the exception and then
I can do something with it.

10376
07:34:17,501 --> 07:34:19,240
Now I can decide to do print ln,

10377
07:34:20,850 --> 07:34:25,430
caught the exception, et cetera.

10378
07:34:25,430 --> 07:34:27,860
Now, when I run this, now the application

10379
07:34:27,860 --> 07:34:30,090
is not going to crash, I got a typo there.

10380
07:34:32,130 --> 07:34:34,120
And what we see is caught the exception.

10381
07:34:34,120 --> 07:34:35,570
Again, we'll fix the
type, we'll run it again.

10382
07:34:35,570 --> 07:34:36,970
We see caught the exception,

10383
07:34:38,702 --> 07:34:40,290
but we still didn't get
all these values run.

10384
07:34:40,290 --> 07:34:43,280
Now this is beneficial
because if we don't have this,

10385
07:34:43,280 --> 07:34:45,320
let's go ahead and comment this out.

10386
07:34:45,320 --> 07:34:48,550
What can end up happening is
our application could run.

10387
07:34:48,550 --> 07:34:50,760
And then for whatever
reason, it just blows up.

10388
07:34:50,760 --> 07:34:53,160
And maybe we don't want it to blow up.

10389
07:34:53,160 --> 07:34:54,740
Again, as a library or something,

10390
07:34:54,740 --> 07:34:57,240
we get an exception and we
wanna do something different.

10391
07:34:57,240 --> 07:35:00,640
So we were like, oh wow, okay,
this person's age is not 13.

10392
07:35:00,640 --> 07:35:03,280
Okay, maybe then we kind
of do some other type

10393
07:35:03,280 --> 07:35:05,680
of code handling, set some variables

10394
07:35:05,680 --> 07:35:06,980
and do anything like that.

10395
07:35:07,830 --> 07:35:11,490
So that's how we can catch an
exception inside of Kotlin.

10396
07:35:11,490 --> 07:35:16,490
Now inside of here, if this were,

10397
07:35:16,590 --> 07:35:18,040
if we're gonna do print line,

10398
07:35:19,290 --> 07:35:22,430
exception was caught
or say caught for now.

10399
07:35:22,430 --> 07:35:24,880
If for some reason this person was 23.

10400
07:35:24,880 --> 07:35:28,430
What we're gonna see now
is the code is going to run

10401
07:35:28,430 --> 07:35:30,430
and check age is gonna run, that's fine.

10402
07:35:31,532 --> 07:35:32,530
And then all of these
statements are gonna run.

10403
07:35:32,530 --> 07:35:35,820
And this block of code right
here is gonna be skipped.

10404
07:35:35,820 --> 07:35:36,653
It's completely skipped.

10405
07:35:36,653 --> 07:35:38,700
So what ends up happening is Kotlin says,

10406
07:35:39,700 --> 07:35:41,180
all right, I'm gonna try to
do all the stuff in here.

10407
07:35:41,180 --> 07:35:42,670
And then if anything bad happens,

10408
07:35:42,670 --> 07:35:45,000
I'm gonna go ahead and
basically short circuit

10409
07:35:45,000 --> 07:35:47,330
down into this little branch down here.

10410
07:35:47,330 --> 07:35:49,330
Now that's great.

10411
07:35:49,330 --> 07:35:52,309
If no errors happen,
then all the code in here

10412
07:35:52,309 --> 07:35:54,350
will successfully execute and
then it'll continue down here.

10413
07:35:54,350 --> 07:35:58,666
So we'll say for an ln after try catch,

10414
07:35:58,666 --> 07:35:59,890
and this is known as a try-catch block.

10415
07:36:00,780 --> 07:36:02,420
Up here, so we have a try catch.

10416
07:36:02,420 --> 07:36:04,880
And so we'll say you done,
done, done, done, done, done

10417
07:36:04,880 --> 07:36:06,190
after try catch.

10418
07:36:06,190 --> 07:36:09,270
And so that's how you can
work and catch exceptions.

10419
07:36:09,270 --> 07:36:11,540
You can also catch very
particular exceptions.

10420
07:36:11,540 --> 07:36:14,180
So maybe if we can see if
this is an illegal argument

10421
07:36:14,180 --> 07:36:16,950
exception, and what we
need to do is change this

10422
07:36:16,950 --> 07:36:18,340
again to something that will fail.

10423
07:36:18,340 --> 07:36:21,497
So we'll set the age to
13, so it throws throw.

10424
07:36:21,497 --> 07:36:25,700
And then we'll notice
here is it all of a sudden

10425
07:36:25,700 --> 07:36:26,720
our application is bombing,

10426
07:36:26,720 --> 07:36:28,450
but we still have a try-catch here.

10427
07:36:29,410 --> 07:36:30,886
What happened?

10428
07:36:30,886 --> 07:36:32,870
Well, the reason is because
what we're at throwing down here

10429
07:36:32,870 --> 07:36:35,680
is an exception, but
what we're checking for

10430
07:36:35,680 --> 07:36:39,490
is a much more granular
level of acception.

10431
07:36:39,490 --> 07:36:41,550
Here, we're checking for
illegal argument exception.

10432
07:36:41,550 --> 07:36:43,190
We're checking, hey, the exception,

10433
07:36:43,190 --> 07:36:45,340
we only wanna catch
this if it's an illegal

10434
07:36:46,522 --> 07:36:47,660
argument exception, otherwise
just let it blow up.

10435
07:36:47,660 --> 07:36:49,750
So this is very useful if
we're trying to make sure

10436
07:36:49,750 --> 07:36:52,790
that inside, maybe we have
that custom exception.

10437
07:36:52,790 --> 07:36:57,790
Again, we have class invalid
name or valid age exception.

10438
07:37:04,140 --> 07:37:05,470
And it's gonna parse in a message.

10439
07:37:05,470 --> 07:37:09,090
And what it is, is it's an
illegal argument exception,

10440
07:37:10,010 --> 07:37:11,810
and we parse in the message there.

10441
07:37:11,810 --> 07:37:15,060
So instead of throwing
this regular exception,

10442
07:37:15,060 --> 07:37:16,810
we're gonna throw it this one here,

10443
07:37:18,870 --> 07:37:20,700
and we can see what happens here.

10444
07:37:20,700 --> 07:37:23,270
And so, oh, looks like
it caught the illegal

10445
07:37:23,270 --> 07:37:24,103
argument exception.

10446
07:37:24,103 --> 07:37:25,820
Well, why did it catch your
legal argument exception

10447
07:37:25,820 --> 07:37:27,950
if it's an invalid age exception,

10448
07:37:27,950 --> 07:37:30,040
because invalid age exception

10449
07:37:30,040 --> 07:37:31,880
is an illegal argument exception.

10450
07:37:31,880 --> 07:37:34,480
Now, if we were to change this to invalid,

10451
07:37:37,290 --> 07:37:39,590
let's say invalid class exceptions,

10452
07:37:39,590 --> 07:37:44,350
which is just a different
exception from the Java.io.

10453
07:37:44,350 --> 07:37:46,080
It's not gonna work because
it's not gonna catch it.

10454
07:37:46,080 --> 07:37:47,930
It's saying invalid age exception.

10455
07:37:47,930 --> 07:37:51,520
So a lot of times you may want
to catch multiple exceptions

10456
07:37:51,520 --> 07:37:53,040
at once, so you need to climb up

10457
07:37:53,040 --> 07:37:55,620
the hierarchy of classes here.

10458
07:37:55,620 --> 07:37:59,780
So the exception is some
classes or form of code,

10459
07:37:59,780 --> 07:38:02,760
throwable, excuse me,
that indicates, et cetera,

10460
07:38:02,760 --> 07:38:04,200
the things are throwable.

10461
07:38:04,200 --> 07:38:06,450
So what you can do is just rely

10462
07:38:06,450 --> 07:38:08,320
on just the default exception.

10463
07:38:08,320 --> 07:38:11,040
So we can just delete this cause it'll use

10464
07:38:11,040 --> 07:38:12,240
Kotlin's type alias.

10465
07:38:14,010 --> 07:38:18,180
And we can see here that the
exceptions kind of all root up

10466
07:38:18,180 --> 07:38:19,013
towards the top.

10467
07:38:19,013 --> 07:38:20,820
And if we use just a high
level exception like this,

10468
07:38:20,820 --> 07:38:24,020
then what we can do is actually
provide a when statement.

10469
07:38:24,020 --> 07:38:29,020
When EX, I can say is
illegal argument exception,

10470
07:38:30,200 --> 07:38:34,550
we can say print ln legal argument.

10471
07:38:36,100 --> 07:38:41,033
When is, we might wanna say
something like invalid age,

10472
07:38:43,550 --> 07:38:47,730
then we wanna print something,
print ln, invalid age,

10473
07:38:49,490 --> 07:38:53,340
and then anything else we just wanna say,

10474
07:38:53,340 --> 07:38:57,573
print ln else, something else.

10475
07:38:57,573 --> 07:39:02,573
Now, if we run this,
let me see invalid age.

10476
07:39:05,070 --> 07:39:07,020
So if I were to remove this,

10477
07:39:07,020 --> 07:39:10,440
let me say index out of bounds exceptions.

10478
07:39:15,110 --> 07:39:19,960
So index out of bounds exception
or using an abbreviation.

10479
07:39:22,650 --> 07:39:24,700
And what we see is invalid
age is still being thrown.

10480
07:39:24,700 --> 07:39:29,523
So I'm gonna change this to
just throw something else,

10481
07:39:35,440 --> 07:39:36,970
throw in legal argument, exception

10482
07:39:36,970 --> 07:39:38,520
inside of the check age method.

10483
07:39:40,380 --> 07:39:42,390
And then we're gonna see
that caught something else.

10484
07:39:42,390 --> 07:39:44,110
So something else was caught down here.

10485
07:39:44,110 --> 07:39:45,120
Now, a lot of times, what you wanna do

10486
07:39:45,120 --> 07:39:47,430
is you wanna go ahead and
re throw that exception

10487
07:39:47,430 --> 07:39:50,700
because you are not sure
what's happening here.

10488
07:39:50,700 --> 07:39:52,650
So you wanna just say, hey, you know what,

10489
07:39:52,650 --> 07:39:55,650
here is the example.

10490
07:39:56,490 --> 07:39:58,460
We have the exceptions come in.

10491
07:39:58,460 --> 07:40:01,750
And when the exception is an
illegal age exception, do this.

10492
07:40:01,750 --> 07:40:03,730
When it's an index out
of bounds exception,

10493
07:40:03,730 --> 07:40:04,563
do something else.

10494
07:40:04,563 --> 07:40:07,380
Otherwise I don't know what to
do with it, just throw this.

10495
07:40:07,380 --> 07:40:09,660
Maybe someone further up
the stack will catch it,

10496
07:40:09,660 --> 07:40:11,330
but these are the only two exceptions

10497
07:40:11,330 --> 07:40:14,190
I know how to handle inside
of this try-catch block.

10498
07:40:14,190 --> 07:40:17,120
'Cause maybe this will throw
an illegal age exception

10499
07:40:17,120 --> 07:40:19,810
and maybe some other call down here

10500
07:40:19,810 --> 07:40:23,750
that we haven't specified
yet will issue an index

10501
07:40:23,750 --> 07:40:25,389
out of bounds exception.

10502
07:40:25,389 --> 07:40:26,790
And then at that point you
can then start catching

10503
07:40:26,790 --> 07:40:28,240
and handling multiple exceptions

10504
07:40:28,240 --> 07:40:30,850
inside of your Kotlin
program or rethrow it

10505
07:40:30,850 --> 07:40:32,780
with the stack trace accordingly,

10506
07:40:32,780 --> 07:40:34,810
and then you'll get the whole stack trace

10507
07:40:34,810 --> 07:40:37,550
all the way outside the call stack.

10508
07:40:37,550 --> 07:40:39,890
So if it's further up, you'll
get the call stack as well.

10509
07:40:39,890 --> 07:40:41,940
And that's how you can catch
multiple different exceptions

10510
07:40:41,940 --> 07:40:42,773
in Kotlin.

10511
07:40:43,680 --> 07:40:45,860
Let's assume that you have some code here

10512
07:40:45,860 --> 07:40:49,300
and you want to surround this with a try

10513
07:40:49,300 --> 07:40:51,510
so you can make sure that it doesn't fail.

10514
07:40:52,490 --> 07:40:55,830
You can also, instead of using a catch,

10515
07:40:55,830 --> 07:41:00,500
you can use a finally here and
you can say for ln finally.

10516
07:41:01,440 --> 07:41:03,560
And perhaps let's have
something that was supposed

10517
07:41:03,560 --> 07:41:05,250
to execute after this.

10518
07:41:06,095 --> 07:41:11,000
So it would say print ln after check age.

10519
07:41:11,000 --> 07:41:12,710
So we should not see check age execute

10520
07:41:12,710 --> 07:41:15,030
because if the user's
age or the person's age

10521
07:41:15,030 --> 07:41:16,690
is less than 18, then we're gonna throw

10522
07:41:16,690 --> 07:41:18,270
an illegal argument exception.

10523
07:41:18,270 --> 07:41:20,410
But this is the show
you that in a try catch

10524
07:41:20,410 --> 07:41:24,300
or a try finally, the finally
block will always execute.

10525
07:41:24,300 --> 07:41:27,690
So even if an exception occurs
inside of this tribe lock,

10526
07:41:27,690 --> 07:41:29,400
if an exception occurs anywhere in here,

10527
07:41:29,400 --> 07:41:31,500
the finally block will always execute.

10528
07:41:31,500 --> 07:41:34,070
So let's go ahead and execute
that now, let's run that.

10529
07:41:34,070 --> 07:41:36,590
And what you're gonna see is that finally,

10530
07:41:36,590 --> 07:41:38,790
which is right here, finally is printed,

10531
07:41:39,640 --> 07:41:41,990
but the exception is still happening,

10532
07:41:41,990 --> 07:41:43,360
which is inside of check age.

10533
07:41:43,360 --> 07:41:46,490
And then basically the
program execution is stopping.

10534
07:41:46,490 --> 07:41:48,880
How do we know that the
program execution is stopping?

10535
07:41:48,880 --> 07:41:50,890
It's pretty simple, the print line

10536
07:41:50,890 --> 07:41:54,000
which is called after a try
is not executing at all.

10537
07:41:54,000 --> 07:41:59,000
So what ends up happening is
this block is executing and now

10538
07:41:59,290 --> 07:42:01,390
we're seeing the finely run here

10539
07:42:01,390 --> 07:42:03,900
and finally will be run
regardless what happens

10540
07:42:03,900 --> 07:42:04,733
inside of try it.

10541
07:42:04,733 --> 07:42:07,380
Now, this is very useful,
let's say if you've opened

10542
07:42:07,380 --> 07:42:12,380
a variable and it's perhaps
reading a file stream

10543
07:42:13,030 --> 07:42:17,100
or maybe an audio store, or
audio or something like that,

10544
07:42:17,100 --> 07:42:18,460
that's gonna take a lot of resources

10545
07:42:18,460 --> 07:42:21,420
that you need to close to make
sure there's no memory leak.

10546
07:42:21,420 --> 07:42:22,690
Then maybe you would say,

10547
07:42:24,144 --> 07:42:26,327
you would have some type of
variable called file stream.

10548
07:42:26,327 --> 07:42:27,710
And then inside of here, you might say,

10549
07:42:27,710 --> 07:42:30,456
hey, regardless of what happens,

10550
07:42:30,456 --> 07:42:32,080
if I'm getting an exception or I don't,

10551
07:42:32,080 --> 07:42:34,800
I wanna close down that stream
so I can kind of clean up

10552
07:42:34,800 --> 07:42:36,940
after myself and not have memory leaks.

10553
07:42:36,940 --> 07:42:39,230
So it's a very common place
to clean up for anything

10554
07:42:39,230 --> 07:42:41,470
that you need that's resource intensive

10555
07:42:41,470 --> 07:42:44,710
or could possibly provide
any type of memory leaks.

10556
07:42:44,710 --> 07:42:46,890
You can put it inside of
the finally area there.

10557
07:42:46,890 --> 07:42:48,760
So if anything were to happen.

10558
07:42:48,760 --> 07:42:52,020
Now, you can also combine a try finally

10559
07:42:52,020 --> 07:42:53,000
with a try catch.

10560
07:42:53,000 --> 07:42:57,830
So I could say catch
exception with exception,

10561
07:42:57,830 --> 07:43:00,860
and of course we can do
this, so we can stack them.

10562
07:43:00,860 --> 07:43:03,170
And this works, this is a
very common pattern here.

10563
07:43:03,170 --> 07:43:05,490
So again, you might wanna
use finally to clean up

10564
07:43:05,490 --> 07:43:07,590
after something that
you've, again, maybe opened

10565
07:43:07,590 --> 07:43:09,980
an audio source, video source,

10566
07:43:09,980 --> 07:43:11,910
something that could leak memory,

10567
07:43:12,790 --> 07:43:14,740
but you might wanna do something
inside of this exception

10568
07:43:14,740 --> 07:43:18,990
and say, print ln handled,

10569
07:43:18,990 --> 07:43:20,800
or maybe you're gonna
handle it a certain way.

10570
07:43:20,800 --> 07:43:22,850
So instead of let's,

10571
07:43:23,920 --> 07:43:26,300
it's going to catch the
illegal argument exception.

10572
07:43:26,300 --> 07:43:28,050
So let's go ahead and do illegal...

10573
07:43:31,106 --> 07:43:32,735
Let's do a legal state exception.

10574
07:43:32,735 --> 07:43:33,820
And if we run this, what we're gonna see

10575
07:43:33,820 --> 07:43:37,750
is we're still going to get
the finally that's called,

10576
07:43:37,750 --> 07:43:42,350
but we had the illegal
argument exception was thrown.

10577
07:43:42,350 --> 07:43:44,650
So what ends up happening
is check age called,

10578
07:43:45,630 --> 07:43:48,370
the exception was thrown immediately.

10579
07:43:49,910 --> 07:43:51,830
This finally block realized
an exception was thrown.

10580
07:43:51,830 --> 07:43:55,270
So finally it's printed and
then finally the program says,

10581
07:43:55,270 --> 07:43:57,660
hey, here's why we executed
with this exception.

10582
07:43:57,660 --> 07:44:01,620
Now, if we were to change this catch block

10583
07:44:01,620 --> 07:44:04,130
to catch that illegal argument exception,

10584
07:44:04,130 --> 07:44:06,600
the whole program execution changes.

10585
07:44:06,600 --> 07:44:10,870
So we're gonna see that
it's gonna execute this,

10586
07:44:11,980 --> 07:44:13,170
but it's gonna throw an exception.

10587
07:44:13,170 --> 07:44:15,690
So we're not going to
see this line of code.

10588
07:44:15,690 --> 07:44:19,250
Remember an illegal argument
exception was called or thrown.

10589
07:44:19,250 --> 07:44:21,840
The catch block sees that
says, yes, I can handle that.

10590
07:44:21,840 --> 07:44:24,300
It then prints out handled,
which is printed out

10591
07:44:24,300 --> 07:44:25,370
handled here.

10592
07:44:25,370 --> 07:44:28,190
And then as always, the finally
block will always be run.

10593
07:44:28,190 --> 07:44:31,730
So we may need to clean up after
some memory intensive stuff

10594
07:44:31,730 --> 07:44:34,360
we'll then go ahead and execute
the code inside of finally.

10595
07:44:34,360 --> 07:44:36,580
And then after that, the
program execution continues

10596
07:44:36,580 --> 07:44:38,974
because the program didn't really crash,

10597
07:44:38,974 --> 07:44:40,450
we handled it right here.

10598
07:44:40,450 --> 07:44:44,080
And at that point it's
executing after the try.

10599
07:44:44,080 --> 07:44:46,850
So you can perform a try and a catch.

10600
07:44:46,850 --> 07:44:49,280
And a finally you can stack
them all on top of each other

10601
07:44:49,280 --> 07:44:51,030
in Kotlin and that's how you do it.

10602
07:44:52,830 --> 07:44:55,860
The difference between
try, catch and try finally

10603
07:44:55,860 --> 07:44:58,700
can be illustrated in
a very simple example.

10604
07:44:58,700 --> 07:45:02,060
Here, we have a try block
inside the check age method.

10605
07:45:02,060 --> 07:45:04,900
We check the variable
for the class person.

10606
07:45:04,900 --> 07:45:06,250
And if they are under the age of 18,

10607
07:45:06,250 --> 07:45:07,660
we throw in the legal argument exception

10608
07:45:07,660 --> 07:45:08,950
with the value of boom.

10609
07:45:10,270 --> 07:45:11,940
And if we run this,
what we're going to see

10610
07:45:11,940 --> 07:45:13,090
is a few things happen.

10611
07:45:14,544 --> 07:45:16,836
We see the word finally
is printed to the output

10612
07:45:16,836 --> 07:45:19,441
and then we see the reason
why the application exited,

10613
07:45:19,441 --> 07:45:21,320
which is the illegal argument
exception which was thrown.

10614
07:45:21,320 --> 07:45:23,290
So this is interesting
because the print line

10615
07:45:23,290 --> 07:45:25,040
was not executed, which we expect

10616
07:45:25,040 --> 07:45:27,040
because it was short-circuited based upon

10617
07:45:27,040 --> 07:45:29,240
the illegal argument exception was thrown.

10618
07:45:30,980 --> 07:45:32,490
Every time this code is called,

10619
07:45:32,490 --> 07:45:34,020
finally is guaranteed to be called.

10620
07:45:34,020 --> 07:45:36,840
So finally it's going to be
called and we print finally

10621
07:45:36,840 --> 07:45:37,673
to the screen.

10622
07:45:37,673 --> 07:45:39,700
And of course, because
the application exited,

10623
07:45:39,700 --> 07:45:41,990
we are not going to
see after the try here.

10624
07:45:42,980 --> 07:45:45,200
Now, how does this differ from a catch?

10625
07:45:45,200 --> 07:45:48,360
Well, a catch allows you to
catch and do something with it.

10626
07:45:48,360 --> 07:45:50,430
Finally just executes
at all point in time.

10627
07:45:50,430 --> 07:45:53,076
So let's just go ahead and replace this,

10628
07:45:53,076 --> 07:45:54,020
comment this out right now.

10629
07:45:54,020 --> 07:45:58,600
And let's go ahead and
actually, I'm gonna go down here

10630
07:45:58,600 --> 07:45:59,950
and we'll comment this out.

10631
07:46:01,161 --> 07:46:03,600
And now we'll say catch EX exception.

10632
07:46:04,500 --> 07:46:08,220
So catch allows us to catch EX exception.

10633
07:46:08,220 --> 07:46:11,710
And we can print line
the exception message,

10634
07:46:13,560 --> 07:46:17,130
actually we're gonna print
caught just to be more clear.

10635
07:46:20,630 --> 07:46:23,780
And once we execute this,
we'll see the word caught

10636
07:46:23,780 --> 07:46:25,320
and we are then after the try it.

10637
07:46:25,320 --> 07:46:27,190
So what this allows us to
do is this whole program

10638
07:46:27,190 --> 07:46:31,060
has now executed though, except
for this line of code here,

10639
07:46:31,060 --> 07:46:33,040
because it was short-circuited
via the check age

10640
07:46:33,040 --> 07:46:36,670
because of the illegal argument
exception that was thrown.

10641
07:46:36,670 --> 07:46:38,420
So the catch, you can actually catch

10642
07:46:38,420 --> 07:46:41,590
either a particular exception,
or you can say if it's not

10643
07:46:41,590 --> 07:46:43,560
a particular exception you can...

10644
07:46:43,560 --> 07:46:45,490
Or if it is a particular exception,

10645
07:46:45,490 --> 07:46:47,450
it can also not get short-circuited

10646
07:46:47,450 --> 07:46:49,390
and still blow up the application.

10647
07:46:49,390 --> 07:46:51,240
However, anytime using a finally,

10648
07:46:51,240 --> 07:46:55,270
which it also can be combined,
a finally is executed

10649
07:46:55,270 --> 07:46:56,103
all the time.

10650
07:46:56,103 --> 07:46:59,590
So regardless if we have an
exception that is caught,

10651
07:46:59,590 --> 07:47:02,750
we have finally this
exception was not caught.

10652
07:47:02,750 --> 07:47:05,560
So it terminated the
program, finally was printed.

10653
07:47:05,560 --> 07:47:08,060
However, if this is an
illegal argument exception,

10654
07:47:09,950 --> 07:47:12,770
we're going to see that the
program execution continues on.

10655
07:47:12,770 --> 07:47:13,950
We didn't crash the application.

10656
07:47:13,950 --> 07:47:15,310
However, finally was still called.

10657
07:47:15,310 --> 07:47:18,100
So regardless of what
happens inside of the try,

10658
07:47:18,100 --> 07:47:20,800
finally is always called
while it's not guaranteed

10659
07:47:20,800 --> 07:47:22,870
to always be called with the catch,

10660
07:47:22,870 --> 07:47:24,940
because we could be filtering
it based upon the type

10661
07:47:24,940 --> 07:47:25,790
of the exception.

10662
07:47:27,610 --> 07:47:29,550
Defining a type alias can be very useful

10663
07:47:29,550 --> 07:47:31,080
in various different scenarios.

10664
07:47:31,080 --> 07:47:33,310
It allows you to alias one particular type

10665
07:47:34,390 --> 07:47:35,550
to another name type.

10666
07:47:35,550 --> 07:47:38,150
So let's assume we have a user class here

10667
07:47:38,150 --> 07:47:40,330
and has a username and
perhaps an auth token,

10668
07:47:40,330 --> 07:47:43,470
and perhaps the account
class also has an auth token

10669
07:47:43,470 --> 07:47:47,840
that is needed to request
the account details.

10670
07:47:47,840 --> 07:47:50,980
And for whatever reason,
there is a order class,

10671
07:47:50,980 --> 07:47:54,310
and it also requires
an auth token as well.

10672
07:47:54,310 --> 07:47:55,910
And it's a string.

10673
07:47:55,910 --> 07:47:57,260
Now, eventually you
start finding yourself,

10674
07:47:57,260 --> 07:48:00,000
having the word auth token all
over your entire application

10675
07:48:00,000 --> 07:48:02,050
and realize that that could be a problem.

10676
07:48:02,050 --> 07:48:05,300
Well, one thing you can
do is actually type alias

10677
07:48:05,300 --> 07:48:08,210
auth token into its own
type, or maybe you can create

10678
07:48:08,210 --> 07:48:09,043
your own type.

10679
07:48:09,043 --> 07:48:09,970
So you could do that too.

10680
07:48:09,970 --> 07:48:14,010
You could say something like
this data class auth token.

10681
07:48:14,890 --> 07:48:17,060
And what it is that just contains a token

10682
07:48:17,060 --> 07:48:17,893
that the string.

10683
07:48:21,150 --> 07:48:24,750
And then you could start
replacing this with auth token,

10684
07:48:24,750 --> 07:48:28,820
but then inside of any of your
providers or anything else

10685
07:48:28,820 --> 07:48:30,770
that's inside of your system,
that's you wanna treat it

10686
07:48:30,770 --> 07:48:33,400
like a string, well now you
have to treat it like an object

10687
07:48:33,400 --> 07:48:34,233
and it's kind of a pain,

10688
07:48:34,233 --> 07:48:36,230
but you would just love to be
able to call it auth token,

10689
07:48:36,230 --> 07:48:38,040
because it would just make much more sense

10690
07:48:38,040 --> 07:48:40,290
when you're reasoning
about your application.

10691
07:48:41,294 --> 07:48:43,010
So I'm gonna go ahead and
put this back as string.

10692
07:48:45,800 --> 07:48:47,040
So I wanna go and get rid of that.

10693
07:48:47,040 --> 07:48:49,770
What you can do is actually
perform a type alias

10694
07:48:49,770 --> 07:48:51,210
and here's how you can do that.

10695
07:48:51,210 --> 07:48:53,120
What you can do is usually
I prefer to type these

10696
07:48:53,120 --> 07:48:54,950
at the top of a file or in some type

10697
07:48:54,950 --> 07:48:58,080
of common extensions area
inside of my application.

10698
07:48:58,080 --> 07:49:00,280
So I might have a file
called extensions.kt.

10699
07:49:01,972 --> 07:49:03,510
And I'll say type alias, and then it says,

10700
07:49:03,510 --> 07:49:06,660
I wanna type alias the word account token,

10701
07:49:06,660 --> 07:49:10,450
excuse me, auth token to equal string.

10702
07:49:11,730 --> 07:49:14,530
And what that means now is I
can use the word auth token

10703
07:49:15,990 --> 07:49:16,823
anywhere.

10704
07:49:16,823 --> 07:49:19,640
So this is also a string,
this is also an auth token.

10705
07:49:21,320 --> 07:49:23,170
But now it's much easier
for me to reason about

10706
07:49:23,170 --> 07:49:25,210
because now if I'm going
to use my user class,

10707
07:49:25,210 --> 07:49:29,490
user.auth token, I could see
that it's an auth token type.

10708
07:49:29,490 --> 07:49:30,960
And then it actually gives
me a hint here saying,

10709
07:49:30,960 --> 07:49:34,000
hey, that is actually a
string behind the scenes.

10710
07:49:34,000 --> 07:49:35,390
And so I can say auth token.

10711
07:49:35,390 --> 07:49:37,660
And then again, I still
have all the same operations

10712
07:49:37,660 --> 07:49:40,340
that I would have on a string
like length and so forth.

10713
07:49:40,340 --> 07:49:43,640
But now it allows me to
have much more meaning

10714
07:49:43,640 --> 07:49:45,240
directly inside of my application.

10715
07:49:45,240 --> 07:49:47,910
So if I'm creating a new order,

10716
07:49:48,830 --> 07:49:50,740
a new order is going
to take an auth token.

10717
07:49:50,740 --> 07:49:53,730
So instead of it taking a
string, it's an auth token.

10718
07:49:53,730 --> 07:49:55,440
And so I could do one thing.

10719
07:49:55,440 --> 07:49:57,961
I could actually provide the auth token

10720
07:49:57,961 --> 07:49:59,640
and say user.auth token, that'll work,

10721
07:49:59,640 --> 07:50:01,960
or if I just have a string,
because auth tokens are string,

10722
07:50:01,960 --> 07:50:04,130
I'll say, my auth token.

10723
07:50:04,130 --> 07:50:07,110
And this will also work too
because underneath the hood,

10724
07:50:07,110 --> 07:50:10,040
Kotlin knows that auth token is a string.

10725
07:50:10,040 --> 07:50:13,890
However, just for
usability and type systems

10726
07:50:13,890 --> 07:50:15,850
inside of your application,
it makes it a lot easier

10727
07:50:15,850 --> 07:50:19,310
sometimes with various
different values to use

10728
07:50:19,310 --> 07:50:23,040
type aliasing so you can
actually get the actual types

10729
07:50:23,040 --> 07:50:24,570
that you like without
actually having to create

10730
07:50:24,570 --> 07:50:26,200
a brand new one, because
maybe that auth token

10731
07:50:26,200 --> 07:50:27,860
is just a string, but you would just like

10732
07:50:27,860 --> 07:50:31,130
to have its own type and you
can do that with type aliases.

10733
07:50:31,130 --> 07:50:34,240
And it's very easy to
do just set type alias,

10734
07:50:34,240 --> 07:50:35,970
what you wanna call the type alias equals,

10735
07:50:35,970 --> 07:50:37,050
whatever the type is.

10736
07:50:38,220 --> 07:50:40,690
One of the coolest things
about Kotlin is the ability

10737
07:50:40,690 --> 07:50:43,270
to add functions to existing classes

10738
07:50:43,270 --> 07:50:45,110
already inside of the standard library

10739
07:50:45,110 --> 07:50:47,260
or other existing libraries.

10740
07:50:47,260 --> 07:50:50,360
Now, for example, what I mean
by that is it would be great

10741
07:50:50,360 --> 07:50:53,190
if a string class, which
is what this name is.

10742
07:50:53,190 --> 07:50:55,390
If we were to specified it's string,

10743
07:50:55,390 --> 07:50:59,020
but it's already through implicit nature,

10744
07:50:59,020 --> 07:51:00,724
we already know it's a string.

10745
07:51:00,724 --> 07:51:01,660
It'd be great, if the string class

10746
07:51:01,660 --> 07:51:03,780
had an initials method on it.

10747
07:51:03,780 --> 07:51:05,340
And that would allow me to automatically

10748
07:51:05,340 --> 07:51:07,500
just say name.initials.

10749
07:51:07,500 --> 07:51:09,420
And for that name, it would automatically

10750
07:51:09,420 --> 07:51:11,070
print the initials, so it would print DF.

10751
07:51:11,070 --> 07:51:14,230
Well, we can do that in Kotlin
and here's how we can do it.

10752
07:51:15,850 --> 07:51:17,650
All right, so I've saved
the time of actually typing

10753
07:51:17,650 --> 07:51:19,910
the code for you and I'll
walk you through it here.

10754
07:51:19,910 --> 07:51:22,220
Now, what I've done is
created a new function

10755
07:51:22,220 --> 07:51:24,830
on this line here, and
this function itself,

10756
07:51:25,680 --> 07:51:28,860
we start off by saying the
type that we want to extend,

10757
07:51:28,860 --> 07:51:30,850
here is string and then we wanna say,

10758
07:51:30,850 --> 07:51:33,930
here is the actual name of the
method that we wanna create.

10759
07:51:33,930 --> 07:51:35,370
And then of course, it's going to go ahead

10760
07:51:35,370 --> 07:51:38,990
and it's going to return a string,

10761
07:51:38,990 --> 07:51:40,940
which is we see here, returning string.

10762
07:51:41,800 --> 07:51:43,230
And then at that point in time,

10763
07:51:43,230 --> 07:51:45,850
we're gonna go ahead and go
through all of this here.

10764
07:51:45,850 --> 07:51:46,750
So here we have the values,

10765
07:51:46,750 --> 07:51:49,931
we're just going to split
it on an empty string.

10766
07:51:49,931 --> 07:51:51,350
And then we're gonna
grab the first initial

10767
07:51:51,350 --> 07:51:52,230
using the sub string.

10768
07:51:52,230 --> 07:51:53,570
I'll grab the first character off

10769
07:51:53,570 --> 07:51:56,790
the first part of the array of
the first item in the array.

10770
07:51:57,788 --> 07:51:59,830
And then we're gonna
grab the first character

10771
07:51:59,830 --> 07:52:02,020
off the second item in the array.

10772
07:52:02,020 --> 07:52:03,690
And then at that point, we're
just gonna use some string

10773
07:52:03,690 --> 07:52:06,092
interpolation and return them together.

10774
07:52:06,092 --> 07:52:08,110
So now if I run this, what we're gonna see

10775
07:52:08,110 --> 07:52:09,970
is we're gonna see DF is printed.

10776
07:52:09,970 --> 07:52:14,970
So now any string that I
have, so if I say val equals,

10777
07:52:15,620 --> 07:52:19,890
I could even have the something
like book that I'm reading,

10778
07:52:19,890 --> 07:52:22,660
which is called, I read this
book called "The daily stoic",

10779
07:52:23,830 --> 07:52:28,463
say daily stoic, I could say
print ln book dot initials.

10780
07:52:31,050 --> 07:52:34,680
And what we would get back is DS.

10781
07:52:34,680 --> 07:52:38,334
So of course, DS is printed
before the other name

10782
07:52:38,334 --> 07:52:39,167
and then printed.

10783
07:52:39,167 --> 07:52:41,580
So if we move this up here
would make a little more sense.

10784
07:52:41,580 --> 07:52:43,940
So now we see DF and then DS is printed.

10785
07:52:43,940 --> 07:52:47,290
So anything that has a
string in it is going to be

10786
07:52:47,290 --> 07:52:48,650
easily created.

10787
07:52:48,650 --> 07:52:51,360
Now this is the string is not
a class that we can control.

10788
07:52:51,360 --> 07:52:53,490
This is not, if we look at string,

10789
07:52:53,490 --> 07:52:56,400
this is part of the
Kotlin standard library.

10790
07:52:56,400 --> 07:52:59,080
That's part of Java, we
can't do anything about that,

10791
07:52:59,080 --> 07:53:02,090
but we're actually able to
kind of slap on some additional

10792
07:53:02,090 --> 07:53:04,520
methods for it using extension methods.

10793
07:53:04,520 --> 07:53:07,950
So now what I usually
prefer to do in this case,

10794
07:53:08,810 --> 07:53:11,920
is I like to have a file and
I'll call this extensions.

10795
07:53:15,360 --> 07:53:17,850
And that's where I like to
put my files, my extensions.

10796
07:53:17,850 --> 07:53:20,520
And if I have a lot of them,
I'll call string extensions.

10797
07:53:20,520 --> 07:53:22,950
I'll have integer
extensions, but in this case,

10798
07:53:22,950 --> 07:53:25,690
I'll start off very simply
with one file called extension

10799
07:53:25,690 --> 07:53:28,682
that doesn't need to
be inside of a package.

10800
07:53:28,682 --> 07:53:30,290
It can be a top level
function as we're seeing here.

10801
07:53:30,290 --> 07:53:31,390
Now, at this point,

10802
07:53:31,390 --> 07:53:32,890
I can call this from
anywhere that I would like.

10803
07:53:32,890 --> 07:53:36,360
So back of my main file,
initials still works.

10804
07:53:36,360 --> 07:53:38,690
So anywhere in my application now,

10805
07:53:38,690 --> 07:53:41,290
I'm gonna be able to
use this dot initials.

10806
07:53:41,290 --> 07:53:43,550
Now the same thing can happen
over here in extensions.

10807
07:53:43,550 --> 07:53:48,550
Let's say I wanted to extend
the integer class is adult,

10808
07:53:50,100 --> 07:53:51,950
and this could return a Boolean value

10809
07:53:53,090 --> 07:53:54,590
and all this is going to do...

10810
07:53:57,344 --> 07:53:58,177
And we can actually single line this.

10811
07:53:58,177 --> 07:54:00,360
And we'll say this now
notice how he said this,

10812
07:54:00,360 --> 07:54:05,360
because this is in regards to
what type we are extending.

10813
07:54:06,890 --> 07:54:10,360
So the extension function for
string, we said this.split.

10814
07:54:10,360 --> 07:54:12,300
Here we had this is for the integer.

10815
07:54:12,300 --> 07:54:16,880
So this greater than or equal to 18.

10816
07:54:16,880 --> 07:54:17,713
So is adult.

10817
07:54:17,713 --> 07:54:19,680
So I can single line this
one, this one's easy.

10818
07:54:19,680 --> 07:54:22,110
Again, this could also
be if I wanted to do it

10819
07:54:22,110 --> 07:54:24,500
the other way, which you may
be more familiar with seeing

10820
07:54:24,500 --> 07:54:25,530
to make more sense.

10821
07:54:26,650 --> 07:54:28,000
We can do it this way here.

10822
07:54:28,950 --> 07:54:30,690
It says convert to expression body.

10823
07:54:30,690 --> 07:54:33,710
So there we go as adult
and I can even probably

10824
07:54:33,710 --> 07:54:35,220
get rid of that.

10825
07:54:35,220 --> 07:54:38,070
And so I can now really
make this succinct.

10826
07:54:38,070 --> 07:54:40,910
At this point, we are
looking at, I don't know,

10827
07:54:40,910 --> 07:54:44,030
30 characters total from
start to finish as adult.

10828
07:54:44,030 --> 07:54:48,580
What this allows us to do
is say, val age equals 35,

10829
07:54:48,580 --> 07:54:52,370
and I say, print line, age.is adult.

10830
07:54:53,600 --> 07:54:55,400
And you see how the code completion

10831
07:54:55,400 --> 07:54:57,020
found them automatically.

10832
07:54:57,020 --> 07:54:58,360
And we see that true came back.

10833
07:54:58,360 --> 07:55:01,700
So now I was able to
extend the integer class.

10834
07:55:01,700 --> 07:55:05,230
I've extended the string
class and then furthermore,

10835
07:55:05,230 --> 07:55:09,280
I could also do this with,
let's say another model.

10836
07:55:09,280 --> 07:55:11,840
So I'm gonna create another file here.

10837
07:55:11,840 --> 07:55:12,890
Call this one models.

10838
07:55:15,670 --> 07:55:18,250
Inside the models form I'm
gonna have a data class.

10839
07:55:20,030 --> 07:55:20,863
Data class.

10840
07:55:22,189 --> 07:55:23,110
Actually let's do a regular class.

10841
07:55:23,110 --> 07:55:27,153
The class person is gonna have
a val name string, a val age,

10842
07:55:30,400 --> 07:55:32,180
and that's gonna be int.

10843
07:55:33,420 --> 07:55:36,870
And then what I can do
is I might have my person

10844
07:55:39,930 --> 07:55:43,000
and I'll say, hey, today,
I'm gonna be 89 years old.

10845
07:55:43,000 --> 07:55:45,490
So Donn person age 89.

10846
07:55:45,490 --> 07:55:48,130
Now the cool thing about
this is if I had my full name

10847
07:55:48,130 --> 07:55:50,780
in here, I could do something like this.

10848
07:55:51,640 --> 07:55:52,820
I say person dot...

10849
07:55:53,890 --> 07:55:56,450
Well from here, I could say, initials,

10850
07:55:58,032 --> 07:55:59,780
person.name.initials.

10851
07:56:00,710 --> 07:56:03,940
Now the problem that we're
going to get here is that

10852
07:56:03,940 --> 07:56:07,190
the name Donn, if we run this here,

10853
07:56:07,190 --> 07:56:10,310
we're gonna get an exception
because the initials

10854
07:56:10,310 --> 07:56:14,350
is splitting on a string on a space.

10855
07:56:14,350 --> 07:56:15,900
As we see here, this is
what's happening here.

10856
07:56:15,900 --> 07:56:17,690
Splitting on a space.

10857
07:56:17,690 --> 07:56:19,610
And so there's actually
only one item in the array.

10858
07:56:19,610 --> 07:56:21,310
Therefore, it's going to be blowing up.

10859
07:56:21,310 --> 07:56:22,580
So that's not gonna work right now.

10860
07:56:22,580 --> 07:56:25,990
But if for some reason I had
my name listed as Donn Felker,

10861
07:56:27,890 --> 07:56:30,760
like that, I could then issue that

10862
07:56:30,760 --> 07:56:32,950
and I would've then get
back my correct initials.

10863
07:56:32,950 --> 07:56:35,020
I would see DF again printed.

10864
07:56:35,020 --> 07:56:38,000
So let's now go ahead and
change this person class though.

10865
07:56:38,000 --> 07:56:39,540
And let's kind of show how we can extend.

10866
07:56:39,540 --> 07:56:43,790
Let's pretend that this
class had a first name

10867
07:56:43,790 --> 07:56:45,040
and then had a last name.

10868
07:56:46,630 --> 07:56:49,400
This is a very common example
that you're gonna run into.

10869
07:56:49,400 --> 07:56:52,590
This person could be a user,
it could be anything else.

10870
07:56:52,590 --> 07:56:54,180
And it's usually going to be a class

10871
07:56:54,180 --> 07:56:55,980
that you do not control.

10872
07:56:55,980 --> 07:56:58,770
So we'll say Felker,
we've made it my last name

10873
07:57:00,169 --> 07:57:02,630
and then we'll see again, and
I've got a little bit older

10874
07:57:02,630 --> 07:57:04,680
since the last time we spoke, I'm 90 now.

10875
07:57:05,890 --> 07:57:09,020
And so a lot of times,
if I would want to print

10876
07:57:09,993 --> 07:57:11,493
someone's name, I'm gonna say,

10877
07:57:12,702 --> 07:57:13,535
of course we're gonna
do string interpolation,

10878
07:57:13,535 --> 07:57:16,320
cause it makes more sense,
I'll say person.FirstName,

10879
07:57:18,840 --> 07:57:21,870
and then I'll do a space and
then I'll do person.lastName.

10880
07:57:23,338 --> 07:57:24,370
And that works great.

10881
07:57:24,370 --> 07:57:27,150
The problem is I find myself
repeating myself over and over

10882
07:57:27,150 --> 07:57:28,840
and over my application and I'm doing this

10883
07:57:28,840 --> 07:57:29,890
all over the place.

10884
07:57:29,890 --> 07:57:32,490
But I can't come in and
modify the person class

10885
07:57:32,490 --> 07:57:34,270
because it was in a library somewhere.

10886
07:57:34,270 --> 07:57:37,190
So what I could do is I could
be in my extension class,

10887
07:57:37,190 --> 07:57:39,020
I'm in here, and I say fun person.

10888
07:57:39,020 --> 07:57:44,020
I remember that person and I
can say full name, full name.

10889
07:57:45,150 --> 07:57:47,550
And I'm gonna go ahead and
just inline this one as well.

10890
07:57:47,550 --> 07:57:50,660
And all this is gonna be as this.firstName

10891
07:57:50,660 --> 07:57:54,020
and I'm actually going to
and string interpolate this.

10892
07:57:54,020 --> 07:57:59,020
So we'll do the first name
space, this dot last name,

10893
07:58:01,630 --> 07:58:03,210
close that out.

10894
07:58:03,210 --> 07:58:05,030
And now, instead of doing this,

10895
07:58:05,030 --> 07:58:07,950
I have extended another person.

10896
07:58:07,950 --> 07:58:10,300
So I'm gonna say person.fullName.

10897
07:58:12,300 --> 07:58:14,447
I don't even need the
quotes there actually.

10898
07:58:14,447 --> 07:58:15,280
I can just get rid of all that.

10899
07:58:18,090 --> 07:58:19,340
Now it's person.fullName.

10900
07:58:20,805 --> 07:58:22,020
And if we run this,
we'll see the same thing

10901
07:58:22,020 --> 07:58:23,040
Donn Felker comes here.

10902
07:58:23,040 --> 07:58:28,040
So if we say, you know, John
Smith first and last name,

10903
07:58:28,930 --> 07:58:30,200
John Smith.

10904
07:58:30,200 --> 07:58:31,750
So we've actually, again,

10905
07:58:31,750 --> 07:58:35,144
we're assuming that this
person classes in some other

10906
07:58:35,144 --> 07:58:35,977
library somewhere, we
don't have control over it,

10907
07:58:35,977 --> 07:58:37,360
but we do wanna use it.

10908
07:58:37,360 --> 07:58:39,110
And we wanna make it easier to use.

10909
07:58:39,986 --> 07:58:42,530
We can create an extension
function called full name.

10910
07:58:42,530 --> 07:58:44,350
We can create any type of other function

10911
07:58:44,350 --> 07:58:47,120
that we wanna throw on to those types

10912
07:58:47,120 --> 07:58:50,709
such as we're building
on top of the built-in

10913
07:58:50,709 --> 07:58:52,060
primitive types that are
inside of the type system,

10914
07:58:52,060 --> 07:58:55,380
such as string and int or
even custom types that maybe

10915
07:58:55,380 --> 07:58:58,060
we have control over or we
don't have control over.

10916
07:58:58,060 --> 07:59:00,820
And we would like to provide
extension functions to them.

10917
07:59:00,820 --> 07:59:02,940
A lot of times you might
find an extension function,

10918
07:59:02,940 --> 07:59:06,660
very useful in a particular
domain of your application,

10919
07:59:06,660 --> 07:59:07,820
maybe in a couple of modules.

10920
07:59:07,820 --> 07:59:10,460
And you might put that
extension function over there,

10921
07:59:10,460 --> 07:59:14,100
but that's how you can create
extension functions in Kotlin.

10922
07:59:14,100 --> 07:59:16,040
Let's say that you have a string in Kotlin

10923
07:59:17,070 --> 07:59:17,903
and you wanna print it out.

10924
07:59:17,903 --> 07:59:19,440
But what happens if this string

10925
07:59:19,440 --> 07:59:22,850
was from an expensive operation,
what would you do then?

10926
07:59:24,040 --> 07:59:29,040
You perhaps might wanna use a
lazy keyword inside of Kotlin.

10927
07:59:29,600 --> 07:59:33,450
And so this allows lazy
evaluation inside of Kotlin.

10928
07:59:33,450 --> 07:59:36,610
So what this will do is this
doesn't look any different

10929
07:59:36,610 --> 07:59:37,950
than what we had before.

10930
07:59:40,370 --> 07:59:44,100
Now, if I run this, what
we're gonna see here

10931
07:59:44,100 --> 07:59:46,309
is that we have Donn's printed.

10932
07:59:46,309 --> 07:59:48,710
Now however, something
interesting happens here,

10933
07:59:48,710 --> 07:59:52,310
print line inside of here,
and I'm gonna say computed.

10934
07:59:55,448 --> 07:59:57,180
And then what I'm gonna do is
I'm gonna print this twice.

10935
07:59:57,180 --> 07:59:58,620
And so what we're gonna see
is two different things.

10936
07:59:58,620 --> 07:59:59,980
We should see Donn printed twice,

10937
07:59:59,980 --> 08:00:01,150
but we should also see computed,

10938
08:00:01,150 --> 08:00:05,580
but we're only going to see
computed as printed once

10939
08:00:05,580 --> 08:00:07,750
yet the second Donn is here as well.

10940
08:00:07,750 --> 08:00:10,460
So I printed both the names as done here,

10941
08:00:12,090 --> 08:00:16,700
but we only see computed showing up once.

10942
08:00:16,700 --> 08:00:21,000
And the reason why is
because the first time

10943
08:00:22,130 --> 08:00:25,970
the call to this name has been called,

10944
08:00:25,970 --> 08:00:28,650
Kotlin will then go ahead and
evaluate and execute the code

10945
08:00:28,650 --> 08:00:29,950
that's inside of here.

10946
08:00:29,950 --> 08:00:31,570
And this could be a very
long running operation.

10947
08:00:31,570 --> 08:00:33,670
And then at that point
Kotlin will remember

10948
08:00:33,670 --> 08:00:35,820
the computed value and
then we'll return it

10949
08:00:36,989 --> 08:00:39,366
each subsequent time that it's called.

10950
08:00:39,366 --> 08:00:40,199
So we'll not actually execute it again.

10951
08:00:40,199 --> 08:00:42,480
So if I run this, we'll
see computed and then Don

10952
08:00:42,480 --> 08:00:44,000
will be printed three times.

10953
08:00:44,000 --> 08:00:46,090
So a good way to emulate this is actually,

10954
08:00:46,090 --> 08:00:47,690
if we just did a sleep function.

10955
08:00:48,635 --> 08:00:51,530
And we'll do sleep, I'm
gonna sleep for three seconds

10956
08:00:51,530 --> 08:00:54,650
and sleep is just part
of the Java library.

10957
08:00:54,650 --> 08:00:58,000
So three, not 3000, there we go.

10958
08:00:58,000 --> 08:01:00,210
This is simulating a
long running operation.

10959
08:01:03,752 --> 08:01:05,960
Maybe we had to go off
into a background session

10960
08:01:05,960 --> 08:01:08,510
or we had to do some type
of really complicated

10961
08:01:08,510 --> 08:01:11,680
number crunching and to return this value.

10962
08:01:11,680 --> 08:01:13,740
And this value here is as Don.

10963
08:01:13,740 --> 08:01:15,010
So the first time it's gonna happen,

10964
08:01:15,010 --> 08:01:16,540
we're gonna see print computed,

10965
08:01:16,540 --> 08:01:18,970
and then it's gonna wait 3000 milliseconds

10966
08:01:18,970 --> 08:01:19,810
or three seconds.

10967
08:01:19,810 --> 08:01:22,310
And then we're gonna see
Donn printed most likely

10968
08:01:22,310 --> 08:01:23,510
three times really fast.

10969
08:01:23,510 --> 08:01:26,170
So let's run this here down
here in the output window,

10970
08:01:26,170 --> 08:01:29,320
you're gonna see computed
it's waiting and then boom,

10971
08:01:29,320 --> 08:01:30,430
all three of them were computed.

10972
08:01:30,430 --> 08:01:34,360
So what ended up happening was
the first time this executed,

10973
08:01:34,360 --> 08:01:37,810
all this was being executed
on this first line.

10974
08:01:37,810 --> 08:01:41,090
So the first time this code was executed,

10975
08:01:41,970 --> 08:01:43,740
it was executed right here.

10976
08:01:43,740 --> 08:01:47,020
Now each subsequent call, which happens,

10977
08:01:47,020 --> 08:01:51,130
which ended up happening here and here,

10978
08:01:51,130 --> 08:01:52,360
it got the remembered value.

10979
08:01:52,360 --> 08:01:55,490
So as soon as it came
out, this came out, said,

10980
08:01:55,490 --> 08:01:59,640
all right, well, the new
calculated value is X.

10981
08:01:59,640 --> 08:02:01,820
And then what ends up
happening is each time

10982
08:02:01,820 --> 08:02:04,700
the subsequent calls are
made that calculated value

10983
08:02:04,700 --> 08:02:06,990
is remembered and it's
not executed anymore.

10984
08:02:06,990 --> 08:02:10,230
So on the first execution
when you're using by lazy,

10985
08:02:10,230 --> 08:02:13,540
it'll execute this code
and then drop it into here.

10986
08:02:13,540 --> 08:02:16,452
So that's how you can use by lazy

10987
08:02:16,452 --> 08:02:17,340
to remember computed values

10988
08:02:17,340 --> 08:02:18,990
so things are a little bit faster

10989
08:02:20,146 --> 08:02:21,760
and so you can have a
little bit more performance.

10990
08:02:22,682 --> 08:02:24,223
And if you want the value
remembered inside of your

10991
08:02:24,223 --> 08:02:25,523
application in the future.

10992
08:02:26,680 --> 08:02:29,070
In Kotlin, you can have
lazy property valuation,

10993
08:02:29,070 --> 08:02:31,020
and you can also just have a lazy block

10994
08:02:32,036 --> 08:02:33,980
in which you can state some
type of expensive operation

10995
08:02:33,980 --> 08:02:35,920
needs to be lazy evaluated.

10996
08:02:35,920 --> 08:02:37,210
And all you have to really do is provide

10997
08:02:37,210 --> 08:02:38,520
some type of block in here.

10998
08:02:38,520 --> 08:02:41,300
And you can either write
your code inside of here,

10999
08:02:41,300 --> 08:02:43,500
and you can put your code here,

11000
08:02:43,500 --> 08:02:46,310
or maybe you need to call an
actual method as I'm doing here

11001
08:02:46,310 --> 08:02:48,960
to perform some expensive operation.

11002
08:02:48,960 --> 08:02:51,660
And so what I have here is I have a method

11003
08:02:51,660 --> 08:02:52,860
that returns an integer.

11004
08:02:54,405 --> 08:02:56,270
And when it's the first
time it's executed,

11005
08:02:56,270 --> 08:02:58,770
or every time it's executed,
this method is gonna call

11006
08:02:58,770 --> 08:03:01,290
and print out this word computed.

11007
08:03:01,290 --> 08:03:02,910
And then it's gonna sleep for one second

11008
08:03:02,910 --> 08:03:06,390
and then it's gonna return
a randomized integer

11009
08:03:06,390 --> 08:03:09,340
or somewhat random because
that's just the nature

11010
08:03:09,340 --> 08:03:10,280
of the random class,

11011
08:03:10,280 --> 08:03:12,590
but it's gonna randomize
based upon the current time

11012
08:03:12,590 --> 08:03:14,810
milliseconds and et cetera.

11013
08:03:14,810 --> 08:03:16,720
So it's gonna give us a
different random number

11014
08:03:16,720 --> 08:03:18,130
each time.

11015
08:03:18,130 --> 08:03:21,040
So what we wanna see here is what happens

11016
08:03:21,040 --> 08:03:22,010
when we print this out.

11017
08:03:22,010 --> 08:03:24,400
So all we're gonna do
is have a lazy result,

11018
08:03:24,400 --> 08:03:25,440
which is an integer.

11019
08:03:25,440 --> 08:03:28,500
We're gonna print it and
then we actually wanna see,

11020
08:03:28,500 --> 08:03:30,130
there's actually a property on this

11021
08:03:30,130 --> 08:03:33,274
and it's called is initialized.

11022
08:03:33,274 --> 08:03:35,020
And so we're gonna run
this and what we'll see

11023
08:03:35,020 --> 08:03:38,550
is that the first one
when we print the result,

11024
08:03:38,550 --> 08:03:40,930
it says lazy value not initialized yet.

11025
08:03:40,930 --> 08:03:43,390
And I said, is this
initialized and it's false.

11026
08:03:43,390 --> 08:03:46,000
And so we have a couple
of other options on here,

11027
08:03:46,000 --> 08:03:50,390
result.initialized or get
value or just value itself.

11028
08:03:50,390 --> 08:03:54,600
So it's print this line here,
so print line result.value.

11029
08:03:55,690 --> 08:03:58,352
And then what we're gonna
see here is we're of course

11030
08:03:58,352 --> 08:03:59,920
gonna see non initialize,
it's gonna be false.

11031
08:03:59,920 --> 08:04:02,250
And is gonna say computed
and then it returned us

11032
08:04:02,250 --> 08:04:05,910
a number here based
upon the randomization.

11033
08:04:05,910 --> 08:04:09,030
Now to verify that the
lazy evaluation is working

11034
08:04:09,030 --> 08:04:11,790
and lazily evaluating meaning,
it's going to remember

11035
08:04:11,790 --> 08:04:15,130
its future values, let's
execute this a few times

11036
08:04:15,130 --> 08:04:16,930
to see what happens.

11037
08:04:16,930 --> 08:04:20,380
If for some reason, lazy
is not doing its job,

11038
08:04:20,380 --> 08:04:23,360
then we should see computed
printed three times

11039
08:04:23,360 --> 08:04:26,840
and we should see every time
1000 milliseconds sleeps,

11040
08:04:26,840 --> 08:04:29,570
so about a second in between
each one of these values.

11041
08:04:29,570 --> 08:04:31,230
So if we run this, what
we'll see is again,

11042
08:04:31,230 --> 08:04:33,560
we'll see the top two values
printed computed, boom.

11043
08:04:33,560 --> 08:04:34,970
And then all three of these came out

11044
08:04:34,970 --> 08:04:38,210
almost the exact same time, very quickly.

11045
08:04:38,210 --> 08:04:40,680
And what that means is the
first time that this value

11046
08:04:40,680 --> 08:04:43,000
was computed inside of
this lazy evaluation,

11047
08:04:43,000 --> 08:04:44,190
Kotlin then remembered it.

11048
08:04:44,190 --> 08:04:48,010
So for each subsequent time,
we received the same value.

11049
08:04:48,010 --> 08:04:50,650
And then of course, because
we weren't sleeping,

11050
08:04:50,650 --> 08:04:52,230
the milliseconds would
have been different here,

11051
08:04:52,230 --> 08:04:55,310
which means we would got a
most likely a different number

11052
08:04:55,310 --> 08:04:56,900
in one of these values.

11053
08:04:56,900 --> 08:05:00,190
So we can tell here with
a high level of certainty

11054
08:05:00,190 --> 08:05:03,420
that Kotlin is returning
basically a cached value of that

11055
08:05:03,420 --> 08:05:06,010
which been cached for this lazy operation.

11056
08:05:06,010 --> 08:05:08,640
So if we know that we want
that same value over and over,

11057
08:05:08,640 --> 08:05:12,218
and we don't wanna call a
particular method or function

11058
08:05:12,218 --> 08:05:13,940
or class, because it's very expensive,

11059
08:05:13,940 --> 08:05:17,300
more than once we can
wrap it in a lazy block

11060
08:05:17,300 --> 08:05:19,220
and it will be only
executed the first time.

11061
08:05:19,220 --> 08:05:21,780
And then at that point,
all future invocations

11062
08:05:21,780 --> 08:05:25,410
of that operation will then
return the cached value,

11063
08:05:25,410 --> 08:05:28,890
which is cache via the
Kotlin lazy operator,

11064
08:05:28,890 --> 08:05:31,120
which we can see here
creates a new lazy instance

11065
08:05:31,120 --> 08:05:33,910
of the specified initialization function.

11066
08:05:33,910 --> 08:05:37,960
So that's how you can use
the lazy block in Kotlin

11067
08:05:37,960 --> 08:05:39,700
to help speed up your application

11068
08:05:39,700 --> 08:05:41,840
and be a little more performant.

11069
08:05:41,840 --> 08:05:43,700
When creating files
instead of your project,

11070
08:05:43,700 --> 08:05:45,780
you want to think about organization

11071
08:05:45,780 --> 08:05:47,720
and where to put these files.

11072
08:05:47,720 --> 08:05:50,570
Files are usually organized
into various different packages

11073
08:05:50,570 --> 08:05:53,520
inside of your project
and the project explorer

11074
08:05:53,520 --> 08:05:54,990
on the left-hand side.

11075
08:05:54,990 --> 08:05:57,010
And the SRC directory, you
can create a new package

11076
08:05:57,010 --> 08:06:00,820
by going to new package, and
then you can enter a package.

11077
08:06:00,820 --> 08:06:03,780
So one common one that you see a lot used,

11078
08:06:03,780 --> 08:06:08,200
instead of example
projects is com.example.

11079
08:06:08,200 --> 08:06:11,370
As we create com.example, we
see we have kind of what looks

11080
08:06:11,370 --> 08:06:13,120
like a new folder with a dot in it,

11081
08:06:14,421 --> 08:06:15,890
and that signifies it as a package.

11082
08:06:15,890 --> 08:06:18,789
And let's say we wanted
to create another package

11083
08:06:18,789 --> 08:06:19,622
inside of the example.

11084
08:06:19,622 --> 08:06:22,389
We could say, we wanna create another one.

11085
08:06:22,389 --> 08:06:23,750
We could say com.example

11086
08:06:24,840 --> 08:06:26,500
and we see here that the
directory already exists.

11087
08:06:26,500 --> 08:06:28,200
And why does it say directory?

11088
08:06:28,200 --> 08:06:30,300
We'll get to that in a second.

11089
08:06:30,300 --> 08:06:32,550
Let's say we wanna
create a models package,

11090
08:06:32,550 --> 08:06:34,200
we wanna create a models package.

11091
08:06:35,670 --> 08:06:37,840
And so we said com.example.models.

11092
08:06:38,700 --> 08:06:41,444
And so it's kind of been pre pended here.

11093
08:06:41,444 --> 08:06:43,250
Now, as we see these
dots and it kind of looks

11094
08:06:43,250 --> 08:06:46,220
like a backwards domain name
and that's kind of what it is.

11095
08:06:46,220 --> 08:06:48,520
Now the interesting part
about how these files

11096
08:06:48,520 --> 08:06:50,390
are stored in the disc
is if we look at them

11097
08:06:50,390 --> 08:06:53,070
inside of our file
explorer and I'm on a Mac,

11098
08:06:53,070 --> 08:06:56,560
so I'm using finder,
you'll see, we have models,

11099
08:06:57,680 --> 08:06:59,360
an example com.

11100
08:06:59,360 --> 08:07:01,480
And if we go backwards, we
basically gonna come up here

11101
08:07:01,480 --> 08:07:05,500
to our Castro column, our SRC folder,

11102
08:07:05,500 --> 08:07:08,090
which kind of maps to
this folder over here,

11103
08:07:08,090 --> 08:07:13,090
we see our IO our com and
see how we have io.Caster

11104
08:07:14,200 --> 08:07:15,500
package over here.

11105
08:07:15,500 --> 08:07:20,070
So com example models,
each one of the items

11106
08:07:20,070 --> 08:07:22,820
that are separated between the
separators, which are dots,

11107
08:07:22,820 --> 08:07:24,800
periods is actually a new folder.

11108
08:07:25,650 --> 08:07:28,030
So let's say for whatever reason,

11109
08:07:28,030 --> 08:07:31,700
I wanted to create a file
inside of the models project.

11110
08:07:31,700 --> 08:07:35,070
What I would do is they
file new and inside of here,

11111
08:07:35,070 --> 08:07:36,840
I might wanna create a person,

11112
08:07:38,189 --> 08:07:39,639
it's called a customer class.

11113
08:07:41,550 --> 08:07:43,200
And it's customer, you
notice how it automatically

11114
08:07:43,200 --> 08:07:46,270
adds the value package at the top.

11115
08:07:46,270 --> 08:07:49,403
And this is the package
declaration that lets you know

11116
08:07:49,403 --> 08:07:50,236
what package is file is in.

11117
08:07:50,236 --> 08:07:53,760
So here, this is inside of the
package com.example.models.

11118
08:07:53,760 --> 08:07:56,380
And I can have my class
and maybe it would have

11119
08:07:56,380 --> 08:07:59,800
a regular name and a
string for a customer.

11120
08:07:59,800 --> 08:08:00,990
And those are all kinds of common things

11121
08:08:00,990 --> 08:08:01,940
we might have here.

11122
08:08:03,891 --> 08:08:07,740
And then we might have another customer

11123
08:08:07,740 --> 08:08:10,030
or we might have another
value inside of there.

11124
08:08:10,030 --> 08:08:12,020
And now let's go, we're over
here to our other file here.

11125
08:08:12,020 --> 08:08:13,790
Let's say we have something else.

11126
08:08:13,790 --> 08:08:16,050
And let's say we have in
cast or we have something

11127
08:08:16,050 --> 08:08:18,360
known as a video file
and that's a video class,

11128
08:08:18,360 --> 08:08:21,440
we'll say class video and it has a URL.

11129
08:08:21,440 --> 08:08:24,540
That's a string that's
associated with that URL.

11130
08:08:25,650 --> 08:08:28,220
And then inside of there,
we have some other things.

11131
08:08:28,220 --> 08:08:32,100
But maybe it also has some
customers that have watched it.

11132
08:08:32,100 --> 08:08:36,190
So we might have a function,
say something like fun.

11133
08:08:36,190 --> 08:08:40,740
And it would be customers who viewed this

11134
08:08:43,770 --> 08:08:45,856
and perhaps this goes to a database.

11135
08:08:45,856 --> 08:08:48,656
And this database is gonna
go return a list of customers

11136
08:08:50,070 --> 08:08:50,903
of customers.

11137
08:08:51,920 --> 08:08:53,340
Now we're gonna see is we
have a list of customers

11138
08:08:53,340 --> 08:08:56,700
and we see right here IntelliJ has found

11139
08:08:56,700 --> 08:08:59,880
based upon us typing and code completion

11140
08:08:59,880 --> 08:09:01,650
that a customer class have been found.

11141
08:09:01,650 --> 08:09:04,100
Now, if I hit tab, which I'm going to do,

11142
08:09:05,000 --> 08:09:08,800
automatically, what happens
is something is imported.

11143
08:09:08,800 --> 08:09:12,030
This import is basically
saying, look, we wanna use

11144
08:09:12,030 --> 08:09:14,670
a customer from a different package.

11145
08:09:14,670 --> 08:09:15,650
And we're gonna use this from

11146
08:09:15,650 --> 08:09:17,720
the com.example.model's package.

11147
08:09:17,720 --> 08:09:20,430
Now of course I could just
hear, I could just hit return

11148
08:09:20,430 --> 08:09:22,280
just to get the compiler to be happy.

11149
08:09:22,280 --> 08:09:24,560
I could return them to the list.

11150
08:09:24,560 --> 08:09:26,060
So we're returning a customer.

11151
08:09:26,920 --> 08:09:29,380
So what we are using it
inside of this video class,

11152
08:09:29,380 --> 08:09:31,690
on the side, we're using
something from different package

11153
08:09:31,690 --> 08:09:32,840
over here.

11154
08:09:32,840 --> 08:09:33,830
Now we could also have
additional packages.

11155
08:09:33,830 --> 08:09:36,420
For example, I wanna
show you another trick

11156
08:09:36,420 --> 08:09:38,070
and go over here.

11157
08:09:38,070 --> 08:09:39,800
And let's say, for example, in models,

11158
08:09:39,800 --> 08:09:42,930
we happened to come to the
file system and type in here

11159
08:09:42,930 --> 08:09:44,840
and we'll say util.

11160
08:09:44,840 --> 08:09:47,570
Now, if we go back over
here, look what happens.

11161
08:09:47,570 --> 08:09:50,598
All of a sudden IntelliJ
recognize we have another folder

11162
08:09:50,598 --> 08:09:52,420
in there, hey, there's actually
some other stuff in here.

11163
08:09:52,420 --> 08:09:55,443
And a lot of times people
will actually create things

11164
08:09:55,443 --> 08:09:59,670
in here that are perhaps view,
we call it model extension

11165
08:09:59,670 --> 08:10:00,620
or something like that.

11166
08:10:00,620 --> 08:10:02,530
Will create some extensions files in here

11167
08:10:02,530 --> 08:10:06,340
for anything that's going to
be like an extension function

11168
08:10:06,340 --> 08:10:09,320
or anything like that, create extensions.

11169
08:10:10,180 --> 08:10:12,630
And this where they'll path
all of their extensions,

11170
08:10:12,630 --> 08:10:13,950
et cetera, or so forth

11171
08:10:13,950 --> 08:10:16,170
and it looks like it was misnamed there.

11172
08:10:16,170 --> 08:10:20,570
So we'll say extensions.kt not a big deal.

11173
08:10:20,570 --> 08:10:25,200
So we have multiple different
packages inside of here.

11174
08:10:25,200 --> 08:10:26,690
And so you can have multiple packages

11175
08:10:26,690 --> 08:10:27,630
inside of your projects.

11176
08:10:27,630 --> 08:10:29,220
So, here we have a couple of them.

11177
08:10:29,220 --> 08:10:32,150
You may import a different
package from another library

11178
08:10:32,150 --> 08:10:33,539
altogether.

11179
08:10:33,539 --> 08:10:36,090
So if we're inside of our
models here and we wanted

11180
08:10:36,090 --> 08:10:38,840
to import something else
from a different project,

11181
08:10:40,060 --> 08:10:42,530
as long as we have imported
inside of whatever build tool

11182
08:10:42,530 --> 08:10:45,687
we're using, we can go
ahead and reference that

11183
08:10:45,687 --> 08:10:48,390
just as we had referenced
to inside of our video file

11184
08:10:48,390 --> 08:10:49,800
over here.

11185
08:10:49,800 --> 08:10:51,980
Now, if for whatever reason you don't,

11186
08:10:51,980 --> 08:10:54,480
you would just create a
file and we don't put it

11187
08:10:54,480 --> 08:10:56,300
inside of a package.

11188
08:10:56,300 --> 08:11:00,340
So let's call this and say,
I'm gonna call it a favorite.

11189
08:11:00,340 --> 08:11:01,250
We'll call it a favorite class.

11190
08:11:01,250 --> 08:11:03,451
And if you're gonna favorite something,

11191
08:11:03,451 --> 08:11:07,060
say class favorite,
and maybe it has an IDE

11192
08:11:08,781 --> 08:11:10,660
that you did for whatever reason.

11193
08:11:10,660 --> 08:11:14,080
This class is in this right
here, it's in the SRC directory.

11194
08:11:14,080 --> 08:11:19,030
It does not have at all,
it does not have a package.

11195
08:11:19,030 --> 08:11:20,800
So the default package, it has no name.

11196
08:11:20,800 --> 08:11:22,410
So at this point, it's
part of the default package

11197
08:11:22,410 --> 08:11:25,420
of the application and the default package

11198
08:11:25,420 --> 08:11:28,450
of the application is nothing,
there's no name for it.

11199
08:11:28,450 --> 08:11:30,200
So here, you're just kind
of sitting at the top level

11200
08:11:30,200 --> 08:11:31,380
of your application.

11201
08:11:31,380 --> 08:11:33,050
This is not recommended to put files

11202
08:11:33,050 --> 08:11:33,900
here at the top level here.

11203
08:11:33,900 --> 08:11:36,800
It's always good to
have a place to put them

11204
08:11:36,800 --> 08:11:38,840
inside of your application.

11205
08:11:38,840 --> 08:11:40,170
So where should you put them,

11206
08:11:40,170 --> 08:11:42,660
maybe you don't have a good idea.

11207
08:11:42,660 --> 08:11:44,620
A lot of times if you're just
working with a sample app

11208
08:11:44,620 --> 08:11:46,020
and you want someplace to put them,

11209
08:11:46,020 --> 08:11:50,190
I recommend just using
com.example or org.example.

11210
08:11:50,190 --> 08:11:53,080
And that puts them in kind
of like an example namespace,

11211
08:11:53,080 --> 08:11:56,040
just so it gives you a little
bit a level of organization,

11212
08:11:56,040 --> 08:11:58,960
or maybe if you have your
own website, like I do,

11213
08:11:58,960 --> 08:12:01,680
what I will do is I'll put
them in my own package.

11214
08:12:01,680 --> 08:12:04,060
And so you can see, I
have a Caster one there,

11215
08:12:04,060 --> 08:12:06,610
but I also have a Donn Felker one.

11216
08:12:06,610 --> 08:12:09,460
So I'll say Donn Felker,
which is my website.

11217
08:12:09,460 --> 08:12:10,830
And I might say something like models.

11218
08:12:10,830 --> 08:12:12,110
If it's something has to do with models,

11219
08:12:12,110 --> 08:12:15,490
it has to do with IO, it might
have to do with input output,

11220
08:12:15,490 --> 08:12:18,240
if it has to do with, I'm
building some calculation stuff

11221
08:12:18,240 --> 08:12:20,060
or math or anything like that,

11222
08:12:20,060 --> 08:12:21,970
I might have it inside of there.

11223
08:12:21,970 --> 08:12:24,480
Or if I'm gonna build some services,

11224
08:12:24,480 --> 08:12:28,120
I have com.Donn Felker.services.

11225
08:12:28,120 --> 08:12:31,320
And now I have some packages in here.

11226
08:12:31,320 --> 08:12:34,140
And if you notice com now has realized,

11227
08:12:34,140 --> 08:12:37,140
hey, well, we have a couple
of packages inside of here

11228
08:12:37,140 --> 08:12:42,140
that also are from the same
root TLD, which is the com,

11229
08:12:43,740 --> 08:12:45,238
let me create a file here.

11230
08:12:45,238 --> 08:12:46,071
And inside of here, we'll have something

11231
08:12:46,071 --> 08:12:49,580
like a customer service, maybe
it does something special

11232
08:12:49,580 --> 08:12:53,090
for customers, or let's just
say it's a tweet service

11233
08:12:53,090 --> 08:12:56,670
for whatever reason I'm
connecting to Twitter.

11234
08:12:59,392 --> 08:13:00,225
So there, we got a tweet service.

11235
08:13:00,225 --> 08:13:03,550
And so this is just to
illustrate that you can have

11236
08:13:03,550 --> 08:13:06,310
multiple different packages inside of here

11237
08:13:06,310 --> 08:13:10,940
and the tweet services inside
of com.Donn Felker services.

11238
08:13:10,940 --> 08:13:13,180
Example over here we have the models,

11239
08:13:13,180 --> 08:13:16,240
we have models in here and
packages give you a way

11240
08:13:16,240 --> 08:13:20,320
to organize your code
into logical groupings.

11241
08:13:20,320 --> 08:13:22,000
So a lot of times you'll see a lot of code

11242
08:13:22,000 --> 08:13:24,830
that's related, maybe it's
with file L IO together,

11243
08:13:24,830 --> 08:13:26,640
database code will be together.

11244
08:13:26,640 --> 08:13:30,660
You'll see services together
and various different projects

11245
08:13:30,660 --> 08:13:31,610
will have a different way.

11246
08:13:31,610 --> 08:13:33,640
So it depends on the
project you're working on.

11247
08:13:33,640 --> 08:13:36,080
Some will be kind of grouped
together by function,

11248
08:13:36,080 --> 08:13:37,700
some will be grouped together by feature,

11249
08:13:37,700 --> 08:13:39,140
kind of depends on what it is.

11250
08:13:39,140 --> 08:13:41,850
But packages allow you
to group your various

11251
08:13:41,850 --> 08:13:44,800
different pieces of your
application and your classes

11252
08:13:44,800 --> 08:13:45,780
into different locations.

11253
08:13:45,780 --> 08:13:49,320
And again, if it's not part
of a particular package

11254
08:13:49,320 --> 08:13:52,486
and it's at the root level,
perhaps just right here

11255
08:13:52,486 --> 08:13:54,370
in the source directory, it's
part of the default package,

11256
08:13:54,370 --> 08:13:55,710
which has no name at all.

11257
08:13:55,710 --> 08:13:58,380
And usually this isn't
recommended when you're developing

11258
08:13:58,380 --> 08:14:00,250
a real production application.

11259
08:14:00,250 --> 08:14:03,000
And that's how you work with
packages inside of Kotlin.

11260
08:14:04,230 --> 08:14:06,500
Kotlin has type inference.

11261
08:14:06,500 --> 08:14:09,210
Let's talk about exactly what that means.

11262
08:14:09,210 --> 08:14:13,050
Now at a real high level,
what that really means

11263
08:14:13,050 --> 08:14:16,410
is that Kotlin can infer a
particular type of variable.

11264
08:14:16,410 --> 08:14:18,300
Now Kotlin is a strongly typed language.

11265
08:14:18,300 --> 08:14:22,700
That means that each variable
has a particular type.

11266
08:14:22,700 --> 08:14:24,270
The competitor's gonna check those types

11267
08:14:24,270 --> 08:14:25,830
and we have a lot of competitor things

11268
08:14:25,830 --> 08:14:28,410
that the competitor does that
makes our life a lot easier.

11269
08:14:28,410 --> 08:14:30,580
And one of those things is type checking.

11270
08:14:30,580 --> 08:14:32,750
However, in traditional
languages, such as Java,

11271
08:14:32,750 --> 08:14:35,040
you have to inform the compiler,

11272
08:14:35,040 --> 08:14:36,940
here's the type that I'm going to use.

11273
08:14:37,904 --> 08:14:38,737
And then you can start using the variable.

11274
08:14:38,737 --> 08:14:40,050
Kotlin has type inference.

11275
08:14:40,050 --> 08:14:45,050
So here we have a variable
or value by the name of name.

11276
08:14:46,460 --> 08:14:48,640
And it contains the value of Don

11277
08:14:48,640 --> 08:14:49,730
and we have another value here,

11278
08:14:49,730 --> 08:14:51,830
which contains the value of age.

11279
08:14:51,830 --> 08:14:54,999
And this could also be
a var, it doesn't matter

11280
08:14:54,999 --> 08:14:59,040
if it's a val or a var,
Kotlin one for both.

11281
08:14:59,040 --> 08:15:01,810
And the old we can see
here just through the helps

11282
08:15:01,810 --> 08:15:05,510
inside of IntelliJ is that
Kotlin has already inferred

11283
08:15:05,510 --> 08:15:08,740
that the name variable here is a string.

11284
08:15:08,740 --> 08:15:11,120
And the reason how it's
doing that is it's looking

11285
08:15:11,120 --> 08:15:13,880
on the right hand side of
the equal sign and saying,

11286
08:15:13,880 --> 08:15:17,680
well, you have omitted declare a variable

11287
08:15:17,680 --> 08:15:18,950
and you want me to call it a name?

11288
08:15:18,950 --> 08:15:21,660
Okay, and then you wanna
assign the value Don

11289
08:15:21,660 --> 08:15:24,220
and I already know the
value Donn is a string.

11290
08:15:24,220 --> 08:15:28,630
And someone gonna put a
string inside of the name.

11291
08:15:28,630 --> 08:15:31,530
So that means that most
likely that name is a string.

11292
08:15:31,530 --> 08:15:33,000
So I'm gonna infer the name of the string.

11293
08:15:33,000 --> 08:15:35,690
And the same thing goes for over here,

11294
08:15:35,690 --> 08:15:39,050
you will want the value
33 and 33 is integer,

11295
08:15:39,050 --> 08:15:40,900
and you wanna shove it into the name,

11296
08:15:41,971 --> 08:15:44,360
excuse me, into the age variable.

11297
08:15:44,360 --> 08:15:47,020
Well, I'm gonna assume
that that age variable

11298
08:15:47,020 --> 08:15:48,330
is actually gonna be an integer.

11299
08:15:48,330 --> 08:15:49,870
And as we can see here from the help

11300
08:15:49,870 --> 08:15:52,040
that compiler is actually
getting this right.

11301
08:15:52,040 --> 08:15:53,160
And this does a few things,

11302
08:15:53,160 --> 08:15:56,060
it allows us to not have
to declare the variable.

11303
08:15:56,060 --> 08:15:57,760
Now we could, of course, just say,

11304
08:15:58,936 --> 08:15:59,769
hey, this is gonna be a string,

11305
08:15:59,769 --> 08:16:01,780
but we're actually kind of
just writing a bunch of code

11306
08:16:01,780 --> 08:16:04,260
that we don't really need to write.

11307
08:16:05,740 --> 08:16:07,090
So we don't really don't have to do this.

11308
08:16:07,090 --> 08:16:11,030
Now that's really nice thing
about us instead of Kotlin,

11309
08:16:11,030 --> 08:16:13,260
with variables, we can
infer them automatically.

11310
08:16:13,260 --> 08:16:15,110
Now there is a caveat here.

11311
08:16:15,110 --> 08:16:18,470
If you remember late
initializations who have a var,

11312
08:16:18,470 --> 08:16:22,270
and we could say maybe your favorite food.

11313
08:16:22,270 --> 08:16:23,103
You could say something like this.

11314
08:16:23,103 --> 08:16:26,300
Well, I'm going to do this
later and again, late init

11315
08:16:26,300 --> 08:16:30,360
means, hey, Kotlin, don't
worry about this yet.

11316
08:16:30,360 --> 08:16:33,840
I'm going to go ahead and
populate the food variable.

11317
08:16:33,840 --> 08:16:34,770
I'm just not gonna do it yet,

11318
08:16:34,770 --> 08:16:37,583
I'm gonna do it somewhere
later down the line,

11319
08:16:37,583 --> 08:16:38,416
but don't worry I got this covered.

11320
08:16:38,416 --> 08:16:39,249
I'll handle it.

11321
08:16:39,249 --> 08:16:42,210
So that's what we're telling
Kotlin at this point in time.

11322
08:16:42,210 --> 08:16:45,900
However, Kotlin says, well, I can infer

11323
08:16:45,900 --> 08:16:48,140
the type of the variable
if you give it to me

11324
08:16:48,140 --> 08:16:50,700
during the initialization,
which is what we're doing here,

11325
08:16:50,700 --> 08:16:53,930
we're allowing the initialization
of the variable to occur

11326
08:16:53,930 --> 08:16:56,030
and therefore type
inference can take place.

11327
08:16:56,030 --> 08:16:58,430
So names like, okay,
that's gonna be a strain

11328
08:16:59,714 --> 08:17:00,970
'cause you're basically
setting it equal to a string.

11329
08:17:00,970 --> 08:17:03,250
In age is gonna be
equivalent to an integer

11330
08:17:03,250 --> 08:17:05,580
because well, you're
setting it equal to 33.

11331
08:17:05,580 --> 08:17:08,900
But late in it food, I don't
know that's gonna be yet

11332
08:17:08,900 --> 08:17:11,710
because somewhere further
down the line here

11333
08:17:11,710 --> 08:17:14,050
in our application, who
knows if it's inside

11334
08:17:15,312 --> 08:17:16,145
of an if statement,
inside of a catch block,

11335
08:17:16,145 --> 08:17:17,740
who knows where it's at.

11336
08:17:17,740 --> 08:17:19,510
But you're gonna set it
somewhere and I don't know

11337
08:17:19,510 --> 08:17:21,310
what it is yet, so you have to tell me.

11338
08:17:21,310 --> 08:17:25,240
So in this instance, I actually
have to define the type

11339
08:17:25,240 --> 08:17:26,570
for the compiler to be happy.

11340
08:17:26,570 --> 08:17:31,400
So I cannot infer a type with
a late initialized variable.

11341
08:17:31,400 --> 08:17:33,880
Well, this also works too if you have...

11342
08:17:33,880 --> 08:17:36,870
For example, let's say we wanna
use a name that's reversed.

11343
08:17:38,060 --> 08:17:40,990
And we have a method which we
have down here at the bottom.

11344
08:17:40,990 --> 08:17:44,300
And this method right here,
we'll just take in a string

11345
08:17:44,300 --> 08:17:45,133
and we reverse it.

11346
08:17:45,133 --> 08:17:46,850
Now, of course we could do that by hand,

11347
08:17:46,850 --> 08:17:49,760
but this is just to illustrate the concept

11348
08:17:49,760 --> 08:17:53,230
that you can have a function
that also return something.

11349
08:17:53,230 --> 08:17:55,500
And we'll take that,
we'll take in the name.

11350
08:17:55,500 --> 08:17:57,220
And what will happen as
Kotlin will then go ahead

11351
08:17:57,220 --> 08:18:00,390
and take a look at this function here

11352
08:18:00,390 --> 08:18:03,152
and say, all right, well,
you wanna use name reverse.

11353
08:18:03,152 --> 08:18:04,320
Okay, well I'm gonna go
look at this function name,

11354
08:18:04,320 --> 08:18:06,230
reversed and then I'm gonna see,

11355
08:18:06,230 --> 08:18:09,260
oh, a name reversed actually
turns a string, oh, okay.

11356
08:18:09,260 --> 08:18:11,872
So in that case, I'm just gonna go ahead

11357
08:18:11,872 --> 08:18:13,060
and make reversed a string.

11358
08:18:14,120 --> 08:18:18,050
So again, kind of as real
quick, just kind of Kotlin says,

11359
08:18:18,050 --> 08:18:19,290
I'm gonna go look at this function here.

11360
08:18:19,290 --> 08:18:21,390
I see it as a string and then, okay, cool.

11361
08:18:22,259 --> 08:18:23,130
It looks like I'm gonna go ahead and make

11362
08:18:23,130 --> 08:18:24,930
this reverse value a string.

11363
08:18:25,990 --> 08:18:27,610
So pretty simple.

11364
08:18:29,818 --> 08:18:31,700
And what is doing behind the
scenes, so you can do that.

11365
08:18:31,700 --> 08:18:33,840
Kotlin will also do some inferring too,

11366
08:18:33,840 --> 08:18:37,960
So, let's say we have two
prices, so price equals 10.

11367
08:18:37,960 --> 08:18:41,140
Now this is gonna be an
integer and I've priced two.

11368
08:18:41,140 --> 08:18:44,750
And whoops, so this might be price two

11369
08:18:44,750 --> 08:18:46,250
and this could be val as well.

11370
08:18:47,714 --> 08:18:48,547
So 20.01.

11371
08:18:50,124 --> 08:18:52,524
And then I say, all right,
print line price one.

11372
08:18:55,390 --> 08:18:56,840
I'd say print line price two.

11373
08:19:01,920 --> 08:19:03,710
If we look at what the
competitor is telling us here

11374
08:19:03,710 --> 08:19:06,110
is it, well, price is an integer

11375
08:19:07,090 --> 08:19:08,350
and price two is a double.

11376
08:19:09,891 --> 08:19:12,524
And then what happens if
we initialize another one?

11377
08:19:12,524 --> 08:19:14,293
And we say, this is a total number.

11378
08:19:14,293 --> 08:19:16,643
The total is gonna be
the price plus price two.

11379
08:19:17,565 --> 08:19:18,398
Now what's gonna happen here.

11380
08:19:18,398 --> 08:19:19,231
We're combining two different types.

11381
08:19:19,231 --> 08:19:21,450
Well, this is a double
and this is an integer.

11382
08:19:21,450 --> 08:19:23,740
Well, Kotlin is like, well,
what am I gonna do here?

11383
08:19:23,740 --> 08:19:26,290
Well, Kotlin is smart
enough to know the compiler

11384
08:19:27,337 --> 08:19:28,510
is well, you're getting
an integer and a double.

11385
08:19:28,510 --> 08:19:31,550
So most likely you want the
precision of this to be a double

11386
08:19:31,550 --> 08:19:33,930
because otherwise you
would lose some precision

11387
08:19:33,930 --> 08:19:35,510
if we just stuck with an integer,

11388
08:19:35,510 --> 08:19:38,338
meaning that we would
end up with, you know,

11389
08:19:38,338 --> 08:19:39,820
what would this be, it
would be 30 most likely.

11390
08:19:39,820 --> 08:19:42,310
So at this point in time,
total is gonna end up

11391
08:19:42,310 --> 08:19:46,070
being a double, which we can
see here from the IDE help.

11392
08:19:46,070 --> 08:19:48,810
So Kotlin is then doing type inference

11393
08:19:48,810 --> 08:19:53,450
based upon a calculation
of an integer and a double.

11394
08:19:53,450 --> 08:19:56,308
Now in other languages,
you might have to do

11395
08:19:56,308 --> 08:19:57,141
particular types of casting to make sure

11396
08:19:57,141 --> 08:19:58,690
that you don't lose any precision,

11397
08:19:58,690 --> 08:20:00,210
because if you didn't do the casting,

11398
08:20:00,210 --> 08:20:01,650
you might have precision problems,

11399
08:20:01,650 --> 08:20:04,010
meaning you're losing decimals, et cetera.

11400
08:20:04,010 --> 08:20:05,290
But Kotlin is smart enough to figure

11401
08:20:05,290 --> 08:20:07,090
some of these things out here.

11402
08:20:07,090 --> 08:20:11,230
So this is basically an essence,
what type of inference is.

11403
08:20:11,230 --> 08:20:14,220
And so you can get inference
when you are initializing

11404
08:20:14,220 --> 08:20:17,810
variables and then different
types of returned, et cetera,

11405
08:20:17,810 --> 08:20:22,270
are going to be inferred, such
as the function name is here.

11406
08:20:22,270 --> 08:20:25,170
And Kotlin will both go
basically look throughout

11407
08:20:25,170 --> 08:20:26,820
the execution path as a code set,

11408
08:20:27,836 --> 08:20:28,669
all right, what is being returned here?

11409
08:20:28,669 --> 08:20:32,440
Okay, it's being set into
this other value up here.

11410
08:20:32,440 --> 08:20:33,370
Okay, that sounds good.

11411
08:20:33,370 --> 08:20:35,930
So it looks like reversed is that point

11412
08:20:35,930 --> 08:20:38,460
is now going to be a
string and we can go ahead

11413
08:20:38,460 --> 08:20:40,120
and infer that for you.

11414
08:20:40,120 --> 08:20:42,200
For some reason, though,
if we are using again,

11415
08:20:42,200 --> 08:20:44,830
a late init and we're gonna
go ahead and use a var

11416
08:20:45,897 --> 08:20:46,730
and have our favorite food,

11417
08:20:48,030 --> 08:20:51,740
we will have to actually declare
the type when we declare it

11418
08:20:51,740 --> 08:20:53,270
because Kotlin is not
smart enough to know,

11419
08:20:53,270 --> 08:20:55,170
hey, I don't know what this is gonna be.

11420
08:20:55,170 --> 08:20:56,870
And because it's a
strongly typed language,

11421
08:20:56,870 --> 08:20:59,620
we can't just kind of let this
type just kind of be floating

11422
08:20:59,620 --> 08:21:02,090
around and nowhere and
we don't know what it is.

11423
08:21:02,090 --> 08:21:04,450
So you do have to declare the type here,

11424
08:21:04,450 --> 08:21:06,310
if it's gonna be late initialized.

11425
08:21:06,310 --> 08:21:09,410
And that's how type
inference works in Kotlin.

11426
08:21:09,410 --> 08:21:12,120
Okay, let's talk about lambda functions.

11427
08:21:12,120 --> 08:21:15,900
Now, lambda in Kotlin is
defined as the following.

11428
08:21:15,900 --> 08:21:18,010
And these can look very
confusing the first few times

11429
08:21:18,010 --> 08:21:19,520
you see them.

11430
08:21:19,520 --> 08:21:21,150
So if we're gonna build
our own lambda function

11431
08:21:21,150 --> 08:21:22,340
so you can understand what they are.

11432
08:21:22,340 --> 08:21:24,750
And basically functions
are functions that are,

11433
08:21:24,750 --> 08:21:26,760
I'm not gonna get really
mathematical about you

11434
08:21:26,760 --> 08:21:28,910
and high order functions
and everything like that,

11435
08:21:28,910 --> 08:21:31,710
though I really advise you
to go read the documentation.

11436
08:21:33,217 --> 08:21:34,190
Lambda functions are
basically little functions

11437
08:21:34,190 --> 08:21:37,290
that you can create and
start parsing around

11438
08:21:37,290 --> 08:21:38,270
inside of your application

11439
08:21:38,270 --> 08:21:41,417
and allows you to be very
functional in nature.

11440
08:21:41,417 --> 08:21:44,350
So enough of that let's
get into implementation.

11441
08:21:44,350 --> 08:21:48,380
So a lambda is defined as
having a name of a lambda,

11442
08:21:48,380 --> 08:21:50,080
and then you have its input types,

11443
08:21:50,917 --> 08:21:52,390
which are gonna be the
parameters that are parsed in,

11444
08:21:52,390 --> 08:21:54,880
and then it's gonna have a return value.

11445
08:21:54,880 --> 08:21:57,360
And then inside of that,
you're gonna actually have

11446
08:21:57,360 --> 08:21:59,720
some arguments that you get
to provide the names for,

11447
08:21:59,720 --> 08:22:01,330
and you have to provide their types again,

11448
08:22:01,330 --> 08:22:03,170
that's gonna be the input type over here,

11449
08:22:03,170 --> 08:22:04,730
so we can go and change
this to input types

11450
08:22:04,730 --> 08:22:07,200
so it makes more sense and put type.

11451
08:22:07,200 --> 08:22:09,600
And then you're gonna have
the body of your actual

11452
08:22:09,600 --> 08:22:12,030
Lambda function which does its work.

11453
08:22:12,030 --> 08:22:14,050
Now, a lot of type inference
will happen with this,

11454
08:22:14,050 --> 08:22:15,520
which we can get into in a second,

11455
08:22:15,520 --> 08:22:17,600
but let's go and create a first one.

11456
08:22:17,600 --> 08:22:19,350
And the first one we're
gonna call is the end result

11457
08:22:19,350 --> 08:22:22,280
is what we wanna be able
to do is say greeter.

11458
08:22:22,280 --> 08:22:24,500
We wanna be able to do this,

11459
08:22:24,500 --> 08:22:26,170
and I wanna be able to parse in my name.

11460
08:22:26,170 --> 08:22:30,890
And what I want to happen
is I want hello Don

11461
08:22:30,890 --> 08:22:32,560
to come out somehow.

11462
08:22:32,560 --> 08:22:34,300
So how are we gonna do that?

11463
08:22:34,300 --> 08:22:37,040
So this is a very rudimentary example

11464
08:22:37,040 --> 08:22:38,990
of what you could normally
write a regular function for,

11465
08:22:38,990 --> 08:22:42,450
but this illustrates the lambda functions.

11466
08:22:42,450 --> 08:22:44,440
And so what we would say is it's a val,

11467
08:22:44,440 --> 08:22:47,750
it's a greeter and we do colon
and then we need to provide

11468
08:22:47,750 --> 08:22:49,120
the input types.

11469
08:22:49,120 --> 08:22:51,504
So remember, let's look
at our example again,

11470
08:22:51,504 --> 08:22:55,130
we have greeter and inside
of the greeter function,

11471
08:22:56,211 --> 08:22:57,660
we wanna be able to parse in the word Don.

11472
08:22:58,730 --> 08:22:59,563
And so here, what we need to do is say,

11473
08:22:59,563 --> 08:23:01,510
hey, we need to parse in an input type.

11474
08:23:01,510 --> 08:23:03,400
That input type is gonna be a string.

11475
08:23:04,370 --> 08:23:07,490
And then what do we expect the
return type of greeter to be,

11476
08:23:07,490 --> 08:23:09,690
remember what we wanted
it to be Donn Felker

11477
08:23:10,616 --> 08:23:11,449
is what we want it to come out of it.

11478
08:23:11,449 --> 08:23:13,590
So we expect a return type to be a string.

11479
08:23:14,700 --> 08:23:17,460
Now we need to start defining
what our lambda expression

11480
08:23:17,460 --> 08:23:19,650
looks like, a lambda function.

11481
08:23:19,650 --> 08:23:22,180
And so in here, we actually
are gonna have the parameters.

11482
08:23:22,180 --> 08:23:24,880
So our first parameter here,
which is parsing is Donn.

11483
08:23:25,938 --> 08:23:26,771
That's a string.

11484
08:23:26,771 --> 08:23:28,456
Let's go ahead and give it a
name so we can work with it.

11485
08:23:28,456 --> 08:23:29,300
So let's just call it name.

11486
08:23:29,300 --> 08:23:30,750
And of course we know
it's gonna be a string.

11487
08:23:30,750 --> 08:23:32,690
So again, we have to
provide it right here.

11488
08:23:32,690 --> 08:23:36,150
That's the one of the arguments
and provide its input type.

11489
08:23:36,150 --> 08:23:38,170
And now we actually provide the code body.

11490
08:23:38,170 --> 08:23:40,890
And so now this is the actual body of code

11491
08:23:40,890 --> 08:23:41,960
in which we can do some stuff.

11492
08:23:41,960 --> 08:23:44,040
So here, what we can say is, hello

11493
08:23:44,966 --> 08:23:47,910
and then we can use string
interpolation and we'll say name.

11494
08:23:47,910 --> 08:23:51,940
And what ends up happening
is the last value

11495
08:23:51,940 --> 08:23:54,030
that's inside of this lambda expression

11496
08:23:54,030 --> 08:23:56,430
of this block of code is the return type.

11497
08:23:56,430 --> 08:23:58,730
So whatever this type is, is
going to be the return type.

11498
08:23:58,730 --> 08:24:00,570
So if this was multiple lines,

11499
08:24:00,570 --> 08:24:03,170
which it could be what we can
put these on different lines

11500
08:24:03,170 --> 08:24:05,100
and we can have multiple lines,

11501
08:24:05,100 --> 08:24:06,720
whatever is the last one here I could say,

11502
08:24:06,720 --> 08:24:10,200
val foo equals zero, it
doesn't really do anything.

11503
08:24:10,200 --> 08:24:13,010
And then we get this nice
little lambda notation here.

11504
08:24:13,010 --> 08:24:16,320
It says, hey, this is the
return value of our lambda.

11505
08:24:16,320 --> 08:24:18,260
So whatever this type is
gonna be the return value.

11506
08:24:18,260 --> 08:24:19,290
So it's a string.

11507
08:24:19,290 --> 08:24:21,930
So if I said, hey, I want
the length of the string,

11508
08:24:21,930 --> 08:24:24,500
we're gonna get a compiler
error because it's gonna say

11509
08:24:24,500 --> 08:24:26,260
we are requiring a string.

11510
08:24:26,260 --> 08:24:28,540
Again, this is the return
type of the lambda,

11511
08:24:28,540 --> 08:24:30,260
but you're actually giving us an integer

11512
08:24:30,260 --> 08:24:32,160
because this is the last line on here.

11513
08:24:33,029 --> 08:24:35,787
We're not seeing return
anywhere, but by default,

11514
08:24:35,787 --> 08:24:37,670
the last value is the value returned.

11515
08:24:37,670 --> 08:24:40,160
So since we can single line
this, we'll do that now,

11516
08:24:40,160 --> 08:24:41,530
it's pretty easy.

11517
08:24:41,530 --> 08:24:43,430
And we'll get everything back on one line.

11518
08:24:43,430 --> 08:24:44,850
And then what we can do is we can go ahead

11519
08:24:44,850 --> 08:24:48,260
and execute greeter and we'll
go ahead and parse name Donn.

11520
08:24:48,260 --> 08:24:50,280
And so it looks like a regular function.

11521
08:24:50,280 --> 08:24:53,140
And we can see here when we did that,

11522
08:24:53,140 --> 08:24:55,280
we created the new greeter here.

11523
08:24:56,320 --> 08:25:01,220
We could see that it's
going to take in a string.

11524
08:25:01,220 --> 08:25:02,680
Let's go ahead and run it.

11525
08:25:02,680 --> 08:25:04,960
And then what we're gonna
see is that nothing happens

11526
08:25:04,960 --> 08:25:06,080
down here in the output window.

11527
08:25:06,080 --> 08:25:09,530
We're expecting something to
show up here, but nothing did.

11528
08:25:09,530 --> 08:25:12,720
And the reason why is
because greeter is a function

11529
08:25:12,720 --> 08:25:14,400
that takes a string and return to string,

11530
08:25:14,400 --> 08:25:15,430
it doesn't do anything with it.

11531
08:25:15,430 --> 08:25:17,180
So we actually have to
actually do something with it.

11532
08:25:17,180 --> 08:25:19,610
So let's go and print that return value,

11533
08:25:19,610 --> 08:25:23,330
which we could just do this
too just so you're aware.

11534
08:25:23,330 --> 08:25:28,330
We could actually say greeting
equals greeter like that.

11535
08:25:29,409 --> 08:25:31,020
And then we could say print line greeting.

11536
08:25:32,545 --> 08:25:33,500
And then when we run this,

11537
08:25:33,500 --> 08:25:35,180
what we're gonna see is the output finally

11538
08:25:35,180 --> 08:25:37,130
at that function since say, hello Donn.

11539
08:25:38,357 --> 08:25:39,701
So again, to kind of cover this here,

11540
08:25:39,701 --> 08:25:42,820
we have the name of the lambda,
which is coming right here.

11541
08:25:42,820 --> 08:25:45,970
The name of the lambda, we'll
do a little simple line here.

11542
08:25:45,970 --> 08:25:49,540
So it's the name of the lambda
then we have the input type.

11543
08:25:49,540 --> 08:25:52,380
Then we have the return
type and then we're having

11544
08:25:52,380 --> 08:25:54,830
the arguments and their
corresponding input,

11545
08:25:54,830 --> 08:25:56,930
the corresponding type was a string.

11546
08:25:56,930 --> 08:26:00,810
And then this little section
over here is the code body,

11547
08:26:00,810 --> 08:26:03,690
which comes right here,
that's the code body.

11548
08:26:04,580 --> 08:26:07,040
So that's how all that's
mapping right here.

11549
08:26:07,040 --> 08:26:09,040
So now let's take this a
little bit further though.

11550
08:26:09,040 --> 08:26:13,980
Let's say for some reason
we wanted to be able to say,

11551
08:26:13,980 --> 08:26:15,350
like we said, we have Donn Felker here,

11552
08:26:15,350 --> 08:26:16,650
but instead of saying, hello, Donn.

11553
08:26:16,650 --> 08:26:18,500
So we got that wrong.

11554
08:26:18,500 --> 08:26:20,390
So there was a bug in our code.

11555
08:26:20,390 --> 08:26:22,030
How are we gonna fix this?.

11556
08:26:22,030 --> 08:26:24,280
This actually should
say, hello, Donn Felker.

11557
08:26:25,860 --> 08:26:26,900
Okay, well, that's easy enough.

11558
08:26:26,900 --> 08:26:29,842
We could just say hello, you know,

11559
08:26:29,842 --> 08:26:30,680
we just put Donn Felker in
there and that would work.

11560
08:26:30,680 --> 08:26:33,140
But what if we wanted to bill
accept two different names

11561
08:26:33,140 --> 08:26:37,070
because in our database,
everything is separated out.

11562
08:26:37,070 --> 08:26:39,864
So we need to have this
greeter and it's built

11563
08:26:39,864 --> 08:26:41,650
to two values.

11564
08:26:41,650 --> 08:26:44,010
So again, we need to come
into our expression and say,

11565
08:26:44,010 --> 08:26:46,860
all right, it's gonna take
an input type of string

11566
08:26:46,860 --> 08:26:48,360
and another input type of string.

11567
08:26:48,360 --> 08:26:49,450
So it's gonna have two.

11568
08:26:49,450 --> 08:26:51,900
Think of this, like the when
you write a regular function

11569
08:26:51,900 --> 08:26:54,360
like this or a function, my function.

11570
08:26:55,310 --> 08:26:57,770
And then inside of this
function, you have some stuff

11571
08:26:57,770 --> 08:27:01,650
and it's gonna be name,
string foo whatever it is,

11572
08:27:01,650 --> 08:27:04,140
last name, string.

11573
08:27:04,140 --> 08:27:07,160
Well, notice how this, the
way I like to think about it

11574
08:27:07,160 --> 08:27:08,760
is these parentheses right here.

11575
08:27:10,735 --> 08:27:12,230
it almost like maps
directly to that print.

11576
08:27:12,230 --> 08:27:13,500
So you kind of map there that prints,

11577
08:27:13,500 --> 08:27:14,560
they maps there and basically says,

11578
08:27:14,560 --> 08:27:18,460
hey, look, there's a string
here and there's a string here.

11579
08:27:18,460 --> 08:27:21,170
And that's how I of visualize
what these parentheses

11580
08:27:21,170 --> 08:27:22,180
up here are.

11581
08:27:22,180 --> 08:27:25,005
So this is gonna take
in some type of string

11582
08:27:25,005 --> 08:27:25,838
is one parameter.

11583
08:27:25,838 --> 08:27:28,361
The next type of in that next
parameter is gonna be string.

11584
08:27:28,361 --> 08:27:32,520
And the whole lambda expression
is still just gonna return

11585
08:27:32,520 --> 08:27:34,026
a string.

11586
08:27:34,026 --> 08:27:35,621
Now we get a problem over here.

11587
08:27:35,621 --> 08:27:36,490
It says, hey, we're
expecting two parameters

11588
08:27:36,490 --> 08:27:37,430
of type string and string.

11589
08:27:37,430 --> 08:27:40,710
Remember we were taking
a two now, but over here,

11590
08:27:41,971 --> 08:27:42,804
this is the list of arguments.

11591
08:27:42,804 --> 08:27:45,234
Remember, this is where the
list of arguments map in.

11592
08:27:45,234 --> 08:27:46,067
And if there's more than one,

11593
08:27:46,067 --> 08:27:47,120
then we need to put a comma here,

11594
08:27:47,120 --> 08:27:50,950
just like we would traditionally
in a regular function.

11595
08:27:50,950 --> 08:27:52,560
So I'm gonna rename this as first name,

11596
08:27:52,560 --> 08:27:54,881
'cause I can name the same thing I want.

11597
08:27:54,881 --> 08:27:57,360
And then I'm gonna say a last name string.

11598
08:27:57,360 --> 08:28:00,594
And now I'm starting to run
out of a little bit room here

11599
08:28:00,594 --> 08:28:01,640
so I could shrink this down a little bit.

11600
08:28:02,980 --> 08:28:05,090
But what I have over here,
I need to change this

11601
08:28:05,090 --> 08:28:09,370
to first name and then last name.

11602
08:28:10,832 --> 08:28:11,665
And I'll do string interpolation again.

11603
08:28:13,150 --> 08:28:16,680
And now we have a lambda
expression that's gonna take

11604
08:28:16,680 --> 08:28:17,992
in to values.

11605
08:28:17,992 --> 08:28:19,648
So you see right here, it
says, hey, we're waiting

11606
08:28:19,648 --> 08:28:23,110
for the second value P two,
which can be a second parameter.

11607
08:28:23,110 --> 08:28:25,540
So I'll take a Donn Felker, there we go.

11608
08:28:27,659 --> 08:28:28,765
And I'm gonna go ahead and run this again

11609
08:28:28,765 --> 08:28:29,598
and what we're gonna
and what we're gonna see

11610
08:28:29,598 --> 08:28:30,880
on the greeting now is
it Donn Felker's returned

11611
08:28:30,880 --> 08:28:32,970
because we're parsing in a string here,

11612
08:28:32,970 --> 08:28:34,590
Donn and on our string for Felker.

11613
08:28:34,590 --> 08:28:37,080
These basically, if you take
a look at how this maps,

11614
08:28:37,080 --> 08:28:39,260
this one is mapping to this one,

11615
08:28:39,260 --> 08:28:41,560
and this one is mapping to this one.

11616
08:28:41,560 --> 08:28:43,240
That's how they're mapping right there.

11617
08:28:44,444 --> 08:28:46,866
And we can see that the
first strings we're calling

11618
08:28:46,866 --> 08:28:47,699
that one first name, the second string,

11619
08:28:47,699 --> 08:28:48,830
we're calling that last name.

11620
08:28:48,830 --> 08:28:51,050
And then at that point
was since we're inside

11621
08:28:51,050 --> 08:28:53,540
of this lambda expression, we
have access to those variables

11622
08:28:53,540 --> 08:28:55,680
and we do whatever we want with them.

11623
08:28:55,680 --> 08:28:57,920
Now, if for whatever reason
we wanted to get kind of do

11624
08:28:57,920 --> 08:29:01,510
some hokey pokiness stuff,
some hokey stuff in here,

11625
08:29:01,510 --> 08:29:03,450
we could, we could actually
do some different things.

11626
08:29:03,450 --> 08:29:08,450
So let's go a val modified first F name.

11627
08:29:09,350 --> 08:29:11,677
Actually first name is spelled out.

11628
08:29:11,677 --> 08:29:14,710
And what we could just say
his first name.two upper case

11629
08:29:14,710 --> 08:29:16,445
for whatever reason.

11630
08:29:16,445 --> 08:29:20,690
And I'm gonna say val modified last name.

11631
08:29:20,690 --> 08:29:24,150
We can say, last name,
not owner exception.

11632
08:29:26,190 --> 08:29:31,190
Last name, last name that two
lowercase for whatever reason.

11633
08:29:32,240 --> 08:29:33,820
And then we can go ahead and replace this

11634
08:29:33,820 --> 08:29:37,580
with the two modified
ones, modified first name,

11635
08:29:37,580 --> 08:29:38,850
modified last name.

11636
08:29:42,037 --> 08:29:44,289
And now if we run this,
now, what we're gonna see

11637
08:29:44,289 --> 08:29:46,750
is that we have a lambda
expression with multiple lines.

11638
08:29:46,750 --> 08:29:47,870
Hello, Donn Felker.

11639
08:29:47,870 --> 08:29:50,670
So we've capitalized and
done different things here.

11640
08:29:50,670 --> 08:29:51,503
Okay, that's cool.

11641
08:29:51,503 --> 08:29:53,640
So we see that the,
again, the last line here

11642
08:29:53,640 --> 08:29:56,300
is the one that's returning the type here

11643
08:29:56,300 --> 08:29:58,650
and that's the type that's
going to be basically

11644
08:29:58,650 --> 08:30:00,660
this lambda is saying, all right, look,

11645
08:30:00,660 --> 08:30:03,330
we have a return type of
string and that's mapping

11646
08:30:03,330 --> 08:30:04,490
to right here.

11647
08:30:04,490 --> 08:30:08,650
So string, which is right
here is mapping to this

11648
08:30:08,650 --> 08:30:10,430
and the last line of
the lambda expression,

11649
08:30:10,430 --> 08:30:13,340
whatever its type is, it
needs to match this up here.

11650
08:30:13,340 --> 08:30:14,840
So it's go and get rid of that.

11651
08:30:16,020 --> 08:30:19,980
So let's just say for whatever
reason we wanted to say

11652
08:30:19,980 --> 08:30:22,810
greeter needs to return an integer value

11653
08:30:22,810 --> 08:30:26,257
and it could be the number of characters

11654
08:30:26,257 --> 08:30:27,195
inside of this greeting.

11655
08:30:27,195 --> 08:30:28,100
I don't know, for whatever reason.

11656
08:30:28,100 --> 08:30:29,980
We've changed this
integer, which means now

11657
08:30:29,980 --> 08:30:34,470
that this lambda expression
needs to return an integer,

11658
08:30:34,470 --> 08:30:36,840
but down here, the last line
is what's going to be returned

11659
08:30:36,840 --> 08:30:39,300
in rest last line is returning a string.

11660
08:30:39,300 --> 08:30:40,340
So this is not gonna work.

11661
08:30:40,340 --> 08:30:43,120
So what we can do is we
can just go over here

11662
08:30:43,120 --> 08:30:46,520
and may just return the
length of this name.

11663
08:30:46,520 --> 08:30:48,560
If we run this, now
what's gonna be returned.

11664
08:30:48,560 --> 08:30:50,790
It's still gonna take
in a first and last name

11665
08:30:50,790 --> 08:30:54,080
and it's gonna concatenate hello on there,

11666
08:30:54,080 --> 08:30:55,020
but then we're gonna grab the link

11667
08:30:55,020 --> 08:30:56,070
and we're gonna print the link.

11668
08:30:56,070 --> 08:30:58,940
That's what greeter's gonna
do at this point in time.

11669
08:30:58,940 --> 08:30:59,810
Okay, that sounds cool,

11670
08:30:59,810 --> 08:31:01,090
but maybe that's not what we really want.

11671
08:31:01,090 --> 08:31:02,740
So let's take this back to string.

11672
08:31:04,460 --> 08:31:07,610
Now let's assume that we
really like what it does,

11673
08:31:07,610 --> 08:31:10,524
but we just want greeter
to actually just to display

11674
08:31:10,524 --> 08:31:12,590
the greeting, so we don't
wanna have to do this.

11675
08:31:12,590 --> 08:31:13,670
We don't wanna have to print this.

11676
08:31:13,670 --> 08:31:15,710
We just want, as soon as the call greeter

11677
08:31:15,710 --> 08:31:19,130
to automatically just print
line hello, Donn Felker.

11678
08:31:19,130 --> 08:31:19,963
So how can we do that?

11679
08:31:19,963 --> 08:31:23,530
Well, this return value is what
the is going to be returned

11680
08:31:23,530 --> 08:31:24,900
from the lambda expression.

11681
08:31:24,900 --> 08:31:27,000
So we can change it to unit.

11682
08:31:27,000 --> 08:31:29,820
Unit is basically like
void in Java, which means,

11683
08:31:29,820 --> 08:31:31,340
hey, we're not gonna return anything,

11684
08:31:31,340 --> 08:31:33,310
we're just gonna do something,

11685
08:31:33,310 --> 08:31:34,750
but we're not gonna return any value.

11686
08:31:34,750 --> 08:31:37,250
So here we're just gonna
go ahead and return unit,

11687
08:31:38,400 --> 08:31:39,233
which has nothing.

11688
08:31:39,233 --> 08:31:41,340
And then what we can do here
is we can say print line,

11689
08:31:42,530 --> 08:31:46,510
inside of here and we can just do that.

11690
08:31:46,510 --> 08:31:49,080
And then what's gonna
happen now when we run this,

11691
08:31:49,080 --> 08:31:51,800
what we're gonna see is we're
gonna call the first name,

11692
08:31:51,800 --> 08:31:53,920
the last name that'd be parsed in

11693
08:31:53,920 --> 08:31:54,840
and then we're just gonna print line.

11694
08:31:54,840 --> 08:31:57,340
There it goes, hello, Donn Felker.

11695
08:31:57,340 --> 08:31:58,780
So we can do all different kinds of stuff.

11696
08:31:58,780 --> 08:31:59,830
And there's gonna be multiple lines,

11697
08:31:59,830 --> 08:32:01,300
could be hundreds of lines of, you know.

11698
08:32:01,300 --> 08:32:03,650
Of course I don't recommend
that if you wanna make

11699
08:32:03,650 --> 08:32:05,400
your code easily read and so forth.

11700
08:32:06,470 --> 08:32:08,730
Because Kotlin has type inference,

11701
08:32:08,730 --> 08:32:10,370
you can actually clean
this up quite a bit.

11702
08:32:10,370 --> 08:32:12,310
We don't need a lot of this stuff in here.

11703
08:32:13,247 --> 08:32:15,650
So what we can tell Kotlin is
because Kotlin can look inside

11704
08:32:15,650 --> 08:32:17,543
of this lambda expression and say,

11705
08:32:17,543 --> 08:32:18,380
well, we know we have one parameter,

11706
08:32:18,380 --> 08:32:20,080
we know we have another parameter.

11707
08:32:21,196 --> 08:32:22,029
Okay, so this first parameter is a string.

11708
08:32:22,029 --> 08:32:23,620
We know the second parameter is a string.

11709
08:32:23,620 --> 08:32:26,670
Okay, we can do that, Kotlin's
figuring that out for us.

11710
08:32:26,670 --> 08:32:28,500
And then is looking at
this last line down here

11711
08:32:28,500 --> 08:32:31,150
and Kotlin saying, well,
this lambda expression

11712
08:32:31,150 --> 08:32:32,430
is not returning anything.

11713
08:32:32,430 --> 08:32:36,080
So it's actually gonna
be unit so it can infer

11714
08:32:36,080 --> 08:32:39,929
the return type and it can
infer the parameter list.

11715
08:32:39,929 --> 08:32:41,590
So we can actually do
due to type inferences,

11716
08:32:41,590 --> 08:32:44,730
just go ahead and get rid of that.

11717
08:32:44,730 --> 08:32:49,730
So now we have a very succinct
or much more sustained

11718
08:32:51,220 --> 08:32:52,053
lambda expression.

11719
08:32:52,053 --> 08:32:55,050
So if we wanna do the simple
one, so we wanna do it

11720
08:32:55,050 --> 08:32:57,010
just as simple one,
greet, we could've done

11721
08:32:57,010 --> 08:32:58,010
something like this.

11722
08:32:58,983 --> 08:33:03,710
We could have said name,
string and then it gets to this

11723
08:33:03,710 --> 08:33:07,650
print line, hello name.

11724
08:33:08,900 --> 08:33:11,260
And there, we have our
very simple little greet.

11725
08:33:11,260 --> 08:33:12,800
So of course we have our greeter that does

11726
08:33:12,800 --> 08:33:16,290
a bunch of different stuff,
modify some variables,

11727
08:33:16,290 --> 08:33:18,300
which we'll move up
here just so is obvious.

11728
08:33:18,300 --> 08:33:21,250
And then we have the very simple
version right here, greet.

11729
08:33:24,080 --> 08:33:27,910
If we print these, of course,
we got the spelling wrong.

11730
08:33:27,910 --> 08:33:29,630
And if we print these,
what we're gonna see here

11731
08:33:29,630 --> 08:33:33,830
is we have both of these
printing out values.

11732
08:33:33,830 --> 08:33:37,130
Now lambda expressions are
not limited to one or two

11733
08:33:37,130 --> 08:33:39,170
or three different types.

11734
08:33:40,065 --> 08:33:40,898
You can parse in many different types

11735
08:33:40,898 --> 08:33:42,130
into your lambda expressions.

11736
08:33:43,110 --> 08:33:44,510
If for some reason, when you're writing

11737
08:33:44,510 --> 08:33:46,900
your lambda expressions,
and for some reason Kotlin

11738
08:33:46,900 --> 08:33:49,610
cannot do perform type inference,

11739
08:33:49,610 --> 08:33:52,360
you will have to provide these hints.

11740
08:33:52,360 --> 08:33:54,210
And sometimes you'll run
into weird situations

11741
08:33:54,210 --> 08:33:56,910
where based upon something
that you're doing,

11742
08:33:56,910 --> 08:33:59,850
you're going to have to tell
Kotlin, hey, by the way,

11743
08:33:59,850 --> 08:34:02,923
here's how we're gonna go
ahead and do all this stuff.

11744
08:34:02,923 --> 08:34:05,217
It's gonna be unit or
whatever and so forth.

11745
08:34:07,730 --> 08:34:09,460
So you'll have to provide all information.

11746
08:34:09,460 --> 08:34:11,490
And this is the blueprint up here.

11747
08:34:11,490 --> 08:34:13,310
This is the blueprint that
you just need to remember,

11748
08:34:13,310 --> 08:34:15,610
that you're gonna have lambda name,

11749
08:34:15,610 --> 08:34:16,640
then you're provided input type,

11750
08:34:16,640 --> 08:34:20,606
the return type equals
whatever this lambda is.

11751
08:34:20,606 --> 08:34:21,439
And it's gonna have your arguments,

11752
08:34:21,439 --> 08:34:23,090
which is gonna have one to many of them.

11753
08:34:23,090 --> 08:34:24,840
You have the body of it, et cetera.

11754
08:34:26,400 --> 08:34:29,497
And that's understanding
lambda expressions.

11755
08:34:29,497 --> 08:34:31,630
Using lambda expressions in your code

11756
08:34:31,630 --> 08:34:35,011
can be very beneficial,
especially if you decide

11757
08:34:35,011 --> 08:34:38,000
to take lambda expressions
as a function parameter.

11758
08:34:38,000 --> 08:34:40,150
So it's assumed that you have a function

11759
08:34:40,150 --> 08:34:42,350
and you want to make something repeat,

11760
08:34:43,510 --> 08:34:45,210
actually it's call it line logger.

11761
08:34:46,336 --> 08:34:48,600
And you want something
to kind of log various

11762
08:34:48,600 --> 08:34:50,550
different lines over and over and over.

11763
08:34:51,460 --> 08:34:55,030
And so what you could do is
you could take a message.

11764
08:34:56,010 --> 08:34:57,710
There is a string.

11765
08:34:57,710 --> 08:34:59,480
And then perhaps if you wanted some logs

11766
08:34:59,480 --> 08:35:02,950
to very basically kind of look like this,

11767
08:35:02,950 --> 08:35:07,540
you want a bunch of these kind
of lines separating your logs

11768
08:35:07,540 --> 08:35:10,473
just for maybe 'cause you
have really chatty logs,

11769
08:35:10,473 --> 08:35:11,306
you could do something like this.

11770
08:35:11,306 --> 08:35:15,560
You could say repeat five
times and then you parse it

11771
08:35:15,560 --> 08:35:18,010
on little lambda expression.

11772
08:35:18,010 --> 08:35:20,090
It's a print line and then let's go ahead

11773
08:35:21,002 --> 08:35:24,530
and put in one, two, three,
four, four, five, six,

11774
08:35:24,530 --> 08:35:26,056
seven, eight of these lines.

11775
08:35:26,056 --> 08:35:28,210
And let's do that twice
and then what we'll do

11776
08:35:28,210 --> 08:35:31,360
is do print line our message.

11777
08:35:31,360 --> 08:35:32,710
Now this works pretty well.

11778
08:35:33,710 --> 08:35:36,760
So anytime we wanna use
this, we can say line logger

11779
08:35:36,760 --> 08:35:38,940
and to say hello there.

11780
08:35:39,867 --> 08:35:41,040
And then if we run this
down in our output window,

11781
08:35:41,040 --> 08:35:43,620
what we're gonna see down
here is we're gonna see

11782
08:35:43,620 --> 08:35:45,500
that hello there is printed out.

11783
08:35:46,698 --> 08:35:49,400
Maybe this is useful to kind
of help break up your logs

11784
08:35:49,400 --> 08:35:50,390
for a visual aspect or whatever.

11785
08:35:51,390 --> 08:35:54,090
But sometimes that can
be not what we wanna do

11786
08:35:54,090 --> 08:35:56,980
and there's a way we can
actually make this much more

11787
08:35:56,980 --> 08:36:01,460
in tune with being able to
do anything we really want

11788
08:36:01,460 --> 08:36:02,922
inside of here.

11789
08:36:02,922 --> 08:36:05,197
What if we wanna provide not one message,

11790
08:36:05,197 --> 08:36:06,030
but we wanna provide two messages.

11791
08:36:06,030 --> 08:36:09,650
So let's go message two, two string.

11792
08:36:10,490 --> 08:36:11,323
Now we're gonna come in here.

11793
08:36:11,323 --> 08:36:14,490
we're gonna say print line message two.

11794
08:36:16,380 --> 08:36:19,050
We are in this again, we get
our message one, message two.

11795
08:36:19,990 --> 08:36:21,860
It looks like we're missing
message two up here.

11796
08:36:21,860 --> 08:36:25,270
Of course, we forgot to add
that to the parameter list.

11797
08:36:25,270 --> 08:36:27,880
Hello again and when
we run this this time,

11798
08:36:27,880 --> 08:36:28,810
we're gonna see hello again.

11799
08:36:28,810 --> 08:36:31,370
Now the problem is as
we continue to grow this

11800
08:36:31,370 --> 08:36:34,850
and our requirements increase,
what we're gonna run into

11801
08:36:34,850 --> 08:36:37,540
is a situation where we're
just becoming overloaded here.

11802
08:36:37,540 --> 08:36:40,440
And what we really wanna
do is be able to have a way

11803
08:36:41,511 --> 08:36:44,030
for us to print this kind
of this block at the top

11804
08:36:44,030 --> 08:36:45,260
and the block in the bottom,

11805
08:36:45,260 --> 08:36:47,220
and then whatever we want
right here in the middle.

11806
08:36:47,220 --> 08:36:50,280
And so yeah, we could
build our own strengths.

11807
08:36:50,280 --> 08:36:51,300
We'll just leave it at one string.

11808
08:36:51,300 --> 08:36:54,670
We could build our own string
up here and I could do this.

11809
08:36:54,670 --> 08:36:57,330
I can kind of maybe kind of
do this like a little weird.

11810
08:36:58,280 --> 08:37:00,520
I could do this thing up here
where I do like a new line

11811
08:37:00,520 --> 08:37:02,300
thing and I kind of got there,

11812
08:37:02,300 --> 08:37:03,800
but then it starts getting really hacky

11813
08:37:03,800 --> 08:37:06,190
as soon as I wanna get anything
else kinda done in there.

11814
08:37:06,190 --> 08:37:08,400
But there's a way we can solve
this with lambda expressions.

11815
08:37:08,400 --> 08:37:10,660
And so what we can do
is what we're gonna do

11816
08:37:10,660 --> 08:37:12,470
is I'm gonna call this block.

11817
08:37:12,470 --> 08:37:14,930
And this is again, this is
the name of the variable,

11818
08:37:14,930 --> 08:37:15,763
it's called block.

11819
08:37:15,763 --> 08:37:17,030
And then what type of it's gonna be,

11820
08:37:17,030 --> 08:37:18,570
it's gonna be a lambda expression.

11821
08:37:18,570 --> 08:37:20,530
It's not gonna have any parameters

11822
08:37:20,530 --> 08:37:22,930
and it's just gonna go return a unit.

11823
08:37:22,930 --> 08:37:24,240
So again, remember, let's go ahead

11824
08:37:24,240 --> 08:37:26,620
and take a brief review here.

11825
08:37:26,620 --> 08:37:30,700
We have the input type,
which is right here.

11826
08:37:30,700 --> 08:37:33,000
That's gonna be, there's
no nothing input type,

11827
08:37:33,000 --> 08:37:34,450
so it's no parameters.

11828
08:37:34,450 --> 08:37:37,154
And then the lambda has a return type.

11829
08:37:37,154 --> 08:37:38,870
And what does that return
type, the return type

11830
08:37:38,870 --> 08:37:40,410
is gonna be unit, so it's
not gonna do anything.

11831
08:37:40,410 --> 08:37:42,760
And again, the name of
it is just called block.

11832
08:37:43,805 --> 08:37:44,638
And the reason why we're
calling it block here

11833
08:37:44,638 --> 08:37:46,430
is because it can be a block of code.

11834
08:37:47,430 --> 08:37:48,750
And so this is a block and
so I can get rid of this.

11835
08:37:48,750 --> 08:37:50,960
Now, what I can do is
just invoke this block

11836
08:37:52,050 --> 08:37:53,250
since this is basically just a function.

11837
08:37:53,250 --> 08:37:54,850
I'm saying, hey, this is
a function I wanna do.

11838
08:37:54,850 --> 08:37:58,220
And so what I can do now is I
can get rid of this code here

11839
08:37:58,220 --> 08:38:00,220
and I can actually just do this.

11840
08:38:00,220 --> 08:38:02,760
Now, of course you wondering
where did the parentheses go?

11841
08:38:02,760 --> 08:38:04,750
So I could just do exactly this.

11842
08:38:04,750 --> 08:38:07,190
And then I need to put
my code block in there.

11843
08:38:07,190 --> 08:38:09,020
But what you're gonna see
here is this little squiggly

11844
08:38:09,020 --> 08:38:12,120
and say, hey, you can go ahead
and move the lambda argument

11845
08:38:12,120 --> 08:38:13,748
out of the parentheses.

11846
08:38:13,748 --> 08:38:16,320
It's just a convention that
is allowed inside of Kotlin.

11847
08:38:16,320 --> 08:38:17,760
So now I can just say
anything I want here.

11848
08:38:17,760 --> 08:38:22,630
I say print line message one.

11849
08:38:22,630 --> 08:38:25,890
I can say two, I can say three.

11850
08:38:25,890 --> 08:38:28,570
I could do something like
this, I could run this.

11851
08:38:30,148 --> 08:38:31,210
I could even put my own
loop inside of here.

11852
08:38:31,210 --> 08:38:36,210
I could say repeat five times
I could do my own lambda

11853
08:38:37,400 --> 08:38:39,450
express, you know, 'cause
that repeat thing takes

11854
08:38:39,450 --> 08:38:40,470
on its own land expression.

11855
08:38:40,470 --> 08:38:43,784
Repeat as part of the Kotlin
standard library, by the way.

11856
08:38:43,784 --> 08:38:45,810
And if we run that
again, what we'll see now

11857
08:38:45,810 --> 08:38:49,030
is we'll see message one,
two, three, four, five,

11858
08:38:49,030 --> 08:38:50,710
repeated right here in the middle,

11859
08:38:50,710 --> 08:38:55,710
all separated by our top and
our bottom parts of our line.

11860
08:38:57,380 --> 08:39:01,940
So what this has allowed
us to do is create

11861
08:39:01,940 --> 08:39:05,070
a much more extendable function.

11862
08:39:05,920 --> 08:39:08,590
So we now have a function
called line logger

11863
08:39:08,590 --> 08:39:10,520
that I can pars in whatever I want.

11864
08:39:10,520 --> 08:39:12,960
I can do 20 different logs and
hearing do 10 different logs.

11865
08:39:12,960 --> 08:39:15,750
And it'll help me be able
to find perhaps my logs

11866
08:39:15,750 --> 08:39:16,780
instead of a logger.

11867
08:39:16,780 --> 08:39:19,650
That's a very naive and simple example,

11868
08:39:19,650 --> 08:39:22,180
but it shows you the power
of basically delegating

11869
08:39:22,180 --> 08:39:24,360
the responsibility back to the caller.

11870
08:39:24,360 --> 08:39:26,590
So I'm yielding this call.

11871
08:39:26,590 --> 08:39:29,420
So right here, I'm gonna be
yielding whatever's happening

11872
08:39:29,420 --> 08:39:31,520
here to execute what's gonna happen here.

11873
08:39:31,520 --> 08:39:34,530
So what's, let's think
about this for a second.

11874
08:39:34,530 --> 08:39:36,790
First thing that happens
is we called line logger,

11875
08:39:36,790 --> 08:39:38,750
line lager said, hey, no problem, cool.

11876
08:39:39,704 --> 08:39:41,079
I have a block.

11877
08:39:41,079 --> 08:39:42,786
And then the first line
of code executes and says,

11878
08:39:42,786 --> 08:39:44,300
all right, well, I'm gonna
print this thing five times.

11879
08:39:44,300 --> 08:39:45,870
And then now after that,

11880
08:39:45,870 --> 08:39:49,200
what I have now is I have
this little block of code.

11881
08:39:49,200 --> 08:39:52,500
And this little block of code
right here, I need to run.

11882
08:39:52,500 --> 08:39:55,610
Then that little block of
code is this stuff right here.

11883
08:39:55,610 --> 08:39:58,080
It's whatever's in between
these two brackets up here

11884
08:39:59,550 --> 08:40:00,383
and that's gonna run that block of code.

11885
08:40:00,383 --> 08:40:03,134
And then after that's
done, it's gonna go ahead

11886
08:40:03,134 --> 08:40:06,020
and return back down and it's
gonna run the next three,

11887
08:40:06,020 --> 08:40:09,140
next five iterations of this repeat loop.

11888
08:40:09,140 --> 08:40:12,200
So it's basically going
inside of here, running this,

11889
08:40:12,200 --> 08:40:13,810
hopping back out, doing something out here

11890
08:40:13,810 --> 08:40:16,520
and then hopping back in
and finishing up down here.

11891
08:40:16,520 --> 08:40:19,210
And so it's a very simple
way that you can actually

11892
08:40:19,210 --> 08:40:22,330
implement a lambda expression
inside of a function.

11893
08:40:23,420 --> 08:40:26,990
Now let's also create maybe
another lambda expression here.

11894
08:40:26,990 --> 08:40:28,910
Let's call this one repeater.

11895
08:40:28,910 --> 08:40:31,920
So repeater we'll wanna say,

11896
08:40:31,920 --> 08:40:33,790
maybe you wanna do
something over and over.

11897
08:40:33,790 --> 08:40:37,400
Kind of like very similar
to like a loop would have.

11898
08:40:37,400 --> 08:40:38,820
So let's do the same thing.

11899
08:40:38,820 --> 08:40:41,200
Let's create the same signature here,

11900
08:40:41,200 --> 08:40:45,430
but this time I'm gonna
say repeat five times.

11901
08:40:45,430 --> 08:40:47,240
And then what we're gonna
do is we're gonna call

11902
08:40:47,240 --> 08:40:48,910
the block five times over.

11903
08:40:50,420 --> 08:40:53,120
So then what we could do is we
could do something like this

11904
08:40:53,120 --> 08:40:55,370
and we're gonna call, I'm
just gonna comment this out

11905
08:40:55,370 --> 08:40:57,730
for now 'cause we don't wanna
see that inside of the output.

11906
08:40:57,730 --> 08:41:01,670
So we'll say repeater, and
then it's gonna take it out

11907
08:41:01,670 --> 08:41:02,503
in a block.

11908
08:41:02,503 --> 08:41:05,757
And so inside of here, I can
just say, print ln, hello.

11909
08:41:08,605 --> 08:41:10,570
And what's gonna happen
is I'm gonna run this,

11910
08:41:10,570 --> 08:41:12,130
repeater is gonna run
and it's gonna print it

11911
08:41:12,130 --> 08:41:13,801
five times in a row.

11912
08:41:13,801 --> 08:41:16,403
But now of course, we're
trying to make our application

11913
08:41:16,403 --> 08:41:17,420
a lot more user-friendly.

11914
08:41:17,420 --> 08:41:19,340
So we wanna be able to
provide how many times

11915
08:41:19,340 --> 08:41:21,964
we think these things should repeat.

11916
08:41:21,964 --> 08:41:22,797
And so what we can do is
we can go ahead and say,

11917
08:41:22,797 --> 08:41:24,750
all right, one or five in here.

11918
08:41:24,750 --> 08:41:27,970
And so I'm saying number
five, but there's no way

11919
08:41:27,970 --> 08:41:29,140
we can tell repeater
to do that, but we can.

11920
08:41:29,140 --> 08:41:31,730
So we can go down here
and say, how many times

11921
08:41:31,730 --> 08:41:33,850
do we want you to repeat,
and that's an integer value.

11922
08:41:33,850 --> 08:41:36,270
And I can take the energy
value and just drop it

11923
08:41:36,270 --> 08:41:37,650
right into this repeat function.

11924
08:41:37,650 --> 08:41:39,890
Again, we're kind of duplicating
what's happening here,

11925
08:41:39,890 --> 08:41:43,720
but I'm basically telling,
hey, I want our little repeater

11926
08:41:43,720 --> 08:41:47,670
to run five times and then
what's gonna end up happening

11927
08:41:47,670 --> 08:41:49,070
is it's gonna run five times.

11928
08:41:49,070 --> 08:41:50,340
Now for whatever reason later on,

11929
08:41:50,340 --> 08:41:53,240
I decided I want this
repeater to run three times

11930
08:41:53,240 --> 08:41:56,150
or 13 times, I'll run this here,

11931
08:41:56,150 --> 08:41:59,290
our little repeater
thing will run 13 times.

11932
08:41:59,290 --> 08:42:03,490
Now, as I start thinking about
it, eventually I realized

11933
08:42:03,490 --> 08:42:06,140
it would be really
great if there was a way

11934
08:42:08,185 --> 08:42:10,600
that I can get to what iteration I was on,

11935
08:42:10,600 --> 08:42:15,600
because I realized that when
I am gonna repeat five times,

11936
08:42:17,150 --> 08:42:18,650
I wanna say hello three times.

11937
08:42:19,610 --> 08:42:21,360
So hello, three times.

11938
08:42:22,300 --> 08:42:26,010
And then I wanna say goodbye two times

11939
08:42:26,010 --> 08:42:27,010
for whatever reason.

11940
08:42:28,440 --> 08:42:30,700
So how would I do that,
so I wanna say print line,

11941
08:42:32,930 --> 08:42:34,510
I'll say goodbye.

11942
08:42:34,510 --> 08:42:36,180
But how am I gonna say that on the first

11943
08:42:36,180 --> 08:42:37,950
couple of iterations, I
don't know what that is.

11944
08:42:37,950 --> 08:42:41,500
So what I need to do is expose
that value to the block.

11945
08:42:41,500 --> 08:42:43,080
So basically I needed to tell the block,

11946
08:42:43,080 --> 08:42:45,540
hey, you need to be
able to get some value.

11947
08:42:45,540 --> 08:42:49,830
Now, remember this value, this
right here is the input type.

11948
08:42:49,830 --> 08:42:50,900
There's no input types here,

11949
08:42:50,900 --> 08:42:53,550
we didn't provide any parameters.

11950
08:42:53,550 --> 08:42:55,870
It's still gonna return a unit,

11951
08:42:55,870 --> 08:42:57,160
so it's not gonna do anything.

11952
08:42:57,160 --> 08:42:59,410
But what I wanted to change
is to say, hey, you know what,

11953
08:42:59,410 --> 08:43:00,870
I want this block.

11954
08:43:00,870 --> 08:43:03,690
So again, this chunk of
code, I want it to be able

11955
08:43:03,690 --> 08:43:05,090
to accept a parameter and this parameter

11956
08:43:05,090 --> 08:43:06,560
is gonna be an integer value.

11957
08:43:06,560 --> 08:43:09,190
And now immediately, what
you'll notice right here,

11958
08:43:09,190 --> 08:43:10,710
we have a squiggly error saying,

11959
08:43:10,710 --> 08:43:12,785
hey, there's something wrong.

11960
08:43:12,785 --> 08:43:13,900
And what that means is
that we need to parse

11961
08:43:13,900 --> 08:43:15,180
a value in there.

11962
08:43:15,180 --> 08:43:18,200
Now, little did you know
that the repeat function

11963
08:43:18,200 --> 08:43:20,980
that is built into the standard library

11964
08:43:20,980 --> 08:43:22,100
actually it gives us an index,

11965
08:43:22,100 --> 08:43:23,750
we just were not using it before.

11966
08:43:25,068 --> 08:43:26,770
And so I'm just gonna
go ahead and use it now.

11967
08:43:26,770 --> 08:43:29,701
And so I'm gonna parse an
index and every time the repeat

11968
08:43:29,701 --> 08:43:30,760
function fires off, it's
gonna give us an index.

11969
08:43:30,760 --> 08:43:34,830
I'm gonna send that index
directly back to our block

11970
08:43:34,830 --> 08:43:36,190
and that's gonna get
called inside of here.

11971
08:43:36,190 --> 08:43:38,190
And so let's go ahead and use our index.

11972
08:43:39,630 --> 08:43:42,748
There's our index and now
we can do something with it.

11973
08:43:42,748 --> 08:43:43,790
So what we can do in here is we can say,

11974
08:43:43,790 --> 08:43:48,790
if index is less than
three, go ahead and do this.

11975
08:43:51,110 --> 08:43:53,360
And else we're gonna go
ahead and print this.

11976
08:43:54,280 --> 08:43:56,530
So now we run this, what
we're gonna see here

11977
08:43:57,870 --> 08:43:59,520
is hello, hello, hello, goodbye, goodbye.

11978
08:43:59,520 --> 08:44:02,555
Because what's happening is
the index is being print.

11979
08:44:02,555 --> 08:44:04,110
So it's go ahead and
print line on the index.

11980
08:44:05,060 --> 08:44:09,780
For each iteration of this
loop, we can see down here.

11981
08:44:12,090 --> 08:44:13,860
Each time, so remember
what we're calling repeat,

11982
08:44:13,860 --> 08:44:16,070
which is built into the Kotlin
center library just tells,

11983
08:44:16,070 --> 08:44:20,790
hey, repeat this little
function however many times

11984
08:44:20,790 --> 08:44:22,720
we tell at the time, we told it five.

11985
08:44:22,720 --> 08:44:25,250
And each time iterate is
gonna call this block.

11986
08:44:25,250 --> 08:44:27,510
And this block, all this block is,

11987
08:44:27,510 --> 08:44:30,330
is this chunk of code
here, this is the block.

11988
08:44:30,330 --> 08:44:31,740
And then what it's gonna do is gonna parse

11989
08:44:31,740 --> 08:44:33,680
its current index in here,
which is what we decided

11990
08:44:33,680 --> 08:44:34,680
to do here.

11991
08:44:34,680 --> 08:44:37,930
And now we can decide to
start iterating inside of here

11992
08:44:37,930 --> 08:44:40,250
and perhaps perform some logic.

11993
08:44:40,250 --> 08:44:42,280
And if it's less than three, of course,

11994
08:44:42,280 --> 08:44:44,050
we're just gonna print hello.

11995
08:44:44,050 --> 08:44:45,560
Otherwise we're gonna print and goodbye.

11996
08:44:45,560 --> 08:44:47,800
Now this can be done for
any number of things,

11997
08:44:47,800 --> 08:44:49,180
we could decide to use the index.

11998
08:44:49,180 --> 08:44:51,760
We decided not to use
the index or whatever.

11999
08:44:51,760 --> 08:44:53,500
And again, if we don't wanna
use it, we don't have to,

12000
08:44:53,500 --> 08:44:55,260
we can just kind of get rid of it.

12001
08:44:55,260 --> 08:44:57,640
Again we'd have to make sure
we're not using the variable,

12002
08:44:57,640 --> 08:44:58,473
but here we are.

12003
08:44:59,380 --> 08:45:01,950
So this is how you can go
ahead and parse a variable

12004
08:45:01,950 --> 08:45:06,950
into a lambda function and
basically receive that variable

12005
08:45:07,060 --> 08:45:09,140
back into the block itself.

12006
08:45:09,990 --> 08:45:12,300
So we've created a
function called repeater.

12007
08:45:12,300 --> 08:45:14,660
We're gonna tell it how many
times it needs to do something.

12008
08:45:14,660 --> 08:45:16,860
And then we're saying, hey,
every time you do something,

12009
08:45:16,860 --> 08:45:19,310
we want you to call a particular function,

12010
08:45:19,310 --> 08:45:20,920
this function we're gonna call it block.

12011
08:45:20,920 --> 08:45:22,480
It's gonna take in an integer,

12012
08:45:22,480 --> 08:45:24,040
I don't care what the integer is,

12013
08:45:24,040 --> 08:45:25,260
but it's gonna take an integer

12014
08:45:25,260 --> 08:45:27,040
and it's not gonna return anything.

12015
08:45:27,040 --> 08:45:28,620
And then inside of our function, we say,

12016
08:45:28,620 --> 08:45:32,089
hey, we're gonna use the
built-in function called repeat.

12017
08:45:32,089 --> 08:45:32,922
It's gonna repeat.

12018
08:45:32,922 --> 08:45:33,755
And then every time
it's gonna give an index

12019
08:45:33,755 --> 08:45:35,770
and we're gonna parse
that index into here.

12020
08:45:35,770 --> 08:45:37,660
Now I could parse any number I want here.

12021
08:45:37,660 --> 08:45:39,260
If I want it through the
whole time, I can just parse

12022
08:45:39,260 --> 08:45:40,640
number three, it doesn't matter.

12023
08:45:40,640 --> 08:45:41,870
It doesn't have to be the index.

12024
08:45:41,870 --> 08:45:44,750
I could be three times
1000, it doesn't matter.

12025
08:45:44,750 --> 08:45:47,880
All this block, all this
sick function signature

12026
08:45:47,880 --> 08:45:52,280
is saying is this block is
expecting its first parameter

12027
08:45:52,280 --> 08:45:55,340
to be an integer and it's
not going to return anything.

12028
08:45:55,340 --> 08:45:56,173
That's all it's saying.

12029
08:45:56,173 --> 08:46:01,100
So it doesn't matter if this
value right here is the index,

12030
08:46:01,100 --> 08:46:04,850
or if it's a random number,
that's up for you to decide.

12031
08:46:04,850 --> 08:46:08,710
Here, we're parsing in the
index because we wanna know

12032
08:46:08,710 --> 08:46:11,710
when we're using a repeater
function, what index we are.

12033
08:46:11,710 --> 08:46:14,050
And when we're repeating,
are we the fifth iteration,

12034
08:46:14,050 --> 08:46:15,700
et cetera, or the 20th iteration,

12035
08:46:16,863 --> 08:46:17,696
what are we doing at that point in time.

12036
08:46:17,696 --> 08:46:19,630
Okay, so now we have that repeater.

12037
08:46:19,630 --> 08:46:21,580
So let's go ahead and comment this out.

12038
08:46:22,660 --> 08:46:25,640
So let's assume we wanted
to have to do something

12039
08:46:25,640 --> 08:46:27,053
a little different.

12040
08:46:27,053 --> 08:46:29,146
So let's say we have,
what's called a function

12041
08:46:29,146 --> 08:46:29,979
called Derby announcer.

12042
08:46:31,430 --> 08:46:35,180
This Derby announcer
function is gonna take in

12043
08:46:35,180 --> 08:46:38,370
a lambda expression.

12044
08:46:38,370 --> 08:46:39,760
This lambda expression
will look like this.

12045
08:46:39,760 --> 08:46:42,490
There'll be a block of code,
it's gonna take in a string.

12046
08:46:42,490 --> 08:46:44,656
So this first parameter
is gonna be a string

12047
08:46:44,656 --> 08:46:46,830
and then it's actually
gonna return a string.

12048
08:46:46,830 --> 08:46:49,510
So this lambda expression
is gonna return a string

12049
08:46:50,830 --> 08:46:52,630
and this announcer is spelled wrong.

12050
08:46:55,436 --> 08:46:58,029
And so what we'll do here
is let me fill this out.

12051
08:46:58,029 --> 08:46:59,730
Okay, we're back soon
and have to see me tight.

12052
08:46:59,730 --> 08:47:01,910
So the Derby announcer
function does a few things.

12053
08:47:01,910 --> 08:47:04,830
It has a lambda expression, it's a block.

12054
08:47:04,830 --> 08:47:08,290
That block takes in a
string as a parameter,

12055
08:47:08,290 --> 08:47:09,600
and then it returns a string.

12056
08:47:09,600 --> 08:47:12,267
And then what we're gonna
do here is this gonna be

12057
08:47:12,267 --> 08:47:13,100
like a home run Derby announcer.

12058
08:47:13,100 --> 08:47:14,150
And these are different names of perhaps

12059
08:47:14,150 --> 08:47:15,320
some baseball players.

12060
08:47:15,320 --> 08:47:17,380
So you McGuire, can say,
go Honeycutt, Davis,

12061
08:47:17,380 --> 08:47:19,220
Dolly Weiss, et cetera.

12062
08:47:19,220 --> 08:47:21,330
And then what we're gonna do
is we're gonna randomly choose

12063
08:47:21,330 --> 08:47:23,250
a player's name and then to the screen,

12064
08:47:23,250 --> 08:47:24,860
we're gonna put the next player's name.

12065
08:47:24,860 --> 08:47:27,630
The next player is whatever
this random word is.

12066
08:47:27,630 --> 08:47:28,990
No it's gonna be, you
know, we can change this

12067
08:47:28,990 --> 08:47:29,840
to random player.

12068
08:47:32,219 --> 08:47:34,440
At that point, this will
print to the screen.

12069
08:47:34,440 --> 08:47:35,850
And then what we wanna
do is maybe we wanna have

12070
08:47:35,850 --> 08:47:37,970
some type of log that we
wanna print to the screen,

12071
08:47:37,970 --> 08:47:39,975
but we don't know what that's gonna be,

12072
08:47:39,975 --> 08:47:42,970
or print some other type of
thing we could call it a log,

12073
08:47:42,970 --> 08:47:45,440
could call it something
from the announcer,

12074
08:47:47,620 --> 08:47:50,430
announcer topic, announcer
message, do that.

12075
08:47:51,870 --> 08:47:53,571
But we don't know what that's gonna be

12076
08:47:53,571 --> 08:47:54,700
'cause it could vary between announcer.

12077
08:47:54,700 --> 08:47:57,160
And so each announcer could
be a little bit different.

12078
08:47:57,160 --> 08:48:00,200
And so what we wanna do
is allow the announcer

12079
08:48:00,200 --> 08:48:02,260
to say what they wanna say.

12080
08:48:02,260 --> 08:48:05,583
And so we're gonna delegate
that back up to the block.

12081
08:48:05,583 --> 08:48:06,610
And remember we're gonna
parse into the random player

12082
08:48:06,610 --> 08:48:09,053
that we chose, we're gonna
parse back up to them.

12083
08:48:09,053 --> 08:48:10,313
But this block also
returns a string, remember.

12084
08:48:10,313 --> 08:48:13,546
So if we look at this
block, it takes in a string

12085
08:48:13,546 --> 08:48:16,240
right here, it takes in a string

12086
08:48:16,240 --> 08:48:17,690
and then it returns a string.

12087
08:48:19,119 --> 08:48:19,952
So if we were to implement this,

12088
08:48:19,952 --> 08:48:22,270
what we could do is we
would say Derby announcer,

12089
08:48:23,680 --> 08:48:26,457
and we're just gonna parse
him a lambda expression.

12090
08:48:26,457 --> 08:48:28,780
Again, this is gonna take in a player

12091
08:48:28,780 --> 08:48:29,700
is what's gonna be sent in.

12092
08:48:29,700 --> 08:48:31,100
So it's gonna take a string.

12093
08:48:32,686 --> 08:48:33,550
We could say, this is a string,

12094
08:48:33,550 --> 08:48:35,440
or we could use type inference.

12095
08:48:35,440 --> 08:48:36,900
And then we can go ahead and do something.

12096
08:48:36,900 --> 08:48:39,729
And now we need to return
something out of here.

12097
08:48:39,729 --> 08:48:44,120
And we can say something like
this, player is a great asset

12098
08:48:45,220 --> 08:48:46,390
to the team.

12099
08:48:49,280 --> 08:48:50,960
And this is the value that's
gonna be returned, remember

12100
08:48:50,960 --> 08:48:52,650
'cause it's the last value
in the lambda expression.

12101
08:48:52,650 --> 08:48:55,517
It's what's going to be
returned inside of here.

12102
08:48:55,517 --> 08:48:58,450
Now, if I did length, we're
gonna run into a problem.

12103
08:48:58,450 --> 08:49:00,780
Why, because we're expecting a string,

12104
08:49:00,780 --> 08:49:02,570
but we're giving it back an integer.

12105
08:49:03,723 --> 08:49:04,556
So, okay, now we have this.

12106
08:49:04,556 --> 08:49:07,640
So the Derby announcer
is gonna say something.

12107
08:49:07,640 --> 08:49:08,880
The Derby announcer's
gonna say this player

12108
08:49:08,880 --> 08:49:10,020
is a great asset to the team.

12109
08:49:10,020 --> 08:49:12,110
So now what's gonna happen if we run this

12110
08:49:13,450 --> 08:49:14,610
is it the Derby announcer.

12111
08:49:14,610 --> 08:49:16,710
We don't know what player we're gonna get,

12112
08:49:17,612 --> 08:49:19,300
but here we get the
next player is Consaco.

12113
08:49:19,300 --> 08:49:21,280
Consaco is a great asset to the team.

12114
08:49:22,708 --> 08:49:24,710
And again, the way this
happens is Derby announcer

12115
08:49:24,710 --> 08:49:27,990
gets called, we have a list of players.

12116
08:49:27,990 --> 08:49:30,660
We grab a random player off of that list,

12117
08:49:30,660 --> 08:49:32,750
we then print something to the screen.

12118
08:49:32,750 --> 08:49:36,200
We then take that random
player, we send it to the block,

12119
08:49:37,519 --> 08:49:39,150
which is this player here.

12120
08:49:39,150 --> 08:49:41,510
We then do something with it,
so this could be any string.

12121
08:49:41,510 --> 08:49:43,210
So it depends on the Derby announcer,

12122
08:49:43,210 --> 08:49:46,330
whoever's using the Derby
announcer lambda expression.

12123
08:49:46,330 --> 08:49:47,470
It could be a number of things.

12124
08:49:47,470 --> 08:49:49,503
I mean, it could be
going out to a database,

12125
08:49:49,503 --> 08:49:50,336
could be going to a web service.

12126
08:49:50,336 --> 08:49:54,280
It could be going to a
Megatron at a big ballpark

12127
08:49:54,280 --> 08:49:56,320
to degenerate stuff.

12128
08:49:56,320 --> 08:50:00,040
And then once that is happens, we go ahead

12129
08:50:00,040 --> 08:50:02,780
and take that value and we send that value

12130
08:50:02,780 --> 08:50:05,430
of whatever message we have,
we're gonna send it back

12131
08:50:07,092 --> 08:50:07,925
through the lambda expression saying,

12132
08:50:07,925 --> 08:50:08,980
here's what we wanna return.

12133
08:50:09,930 --> 08:50:11,730
The lemon expression takes
that and then does something

12134
08:50:11,730 --> 08:50:13,790
with it and here, it's just
gonna print it to the screen.

12135
08:50:13,790 --> 08:50:16,560
So we're basically coming
in here, hopping back out,

12136
08:50:16,560 --> 08:50:18,510
doing something, grabbing
the value outside

12137
08:50:18,510 --> 08:50:21,890
of this external function
of this lambda expression

12138
08:50:21,890 --> 08:50:24,590
inside of here, bringing it
back inside of this function

12139
08:50:24,590 --> 08:50:26,180
and then doing something with it again.

12140
08:50:26,180 --> 08:50:28,950
So we're allowing it to
like yield some control.

12141
08:50:28,950 --> 08:50:31,330
This line right here is allowing
us to yield some control

12142
08:50:31,330 --> 08:50:33,950
to some outside caller,
which is really powerful.

12143
08:50:33,950 --> 08:50:36,580
And this enables you to do
some really powerful things.

12144
08:50:36,580 --> 08:50:37,690
And it doesn't have to be a string,

12145
08:50:37,690 --> 08:50:39,767
it could be any types of things.

12146
08:50:39,767 --> 08:50:40,862
It doesn't have to return a string,

12147
08:50:40,862 --> 08:50:43,142
it could be returning all
different kinds of things.

12148
08:50:43,142 --> 08:50:45,170
And so this is how you
can use lambda expressions

12149
08:50:45,170 --> 08:50:48,370
by parsing them as parameters,

12150
08:50:48,370 --> 08:50:50,450
as arguments into other functions.

12151
08:50:51,305 --> 08:50:54,180
You can create your own lambed
expressions to parse around.

12152
08:50:54,180 --> 08:50:55,840
You can create your own
functions that require

12153
08:50:55,840 --> 08:50:57,260
lambda expressions.

12154
08:50:57,260 --> 08:51:01,160
And then you can delegate
behavior back to up to the caller.

12155
08:51:01,160 --> 08:51:04,030
You may be developing an API
and you know that you wanted

12156
08:51:04,030 --> 08:51:06,250
to get something from the end
user, but you don't know what,

12157
08:51:06,250 --> 08:51:08,230
but you wanna give them
a little bit of data.

12158
08:51:08,230 --> 08:51:10,810
Here I'm saying this is my announcer.

12159
08:51:10,810 --> 08:51:14,810
Perhaps I'm creating some
code for a baseball field.

12160
08:51:14,810 --> 08:51:18,352
And this announcer is gonna be, you know,

12161
08:51:18,352 --> 08:51:19,185
get a random player for whatever reason.

12162
08:51:19,185 --> 08:51:20,020
There is a home run Derby.

12163
08:51:20,020 --> 08:51:21,490
And so we're gonna get the random player,

12164
08:51:21,490 --> 08:51:23,090
who knows what they're
gonna say from there,

12165
08:51:23,090 --> 08:51:24,707
but I need to get that information back

12166
08:51:24,707 --> 08:51:27,270
because maybe I need to
take this information

12167
08:51:27,270 --> 08:51:28,880
and give it to a teleprompter.

12168
08:51:28,880 --> 08:51:31,020
Maybe it needs to show up on
a teleprompter, I don't know.

12169
08:51:31,020 --> 08:51:32,510
So all different kinds
of things you can do,

12170
08:51:32,510 --> 08:51:34,440
but you can delegate
this stuff pretty easily

12171
08:51:34,440 --> 08:51:35,910
using lambda expressions.

12172
08:51:38,211 --> 08:51:40,820
Let's assume that you're
creating a lorem ipsum generator,

12173
08:51:40,820 --> 08:51:43,570
which is Latin text that's typically used

12174
08:51:43,570 --> 08:51:46,020
in a lot of copywriting
when you're not sure

12175
08:51:46,020 --> 08:51:49,034
what you wanna write and
you're designing some texts.

12176
08:51:49,034 --> 08:51:51,540
And when you're doing this,
here's for example, the code,

12177
08:51:51,540 --> 08:51:54,220
we have a bunch of Latin words here,

12178
08:51:54,220 --> 08:51:57,050
and we want to randomly
get a bunch of words.

12179
08:51:57,050 --> 08:52:01,560
And we have a function here
that basically says lorem ipsum

12180
08:52:01,560 --> 08:52:03,650
takes in the number of times we want,

12181
08:52:03,650 --> 08:52:05,950
number of basically words
or loops we wanna do

12182
08:52:07,536 --> 08:52:09,839
and then basically it does a repeat.

12183
08:52:09,839 --> 08:52:11,850
And what happens is we will do
something a number of times.

12184
08:52:11,850 --> 08:52:14,680
So it's five times, it'll
repeat this five times

12185
08:52:14,680 --> 08:52:16,860
giving us the index of each time.

12186
08:52:16,860 --> 08:52:19,910
And then what we do is we look
at the list of Latin words

12187
08:52:19,910 --> 08:52:20,860
to get a random word.

12188
08:52:20,860 --> 08:52:25,290
And then we send that back to
whatever the block is here.

12189
08:52:25,290 --> 08:52:29,590
In that case, it's going
to be this caller here

12190
08:52:29,590 --> 08:52:31,370
and you're gonna get back to the index.

12191
08:52:31,370 --> 08:52:33,790
So basically the current iteration.

12192
08:52:33,790 --> 08:52:36,296
So if it's the first one,
it would be number one,

12193
08:52:36,296 --> 08:52:37,730
if it's the fifth iteration, it'd be five.

12194
08:52:37,730 --> 08:52:39,030
And then whatever the random word is.

12195
08:52:39,030 --> 08:52:41,000
And at that point, you can
do whatever you wanna do

12196
08:52:41,000 --> 08:52:44,590
with this random words
from this lorem ipsum text.

12197
08:52:44,590 --> 08:52:46,890
So let's say you do that
and you run this now,

12198
08:52:46,890 --> 08:52:49,750
and then you have this text here.

12199
08:52:49,750 --> 08:52:51,920
And of course this is
gonna change each time

12200
08:52:51,920 --> 08:52:54,420
because everything is kind of random.

12201
08:52:54,420 --> 08:52:56,770
Now notice one thing here is
that we're not really using

12202
08:52:56,770 --> 08:52:58,210
this index parameter.

12203
08:52:58,210 --> 08:53:01,526
And so we do need the word parameter.

12204
08:53:01,526 --> 08:53:04,330
So what we can actually do in this case

12205
08:53:04,330 --> 08:53:05,920
is a couple of things to clean this up.

12206
08:53:05,920 --> 08:53:09,470
First of all, due to
type inference in Kotlin,

12207
08:53:09,470 --> 08:53:11,290
we can get rid of the types.

12208
08:53:11,290 --> 08:53:14,310
So alrighty, Kotlin is gonna know.

12209
08:53:14,310 --> 08:53:16,940
Sounds good, we already know
that the first type here

12210
08:53:16,940 --> 08:53:20,050
is gonna be an integer because
that's declared right here.

12211
08:53:20,050 --> 08:53:22,838
And the second type is
going to be a string

12212
08:53:22,838 --> 08:53:23,671
because that's declared there.

12213
08:53:23,671 --> 08:53:25,450
So we don't need you to
define the types for us,

12214
08:53:25,450 --> 08:53:26,940
we can do that for us.

12215
08:53:26,940 --> 08:53:31,530
Next by default, there
is a kind of standard

12216
08:53:31,530 --> 08:53:33,210
that when a parameter is not used,

12217
08:53:33,210 --> 08:53:35,830
but we do need to declare
it here for the purposes

12218
08:53:35,830 --> 08:53:39,670
of the compiler, you can use a underscore.

12219
08:53:39,670 --> 08:53:40,990
And that basically tells Kotlin,

12220
08:53:40,990 --> 08:53:42,990
hey, we know that there's a variable here,

12221
08:53:42,990 --> 08:53:45,400
but just go ahead and ignore that.

12222
08:53:45,400 --> 08:53:48,440
And so if we run this
again, we can execute it

12223
08:53:48,440 --> 08:53:49,970
and that would work just fine.

12224
08:53:49,970 --> 08:53:52,400
Now, another interesting
thing is if for some reason

12225
08:53:52,400 --> 08:53:54,450
we didn't wanna do anything with it here,

12226
08:53:55,350 --> 08:53:56,900
say, we didn't wanna use word either.

12227
08:53:56,900 --> 08:53:58,200
Now we also get this here.

12228
08:53:59,340 --> 08:54:01,440
We can rename both of these to underscore,

12229
08:54:02,331 --> 08:54:04,300
and that's kind of the default mechanism

12230
08:54:04,300 --> 08:54:07,150
and the default nomenclature for variables

12231
08:54:07,150 --> 08:54:09,280
inside of a lambda
expression that are not used.

12232
08:54:09,280 --> 08:54:12,277
So basically this means unused.

12233
08:54:12,277 --> 08:54:14,630
So anytime you see an underscore inside

12234
08:54:14,630 --> 08:54:17,287
of a lambda expression that you're using

12235
08:54:17,287 --> 08:54:19,630
or in code somewhere, it means
whatever this variable is,

12236
08:54:19,630 --> 08:54:21,420
it's not being used, so
therefore it's been turned

12237
08:54:21,420 --> 08:54:22,370
into an underscore.

12238
08:54:24,710 --> 08:54:27,470
It's very common that a
Kotlin lambda expression

12239
08:54:27,470 --> 08:54:30,810
only has one parameter as the
repeat function does here,

12240
08:54:30,810 --> 08:54:33,410
which is built into the
Kotlin standard library

12241
08:54:33,410 --> 08:54:34,243
as shown here.

12242
08:54:35,167 --> 08:54:37,460
It has one value and that's the index

12243
08:54:37,460 --> 08:54:39,770
that is currently iterating upon.

12244
08:54:39,770 --> 08:54:43,140
So if we were to run this
right now and we told it

12245
08:54:43,140 --> 08:54:44,200
to repeat 10 times,

12246
08:54:44,200 --> 08:54:46,870
we would see that this is
iteration zero through nine.

12247
08:54:46,870 --> 08:54:49,080
Again, this is zero base indexing.

12248
08:54:49,080 --> 08:54:50,850
So we have 10 iterations here.

12249
08:54:50,850 --> 08:54:52,890
So this is printed 10 times.

12250
08:54:52,890 --> 08:54:56,730
Now, anytime you're working
with a lambda expression

12251
08:54:56,730 --> 08:54:59,870
that has one parameter the
compiler is usually smart enough

12252
08:54:59,870 --> 08:55:04,180
to figure out in almost all
of the instances, the types.

12253
08:55:04,180 --> 08:55:06,540
So it can move the type
that's one can prove me here,

12254
08:55:06,540 --> 08:55:08,870
but you can actually improve
this a little bit further

12255
08:55:08,870 --> 08:55:11,829
by actually completely
removing the parameter

12256
08:55:11,829 --> 08:55:16,829
all together and on a single
on a lambda expression

12257
08:55:17,940 --> 08:55:22,940
with one parameter, by default
Kotlin we'll call it it.

12258
08:55:24,810 --> 08:55:28,520
So it can infer the type
of the actual parameter.

12259
08:55:28,520 --> 08:55:30,630
So if it's a single
parameter in this case,

12260
08:55:30,630 --> 08:55:33,490
repeat only has a single
parameter, it'll show as it.

12261
08:55:35,122 --> 08:55:35,955
Now the same thing happens
for many other things

12262
08:55:35,955 --> 08:55:39,160
like the map, instead of
the collections of map,

12263
08:55:39,160 --> 08:55:41,050
you're gonna have
filter, you're gonna have

12264
08:55:41,050 --> 08:55:43,120
a bunch of other things of that nature.

12265
08:55:43,120 --> 08:55:45,410
And it only has one parameter,
you can reference it

12266
08:55:45,410 --> 08:55:47,590
with the word it and Kotlin

12267
08:55:47,590 --> 08:55:49,290
will automatically map it to that.

12268
08:55:50,379 --> 08:55:51,212
So now if we run this again,

12269
08:55:51,212 --> 08:55:52,045
we'll get the same exact result,

12270
08:55:52,045 --> 08:55:55,400
but we save herself a number
of characters when we're coding

12271
08:55:55,400 --> 08:55:59,370
and over the course of a long
weeks and months of times,

12272
08:55:59,370 --> 08:56:01,850
it's a lot of code and less cognitive load

12273
08:56:01,850 --> 08:56:03,400
for you to read in the future.

12274
08:56:03,400 --> 08:56:06,470
And you can just replace all
the extra code with the word it

12275
08:56:06,470 --> 08:56:07,930
and make sure you include the dollar sign

12276
08:56:07,930 --> 08:56:12,322
if you're using anything in
regards to string interpolation.

12277
08:56:12,322 --> 08:56:16,350
Otherwise, if you didn't
wanna use string interpolation

12278
08:56:16,350 --> 08:56:18,706
and you were going to
use something like this,

12279
08:56:18,706 --> 08:56:23,706
you could then go and
say it, plus maybe one,

12280
08:56:24,240 --> 08:56:25,073
let's say you wanted to do that.

12281
08:56:25,073 --> 08:56:27,430
And you're gonna print that line.

12282
08:56:27,430 --> 08:56:28,710
So it again is just a variable.

12283
08:56:30,007 --> 08:56:31,860
And now we get one through
10 because we added one

12284
08:56:31,860 --> 08:56:33,230
to the index.

12285
08:56:33,230 --> 08:56:35,060
And that's how you can use the it keyword

12286
08:56:35,060 --> 08:56:37,000
in Kotlin in lambda expressions.

12287
08:56:38,080 --> 08:56:40,700
Let's talk about how you
can call Kotlin classes

12288
08:56:40,700 --> 08:56:42,260
from within Java.

12289
08:56:42,260 --> 08:56:45,070
So we'll talk about
the JVM interrupt here.

12290
08:56:45,070 --> 08:56:47,800
So let's assume we have
a couple of files here.

12291
08:56:47,800 --> 08:56:50,980
One on the left-hand side,
we have a customer model.

12292
08:56:50,980 --> 08:56:54,880
All it is a Kotlin data class
that contains the customer

12293
08:56:54,880 --> 08:56:55,900
and it has a function in it.

12294
08:56:55,900 --> 08:56:58,360
And basically the function
checks if the customer

12295
08:56:58,360 --> 08:57:01,960
has a long, we have maybe
some type of service.

12296
08:57:01,960 --> 08:57:04,550
So we have a couple of packages here.

12297
08:57:04,550 --> 08:57:07,260
And inside of this application,
we have some Kotlin,

12298
08:57:07,260 --> 08:57:08,490
some Java for whatever reason.

12299
08:57:08,490 --> 08:57:11,440
It has to be Java, or it's
just maybe a very large file

12300
08:57:11,440 --> 08:57:13,440
that we haven't converted to Kotlin yet.

12301
08:57:14,400 --> 08:57:16,390
And you need to call into some Kotlin,

12302
08:57:16,390 --> 08:57:17,980
maybe that was written.

12303
08:57:17,980 --> 08:57:18,820
Now you can actually do that.

12304
08:57:18,820 --> 08:57:21,330
So here we're in a Java file
and let's say that we need

12305
08:57:21,330 --> 08:57:23,400
to interact with the customer.

12306
08:57:23,400 --> 08:57:26,790
And so let's have a method
called process customer.

12307
08:57:26,790 --> 08:57:30,080
So we'll say public void process customer.

12308
08:57:32,120 --> 08:57:33,980
And then what we need
to do is we need to work

12309
08:57:33,980 --> 08:57:35,680
with the customer, so we need
to take a parameter here.

12310
08:57:35,680 --> 08:57:38,500
So we're gonna say customer
and there is customer,

12311
08:57:40,033 --> 08:57:42,650
so we'll do it just like Java
has it open, closed brackets.

12312
08:57:42,650 --> 08:57:43,590
We need to import this.

12313
08:57:43,590 --> 08:57:46,090
Now again, this is a Kotlin class.

12314
08:57:46,090 --> 08:57:48,080
So if we look, go through the definition,

12315
08:57:48,080 --> 08:57:49,770
we're gonna see that now
we're back in Kotlin.

12316
08:57:49,770 --> 08:57:54,260
And that's it, now we are able
to work with this customer.

12317
08:57:54,260 --> 08:57:56,320
If we wanna do something
with the customer,

12318
08:57:56,320 --> 08:57:59,450
we can say customer dot, and
then we have all of the methods

12319
08:57:59,450 --> 08:58:00,283
that are available to us.

12320
08:58:00,283 --> 08:58:04,080
So customer has long name,
that's a Boolean value.

12321
08:58:04,080 --> 08:58:06,710
That's over here, that's
this method right here.

12322
08:58:08,762 --> 08:58:10,580
If we want to get the customer's name,

12323
08:58:11,785 --> 08:58:13,130
we don't have get name,
now this is interesting.

12324
08:58:13,130 --> 08:58:16,140
So get name, actually goes to name,

12325
08:58:16,140 --> 08:58:18,580
but we never defined a get name method.

12326
08:58:18,580 --> 08:58:21,110
Now Kotlin takes care of that
forest underneath the hood

12327
08:58:21,110 --> 08:58:24,700
basically creates a get
name and set name for us.

12328
08:58:24,700 --> 08:58:28,520
But if we look there is no set name,

12329
08:58:28,520 --> 08:58:31,950
and the reason why is
because this is a val.

12330
08:58:31,950 --> 08:58:33,650
So this is a read only.

12331
08:58:34,670 --> 08:58:37,770
So we cannot reassign this
value, it's a read only type.

12332
08:58:37,770 --> 08:58:41,650
If for whatever reason,
this needed to be writable,

12333
08:58:41,650 --> 08:58:45,840
needed to be mutated, we
could then change this

12334
08:58:45,840 --> 08:58:48,780
if we had access to the Kotlin code.

12335
08:58:48,780 --> 08:58:53,500
And then at that point, Kotlin
will give us the set name

12336
08:58:53,500 --> 08:58:57,590
and we can parse in the value,
whatever the new name is.

12337
08:58:57,590 --> 08:59:02,590
Now, at this point, you can
call into Kotlin very easily.

12338
08:59:03,140 --> 08:59:07,310
You can say customer.customer
has long name,

12339
08:59:07,310 --> 08:59:09,680
and you can do anything that
you would really like to do

12340
08:59:09,680 --> 08:59:11,050
at this point in time.

12341
08:59:11,050 --> 08:59:13,250
The only thing you really
have to really worry about

12342
08:59:13,250 --> 08:59:16,160
with these classes is the different types.

12343
08:59:16,160 --> 08:59:18,690
And you can know that
the getters and setters

12344
08:59:18,690 --> 08:59:21,900
are generated for you automatically

12345
08:59:21,900 --> 08:59:25,220
for through Kotlin
because inside of Kotlin,

12346
08:59:25,220 --> 08:59:28,830
we don't need to actually
generate the getters and setters

12347
08:59:28,830 --> 08:59:30,810
because we just will access it directly

12348
08:59:30,810 --> 08:59:32,000
off of the name properties.

12349
08:59:32,000 --> 08:59:34,200
We can just set the
name equal to something.

12350
08:59:35,460 --> 08:59:38,360
And that's how you can call
very simple objects in Kotlin.

12351
08:59:39,460 --> 08:59:41,872
Let's assume that we have this Java class

12352
08:59:41,872 --> 08:59:44,300
and we need to call it from Kotlin.

12353
08:59:44,300 --> 08:59:46,380
Well, that's pretty easy to do.

12354
08:59:46,380 --> 08:59:47,840
This class has a couple of options.

12355
08:59:47,840 --> 08:59:50,480
One is we can get a customer
from a social profile.

12356
08:59:50,480 --> 08:59:52,740
So this would assume
that this was going out

12357
08:59:52,740 --> 08:59:57,740
to some social media API, and
it would get the customer,

12358
08:59:57,750 --> 08:59:58,980
and then returned customer back.

12359
08:59:58,980 --> 09:00:01,620
Maybe we would look it up by
their social media handle.

12360
09:00:02,918 --> 09:00:04,920
And this method basically
returns a list of process

12361
09:00:04,920 --> 09:00:07,310
customers, which doing some
processing in the background.

12362
09:00:07,310 --> 09:00:08,840
The implementation is not important,

12363
09:00:08,840 --> 09:00:11,710
but what is, is the types
and how it's being called.

12364
09:00:11,710 --> 09:00:14,900
And then we have a Kotlin
file called customer facade,

12365
09:00:14,900 --> 09:00:16,780
following a very common facade pattern

12366
09:00:16,780 --> 09:00:18,290
where maybe it's interacting with a bunch

12367
09:00:18,290 --> 09:00:20,740
of different services to perform some work

12368
09:00:20,740 --> 09:00:22,510
on some customer objects.

12369
09:00:22,510 --> 09:00:24,980
And lastly, of course, we
have the customer object,

12370
09:00:24,980 --> 09:00:28,440
which just has customers name
and similar methods in here,

12371
09:00:28,440 --> 09:00:30,270
which are negligible at this point.

12372
09:00:32,333 --> 09:00:33,166
So inside of customer facade, let's assume

12373
09:00:33,166 --> 09:00:36,250
that we need to call into
the customer service,

12374
09:00:36,250 --> 09:00:37,950
which is Java.

12375
09:00:37,950 --> 09:00:39,814
How would we do that?

12376
09:00:39,814 --> 09:00:40,820
Well, let's assume we wanted to parse it

12377
09:00:40,820 --> 09:00:41,940
via the constructor.

12378
09:00:41,940 --> 09:00:44,190
So what we can say, this
is customer service,

12379
09:00:44,190 --> 09:00:47,542
and now we are working directly
with the customer service

12380
09:00:47,542 --> 09:00:48,375
and we can say something like this.

12381
09:00:48,375 --> 09:00:50,765
We wanna get the customer, customer.

12382
09:00:50,765 --> 09:00:54,940
And then we can say equals
customer service.customer

12383
09:00:56,684 --> 09:00:59,430
from social, and then maybe
we'll parse in user name.

12384
09:00:59,430 --> 09:01:01,070
This is an example username.

12385
09:01:02,240 --> 09:01:07,240
Here we are now calling
into Java from Kotlin,

12386
09:01:07,870 --> 09:01:10,290
but there's something
interesting to note here,

12387
09:01:10,290 --> 09:01:12,820
is if you look at this right here,

12388
09:01:13,700 --> 09:01:16,240
you'll see the customer has an
exclamation point at the end.

12389
09:01:16,240 --> 09:01:19,990
And what that means is
that it is a platform type.

12390
09:01:19,990 --> 09:01:24,990
And this means right
here, that T could be null

12391
09:01:27,070 --> 09:01:28,180
or it could not be null.

12392
09:01:28,180 --> 09:01:30,680
So we're not sure, you
have to decide for yourself

12393
09:01:31,926 --> 09:01:32,759
because you're calling into Kotlin.

12394
09:01:32,759 --> 09:01:34,510
So there's a couple of
things you could do here.

12395
09:01:34,510 --> 09:01:36,280
Now, of course, if I were to just type

12396
09:01:36,280 --> 09:01:40,230
inside of my application, I
would just type in customer.name

12397
09:01:44,261 --> 09:01:46,930
I could do this, I could say
print line customer, not name.

12398
09:01:46,930 --> 09:01:48,010
And that should work.

12399
09:01:48,010 --> 09:01:50,323
As long as the customer is not know about.

12400
09:01:50,323 --> 09:01:52,436
However, there is a chance
that this customer object

12401
09:01:52,436 --> 09:01:53,269
could be null.

12402
09:01:53,269 --> 09:01:54,420
And if it does come back
null, I am going to get

12403
09:01:54,420 --> 09:01:55,920
a null pointer exception.

12404
09:01:55,920 --> 09:01:59,320
So couple of ways to handle
this inside of our Kotlin code,

12405
09:01:59,320 --> 09:02:00,770
we could of course, just go ahead and use

12406
09:02:00,770 --> 09:02:03,120
the double bang operator that
will force it to not be null.

12407
09:02:03,120 --> 09:02:05,890
However, that is a little
bit of a code smell.

12408
09:02:05,890 --> 09:02:08,980
We could use require not
null, that will work as well,

12409
09:02:08,980 --> 09:02:11,310
but again, this will
crash the application.

12410
09:02:12,250 --> 09:02:13,680
Sometimes that's the only thing you can do

12411
09:02:13,680 --> 09:02:14,790
when you're calling into a library

12412
09:02:14,790 --> 09:02:16,590
you don't have control over.

12413
09:02:16,590 --> 09:02:18,400
Then at this point you're
saying, well, I know the customer

12414
09:02:18,400 --> 09:02:19,890
is not gonna be null
because I'm requiring it

12415
09:02:19,890 --> 09:02:21,190
not to be null.

12416
09:02:21,190 --> 09:02:23,490
you could write this in a try-catch.

12417
09:02:23,490 --> 09:02:26,130
If you have access though,
to the actual Java code,

12418
09:02:26,130 --> 09:02:27,930
you can go to this
implementation and you can slap

12419
09:02:27,930 --> 09:02:29,450
on an annotation.

12420
09:02:29,450 --> 09:02:32,676
You can slap on the not null annotation,

12421
09:02:32,676 --> 09:02:34,420
and you could re various
different ones from the JSR

12422
09:02:34,420 --> 09:02:37,566
to I'm using JetBrains version here,

12423
09:02:37,566 --> 09:02:38,760
there's one for Android as well.

12424
09:02:38,760 --> 09:02:42,000
And what this will do is tell Kotlin that,

12425
09:02:42,000 --> 09:02:45,090
hey, trust us, we know what we're doing.

12426
09:02:45,090 --> 09:02:47,440
If we return from this,
it's not gonna be null.

12427
09:02:48,340 --> 09:02:50,860
So now if you notice the
exclamation point went away.

12428
09:02:50,860 --> 09:02:53,610
Kotlin saying, well, you are
telling me via this annotation

12429
09:02:53,610 --> 09:02:56,701
that whoever calls into
customer from social

12430
09:02:56,701 --> 09:02:57,750
will get back a customer object

12431
09:02:57,750 --> 09:02:59,950
and that customer object will not be null.

12432
09:02:59,950 --> 09:03:00,920
So we're gonna go ahead and trust you

12433
09:03:00,920 --> 09:03:03,760
and then we can go ahead
and execute accordingly.

12434
09:03:03,760 --> 09:03:06,110
And at that point in time,
I can do whatever I want.

12435
09:03:07,071 --> 09:03:07,940
Now, this also can be a
little bit further here.

12436
09:03:07,940 --> 09:03:09,760
Let's take a look at the other method.

12437
09:03:11,053 --> 09:03:11,970
The other method is processed customers.

12438
09:03:11,970 --> 09:03:15,850
So process customers here,
let's say val customers,

12439
09:03:17,040 --> 09:03:20,220
you can say a customer
service.processed customers.

12440
09:03:20,220 --> 09:03:23,550
Maybe you're processing them
to update account details

12441
09:03:23,550 --> 09:03:24,490
or whatever.

12442
09:03:24,490 --> 09:03:25,680
Now notice the same thing.

12443
09:03:25,680 --> 09:03:28,740
Again, a platform type
is being returned here.

12444
09:03:28,740 --> 09:03:32,094
We have the exclamation
points that are determined.

12445
09:03:32,094 --> 09:03:32,927
Now we have two of them.

12446
09:03:32,927 --> 09:03:34,700
We have a list and we have the customers.

12447
09:03:34,700 --> 09:03:39,680
Now what this is saying is
like, hey, caller, Kotlin folks,

12448
09:03:39,680 --> 09:03:42,060
we're not sure if this
is a read only list,

12449
09:03:42,060 --> 09:03:44,110
we're not sure if this is a mutable list.

12450
09:03:45,349 --> 09:03:46,182
We're not sure if this
is null, we're not sure

12451
09:03:46,182 --> 09:03:48,870
if this is nullable, we
don't really know yet.

12452
09:03:48,870 --> 09:03:51,990
Because you're calling
into a platform type,

12453
09:03:51,990 --> 09:03:53,280
we're not sure what it is.

12454
09:03:53,280 --> 09:03:55,580
And so you can start slapping
on additional annotations

12455
09:03:55,580 --> 09:03:57,190
on here, but for example, you can also put

12456
09:03:57,190 --> 09:03:58,630
a not null annotation here.

12457
09:04:00,060 --> 09:04:03,371
That is not null annotation
and again, we'll remove that

12458
09:04:03,371 --> 09:04:05,620
saying, hey, at this point,
this is a list that's not

12459
09:04:05,620 --> 09:04:06,530
gonna be null.

12460
09:04:06,530 --> 09:04:09,870
So therefore, if we do perform
some operations on the list,

12461
09:04:09,870 --> 09:04:12,490
which we get at this point, which is nice,

12462
09:04:12,490 --> 09:04:14,680
we can actually map over this list,

12463
09:04:14,680 --> 09:04:18,050
which is interesting because
we're calling into Kotlin,

12464
09:04:18,980 --> 09:04:20,680
we're getting back in a array list

12465
09:04:22,339 --> 09:04:23,172
and then, and then array
list, we're getting it back

12466
09:04:23,172 --> 09:04:24,005
inside of Kotlin.

12467
09:04:24,005 --> 09:04:27,151
And now we can start
performing using our Kotlin

12468
09:04:27,151 --> 09:04:29,051
standard library collection utilities.

12469
09:04:30,134 --> 09:04:31,170
Now this makes life a lot easier.

12470
09:04:31,170 --> 09:04:33,901
I can perform filtering I can perform

12471
09:04:33,901 --> 09:04:36,300
all different types of things
directly inside of Kotlin

12472
09:04:36,300 --> 09:04:38,410
after I've called into Java.

12473
09:04:40,073 --> 09:04:41,200
So a bunch of different stuff you can do.

12474
09:04:41,200 --> 09:04:43,050
One thing you just wanna be
aware of is when you are calling

12475
09:04:43,050 --> 09:04:46,350
into these various platform
types that you check

12476
09:04:47,595 --> 09:04:50,502
for nullables and make
sure that you don't have

12477
09:04:50,502 --> 09:04:51,335
no pointer exceptions.

12478
09:04:51,335 --> 09:04:53,520
Let's assume that we have
this extension function

12479
09:04:53,520 --> 09:04:57,240
inside of a string extensions.kt file.

12480
09:04:57,240 --> 09:05:00,330
And this extension function
extends this string class

12481
09:05:00,330 --> 09:05:02,440
and allows us to grab the initials.

12482
09:05:02,440 --> 09:05:04,850
So if we were to have something like this,

12483
09:05:06,212 --> 09:05:07,910
have a string that says Donn Felker,

12484
09:05:09,099 --> 09:05:09,932
the output would then equal DF.

12485
09:05:11,811 --> 09:05:12,644
It would just grab those initials.

12486
09:05:12,644 --> 09:05:13,477
So it's not a very robust function.

12487
09:05:13,477 --> 09:05:15,320
Actually it could be quite error prone,

12488
09:05:15,320 --> 09:05:17,620
but for simplicity sake,
this is what it does.

12489
09:05:18,688 --> 09:05:20,860
If you parse in a string
with that separated by space,

12490
09:05:20,860 --> 09:05:21,780
you'll get back the initials

12491
09:05:21,780 --> 09:05:23,480
and let's just assume it the name.

12492
09:05:24,640 --> 09:05:26,580
Now, if you wanna call this from Kotlin,

12493
09:05:26,580 --> 09:05:28,380
of course, we're very
easy, we can do that.

12494
09:05:28,380 --> 09:05:30,580
So with let's assume
we have a customer here

12495
09:05:31,739 --> 09:05:32,572
and the customer has a name property.

12496
09:05:32,572 --> 09:05:35,610
So again, if we go look
at what a customer is,

12497
09:05:35,610 --> 09:05:37,330
it's we have a customer class.

12498
09:05:38,450 --> 09:05:40,190
So it's a very simple data class.

12499
09:05:41,759 --> 09:05:42,592
Now, if we have a name, a name as a string

12500
09:05:42,592 --> 09:05:45,050
as we can see here, and we
can just get the initials

12501
09:05:45,050 --> 09:05:48,950
off of the name, so that's
pretty easy in Kotlin.

12502
09:05:48,950 --> 09:05:50,920
So now we have the initials,
we can do whatever we want

12503
09:05:50,920 --> 09:05:51,950
and make sense.

12504
09:05:51,950 --> 09:05:53,690
However, there are times
when you would like

12505
09:05:53,690 --> 09:05:58,060
to call these extinction
functions from a Java file.

12506
09:05:58,060 --> 09:05:59,380
The question is, can you do it?

12507
09:05:59,380 --> 09:06:01,250
So let's assume that
we have this Java file

12508
09:06:01,250 --> 09:06:04,542
that processes customers,
and in this method,

12509
09:06:04,542 --> 09:06:05,600
customer from social.

12510
09:06:05,600 --> 09:06:08,250
Assume, we are retrieving
a customer profile

12511
09:06:09,917 --> 09:06:12,787
from a social API, and here
we have the customer object.

12512
09:06:12,787 --> 09:06:14,237
Now we wanna use user's name.

12513
09:06:15,658 --> 09:06:16,690
So of course we have get named,
which is generated for us.

12514
09:06:16,690 --> 09:06:19,577
Now if we were to type
initials, we're gonna see

12515
09:06:19,577 --> 09:06:21,100
that it doesn't exist
because extension functions

12516
09:06:21,100 --> 09:06:22,950
don't exist in Java,

12517
09:06:22,950 --> 09:06:27,220
but we can still use that
code that we'd wrote in Kotlin

12518
09:06:27,220 --> 09:06:29,050
as an extension function.

12519
09:06:29,050 --> 09:06:31,280
And previously, if you've
worked inside of Java,

12520
09:06:31,280 --> 09:06:33,180
you've probably written
a lot of helper functions

12521
09:06:33,180 --> 09:06:36,220
and they've been inside of
basically static classes.

12522
09:06:36,220 --> 09:06:39,990
And so what we'll go ahead and
do is the string extensions

12523
09:06:39,990 --> 09:06:43,840
file actually generates a file for you.

12524
09:06:43,840 --> 09:06:47,298
So this is a top of a function
it's not inside of a class

12525
09:06:47,298 --> 09:06:48,790
at all, but it does
generate a file for you.

12526
09:06:50,155 --> 09:06:50,988
And so if we type string extensions,

12527
09:06:50,988 --> 09:06:53,550
you'll see string extensions
and a kt at the end.

12528
09:06:53,550 --> 09:06:56,790
String of tensions kt and
then there's a static method

12529
09:06:56,790 --> 09:07:00,009
called initials, you parse in a string,

12530
09:07:00,009 --> 09:07:01,910
and now you can get your initials.

12531
09:07:02,879 --> 09:07:05,410
So you can say string initials equals.

12532
09:07:06,820 --> 09:07:09,180
And this will call into
if I go to the definition,

12533
09:07:09,180 --> 09:07:11,330
calls into this extension function.

12534
09:07:12,780 --> 09:07:15,120
So this is how you can call
into an extension function

12535
09:07:15,120 --> 09:07:17,410
inside of Kotlin.

12536
09:07:17,410 --> 09:07:19,070
So any extinction function you have,

12537
09:07:19,070 --> 09:07:20,820
you'll wanna look at the actual file name.

12538
09:07:20,820 --> 09:07:23,990
Now there is a way to modify
the file name and using

12539
09:07:25,377 --> 09:07:26,210
the JVM name annotation.

12540
09:07:26,210 --> 09:07:28,220
And I'll show you that in another video,

12541
09:07:28,220 --> 09:07:30,720
but if you wanna call into
any of your extensions.

12542
09:07:31,842 --> 09:07:33,060
So if this was just called extensions.kt,

12543
09:07:34,914 --> 09:07:35,747
then in that case, it would
just be extensions kt.

12544
09:07:35,747 --> 09:07:38,270
So basically slaps the
two letter kt at the end.

12545
09:07:39,307 --> 09:07:40,140
And then at that point in time,

12546
09:07:40,140 --> 09:07:43,030
you can access it just as if
you did with a regular helper

12547
09:07:43,030 --> 09:07:46,141
function that you may
have traditionally built

12548
09:07:46,141 --> 09:07:46,974
inside of Java.

12549
09:07:46,974 --> 09:07:49,890
And that's how you call an
extension can function from Java.

12550
09:07:51,660 --> 09:07:55,300
Calling an extinction
function from Java works,

12551
09:07:55,300 --> 09:07:57,950
but let's be honest, it looks
a little bit clunky here.

12552
09:07:57,950 --> 09:08:01,230
There's this weird kt thing
that we have at the end,

12553
09:08:01,230 --> 09:08:03,090
which we didn't specify there.

12554
09:08:03,090 --> 09:08:04,940
Inside of the string extensions file,

12555
09:08:06,073 --> 09:08:06,906
it just looks like this.

12556
09:08:06,906 --> 09:08:08,880
We never specified a kt in here.

12557
09:08:08,880 --> 09:08:11,130
So having kt riddled
throughout your code base

12558
09:08:11,130 --> 09:08:14,990
can be kind of a weird feeling
and kind of a code smell.

12559
09:08:14,990 --> 09:08:17,990
Thankfully, the folks
over who developed Kotlin

12560
09:08:17,990 --> 09:08:19,040
thought of this.

12561
09:08:19,040 --> 09:08:21,310
And what you can do is
actually change the name

12562
09:08:21,310 --> 09:08:22,730
of the actual file is generated.

12563
09:08:22,730 --> 09:08:25,410
And what you can do is add
this annotation called file,

12564
09:08:25,410 --> 09:08:28,580
JVM name and provide the name of the file.

12565
09:08:28,580 --> 09:08:31,090
So here, I would wanna
say string extensions,

12566
09:08:31,090 --> 09:08:34,170
or I could say string utils,
so say a tree extensions.

12567
09:08:35,940 --> 09:08:37,780
Let's save that and we'll go
back to where I'm calling it

12568
09:08:37,780 --> 09:08:38,613
from Java.

12569
09:08:38,613 --> 09:08:40,920
And then immediately we
noticed that our previous call

12570
09:08:40,920 --> 09:08:42,720
in here is not working anymore.

12571
09:08:42,720 --> 09:08:44,940
So if we were just
typed string extensions,

12572
09:08:44,940 --> 09:08:47,180
now we just see string
extensions.initials.

12573
09:08:48,299 --> 09:08:50,860
So I can go ahead and fix
this by just ruin the kt.

12574
09:08:50,860 --> 09:08:55,860
Now I don't even really know
that I'm using Kotlin at all.

12575
09:08:55,940 --> 09:08:58,100
It's not basically polluting my code base

12576
09:08:58,100 --> 09:08:59,710
inside of my Java files.

12577
09:09:01,053 --> 09:09:02,410
Now there may be various
reasons why you can't move this

12578
09:09:02,410 --> 09:09:04,270
to Kotlin, and if that's the case,

12579
09:09:04,270 --> 09:09:06,220
this might be a very good use to you.

12580
09:09:06,220 --> 09:09:08,270
Or if you're exposing
your extension functions

12581
09:09:08,270 --> 09:09:11,100
to outside callers in other JVM languages,

12582
09:09:11,100 --> 09:09:13,165
you may wanna go ahead
and provide a JVM name.

12583
09:09:13,165 --> 09:09:16,200
So it's nice and extensible and readable

12584
09:09:16,200 --> 09:09:18,150
and doesn't pollute their code as well.

12585
09:09:19,802 --> 09:09:20,635
Now you can name this, anything you want.

12586
09:09:20,635 --> 09:09:21,710
It doesn't have to be
whatever the file name is.

12587
09:09:21,710 --> 09:09:26,710
If I want this to be happy
clown file, happy clown stuff.

12588
09:09:26,830 --> 09:09:29,712
I'm gonna go over to customer
service and we're gonna see

12589
09:09:29,712 --> 09:09:30,545
that this doesn't work.

12590
09:09:30,545 --> 09:09:33,630
I'm gonna have to replace
this with happy clown stuff.

12591
09:09:33,630 --> 09:09:36,620
And so I can give that JVM
file name whatever I want,

12592
09:09:36,620 --> 09:09:37,950
that's what that's gonna be.

12593
09:09:37,950 --> 09:09:39,650
And so that wouldn't work anymore.

12594
09:09:40,800 --> 09:09:42,160
So of course we would never
wanna name something like that,

12595
09:09:42,160 --> 09:09:46,100
but we can go and take it
back to string extensions.

12596
09:09:46,100 --> 09:09:48,550
We'll save that, again
that's not gonna work

12597
09:09:48,550 --> 09:09:50,470
the string extensions.

12598
09:09:50,470 --> 09:09:53,120
So anytime you are working with something

12599
09:09:53,120 --> 09:09:56,200
like the Kotlin file that has
a lot of top level functions,

12600
09:09:56,200 --> 09:09:57,710
which this is a top level function

12601
09:09:57,710 --> 09:09:59,030
that's not inside of a class.

12602
09:09:59,030 --> 09:10:00,960
It's just basically sitting
inside of a file somewhere

12603
09:10:00,960 --> 09:10:02,810
at the top level function.

12604
09:10:02,810 --> 09:10:05,900
And you need to expose those
to other JVM languages,

12605
09:10:05,900 --> 09:10:09,580
such as Java, and you want it
to have a nice pretty name.

12606
09:10:09,580 --> 09:10:12,270
Go ahead and slap the JVM
name annotation on there

12607
09:10:12,270 --> 09:10:14,880
at the top of the file, and
it will change the name.

12608
09:10:14,880 --> 09:10:17,310
So therefore when you call
it from another language,

12609
09:10:17,310 --> 09:10:19,550
it'll look nice and
won't pollute the code.

12610
09:10:20,830 --> 09:10:22,790
Quick little hack I wanna show you.

12611
09:10:22,790 --> 09:10:24,880
Instead of any file, you
can put a top level function

12612
09:10:24,880 --> 09:10:27,170
called main and inside
of this main function

12613
09:10:28,247 --> 09:10:29,080
anywhere you want, you can print line

12614
09:10:29,080 --> 09:10:30,300
or do whatever you want.

12615
09:10:30,300 --> 09:10:32,210
And what you can do is type code here.

12616
09:10:32,210 --> 09:10:35,460
Now I can actually run this
directly here inside of the IDE

12617
09:10:35,460 --> 09:10:36,890
and it will execute this code.

12618
09:10:36,890 --> 09:10:38,920
Now I do have another main file down here,

12619
09:10:38,920 --> 09:10:41,600
which is where my main
application would normally start.

12620
09:10:41,600 --> 09:10:44,510
However, if I'm buried
somewhere in my application

12621
09:10:44,510 --> 09:10:46,040
and I would like to test out a quick idea,

12622
09:10:46,040 --> 09:10:48,980
maybe I'm kind of working with
the red I wanna play with.

12623
09:10:48,980 --> 09:10:51,030
I can just run this directly
right here and I can hit run.

12624
09:10:51,030 --> 09:10:53,763
I can do debugging everything.

12625
09:10:53,763 --> 09:10:56,320
And if I hit run down in the
output window, we'll see foo.

12626
09:10:56,320 --> 09:10:58,620
So this can be anywhere,
I can take this here.

12627
09:10:59,825 --> 09:11:00,658
I can go over to a customer class.

12628
09:11:00,658 --> 09:11:02,110
I can put a function over here

12629
09:11:05,500 --> 09:11:06,580
and I can do something here

12630
09:11:06,580 --> 09:11:07,930
and I can run something from here.

12631
09:11:07,930 --> 09:11:10,210
So anywhere you put a main
on top of main function,

12632
09:11:10,210 --> 09:11:12,110
you can execute it with inside of the IDE

12633
09:11:12,110 --> 09:11:15,150
for quick feedback loop
inside of IntelliJ.

12634
09:11:15,150 --> 09:11:17,540
Sometimes you wanna
interact with your code

12635
09:11:17,540 --> 09:11:20,780
and a session where you
can kind of play with it.

12636
09:11:20,780 --> 09:11:23,050
One way you can do that
is with the Kotlin repl,

12637
09:11:23,050 --> 09:11:25,230
which is a real evil print loop.

12638
09:11:26,070 --> 09:11:28,890
And to do that again, that's
through tools, Kotlin,

12639
09:11:28,890 --> 09:11:32,600
Kotlin repl, and once
everything is loaded,

12640
09:11:32,600 --> 09:11:34,030
then you can start typing code into here.

12641
09:11:34,030 --> 09:11:36,320
So for example, let's assume
that we wanted to go ahead

12642
09:11:36,320 --> 09:11:37,610
and build a string.

12643
09:11:37,610 --> 09:11:40,500
So we say val name equals Donn.

12644
09:11:41,590 --> 09:11:43,710
And then I use command enter
to enter into a new line.

12645
09:11:43,710 --> 09:11:46,680
I can say name.length, command line.

12646
09:11:46,680 --> 09:11:49,730
It'll tell me if they integer
it's four characters long.

12647
09:11:50,710 --> 09:11:53,160
I can do other things such
as name that substring

12648
09:11:56,010 --> 09:11:58,460
and I'll get the nice IntelliSense in here

12649
09:11:58,460 --> 09:12:00,390
or code completion.

12650
09:12:00,390 --> 09:12:02,340
And we go with the first
character, there is D.

12651
09:12:02,340 --> 09:12:05,670
I can also use, for example,
some of the classes I have.

12652
09:12:05,670 --> 09:12:08,150
I have a customer class
here, which is a data class.

12653
09:12:08,150 --> 09:12:10,879
I can use that inside of my
repl, 'cause it was loaded,

12654
09:12:10,879 --> 09:12:11,940
so I can say customer.

12655
09:12:11,940 --> 09:12:14,330
So I can go down tab, and what will happen

12656
09:12:14,330 --> 09:12:16,760
is you'll see it actually
imported customer there for me.

12657
09:12:16,760 --> 09:12:21,760
And so I'm gonna say val
customer equals customer

12658
09:12:24,260 --> 09:12:25,810
Donn enter.

12659
09:12:26,690 --> 09:12:28,550
And so had to import it
because if I don't import it,

12660
09:12:28,550 --> 09:12:30,130
I won't know about it inside of the repl.

12661
09:12:30,130 --> 09:12:32,110
So I can say customer and if
I hit enter on a customer,

12662
09:12:32,110 --> 09:12:34,010
it'll tell me the type of the customer

12663
09:12:34,976 --> 09:12:36,360
and then what the two string value is.

12664
09:12:36,360 --> 09:12:37,890
And so I can say customer.name.

12665
09:12:41,612 --> 09:12:43,440
I can also do customer.name.initials.

12666
09:12:44,806 --> 09:12:49,806
Now notice this I'm actually
calling in a extension function

12667
09:12:52,170 --> 09:12:53,410
that I have, it's called initials

12668
09:12:53,410 --> 09:12:55,712
and we we have an exception there.

12669
09:12:55,712 --> 09:12:56,545
And the reason why we got an exception

12670
09:12:56,545 --> 09:12:58,720
is because the string value of customer,

12671
09:12:58,720 --> 09:13:00,290
it does not have a space in it.

12672
09:13:00,290 --> 09:13:01,880
So if I were to redefine my customer,

12673
09:13:01,880 --> 09:13:03,280
so we'd do another customer,

12674
09:13:05,175 --> 09:13:07,200
customer two equals Howard Parr.

12675
09:13:08,155 --> 09:13:08,988
I had my full name with a space

12676
09:13:08,988 --> 09:13:10,480
then the initials function would work.

12677
09:13:11,840 --> 09:13:12,673
And I didn't tell it to execute yet,

12678
09:13:12,673 --> 09:13:15,430
I just pressed the enter,

12679
09:13:15,430 --> 09:13:20,130
and I say, initial
customer two.name.initials.

12680
09:13:20,130 --> 09:13:20,963
Now, if I enter here,

12681
09:13:20,963 --> 09:13:23,270
we'll see that it does execute properly.

12682
09:13:23,270 --> 09:13:26,180
So you can actually interact
and do all different types

12683
09:13:26,180 --> 09:13:28,890
of things inside of the Kotlin repl.

12684
09:13:28,890 --> 09:13:32,110
And again, that's access
via the tools, Kotlin.

12685
09:13:32,110 --> 09:13:33,531
Kotlin repl.

12686
09:13:33,531 --> 09:13:34,730
So it's a good place to
come around and play around

12687
09:13:34,730 --> 09:13:37,130
with some code that you're maybe testing,

12688
09:13:37,130 --> 09:13:38,730
trying to figure out if
it's going to work or not.

12689
09:13:38,730 --> 09:13:41,710
Maybe you're trying to
understand a certain interaction

12690
09:13:41,710 --> 09:13:43,942
with the library and you don't
wanna fire up an application.

12691
09:13:43,942 --> 09:13:45,890
The repl is a great place
where you can do that.

12692
09:13:45,890 --> 09:13:47,750
And when you're done, you
can go ahead and over here

12693
09:13:47,750 --> 09:13:50,600
and hit the close button and
then you're out of the repl.

12694
09:13:51,760 --> 09:13:55,290
So let's go ahead and
create a actual Kotlin

12695
09:13:55,290 --> 09:13:56,420
simple calculator.

12696
09:13:56,420 --> 09:13:57,520
To do that, you open IntelliJ,

12697
09:13:57,520 --> 09:14:00,300
you'll click create new project.

12698
09:14:00,300 --> 09:14:03,310
You're gonna wanna select
Kotlin from the left-hand side,

12699
09:14:03,310 --> 09:14:04,280
then JVM idea.

12700
09:14:06,637 --> 09:14:09,180
You wanna give it a name, I
want to say simple calculator.

12701
09:14:10,680 --> 09:14:13,810
You can you leave these
default settings enabled

12702
09:14:13,810 --> 09:14:14,643
and hit finish.

12703
09:14:16,970 --> 09:14:19,697
This is gonna go ahead and
create a new project for us.

12704
09:14:19,697 --> 09:14:20,730
On the left-hand side if the
project window is not open,

12705
09:14:20,730 --> 09:14:23,732
go ahead and click the
project window to open it,

12706
09:14:23,732 --> 09:14:24,565
the project explorer.

12707
09:14:24,565 --> 09:14:27,217
And instead of SRC, we're
just gonna create a new file.

12708
09:14:27,217 --> 09:14:28,660
So you can right click or command in.

12709
09:14:30,379 --> 09:14:33,150
So right click new cotton file class.

12710
09:14:33,150 --> 09:14:34,350
I wanna call it main.kt.

12711
09:14:36,980 --> 09:14:37,910
Now it's an empty file here.

12712
09:14:37,910 --> 09:14:39,680
Now at this point in time,
we needed to go ahead

12713
09:14:39,680 --> 09:14:43,860
and fill this out so we can say fun main.

12714
09:14:43,860 --> 09:14:46,360
That's gonna be the main
function, open and close.

12715
09:14:48,260 --> 09:14:49,860
And now we have a main function.

12716
09:14:52,266 --> 09:14:53,099
Now typically a main function

12717
09:14:53,099 --> 09:14:56,142
will have some type of
parameters it can be parsed to it

12718
09:14:56,142 --> 09:14:56,975
from a command line.

12719
09:14:56,975 --> 09:14:59,588
So that's gonna be var Argh, Argh string,

12720
09:14:59,588 --> 09:15:00,421
which means that there
could be many variable

12721
09:15:00,421 --> 09:15:02,340
amount of arguments that are parsed in.

12722
09:15:03,578 --> 09:15:04,411
It's been basically great out

12723
09:15:04,411 --> 09:15:05,950
'cause they're not used right now.

12724
09:15:07,638 --> 09:15:08,471
So none at this point in time,

12725
09:15:08,471 --> 09:15:09,870
we're ready to start
building our application.

12726
09:15:09,870 --> 09:15:11,980
And the first thing we can
do is provide some type

12727
09:15:11,980 --> 09:15:16,980
of basic output and we'll
say, please enter and arith.

12728
09:15:21,230 --> 09:15:22,980
Please enter an arithmetic problem.

12729
09:15:24,693 --> 09:15:27,147
And if we save this and then
we click this little run button

12730
09:15:27,147 --> 09:15:29,420
now and hit run main kt, will
know this is going to build

12731
09:15:29,420 --> 09:15:31,260
down here, and then down at the bottom,

12732
09:15:31,260 --> 09:15:32,890
the run window will open and it'll say,

12733
09:15:32,890 --> 09:15:35,090
please enter an arithmetic problem.

12734
09:15:35,090 --> 09:15:36,860
At this point in time,
you've actually created

12735
09:15:36,860 --> 09:15:40,060
your first Kotlin program,
though all it does really

12736
09:15:40,060 --> 09:15:43,450
is write some text to a console and exit,

12737
09:15:43,450 --> 09:15:46,049
and we can see that
the program has exited.

12738
09:15:46,049 --> 09:15:47,400
So basically the execution of program

12739
09:15:47,400 --> 09:15:48,700
started the main function.

12740
09:15:49,779 --> 09:15:51,780
It printed this, had nothing
left to do and it exited.

12741
09:15:51,780 --> 09:15:54,617
So that is the beginning
of our application.

12742
09:15:54,617 --> 09:15:57,620
So we've built the first
version of our application,

12743
09:15:57,620 --> 09:16:00,510
but we need to receive
some input from the user.

12744
09:16:00,510 --> 09:16:02,970
And to do that, we can
use the read line function

12745
09:16:02,970 --> 09:16:04,920
that's built into kotlin.io.

12746
09:16:04,920 --> 09:16:07,130
And his is built into the platform.

12747
09:16:07,130 --> 09:16:09,240
And this allows us to read
some input from the user

12748
09:16:09,240 --> 09:16:10,490
on the command line.

12749
09:16:10,490 --> 09:16:12,590
And then what we can do is say print line,

12750
09:16:13,815 --> 09:16:15,840
let's say you entered the
value that you entered

12751
09:16:15,840 --> 09:16:17,190
using string interpolation.

12752
09:16:18,280 --> 09:16:21,941
And if we go ahead and run
this now in the output window,

12753
09:16:21,941 --> 09:16:24,050
down below, what you're
going to see down here

12754
09:16:24,050 --> 09:16:26,470
is that please enter
your arithmetic problem.

12755
09:16:26,470 --> 09:16:30,250
Let's see one plus two and
then we'll see over here

12756
09:16:30,250 --> 09:16:32,130
that you entered one plus two,

12757
09:16:33,558 --> 09:16:34,720
and then of course the application exited

12758
09:16:34,720 --> 09:16:36,340
at that point in time.

12759
09:16:36,340 --> 09:16:39,030
So this works great, we
can now get some values

12760
09:16:39,030 --> 09:16:39,863
from the user.

12761
09:16:39,863 --> 09:16:42,030
But just like a regular calculator,

12762
09:16:42,030 --> 09:16:44,580
a calculator is not going
to stop after you enter

12763
09:16:44,580 --> 09:16:46,670
one problem, so we need to
enter multiple problems.

12764
09:16:46,670 --> 09:16:49,670
And this is a perfect
opportunity to use a wile loop.

12765
09:16:49,670 --> 09:16:52,740
So what we're gonna say is,
while while is not null,

12766
09:16:54,650 --> 09:16:58,590
then we can go ahead and grab some values.

12767
09:16:58,590 --> 09:17:03,590
And so it we'll say here is we
need to get the input again,

12768
09:17:08,984 --> 09:17:10,657
and then let's go ahead
and print this here.

12769
09:17:11,669 --> 09:17:12,768
So we did val, we need
to make this a var now,

12770
09:17:12,768 --> 09:17:15,681
'cause we're gonna be
resetting it every time.

12771
09:17:15,681 --> 09:17:17,360
Now let's go ahead and
print line what we know

12772
09:17:18,465 --> 09:17:21,750
you entered input.

12773
09:17:21,750 --> 09:17:23,490
Now we're gonna run into a problem here

12774
09:17:23,490 --> 09:17:27,740
because we haven't told a way
for the while line to exit.

12775
09:17:27,740 --> 09:17:30,030
And if we know anything
about the read line,

12776
09:17:30,030 --> 09:17:32,660
what read line says is
it will return a read

12777
09:17:32,660 --> 09:17:35,550
or null if the input stream
is redirected to the file.

12778
09:17:35,550 --> 09:17:36,840
We're not redirecting to a file,

12779
09:17:36,840 --> 09:17:38,830
so we're not going to get null back.

12780
09:17:38,830 --> 09:17:41,680
So if I press enter, we're
probably gonna get a line feed

12781
09:17:42,515 --> 09:17:43,348
inside of here.

12782
09:17:43,348 --> 09:17:45,836
So what we need to do is
have a way to short circuit

12783
09:17:45,836 --> 09:17:46,669
out of the wild loop.

12784
09:17:46,669 --> 09:17:49,260
Otherwise this chunk of code
will just continually run on

12785
09:17:49,260 --> 09:17:50,910
forever, there's no way
for us to get out of it.

12786
09:17:50,910 --> 09:17:53,110
So if we were to run this
now, let's go and see

12787
09:17:53,110 --> 09:17:54,550
what that looks like.

12788
09:17:54,550 --> 09:17:57,530
Let's run it and that's enter a problem.

12789
09:17:57,530 --> 09:18:02,493
One plus two, okay, two plus
three, five divided by 10.

12790
09:18:03,590 --> 09:18:08,510
If I enter, we can't get
out of this, we're stuck.

12791
09:18:08,510 --> 09:18:10,270
So we need to wait it to
short suit circuit out.

12792
09:18:10,270 --> 09:18:11,961
So I'm gonna stop the program.

12793
09:18:11,961 --> 09:18:14,310
So we do need to actually figure out a way

12794
09:18:14,310 --> 09:18:15,143
to get out of this.

12795
09:18:15,143 --> 09:18:17,610
So what we can do is we can check to see

12796
09:18:18,453 --> 09:18:19,286
if the input is null.

12797
09:18:19,286 --> 09:18:20,600
So if the input does not equal to null,

12798
09:18:21,640 --> 09:18:22,473
that's what we're doing,
but let's also check

12799
09:18:22,473 --> 09:18:23,306
to see if it's empty.

12800
09:18:23,306 --> 09:18:27,770
So, and the input is not blank.

12801
09:18:28,850 --> 09:18:31,590
So if we go look at the
implementation of that,

12802
09:18:31,590 --> 09:18:34,650
returns true if it's not empty
and contains some characters

12803
09:18:34,650 --> 09:18:36,350
except the white space characters.

12804
09:18:37,736 --> 09:18:38,569
So we wanna make sure it's not blank

12805
09:18:38,569 --> 09:18:39,610
it just contain something.

12806
09:18:41,446 --> 09:18:44,176
So if that's the case,
then this piece of code

12807
09:18:44,176 --> 09:18:45,009
will just continue executing.

12808
09:18:45,009 --> 09:18:46,700
And this will be the main in a moment,

12809
09:18:47,675 --> 09:18:49,390
this would be the main
section of our calculator app.

12810
09:18:50,406 --> 09:18:51,239
So let's go ahead and run this again

12811
09:18:51,239 --> 09:18:52,072
to see what this looks like.

12812
09:18:53,400 --> 09:18:56,300
And once we run this, we'll
see, okay, one plus two,

12813
09:18:56,300 --> 09:18:58,160
there we go, we got two plus three,

12814
09:18:59,561 --> 09:19:00,394
we got five divided by 10,

12815
09:19:00,394 --> 09:19:01,440
so we can keep entering
things over and over.

12816
09:19:01,440 --> 09:19:04,410
However, now if I press
enter, what we're gonna see

12817
09:19:04,410 --> 09:19:07,220
is that the process finished right there.

12818
09:19:07,220 --> 09:19:08,840
So it exited out of the application,

12819
09:19:08,840 --> 09:19:13,840
because what it made it exit
out is basically it is blank.

12820
09:19:15,430 --> 09:19:17,860
So therefore it only
continues if it's not blank.

12821
09:19:17,860 --> 09:19:20,040
Therefore the application
said, well, it's blank.

12822
09:19:20,040 --> 09:19:22,250
And at that point it exited.

12823
09:19:22,250 --> 09:19:24,621
So now you can do a couple of things here.

12824
09:19:24,621 --> 09:19:26,250
So if you wanted to say goodbye,

12825
09:19:27,437 --> 09:19:28,270
you could pretty much do that right here.

12826
09:19:28,270 --> 09:19:29,990
You could say print ln goodbye.

12827
09:19:34,491 --> 09:19:35,660
And then you would know that
the proper program exited.

12828
09:19:35,660 --> 09:19:37,410
So we could do this very easily.

12829
09:19:37,410 --> 09:19:40,610
You'd hit run here and now we can enter

12830
09:19:41,729 --> 09:19:44,530
that arithmetic problems,
one plus two, three,

12831
09:19:44,530 --> 09:19:47,903
33 plus two and an enter
and I was like, goodbye.

12832
09:19:47,903 --> 09:19:48,736
And then it exits.

12833
09:19:48,736 --> 09:19:50,660
So we know that the
actual program is exiting.

12834
09:19:51,881 --> 09:19:52,714
Of course, we do know
that already from here,

12835
09:19:52,714 --> 09:19:53,750
but when we compile it later,

12836
09:19:53,750 --> 09:19:56,470
it would be nice to have
some user feedback to say,

12837
09:19:56,470 --> 09:19:58,270
hey, we're done with the program.

12838
09:19:58,270 --> 09:20:01,000
So now we can actually
create our calculator

12839
09:20:01,000 --> 09:20:02,860
inside of this piece here,

12840
09:20:02,860 --> 09:20:05,850
because we can now process
many different problems.

12841
09:20:05,850 --> 09:20:07,050
One after another.

12842
09:20:07,050 --> 09:20:09,020
Each time we're gonna get some new input

12843
09:20:09,020 --> 09:20:11,420
via this read line method,
which then will change.

12844
09:20:11,420 --> 09:20:13,020
And then we can process it,

12845
09:20:13,020 --> 09:20:14,970
which we'll end up doing right in here.

12846
09:20:16,030 --> 09:20:17,630
Now that we have the user input,

12847
09:20:17,630 --> 09:20:20,420
we need to decide what to
do with that user input.

12848
09:20:20,420 --> 09:20:21,580
So when you kind of need to break it apart

12849
09:20:21,580 --> 09:20:23,662
into a couple of sections.

12850
09:20:23,662 --> 09:20:25,890
If we have a problem
that's entered like this,

12851
09:20:25,890 --> 09:20:27,310
we need three different components.

12852
09:20:27,310 --> 09:20:29,610
We need the first number when the operator

12853
09:20:30,470 --> 09:20:31,970
and we need the second number.

12854
09:20:33,125 --> 09:20:33,958
So we're gonna need three
different types of variables

12855
09:20:33,958 --> 09:20:34,791
from that one string.

12856
09:20:35,754 --> 09:20:36,710
And we can do that very easily,

12857
09:20:36,710 --> 09:20:37,870
so it's go and get rid of this.

12858
09:20:37,870 --> 09:20:41,340
We can do it very easily by
declaring another variable

12859
09:20:41,340 --> 09:20:42,920
called values.

12860
09:20:42,920 --> 09:20:44,840
And what we're going to
do is we're gonna split

12861
09:20:44,840 --> 09:20:48,410
the string on a space.

12862
09:20:48,410 --> 09:20:50,750
And what that will do is it'll
give us a list of strings

12863
09:20:50,750 --> 09:20:52,480
that we can go ahead and check on.

12864
09:20:52,480 --> 09:20:53,610
So let's go ahead and take a look

12865
09:20:53,610 --> 09:20:54,980
at each one of these strings.

12866
09:20:54,980 --> 09:20:58,220
So we'll say values zero.

12867
09:20:58,220 --> 09:21:01,240
I'm gonna duplicate this line
a few times, one and two.

12868
09:21:02,624 --> 09:21:04,430
Now of course, this is
not gonna be error proof.

12869
09:21:05,384 --> 09:21:07,450
If for some reason we do not
get enough values in here,

12870
09:21:07,450 --> 09:21:09,800
we could crash the program,

12871
09:21:11,138 --> 09:21:11,971
which we'll see here in a second.

12872
09:21:11,971 --> 09:21:15,000
If we run the main program,
what we'll see here,

12873
09:21:15,000 --> 09:21:17,760
please enter arithmetic
problem one plus two.

12874
09:21:17,760 --> 09:21:20,195
We'll then see that we
have all of the operators

12875
09:21:20,195 --> 09:21:22,350
now separated, so we have
the number one, number two.

12876
09:21:22,350 --> 09:21:24,500
If we were to do five plus four,

12877
09:21:25,390 --> 09:21:26,410
we would get those broken apart.

12878
09:21:26,410 --> 09:21:28,540
But if I only put five in here,

12879
09:21:28,540 --> 09:21:31,150
we're gonna get an index
out of bounds exception

12880
09:21:31,150 --> 09:21:32,980
right here on the 10th line,

12881
09:21:32,980 --> 09:21:36,240
because I'm just pressing
press five in there

12882
09:21:36,240 --> 09:21:38,550
is split on a string, so it's
not finding this and saying,

12883
09:21:38,550 --> 09:21:41,400
hey, there is nothing inside of here.

12884
09:21:42,614 --> 09:21:43,590
It looks like by found a
string or or a new line

12885
09:21:43,590 --> 09:21:44,540
or something there.

12886
09:21:45,820 --> 09:21:48,290
So we can't find anything in that regard.

12887
09:21:48,290 --> 09:21:50,490
So we're gonna go ahead
and don't acception.

12888
09:21:51,640 --> 09:21:53,060
So this isn't really
foolproof, but it does give us

12889
09:21:53,060 --> 09:21:57,310
the ability to actually start
performing our operation.

12890
09:21:57,310 --> 09:21:59,340
Now, the one that's really
important to us right now

12891
09:21:59,340 --> 09:22:01,470
is actually this first one.

12892
09:22:01,470 --> 09:22:05,010
And this is because this is
what's gonna give us our plus,

12893
09:22:05,010 --> 09:22:09,210
our minus our multiplication
or our divide operator.

12894
09:22:09,210 --> 09:22:10,689
And then at that point,

12895
09:22:10,689 --> 09:22:14,150
we can decide how we wanna
progress in our application.

12896
09:22:14,150 --> 09:22:19,150
And so, based upon if
this value is a plus sign,

12897
09:22:23,960 --> 09:22:26,990
well, then at that point, I
wanna do add something together.

12898
09:22:28,200 --> 09:22:30,900
And so it's gonna say we're
actually doing print line.

12899
09:22:32,080 --> 09:22:33,060
There we go.

12900
09:22:33,060 --> 09:22:35,470
If the value is a plus
sign, then we're gonna go on

12901
09:22:35,470 --> 09:22:37,940
and go ahead and add it together.

12902
09:22:37,940 --> 09:22:41,130
Otherwise, you know, we
can say else if values

12903
09:22:42,030 --> 09:22:46,310
is values one equals equals minus,

12904
09:22:46,310 --> 09:22:48,310
then we can do something else.

12905
09:22:48,310 --> 09:22:51,170
So we could continue this
path down of else if.

12906
09:22:51,170 --> 09:22:52,840
And this will work, there's
nothing wrong with this.

12907
09:22:52,840 --> 09:22:54,810
We could do this, this'll work.

12908
09:22:54,810 --> 09:22:57,070
However, it does get a little clunky.

12909
09:22:57,070 --> 09:22:59,090
This is a perfect opportunity for us

12910
09:22:59,090 --> 09:23:01,700
to use a when statement.

12911
09:23:01,700 --> 09:23:06,000
So I'm gonna say when values
one, so check that value one.

12912
09:23:07,974 --> 09:23:12,117
And when you say is plus
I wanna do something,

12913
09:23:13,080 --> 09:23:14,610
so, say print line, when is.

12914
09:23:24,270 --> 09:23:25,630
And it is not gonna be needed here

12915
09:23:25,630 --> 09:23:27,880
because we're actually
just using it to directly

12916
09:23:27,880 --> 09:23:28,780
against the value.

12917
09:23:30,110 --> 09:23:34,250
So we'll say, plus, we can say minus

12918
09:23:39,799 --> 09:23:42,030
that's it print line, subtract.

12919
09:23:44,529 --> 09:23:45,362
I'll go ahead and
duplicate these real quick.

12920
09:23:45,362 --> 09:23:47,326
And then we can go ahead
and of course we'll say

12921
09:23:47,326 --> 09:23:48,640
multiply and divide.

12922
09:23:48,640 --> 09:23:53,100
It'd be pretty easy and divide.

12923
09:23:56,100 --> 09:23:57,130
And then for whatever reason,

12924
09:23:57,130 --> 09:23:59,130
if we don't have something that matches,

12925
09:24:00,377 --> 09:24:02,927
we might wanna say, throw
legal argument exception.

12926
09:24:07,057 --> 09:24:10,000
Let me say invalid operator
and we'll just go ahead

12927
09:24:10,000 --> 09:24:13,040
and parse in whatever that value is.

12928
09:24:14,610 --> 09:24:18,660
So parse it in and values one.

12929
09:24:18,660 --> 09:24:19,750
And then that's gonna allow us to go

12930
09:24:19,750 --> 09:24:20,850
and get rid of this down here.

12931
09:24:20,850 --> 09:24:23,620
This will allow us to actually
see and do to something

12932
09:24:23,620 --> 09:24:26,872
different based upon each
one of these input types.

12933
09:24:26,872 --> 09:24:27,705
So let's go ahead and run this program.

12934
09:24:27,705 --> 09:24:31,550
We'll put a few of the
arithmetic problems in here.

12935
09:24:31,550 --> 09:24:34,690
So one plus one, so it
looks like we have add.

12936
09:24:34,690 --> 09:24:38,800
So I have one minus four, subtract.

12937
09:24:38,800 --> 09:24:43,290
We have six times seven, multiply,

12938
09:24:43,290 --> 09:24:47,470
42 divided by 10 is divide.

12939
09:24:47,470 --> 09:24:50,320
And let's go ahead and just
throw something crazy in there.

12940
09:24:50,320 --> 09:24:53,220
Let's do like for example,
maybe we wanna do powers of,

12941
09:24:53,220 --> 09:24:54,400
but we haven't implemented it.

12942
09:24:54,400 --> 09:24:57,130
We could do 10 to the power of five.

12943
09:24:58,100 --> 09:25:01,280
Boom, we have an exception
invalid operator.

12944
09:25:01,280 --> 09:25:03,220
And we add D to the power of operator,

12945
09:25:03,220 --> 09:25:06,220
which is normally used in
map instead of programs.

12946
09:25:06,220 --> 09:25:09,220
So here, our calculator
is a simple calculator.

12947
09:25:09,220 --> 09:25:13,310
It's only gonna process these
different types of inputs.

12948
09:25:13,310 --> 09:25:16,100
So now let's go ahead and
implement each one of these

12949
09:25:16,100 --> 09:25:18,050
and I'll be right back while I do that.

12950
09:25:18,887 --> 09:25:19,720
So you don't have to see me type.

12951
09:25:19,720 --> 09:25:20,553
Okay, now we're back.

12952
09:25:20,553 --> 09:25:24,400
So I've done this very easily,
I've taken the first value.

12953
09:25:24,400 --> 09:25:26,960
I convert it to a double
and take the second value

12954
09:25:26,960 --> 09:25:27,890
and I converted to a double.

12955
09:25:27,890 --> 09:25:29,190
I've converted everything to doubles here

12956
09:25:29,190 --> 09:25:31,037
so we don't lose any precision.

12957
09:25:31,037 --> 09:25:32,520
Now there's one thing I would like to do,

12958
09:25:32,520 --> 09:25:34,420
that would like to clean
this up a little bit.

12959
09:25:34,420 --> 09:25:37,070
So what I'm gonna do here
is let me go ahead and say,

12960
09:25:38,730 --> 09:25:42,740
I'm gonna refactor this,
and I'm just gonna say,

12961
09:25:42,740 --> 09:25:44,280
extract this into a variable.

12962
09:25:45,310 --> 09:25:47,190
And it's gonna ask me to
replace two occurrences

12963
09:25:47,190 --> 09:25:49,040
because it's occurring two places.

12964
09:25:49,040 --> 09:25:51,210
Sure and we call this operator,

12965
09:25:52,340 --> 09:25:53,900
just so it reads a little bit better.

12966
09:25:58,230 --> 09:26:00,080
It's actually saying we can
move it into the declaration

12967
09:26:00,080 --> 09:26:00,913
of the when.

12968
09:26:01,993 --> 09:26:04,080
And if we were to do that,
here's what it would look like.

12969
09:26:04,080 --> 09:26:05,790
I could just move that
into the declaration there.

12970
09:26:05,790 --> 09:26:07,660
I don't like the way that
looks, it looks a little bit,

12971
09:26:07,660 --> 09:26:09,010
it's too much for me to read.

12972
09:26:09,010 --> 09:26:10,420
This is a lot easier for me to read,

12973
09:26:10,420 --> 09:26:12,400
so I'm gonna leave it like that.

12974
09:26:12,400 --> 09:26:13,400
So I'm the operator.

12975
09:26:15,853 --> 09:26:16,880
And then what I could also
say is something like this.

12976
09:26:16,880 --> 09:26:19,990
I could go ahead and extract
this good refractor it.

12977
09:26:21,327 --> 09:26:22,340
I can extract this into a variable

12978
09:26:23,580 --> 09:26:24,700
and it does occur four times.

12979
09:26:24,700 --> 09:26:28,019
So we were repeating ourselves,
which could be problematic

12980
09:26:28,019 --> 09:26:28,852
for updating our code later.

12981
09:26:28,852 --> 09:26:30,840
So I'm gonna call this
LHS for left-hand side.

12982
09:26:33,436 --> 09:26:34,320
I'm gonna do the same thing over here.

12983
09:26:38,137 --> 09:26:39,381
I'm gonna go out and extract a variable.

12984
09:26:39,381 --> 09:26:40,700
We're gonna call right-hand side RHS

12985
09:26:41,791 --> 09:26:42,630
for all four occurrences.

12986
09:26:44,280 --> 09:26:48,980
So now we have our ever input
and we've got our operator,

12987
09:26:48,980 --> 09:26:50,500
our left hand side and
our right hand side.

12988
09:26:50,500 --> 09:26:52,710
And then this is pretty easy to see.

12989
09:26:52,710 --> 09:26:54,170
So when the operator is a plus sign,

12990
09:26:54,170 --> 09:26:56,220
we're gonna go ahead and print out the...

12991
09:26:57,286 --> 09:26:59,235
We're gonna convert all
these to doubles and say,

12992
09:26:59,235 --> 09:27:00,360
all right, so we don't lose any precision

12993
09:27:00,360 --> 09:27:02,990
which can happen sometimes in
multiplication and division,

12994
09:27:02,990 --> 09:27:05,115
depending upon what you're doing.

12995
09:27:05,115 --> 09:27:06,511
And then we're gonna go ahead

12996
09:27:06,511 --> 09:27:07,420
and actually perform the operation.

12997
09:27:07,420 --> 09:27:09,020
And then what we're gonna
do at that point in time

12998
09:27:09,020 --> 09:27:10,600
is we're gonna go and print that value

12999
09:27:10,600 --> 09:27:13,834
and then we're gonna go
ahead and do a read line.

13000
09:27:13,834 --> 09:27:15,310
So let's go and run this
to see what happens.

13001
09:27:17,140 --> 09:27:20,880
So I've entered arithmetic
problem one plus one, we get two.

13002
09:27:20,880 --> 09:27:24,160
Two times five and we see an index

13003
09:27:24,160 --> 09:27:25,340
right out of our exception.

13004
09:27:25,340 --> 09:27:27,288
That's because we didn't
put a space there.

13005
09:27:27,288 --> 09:27:29,030
So we do have a cup, some input problems

13006
09:27:29,030 --> 09:27:30,840
that we probably do need to process.

13007
09:27:30,840 --> 09:27:32,870
So let's go and see if we
can get you to one of these

13008
09:27:32,870 --> 09:27:33,820
to run accordingly.

13009
09:27:36,020 --> 09:27:39,360
So we already did a plus let's
go ahead and do a subtraction

13010
09:27:40,590 --> 09:27:41,490
minus six.

13011
09:27:41,490 --> 09:27:45,980
Okay, that makes sense,
eight times seven, 56.

13012
09:27:45,980 --> 09:27:50,530
Let's do 60 divided by ten, six.

13013
09:27:50,530 --> 09:27:51,810
So all that makes sense.

13014
09:27:51,810 --> 09:27:56,381
So our application does work
now, we now have a application,

13015
09:27:56,381 --> 09:28:01,381
which is a simple calculator
that shows us how to do adding,

13016
09:28:01,400 --> 09:28:03,150
subtracting, multiplying, dividing.

13017
09:28:04,300 --> 09:28:06,110
Our application works fine at this point,

13018
09:28:06,110 --> 09:28:08,720
but we do need to provide
some type of validation.

13019
09:28:08,720 --> 09:28:12,130
For example, let's go ahead
and run our application.

13020
09:28:12,130 --> 09:28:15,349
And let's assume that we
make a mistake during typing,

13021
09:28:15,349 --> 09:28:16,182
which could be very common.

13022
09:28:16,182 --> 09:28:18,910
We say one plus, and we forget to enter,

13023
09:28:18,910 --> 09:28:20,470
what, let's say one plus one works,

13024
09:28:20,470 --> 09:28:22,310
but we do one plus and we forget to enter

13025
09:28:22,310 --> 09:28:24,380
the additional value and we hit enter.

13026
09:28:25,626 --> 09:28:28,394
We receive an index out
of bounds exception.

13027
09:28:28,394 --> 09:28:29,480
So what we need to do
is check that we have

13028
09:28:29,480 --> 09:28:31,831
the proper number of arguments.

13029
09:28:31,831 --> 09:28:34,310
So what we can do is
say, if values dot size

13030
09:28:35,290 --> 09:28:36,750
is less than three, 'cause we need

13031
09:28:36,750 --> 09:28:40,060
at least three parameters,
then we're gonna throw

13032
09:28:40,060 --> 09:28:44,220
an illegal argument exception,
let's say invalid input,

13033
09:28:47,584 --> 09:28:51,153
expected value plus value received.

13034
09:28:54,250 --> 09:28:55,850
And then whatever the input was.

13035
09:28:57,750 --> 09:28:58,910
So now if we run this, what will happen

13036
09:29:00,276 --> 09:29:01,960
is we're not gonna get index
out of bounds exception.

13037
09:29:01,960 --> 09:29:05,200
What will happen is we can
still enter one plus one.

13038
09:29:05,200 --> 09:29:06,985
We'll still get that.

13039
09:29:06,985 --> 09:29:09,150
But if we enter one plus
something, we forget to enter

13040
09:29:09,150 --> 09:29:12,210
the additional value, we'll
now get an legal argument,

13041
09:29:12,210 --> 09:29:13,500
exception that was thrown.

13042
09:29:13,500 --> 09:29:16,350
It's an invalid input, expected
value, blah, blah, blah.

13043
09:29:16,350 --> 09:29:17,940
It was this particular value.

13044
09:29:19,934 --> 09:29:20,767
Now you could decide to crash the program

13045
09:29:20,767 --> 09:29:23,589
if that's what you'd like
to do, or you can decide

13046
09:29:23,589 --> 09:29:26,620
to skip this completely
so we could change this.

13047
09:29:26,620 --> 09:29:29,400
So instead of having
it throw an exception,

13048
09:29:29,400 --> 09:29:32,200
we could actually just
have it say print line.

13049
09:29:34,530 --> 09:29:36,740
We print line of idle
less than three else.

13050
09:29:40,260 --> 09:29:41,490
And then we can wrap everything else

13051
09:29:41,490 --> 09:29:43,480
since I have an else here.

13052
09:29:43,480 --> 09:29:46,180
And what will happen now,
when we run the application,

13053
09:29:49,480 --> 09:29:52,660
run us and we'll go one plus one is two.

13054
09:29:52,660 --> 09:29:55,060
We do one, does it age two plus something,

13055
09:29:55,060 --> 09:29:57,170
we make a mistake, enter, invalid input,

13056
09:29:57,170 --> 09:30:00,729
expected value of up plus
value of received two plus.

13057
09:30:00,729 --> 09:30:03,516
Okay, let's try it again, two plus three.

13058
09:30:03,516 --> 09:30:04,349
Okay, it works.

13059
09:30:04,349 --> 09:30:05,280
So now our application is a crashing.

13060
09:30:05,280 --> 09:30:07,030
We've performed some level of validation.

13061
09:30:07,030 --> 09:30:09,140
We're providing the feedback to the user

13062
09:30:09,140 --> 09:30:11,100
and we can continue using
the app and it works

13063
09:30:11,100 --> 09:30:12,660
as we would expect.

13064
09:30:12,660 --> 09:30:15,090
But we also have another problem.

13065
09:30:15,090 --> 09:30:17,290
The other problem is
gonna be let's go ahead

13066
09:30:18,316 --> 09:30:19,149
and run this.

13067
09:30:19,149 --> 09:30:21,430
What happens if for whatever reason,

13068
09:30:22,930 --> 09:30:25,560
a user enters one plus
two and then the next time

13069
09:30:25,560 --> 09:30:29,680
they say one plus dog,
what's gonna happen there.

13070
09:30:29,680 --> 09:30:31,650
We get another exception from the program

13071
09:30:31,650 --> 09:30:34,350
and the program crashes and
a calculator doesn't know

13072
09:30:34,350 --> 09:30:36,920
how to handle the word string dog.

13073
09:30:36,920 --> 09:30:39,430
And so it says number format exception

13074
09:30:39,430 --> 09:30:41,020
for input string dog.

13075
09:30:41,020 --> 09:30:43,110
And if we take a look at line number 18,

13076
09:30:44,088 --> 09:30:44,921
it's happening right here.

13077
09:30:44,921 --> 09:30:47,641
And the reason why it's happening
is on the right hand side,

13078
09:30:47,641 --> 09:30:49,580
we're trying to convert
that value to RHS value,

13079
09:30:49,580 --> 09:30:51,680
which came from here, which is the second,

13080
09:30:53,004 --> 09:30:53,860
the third item in the list.

13081
09:30:53,860 --> 09:30:55,910
We're trying to convert it to a double

13082
09:30:55,910 --> 09:30:56,970
and that's where the problem occurs.

13083
09:30:56,970 --> 09:30:58,320
So we need to do something here.

13084
09:30:58,320 --> 09:31:01,180
So one quick thing that we can easily do,

13085
09:31:01,180 --> 09:31:03,250
which works very well
because at this point,

13086
09:31:03,250 --> 09:31:05,050
this isn't an illegal argument.

13087
09:31:05,050 --> 09:31:06,150
We shouldn't be able to handle this

13088
09:31:06,150 --> 09:31:08,010
inside of our application.

13089
09:31:08,010 --> 09:31:12,980
What you could do is you
would say to double or null.

13090
09:31:12,980 --> 09:31:15,080
And then what we're gonna
do here is we're gonna do

13091
09:31:15,080 --> 09:31:16,900
the Elvis operator.

13092
09:31:16,900 --> 09:31:20,560
And the Elvis operator says,
hey, if something happens here

13093
09:31:20,560 --> 09:31:23,670
and this is null, the I want
you to return another value.

13094
09:31:23,670 --> 09:31:28,110
And so this is gonna say,
throw legal argument exception,

13095
09:31:30,310 --> 09:31:31,170
invalid input.

13096
09:31:33,712 --> 09:31:34,545
And then we'll go ahead
and actually just go ahead

13097
09:31:34,545 --> 09:31:37,170
and render that input values zero.

13098
09:31:39,320 --> 09:31:42,170
Now what's gonna happen here
is if this value right here

13099
09:31:42,170 --> 09:31:44,810
can be converted to a
double, it will be converted

13100
09:31:44,810 --> 09:31:46,600
to a double and it will be returned here.

13101
09:31:46,600 --> 09:31:48,570
Otherwise, if it can not
be returned to a double,

13102
09:31:48,570 --> 09:31:50,070
a null will be returned.

13103
09:31:50,070 --> 09:31:52,710
At that point, the Elvis
operator will interrupt

13104
09:31:53,639 --> 09:31:57,000
and say, hey, on the left hand
side over here, this is null,

13105
09:31:57,000 --> 09:31:59,430
so we need to do something
on the right-hand side.

13106
09:32:00,543 --> 09:32:02,180
And then we're telling it,
hey, if you encounter null,

13107
09:32:02,180 --> 09:32:04,000
throw an illegal argument exception.

13108
09:32:04,000 --> 09:32:05,260
So basically we're trying to parse it.

13109
09:32:05,260 --> 09:32:06,450
We couldn't parse it as a double.

13110
09:32:06,450 --> 09:32:08,120
So therefore it was returned as a null,

13111
09:32:08,120 --> 09:32:10,220
and at that point, and
then short-circuited

13112
09:32:10,220 --> 09:32:11,460
to the right-hand side over here.

13113
09:32:11,460 --> 09:32:14,210
So we'll do the same thing
over here to double or null.

13114
09:32:16,013 --> 09:32:17,670
And I'm just gonna copy
this to save some typing.

13115
09:32:19,836 --> 09:32:22,790
There we go, and then
this'll be value one.

13116
09:32:22,790 --> 09:32:25,450
Now, if you could see over
here, all these are grayed out,

13117
09:32:25,450 --> 09:32:28,170
'cause we're already
casting these two a double.

13118
09:32:28,170 --> 09:32:30,370
I can actually remove
these redundant calls.

13119
09:32:31,859 --> 09:32:32,692
So boom, we'll just go ahead
and remove these real fast,

13120
09:32:32,692 --> 09:32:33,550
I'll be right back.

13121
09:32:49,069 --> 09:32:52,050
Okay, now I'm back, we
have our very succinct

13122
09:32:52,050 --> 09:32:56,410
and clean version of our calculation.

13123
09:32:56,410 --> 09:32:59,950
And so very nice here, very succinct here,

13124
09:33:01,146 --> 09:33:02,740
but what's happening and we
can actually print things

13125
09:33:02,740 --> 09:33:03,573
directly to the screen.

13126
09:33:03,573 --> 09:33:06,120
So if we were to run it
now say one plus two,

13127
09:33:12,278 --> 09:33:14,420
we'll get back three,
if I say one plus dog,

13128
09:33:15,620 --> 09:33:17,110
we're gonna get an
illegal argument exception

13129
09:33:17,110 --> 09:33:18,370
and valid input.

13130
09:33:18,370 --> 09:33:20,230
Now, of course, this is
crashing the application.

13131
09:33:20,230 --> 09:33:22,430
So there's a couple of
things that you could do here

13132
09:33:22,430 --> 09:33:24,130
and in which I would challenge you

13133
09:33:24,130 --> 09:33:25,980
that we're not gonna do,
that you could do on your own

13134
09:33:25,980 --> 09:33:28,450
to challenge yourself,
is remove the illegal

13135
09:33:28,450 --> 09:33:29,400
argument exception.

13136
09:33:31,120 --> 09:33:33,320
And you can either
decide to make it a zero.

13137
09:33:34,779 --> 09:33:35,612
So you could just do something like this

13138
09:33:35,612 --> 09:33:37,440
that would make it a zero
so that it would be a double

13139
09:33:38,318 --> 09:33:39,160
or zero, which wouldn't work.

13140
09:33:39,160 --> 09:33:42,268
So because as you see here,

13141
09:33:42,268 --> 09:33:43,880
the type inference has
given you an example,

13142
09:33:43,880 --> 09:33:46,170
or you can go ahead
and say double or null.

13143
09:33:47,682 --> 09:33:48,820
At that point in time,
it could be a double

13144
09:33:48,820 --> 09:33:50,480
and the same thing down here

13145
09:33:50,480 --> 09:33:52,510
and then check to see if you have nulls

13146
09:33:52,510 --> 09:33:53,343
for either one of them.

13147
09:33:53,343 --> 09:33:56,040
If you do, perhaps provide
a message to the user

13148
09:33:56,040 --> 09:33:59,230
and then let the application
continue to keep going.

13149
09:33:59,230 --> 09:34:00,450
Here, though we're just gonna keep this

13150
09:34:00,450 --> 09:34:02,560
where it's gonna continue
to short circuit.

13151
09:34:02,560 --> 09:34:05,220
So at this point in time,
we now have an application

13152
09:34:05,220 --> 09:34:08,130
that tells the user that
they're invalid input

13153
09:34:08,130 --> 09:34:10,930
is occurring for their
first or their second value,

13154
09:34:10,930 --> 09:34:13,050
otherwise it's gonna continue on.

13155
09:34:13,050 --> 09:34:14,150
Now, there's one last little thing

13156
09:34:14,150 --> 09:34:15,910
that I would like to
do here in this program

13157
09:34:15,910 --> 09:34:17,290
to clean it up just a little bit

13158
09:34:17,290 --> 09:34:18,700
'cause we have a little
bit of duplication here

13159
09:34:18,700 --> 09:34:19,900
with this print line.

13160
09:34:19,900 --> 09:34:21,870
And what we can do is we
can actually turn a value

13161
09:34:21,870 --> 09:34:22,900
from a when clause.

13162
09:34:22,900 --> 09:34:26,018
So I'm gonna say val result equals when,

13163
09:34:26,018 --> 09:34:28,420
and then we're just gonna
get rid of these print line

13164
09:34:28,420 --> 09:34:32,120
statements and get rid
of the other parentheses

13165
09:34:32,120 --> 09:34:32,970
on the other end.

13166
09:34:36,701 --> 09:34:38,520
And now we have a double that we can use.

13167
09:34:38,520 --> 09:34:41,000
And then what we can use is just go ahead

13168
09:34:41,000 --> 09:34:43,010
and print line the result.

13169
09:34:44,730 --> 09:34:47,330
And this really cleans up our when clause.

13170
09:34:47,330 --> 09:34:49,660
Now we can actually see,
it's really easy to read

13171
09:34:49,660 --> 09:34:50,930
and it's very easy to follow.

13172
09:34:50,930 --> 09:34:53,950
We have an operator, we have
left-hand side right-hand side.

13173
09:34:53,950 --> 09:34:57,686
Based upon the operator if
it's plus minus multiplication

13174
09:34:57,686 --> 09:34:59,140
or divide, we're gonna
perform those operations

13175
09:34:59,140 --> 09:35:00,930
with the left hand side
in the right hand side.

13176
09:35:00,930 --> 09:35:03,320
Otherwise we don't support
whatever operation is thrown

13177
09:35:03,320 --> 09:35:05,480
and we'll basically throw an exception.

13178
09:35:05,480 --> 09:35:08,336
And then it finally, once
that result is returned,

13179
09:35:08,336 --> 09:35:09,584
we'll go ahead and print the results.

13180
09:35:09,584 --> 09:35:10,417
So let's go ahead and run
the application again,

13181
09:35:10,417 --> 09:35:11,680
just to see what it looks like.

13182
09:35:14,390 --> 09:35:18,020
So one plus two, there's
three, three plus five,

13183
09:35:19,050 --> 09:35:24,050
10 times seven, 70, 90 divided by six, 15.

13184
09:35:27,530 --> 09:35:28,980
So now our application works.

13185
09:35:28,980 --> 09:35:31,770
We've added some validation
in here to accept

13186
09:35:31,770 --> 09:35:34,020
the only valid chunks of input.

13187
09:35:34,020 --> 09:35:37,200
We've made sure that we can
only accept certain parameters

13188
09:35:37,200 --> 09:35:38,770
and we're providing feedback to the user.

13189
09:35:38,770 --> 09:35:41,260
And then of course, when we're
done, we can just hit enter

13190
09:35:42,570 --> 09:35:44,210
and the application will say goodbye,

13191
09:35:44,210 --> 09:35:47,710
that we're completely done
and then the process exits.

13192
09:35:47,710 --> 09:35:50,060
And you've now written
your first calculator app.

13193
09:35:51,222 --> 09:35:52,055
Now the next thing is how to deploy it

13194
09:35:52,055 --> 09:35:53,380
so other people can use it.

13195
09:35:55,375 --> 09:35:56,208
You've built your first application

13196
09:35:56,208 --> 09:35:57,210
and it runs within the IDE.

13197
09:35:57,210 --> 09:35:59,050
However you would like
to share with others,

13198
09:35:59,050 --> 09:36:01,200
to do that, you can build a jar file.

13199
09:36:01,200 --> 09:36:04,210
What you'll need to do is go
to file, project structure.

13200
09:36:05,370 --> 09:36:07,280
You wanna make sure that
you have the artifacts item

13201
09:36:07,280 --> 09:36:10,740
selected on the left-hand
side, you'll hit the plus icon,

13202
09:36:11,770 --> 09:36:15,180
select jar from modules with dependencies

13203
09:36:16,700 --> 09:36:18,680
to make sure your module is selected.

13204
09:36:18,680 --> 09:36:21,750
In our case, simple calculator's
the one that I want.

13205
09:36:21,750 --> 09:36:23,530
Then I'm going to select the main file,

13206
09:36:24,650 --> 09:36:27,100
which has main kt in our
case, we'll click, okay.

13207
09:36:28,310 --> 09:36:31,320
Now at this point you
can press apply and okay,

13208
09:36:31,320 --> 09:36:33,280
you're now ready to build your jar file.

13209
09:36:33,280 --> 09:36:37,250
To do so, you'll go to build
menu and then build artifacts

13210
09:36:38,380 --> 09:36:40,980
and you'll get the pop
up and just click build.

13211
09:36:40,980 --> 09:36:42,710
And you'll notice the build
is happening down here

13212
09:36:42,710 --> 09:36:45,960
in the bottom and actually
it's already done.

13213
09:36:45,960 --> 09:36:48,090
And what will happen
is some files be placed

13214
09:36:48,090 --> 09:36:51,090
into the outfielder, so let's
go and expand those out.

13215
09:36:51,090 --> 09:36:54,610
You'll see artifacts,
simple calculator jar.

13216
09:36:54,610 --> 09:36:57,350
And there is our jar
file that can be executed

13217
09:36:57,350 --> 09:36:58,290
on the command line.

13218
09:36:58,290 --> 09:36:59,850
So you'd be able to actually
send us to someone else

13219
09:36:59,850 --> 09:37:02,230
and they could execute
it, so let's do that.

13220
09:37:02,230 --> 09:37:04,220
I'm gonna right click and open this area

13221
09:37:04,220 --> 09:37:05,910
in the terminal down here.

13222
09:37:05,910 --> 09:37:07,160
And this is gonna open up a terminal

13223
09:37:07,160 --> 09:37:08,790
directly in this folder path here

13224
09:37:08,790 --> 09:37:12,110
so I can see out artifacts,
simple calculator jar.

13225
09:37:13,085 --> 09:37:16,190
So what we see here is this
exact folder that's right here.

13226
09:37:16,190 --> 09:37:19,371
So we are now in the
terminal of this location.

13227
09:37:19,371 --> 09:37:21,990
We can see LS and I can
run this jar file by typing

13228
09:37:21,990 --> 09:37:25,790
Java, jar, simple calculator.jar.

13229
09:37:28,274 --> 09:37:31,143
Hit enter and now our
program is executing.

13230
09:37:31,143 --> 09:37:32,053
Please enter arithmetic problem.

13231
09:37:32,053 --> 09:37:36,560
One plus two is three,
four plus five is this.

13232
09:37:37,740 --> 09:37:41,150
40 divided by seven is that value.

13233
09:37:41,150 --> 09:37:45,890
Eight times 22 is this value.

13234
09:37:45,890 --> 09:37:48,460
Hit enter and of course we get to exit.

13235
09:37:48,460 --> 09:37:51,620
So now you have built your
first Java application,

13236
09:37:51,620 --> 09:37:54,020
compiled it down to a jar file,

13237
09:37:54,020 --> 09:37:56,360
which then you can take
and send to anybody else

13238
09:37:56,360 --> 09:37:58,860
and they can execute this
program on their computer.

13239
09:37:58,860 --> 09:38:01,360
Now be aware if you do
send a jar file over email,

13240
09:38:01,360 --> 09:38:03,840
most likely most email
providers are probably going

13241
09:38:03,840 --> 09:38:06,520
to strip that file out
as it can be considered

13242
09:38:06,520 --> 09:38:07,520
unexecutable.

13243
09:38:07,520 --> 09:38:08,980
So you'll need to get it
to them a different way,

13244
09:38:08,980 --> 09:38:12,120
maybe through a file sharing
service of some sorts.

13245
09:38:12,120 --> 09:38:14,700
So that's how you can build a jar file

13246
09:38:14,700 --> 09:38:18,340
simply through IntelliJ and
then you'll get your jar file.

13247
09:38:18,340 --> 09:38:21,700
Congratulations on creating
your first application.

13248
09:38:21,700 --> 09:38:23,750
Playing with Kotlin and
Simon IDE is gonna be

13249
09:38:23,750 --> 09:38:25,300
the best way for you to learn.

13250
09:38:25,300 --> 09:38:28,200
However, sometimes you can
also learn directly on the web.

13251
09:38:29,150 --> 09:38:32,562
And to do that, the folks
over JetBrains have set up

13252
09:38:32,562 --> 09:38:36,430
play.Kotlinlane.org. and
here you can log in for free,

13253
09:38:36,430 --> 09:38:38,630
not even log in just
access, play.kotlin.org

13254
09:38:39,580 --> 09:38:42,530
and start writing code
right here in the browser.

13255
09:38:42,530 --> 09:38:44,650
So now what we can do is
we'll say hello from Donn,

13256
09:38:44,650 --> 09:38:47,030
for example, and I can run this code.

13257
09:38:47,030 --> 09:38:48,880
And what we'll see, it'll run and compile,

13258
09:38:48,880 --> 09:38:50,480
and we'll see the output.

13259
09:38:50,480 --> 09:38:52,530
Now, one of the coolest things
we can do inside of here,

13260
09:38:52,530 --> 09:38:55,716
we can write a bunch of code
and then you can also share it.

13261
09:38:55,716 --> 09:38:58,730
So you can click share
and you can copy this link

13262
09:38:58,730 --> 09:39:01,580
or you can directly embed
it, send it to medium.

13263
09:39:01,580 --> 09:39:03,030
And so let's say I've
taken this and I've sent it

13264
09:39:03,030 --> 09:39:03,930
to somebody else.

13265
09:39:03,930 --> 09:39:06,080
So I have a new incognito
window open here.

13266
09:39:07,926 --> 09:39:08,990
If I paste this, what
we'll see here is we have

13267
09:39:08,990 --> 09:39:12,570
play.Kotlinlane.org
and automatically loads

13268
09:39:14,787 --> 09:39:15,620
the code that I've written.

13269
09:39:15,620 --> 09:39:17,570
So hello from Donn has
been pasted inside here.

13270
09:39:18,693 --> 09:39:19,670
So actually, if you actually take that URL

13271
09:39:19,670 --> 09:39:22,040
that you saw here in the
video and pasted it in,

13272
09:39:22,965 --> 09:39:23,798
you should see this directly from me

13273
09:39:23,798 --> 09:39:24,910
right here in your browser.

13274
09:39:25,770 --> 09:39:27,110
Now this is a great place to play around.

13275
09:39:27,110 --> 09:39:29,410
There's also the hands-on
and there are some examples

13276
09:39:29,410 --> 09:39:30,320
in koans.

13277
09:39:30,320 --> 09:39:31,990
Now Kotlin koans are great.

13278
09:39:31,990 --> 09:39:34,370
Koans are a series of set of
exercises that are allow you

13279
09:39:34,370 --> 09:39:37,910
to get familiar with the actual
Kotlin programming language.

13280
09:39:37,910 --> 09:39:40,390
And the nice thing about it
is they actually give you

13281
09:39:40,390 --> 09:39:43,840
a test that you can actually
have to basically make pars.

13282
09:39:43,840 --> 09:39:45,520
So you have to actually fix the code

13283
09:39:45,520 --> 09:39:47,080
and make these things parse in real time.

13284
09:39:47,080 --> 09:39:48,820
And you can do it right
here on your browser.

13285
09:39:48,820 --> 09:39:51,510
They give you progress that
you can follow along the way.

13286
09:39:51,510 --> 09:39:53,840
So if you learn Kotlin
for me and you're watching

13287
09:39:53,840 --> 09:39:55,630
these videos and you've
picked up quite a bit,

13288
09:39:55,630 --> 09:39:57,700
and you wanna take your
exercises a little bit further

13289
09:39:57,700 --> 09:40:00,420
and challenge yourself, I
advise you go to Kotlin.

13290
09:40:00,420 --> 09:40:02,250
Go to play.Kotlinlane.org.

13291
09:40:02,250 --> 09:40:04,211
You can play in the round the playground,

13292
09:40:04,211 --> 09:40:06,161
and you can also visit the Kotlin koans

13293
09:40:06,999 --> 09:40:07,850
and explore other examples as well.

13294
09:40:07,850 --> 09:40:08,700
I hope you enjoy.

13295
09:40:09,780 --> 09:40:11,880
Woo, you made it.

13296
09:40:13,100 --> 09:40:15,918
Congratulations on finishing the Kotlin

13297
09:40:15,918 --> 09:40:16,770
programming language course.

13298
09:40:16,770 --> 09:40:19,921
It was over nine hours of
content you just watched.

13299
09:40:19,921 --> 09:40:22,818
You should feel proud of
yourself for finishing this.

13300
09:40:22,818 --> 09:40:23,651
This is quite the accomplishment.

13301
09:40:23,651 --> 09:40:26,650
You now should have a solid
fundamental understanding

13302
09:40:26,650 --> 09:40:28,400
of the Kotlin programming language,

13303
09:40:29,372 --> 09:40:30,710
and you shouldn't be able
to go start providing value

13304
09:40:30,710 --> 09:40:33,450
at your company's project,
your own personal project.

13305
09:40:33,450 --> 09:40:35,510
It doesn't matter if you're
a developer, engineer,

13306
09:40:35,510 --> 09:40:37,590
scientist, doctor, or whatever.

13307
09:40:37,590 --> 09:40:40,070
I hope you have received a
lot of value from this course.

13308
09:40:40,070 --> 09:40:42,850
I hope you have learned
Kotlin and I hope it produces

13309
09:40:42,850 --> 09:40:45,080
a ton of value in your
career moving forward.

13310
09:40:45,080 --> 09:40:47,880
And I wish you nothing,
but the best going forward.

13311
09:40:47,880 --> 09:40:49,560
Thanks again for watching the video

13312
09:40:49,560 --> 09:40:50,890
and I'll catch you next time.

